#include <bgbbtj.h>

uint PDPNG_DataAdler32(void *buf, int sz, uint lcrc);
int PDPNG_Paeth(int a, int b, int c);
byte *PDPNG_LoadRaw(char *name, int *w, int *h);

void *bgbv86_ralloc(int sz)
{
	static byte *buf=NULL;
	static byte *bufe, *bufr;
	void *p;

	if(!buf)
	{
		buf=malloc(1<<18);
		bufe=buf+(1<<18);
		bufr=buf;
	}

	sz=(sz+15)&(~15);
	if((bufr+sz)>bufe)bufr=buf;
	p=bufr; bufr+=sz;
	memset(p, 0, sz);
	return(p);
}

char *bgbv86_rstrdup(char *str)
{
	char *t;
	t=bgbv86_ralloc(strlen(str)+1);
	strcpy(t, str);
	return(t);
}

char *bgbv86_rsprint(char *str, ...)
{
	char buf[256];
	va_list lst;
	char *t;

	va_start(lst, str);
	vsprintf(buf, str, lst);
	va_end(lst);

	t=bgbv86_rstrdup(buf);
	return(t);
}

char **bgbv86_rsplit(char *s)
{
	char **a, *t;
	int i;

	a=bgbv86_ralloc(64*sizeof(char *));
	i=0;
	while(*s)
	{
		while(*s && (*s<=' '))s++;
		if(!*s)break;
		t=bgbv86_ralloc(256);
		a[i++]=t;

		if(*s=='"')
		{
			s++;

			while(*s && (*s!='"'))
			{
				if(*s=='\\')
				{
					*t++=*s++;

					if(*s=='x')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}
					if(*s=='u')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}
					if(*s=='U')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}

					*t++=*s++;
					continue;
				}

				*t++=*s++;
			}

			if(*s=='"')s++;

			*t++=0;
			*t++='\"';
			*t++=0;
			continue;
		}

		while(*s && (*s>' '))*t++=*s++;
		*t++=0;
		*t++=0;
	}
	a[i]=NULL;

	return(a);
}

int WAL_ReadInfo(char *name, WalInfo_t *wal)
{
	char tb[1024];
	char **a;
	FILE *fd;
	int i;

//	wal->flags=0;
//	*cnts=0;

	fd=fopen(name, "rt");
	if(!fd)return(-1);

	while(!feof(fd))
	{
		fgets(tb, 1023, fd);
		a=bgbv86_rsplit(tb);

		if(!a)continue;
		if(!a[0])continue;
		if(*(a[0])!='$')continue;

		if(!strcmp(a[0], "$sky"))
		{
			wal->flags|=SURF_SKY;
		}

		if(!strcmp(a[0], "$flags"))
		{
			for(i=1; a[i]; i++)
			{
				if(!strcmp(a[i], "fluid"))
					wal->contents|=CONTENTS_WATER;

				if(!strcmp(a[i], "window"))
					wal->contents|=CONTENTS_WINDOW;
				if(!strcmp(a[i], "water"))
					wal->contents|=CONTENTS_WATER;
				if(!strcmp(a[i], "lava"))
					wal->contents|=CONTENTS_LAVA;
				if(!strcmp(a[i], "slime"))
					wal->contents|=CONTENTS_SLIME;
				if(!strcmp(a[i], "sewer"))
					wal->contents|=CONTENTS_WATER;

				if(!strcmp(a[i], "mist"))
					wal->contents|=CONTENTS_MIST;
				if(!strcmp(a[i], "origin"))
					wal->contents|=CONTENTS_ORIGIN;
				if(!strcmp(a[i], "detail"))
					wal->contents|=CONTENTS_DETAIL;
				if(!strcmp(a[i], "ladder"))
					wal->contents|=CONTENTS_LADDER;

				if(!strcmp(a[i], "slick"))
					wal->flags|=SURF_SLICK;
				if(!strcmp(a[i], "sky"))
					wal->flags|=SURF_SKY;
				if(!strcmp(a[i], "warpst"))
					wal->flags|=SURF_WARP;
				if(!strcmp(a[i], "warp"))
					wal->flags|=SURF_WARP;

				if(!strcmp(a[i], "alpha33"))
					wal->flags|=SURF_TRANS33;
				if(!strcmp(a[i], "alpha66"))
					wal->flags|=SURF_TRANS66;

				if(!strcmp(a[i], "flowing"))
					wal->flags|=SURF_FLOWING;
				if(!strcmp(a[i], "nodraw"))
					wal->flags|=SURF_NODRAW;

				if(!strcmp(a[i], "light"))
				{
					wal->flags|=SURF_LIGHT;
					wal->value=250;
				}

				if(!strcmp(a[i], "clip"))
				{
					wal->flags|=SURF_NODRAW;
					wal->contents|=CONTENTS_PLAYERCLIP;
					wal->contents|=CONTENTS_MONSTERCLIP;
				}
			}
		}
	}

	if(wal->contents&CONTENTS_WATER)
	{
		if(wal->contents&CONTENTS_WINDOW)
			wal->contents&=~CONTENTS_WINDOW;

		wal->flags|=SURF_WARP;

		if(wal->contents&CONTENTS_SLIME)
		{
			wal->contents&=~CONTENTS_WATER;
			wal->flags|=SURF_TRANS66;
		}
		if(wal->contents&CONTENTS_LAVA)
			wal->contents&=~CONTENTS_WATER;

		if((wal->contents&CONTENTS_WATER) &&
			!(wal->flags&SURF_TRANS33) &&
			!(wal->flags&SURF_TRANS66))
		{
			wal->flags|=SURF_TRANS33;
		}
	}

	printf("Info %dx%d\t%08X %08X\n",
		wal->width, wal->height,
		wal->flags, wal->contents);

	fclose(fd);
}

byte *PDTGA_LoadRaw(char *name, int *w, int *h);

int WAL_FileExistsP(char *name)
{
	FILE *fd;
	
	fd=fopen(name, "rb");
	if(!fd)return(0);
	fclose(fd);
	return(1);
}

int WAL_ImageExistsP(char *name)
{
	char tb[256];
	
//	printf("Check Image %s\n", name);
	
	sprintf(tb, "%s.png", name);
	if(WAL_FileExistsP(tb))
		return(1);
	sprintf(tb, "%s.jpg", name);
	if(WAL_FileExistsP(tb))
		return(1);

	return(0);
}

char *WAL_AnimChain(char *name)
{
	char pf[256], sf[256];
	char tb[256];
	char *s, *t, *s0;
	int i, n;

//	if(*name!='+')
//		return(NULL);

	n=0;

	s=name+strlen(name);
	while((s>name) && (*s!='+') && (*s!='/'))s--;
	if(*s!='+')return(NULL);

	s0=name; t=pf;
	while(*s0 && (s0<s))*t++=*s0++;
	*t++=0;
//	printf("PF=%s\n", pf);

	s0=s+1;
	n=atoi(s0);
	while(*s0 && (*s0>='0') && (*s0<='9'))s0++;

	t=sf;
	while(*s0)*t++=*s0++;
	*t++=0;
//	printf("SF=%s\n", sf);

//	s=name+strlen(name)-1;
//	while((s>name) && (*(s-1)>='0') && (*(s-1)<='9'))s--;
//	s0=name; t=tb;
//	while(*s0 && (s0<s))*t++=*s0++;
//	*t++=0;
//	n=atoi(s);
	
//	return(NULL);
	
	sprintf(tb, "%s+%d%s", pf, n+1, sf);
	if(WAL_ImageExistsP(tb))
		return(strdup(tb));

	sprintf(tb, "%s+%d%s", pf, 0, sf);
	if(WAL_ImageExistsP(tb))
		return(strdup(tb));

	return(NULL);
}

void AWAL_UnFilterBuf(byte *tbuf, byte *buf, byte *lbuf,
	int xs, int ys, int fl)
{
	int i, j, k, l, v;
	int a, b, c, d;

//	tb1=malloc(xs*ys*4);
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
			for(k=0; k<4; k++)
	{
		l=lbuf[(i*xs+j)*4+k];
//		l=buf[(i*xs+j)*4+k];

		v=buf[k*(xs*ys)+(i*xs)+j];

		if(fl&1)
//		if(0)
//		if(1)
		{
			a=(j>0)?tbuf[(i*xs+(j-1))*4+k]:0;
			b=(i>0)?tbuf[((i-1)*xs+j)*4+k]:0;
			c=((i>0)&&(j>0))?tbuf[((i-1)*xs+(j-1))*4+k]:0;
			d=PDPNG_Paeth(a, b, c);
		}else d=0;

//		tbuf[k*(xs*ys)+(i*xs)+j]=l-d;
		tbuf[(i*xs+j)*4+k]=l+d+v;
	}
}

void AWAL_FilterBuf(byte *tbuf, byte *buf, byte *lbuf,
	int xs, int ys, int fl)
{
//	byte *tb1;
	int i, j, k, l;
//	int lr, lg, lb, la;
//	int ar, br, cr, dr;
//	int ag, bg, cg, dg;
//	int ab, bb, cb, db;
//	int aa, ba, ca, da;
	int a, b, c, d;

#if 1
//	tb1=malloc(xs*ys*4);
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
			for(k=0; k<4; k++)
	{
		l=buf[(i*xs+j)*4+k]-lbuf[(i*xs+j)*4+k];
//		l=buf[(i*xs+j)*4+k];

		if(fl&1)
//		if(0)
//		if(1)
		{
			a=(j>0)?buf[(i*xs+(j-1))*4+k]:0;
			b=(i>0)?buf[((i-1)*xs+j)*4+k]:0;
			c=((i>0)&&(j>0))?buf[((i-1)*xs+(j-1))*4+k]:0;
			d=PDPNG_Paeth(a, b, c);
		}else d=0;

		tbuf[k*(xs*ys)+(i*xs)+j]=l-d;
//		tbuf[(i*xs+j)*4+k]=l-d;
	}
#endif

#if 0
//	tb1=malloc(xs*ys*4);
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		lr=buf[(i*xs+j)*4+0]-lbuf[(i*xs+j)*4+0];
		lg=buf[(i*xs+j)*4+1]-lbuf[(i*xs+j)*4+1];
		lb=buf[(i*xs+j)*4+2]-lbuf[(i*xs+j)*4+2];
		la=buf[(i*xs+j)*4+3]-lbuf[(i*xs+j)*4+3];
//		l=buf[(i*xs+j)*4+k];

//		lr-=lg;
//		lb-=lg;

		ar=(j>0)?buf[(0*(xs*ys))+(i*xs)+(j-1)]:0;
		ag=(j>0)?buf[(1*(xs*ys))+(i*xs)+(j-1)]:0;
		ab=(j>0)?buf[(2*(xs*ys))+(i*xs)+(j-1)]:0;
		aa=(j>0)?buf[(3*(xs*ys))+(i*xs)+(j-1)]:0;

		br=(i>0)?buf[(0*(xs*ys))+((i-1)*xs)+j]:0;
		bg=(i>0)?buf[(1*(xs*ys))+((i-1)*xs)+j]:0;
		bb=(i>0)?buf[(2*(xs*ys))+((i-1)*xs)+j]:0;
		ba=(i>0)?buf[(3*(xs*ys))+((i-1)*xs)+j]:0;

		cr=((i>0)&&(j>0))?buf[(0*(xs*ys))+((i-1)*xs)+(j-1)]:0;
		cg=((i>0)&&(j>0))?buf[(1*(xs*ys))+((i-1)*xs)+(j-1)]:0;
		cb=((i>0)&&(j>0))?buf[(2*(xs*ys))+((i-1)*xs)+(j-1)]:0;
		ca=((i>0)&&(j>0))?buf[(3*(xs*ys))+((i-1)*xs)+(j-1)]:0;

//		dr=PDPNG_Paeth(ar, br, cr);
//		dg=PDPNG_Paeth(ag, bg, cg);
//		db=PDPNG_Paeth(ab, bb, cb);
//		da=PDPNG_Paeth(aa, ba, ca);
		dr=0; dg=0; db=0; da=0;

		tbuf[0*(xs*ys)+(i*xs)+j]=lr-dr;
		tbuf[1*(xs*ys)+(i*xs)+j]=lg-dg;
		tbuf[2*(xs*ys)+(i*xs)+j]=lb-db;
		tbuf[3*(xs*ys)+(i*xs)+j]=la-da;
	}
#endif
}

int AWAL_Write(FILE *fd, WalInfo_t *inf)
{
	byte tb[256];
	int i, j;

	memset(tb, 0, 256);
	if(inf->name)
		strcpy(tb+ 0, inf->name);
//	if(inf->animname)
//		strcpy(tb+56, inf->animname);

	WAL_Set32LE(tb+32, inf->width);
	WAL_Set32LE(tb+36, inf->height);
	WAL_Set32LE(tb+52, inf->flags);
	WAL_Set32LE(tb+56, inf->contents);
	WAL_Set32LE(tb+60, inf->value);

	i=100;
	WAL_Set32LE(tb+40, i);
//	WAL_Set32LE(tb+44, j);

	fwrite(tb, 1, 100, fd);

	for(i=0; i<inf->n_frames; i++)
	{
		fputc(i?2:1, fd);
		fputc(0, fd);
		fputc(0, fd);
		fputc(0, fd);

		j=inf->frames_sz[i];
		fputc(j&255, fd);
		fputc((j>>8)&255, fd);
		fputc((j>>16)&255, fd);
		fputc((j>>24)&255, fd);

		fwrite(inf->frames[i], 1, j, fd);
	}

	j=ftell(fd)-100;
	WAL_Set32LE(tb+44, j);

//	i=inf->width*inf->height;
//	fwrite(inf->data[0], 1, i, fd);

//	i=(inf->width/2)*(inf->height/2);
//	fwrite(inf->data[1], 1, i, fd);

//	i=(inf->width/4)*(inf->height/4);
//	fwrite(inf->data[2], 1, i, fd);

//	i=(inf->width/8)*(inf->height/8);
//	fwrite(inf->data[3], 1, i, fd);

	fseek(fd, 0, 0);
	fwrite(tb, 1, 100, fd);

	return(0);
}

int AWAL_WriteFile(char *name, WalInfo_t *inf)
{
	FILE *fd;

	fd=fopen(name, "wb");
	if(!fd)return(-1);
	AWAL_Write(fd, inf);
	fclose(fd);
	return(-1);
}

int main(int argc, char *argv[])
{
	byte tb[1024];
	byte *buf, *lbuf, *tbuf, *tbuf1;
	WalInfo_t *wal;
	byte *base, *chain, *s;
	FILE *fd;
	int i, j, k, w, h, w1, h1;

	strcpy(tb, argv[1]);
	base=tb+strlen((char *)tb);
	while(base>tb)
	{
		if(*base=='.')
			{ *base=0; break; }
		base--;
	}
	base=strdup(tb);

	printf("Base=%s\n", base);

#if 1
	//base image, used for size
	sprintf(tb, "%s.png", base);
	buf=PDPNG_LoadRaw(tb, &w, &h);

	if(!buf)return(-1);

	wal=WAL_CreateWal(buf, w, h, NULL);
	wal->name=strdup(base);
	sprintf(tb, "%s.txt", base);
	WAL_ReadInfo(tb, wal);

	printf("%dx%d\t%08X %08X\n",
		wal->width, wal->height,
		wal->flags, wal->contents);

	free(buf);	//don't need

	wal->frames=malloc(1024*sizeof(byte *));
	wal->frames_sz=malloc(1024*sizeof(int));
	wal->n_frames=0;

	lbuf=malloc(w*h*4);
	memset(lbuf, 0, w*h*4);
	tbuf=malloc(w*h*4);

	for(i=0; i<1024; i++)
	{
		sprintf(tb, "%s_%d.png", base, i);
		buf=PDPNG_LoadRaw(tb, &w1, &h1);
		if(!buf)break;
		
		printf("Got %s\n", tb);
		
		AWAL_FilterBuf(tbuf, buf, lbuf, w, h, i?0:1);

		tbuf1=malloc(w*h*8);

//		for(j=0; j<w*h*4; j++)
//			tbuf1[j]=tbuf[j];
//		for(j=0; j<w*h; j++)
//			tbuf1[j*4+3]=255;

		AWAL_UnFilterBuf(tbuf1, tbuf, lbuf, w, h, i?0:1);

		sprintf(tb, "%s_X_%d.png", base, i);
		PDPNG_SaveRaw(tb, tbuf1, w, h);


		memcpy(lbuf, buf, w*h*4);
		free(buf);
		
		
		k=0;
		for(j=0; j<w*h*4; j++)
			k+=tbuf[j];
			
		printf("Entropy=%d, AvgEntropy=%d\n", k, k/j);
		
		//zlib header
		j=(7<<12)|(8<<8)|(3<<6);
		k=j%31;
		if(k)j|=31-k;
		tbuf1[0]=j>>8;
		tbuf1[1]=j&0xFF;

		//deflated frame data
		j=PDZ2_EncodeStreamLvl(tbuf, tbuf1+2, w*h*4, w*h*8, 9);
		
		//checksum
		k=PDPNG_DataAdler32(tbuf, w*h*4, 1);
		tbuf1[2+j+0]=(k>>24)&0xFF;
		tbuf1[2+j+1]=(k>>16)&0xFF;
		tbuf1[2+j+2]=(k>>8)&0xFF;
		tbuf1[2+j+3]=k&0xFF;

		printf("Frame Size: %d\n", j+6);

		wal->frames[i]=tbuf1;
		wal->frames_sz[i]=j+6;
		wal->n_frames=i+1;
	}

	sprintf(tb, "%s.wal", base);
	AWAL_WriteFile(tb, wal);
#endif

	return(0);
}
#include <walpng.h>

byte q2pal[768]=
{
  0,   0,   0,   15,  15,  15,   31,  31,  31,   47,  47,  47,
 63,  63,  63,   75,  75,  75,   91,  91,  91,  107, 107, 107,
123, 123, 123,  139, 139, 139,  155, 155, 155,  171, 171, 171,
187, 187, 187,  203, 203, 203,  219, 219, 219,  235, 235, 235,
 99,  75,  35,   91,  67,  31,   83,  63,  31,   79,  59,  27,
 71,  55,  27,   63,  47,  23,   59,  43,  23,   51,  39,  19,
 47,  35,  19,   43,  31,  19,   39,  27,  15,   35,  23,  15,
 27,  19,  11,   23,  15,  11,   19,  15,   7,   15,  11,   7,
 95,  95, 111,   91,  91, 103,   91,  83,  95,   87,  79,  91,
 83,  75,  83,   79,  71,  75,   71,  63,  67,   63,  59,  59,
 59,  55,  55,   51,  47,  47,   47,  43,  43,   39,  39,  39,
 35,  35,  35,   27,  27,  27,   23,  23,  23,   19,  19,  19,
143, 119,  83,  123,  99,  67,  115,  91,  59,  103,  79,  47,
207, 151,  75,  167, 123,  59,  139, 103,  47,  111,  83,  39,
235, 159,  39,  203, 139,  35,  175, 119,  31,  147,  99,  27,
119,  79,  23,   91,  59,  15,   63,  39,  11,   35,  23,   7,
167,  59,  43,  159,  47,  35,  151,  43,  27,  139,  39,  19,
127,  31,  15,  115,  23,  11,  103,  23,   7,   87,  19,   0,
 75,  15,   0,   67,  15,   0,   59,  15,   0,   51,  11,   0,
 43,  11,   0,   35,  11,   0,   27,   7,   0,   19,   7,   0,
123,  95,  75,  115,  87,  67,  107,  83,  63,  103,  79,  59,
 95,  71,  55,   87,  67,  51,   83,  63,  47,   75,  55,  43,
 67,  51,  39,   63,  47,  35,   55,  39,  27,   47,  35,  23,
 39,  27,  19,   31,  23,  15,   23,  15,  11,   15,  11,   7,
111,  59,  23,   95,  55,  23,   83,  47,  23,   67,  43,  23,
 55,  35,  19,   39,  27,  15,   27,  19,  11,   15,  11,   7,
179,  91,  79,  191, 123, 111,  203, 155, 147,  215, 187, 183,
203, 215, 223,  179, 199, 211,  159, 183, 195,  135, 167, 183,
115, 151, 167,   91, 135, 155,   71, 119, 139,   47, 103, 127,
 23,  83, 111,   19,  75, 103,   15,  67,  91,   11,  63,  83,
  7,  55,  75,    7,  47,  63,    7,  39,  51,    0,  31,  43,
  0,  23,  31,    0,  15,  19,    0,   7,  11,    0,   0,   0,
139,  87,  87,  131,  79,  79,  123,  71,  71,  115,  67,  67,
107,  59,  59,   99,  51,  51,   91,  47,  47,   87,  43,  43,
 75,  35,  35,   63,  31,  31,   51,  27,  27,   43,  19,  19,
 31,  15,  15,   19,  11,  11,   11,   7,   7,    0,   0,   0,
151, 159, 123,  143, 151, 115,  135, 139, 107,  127, 131,  99,
119, 123,  95,  115, 115,  87,  107, 107,  79,   99,  99,  71,
 91,  91,  67,   79,  79,  59,   67,  67,  51,   55,  55,  43,
 47,  47,  35,   35,  35,  27,   23,  23,  19,   15,  15,  11,
159,  75,  63,  147,  67,  55,  139,  59,  47,  127,  55,  39,
119,  47,  35,  107,  43,  27,   99,  35,  23,   87,  31,  19,
 79,  27,  15,   67,  23,  11,   55,  19,  11,   43,  15,   7,
 31,  11,   7,   23,   7,   0,   11,   0,   0,    0,   0,   0,
119, 123, 207,  111, 115, 195,  103, 107, 183,   99,  99, 167,
 91,  91, 155,   83,  87, 143,   75,  79, 127,   71,  71, 115,
 63,  63, 103,   55,  55,  87,   47,  47,  75,   39,  39,  63,
 35,  31,  47,   27,  23,  35,   19,  15,  23,   11,   7,   7,
155, 171, 123,  143, 159, 111,  135, 151,  99,  123, 139,  87,
115, 131,  75,  103, 119,  67,   95, 111,  59,   87, 103,  51,
 75,  91,  39,   63,  79,  27,   55,  67,  19,   47,  59,  11,
 35,  47,   7,   27,  35,   0,   19,  23,   0,   11,  15,   0,
  0, 255,   0,   35, 231,  15,   63, 211,  27,   83, 187,  39,
 95, 167,  47,   95, 143,  51,   95, 123,  51,  255, 255, 255,
255, 255, 211,  255, 255, 167,  255, 255, 127,  255, 255,  83,
255, 255,  39,  255, 235,  31,  255, 215,  23,  255, 191,  15,
255, 171,   7,  255, 147,   0,  239, 127,   0,  227, 107,   0,
211,  87,   0,  199,  71,   0,  183,  59,   0,  171,  43,   0,
155,  31,   0,  143,  23,   0,  127,  15,   0,  115,   7,   0,
 95,   0,   0,   71,   0,   0,   47,   0,   0,   27,   0,   0,
239,   0,   0,   55,  55, 255,  255,   0,   0,    0,   0, 255,
 43,  43,  35,   27,  27,  23,   19,  19,  15,  235, 151, 127,
195, 115,  83,  159,  87,  51,  123,  63,  27,  235, 211, 199,
199, 171, 155,  167, 139, 119,  135, 107,  87,  159,  91,  83,
};


void *bgbv86_ralloc(int sz)
{
	static byte *buf=NULL;
	static byte *bufe, *bufr;
	void *p;

	if(!buf)
	{
		buf=malloc(1<<18);
		bufe=buf+(1<<18);
		bufr=buf;
	}

	sz=(sz+15)&(~15);
	if((bufr+sz)>bufe)bufr=buf;
	p=bufr; bufr+=sz;
	memset(p, 0, sz);
	return(p);
}

char *bgbv86_rstrdup(char *str)
{
	char *t;
	t=bgbv86_ralloc(strlen(str)+1);
	strcpy(t, str);
	return(t);
}

char *bgbv86_rsprint(char *str, ...)
{
	char buf[256];
	va_list lst;
	char *t;

	va_start(lst, str);
	vsprintf(buf, str, lst);
	va_end(lst);

	t=bgbv86_rstrdup(buf);
	return(t);
}

char **bgbv86_rsplit(char *s)
{
	char **a, *t;
	int i;

	a=bgbv86_ralloc(64*sizeof(char *));
	i=0;
	while(*s)
	{
		while(*s && (*s<=' '))s++;
		if(!*s)break;
		t=bgbv86_ralloc(256);
		a[i++]=t;

		if(*s=='"')
		{
			s++;

			while(*s && (*s!='"'))
			{
				if(*s=='\\')
				{
					*t++=*s++;

					if(*s=='x')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}
					if(*s=='u')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}
					if(*s=='U')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}

					*t++=*s++;
					continue;
				}

				*t++=*s++;
			}

			if(*s=='"')s++;

			*t++=0;
			*t++='\"';
			*t++=0;
			continue;
		}

		while(*s && (*s>' '))*t++=*s++;
		*t++=0;
		*t++=0;
	}
	a[i]=NULL;

	return(a);
}

int WAL_ReadInfo(char *name, WalInfo_t *wal)
{
	char tb[1024];
	char **a;
	FILE *fd;
	int i;

//	wal->flags=0;
//	*cnts=0;

	fd=fopen(name, "rt");
	if(!fd)return(-1);

	while(!feof(fd))
	{
		fgets(tb, 1023, fd);
		a=bgbv86_rsplit(tb);

		if(!a)continue;
		if(!a[0])continue;
		if(*(a[0])!='$')continue;

		if(!strcmp(a[0], "$sky"))
		{
			wal->flags|=SURF_SKY;
		}

		if(!strcmp(a[0], "$flags"))
		{
			for(i=1; a[i]; i++)
			{
				if(!strcmp(a[i], "fluid"))
					wal->contents|=CONTENTS_WATER;

				if(!strcmp(a[i], "window"))
					wal->contents|=CONTENTS_WINDOW;
				if(!strcmp(a[i], "water"))
					wal->contents|=CONTENTS_WATER;
				if(!strcmp(a[i], "lava"))
					wal->contents|=CONTENTS_LAVA;
				if(!strcmp(a[i], "slime"))
					wal->contents|=CONTENTS_SLIME;
				if(!strcmp(a[i], "sewer"))
					wal->contents|=CONTENTS_WATER;

				if(!strcmp(a[i], "mist"))
					wal->contents|=CONTENTS_MIST;
				if(!strcmp(a[i], "origin"))
					wal->contents|=CONTENTS_ORIGIN;
				if(!strcmp(a[i], "detail"))
					wal->contents|=CONTENTS_DETAIL;
				if(!strcmp(a[i], "ladder"))
					wal->contents|=CONTENTS_LADDER;

				if(!strcmp(a[i], "slick"))
					wal->flags|=SURF_SLICK;
				if(!strcmp(a[i], "sky"))
					wal->flags|=SURF_SKY;
				if(!strcmp(a[i], "warpst"))
					wal->flags|=SURF_WARP;
				if(!strcmp(a[i], "warp"))
					wal->flags|=SURF_WARP;

				if(!strcmp(a[i], "alpha33"))
					wal->flags|=SURF_TRANS33;
				if(!strcmp(a[i], "alpha66"))
					wal->flags|=SURF_TRANS66;

				if(!strcmp(a[i], "flowing"))
					wal->flags|=SURF_FLOWING;
				if(!strcmp(a[i], "nodraw"))
					wal->flags|=SURF_NODRAW;

				if(!strcmp(a[i], "light"))
				{
					wal->flags|=SURF_LIGHT;
					wal->value=250;
				}

				if(!strcmp(a[i], "clip"))
				{
					wal->flags|=SURF_NODRAW;
					wal->contents|=CONTENTS_PLAYERCLIP;
					wal->contents|=CONTENTS_MONSTERCLIP;
				}
			}
		}
	}

	if(wal->contents&CONTENTS_WATER)
	{
		if(wal->contents&CONTENTS_WINDOW)
			wal->contents&=~CONTENTS_WINDOW;

		wal->flags|=SURF_WARP;

		if(wal->contents&CONTENTS_SLIME)
		{
			wal->contents&=~CONTENTS_WATER;
			wal->flags|=SURF_TRANS66;
		}
		if(wal->contents&CONTENTS_LAVA)
			wal->contents&=~CONTENTS_WATER;

		if((wal->contents&CONTENTS_WATER) &&
			!(wal->flags&SURF_TRANS33) &&
			!(wal->flags&SURF_TRANS66))
		{
			wal->flags|=SURF_TRANS33;
		}
	}

	printf("Info %dx%d\t%08X %08X\n",
		wal->width, wal->height,
		wal->flags, wal->contents);

	fclose(fd);
}

byte *PDTGA_LoadRaw(char *name, int *w, int *h);

int WAL_FileExistsP(char *name)
{
	FILE *fd;
	
	fd=fopen(name, "rb");
	if(!fd)return(0);
	fclose(fd);
	return(1);
}

int WAL_ImageExistsP(char *name)
{
	char tb[256];
	
//	printf("Check Image %s\n", name);
	
	sprintf(tb, "%s.png", name);
	if(WAL_FileExistsP(tb))
		return(1);
	sprintf(tb, "%s.jpg", name);
	if(WAL_FileExistsP(tb))
		return(1);

	return(0);
}

char *WAL_AnimChain(char *name)
{
	char pf[256], sf[256];
	char tb[256];
	char *s, *t, *s0;
	int i, n;

//	if(*name!='+')
//		return(NULL);

	n=0;

	s=name+strlen(name);
	while((s>name) && (*s!='+') && (*s!='/'))s--;
	if(*s!='+')return(NULL);

	s0=name; t=pf;
	while(*s0 && (s0<s))*t++=*s0++;
	*t++=0;
//	printf("PF=%s\n", pf);

	s0=s+1;
	n=atoi(s0);
	while(*s0 && (*s0>='0') && (*s0<='9'))s0++;

	t=sf;
	while(*s0)*t++=*s0++;
	*t++=0;
//	printf("SF=%s\n", sf);

//	s=name+strlen(name)-1;
//	while((s>name) && (*(s-1)>='0') && (*(s-1)<='9'))s--;
//	s0=name; t=tb;
//	while(*s0 && (s0<s))*t++=*s0++;
//	*t++=0;
//	n=atoi(s);
	
//	return(NULL);
	
	sprintf(tb, "%s+%d%s", pf, n+1, sf);
	if(WAL_ImageExistsP(tb))
		return(strdup(tb));

	sprintf(tb, "%s+%d%s", pf, 0, sf);
	if(WAL_ImageExistsP(tb))
		return(strdup(tb));

	return(NULL);
}

int main(int argc, char *argv[])
{
	byte tb[1024];
	byte *buf;
	WalInfo_t *wal;
	byte *base, *chain, *s;
	FILE *fd;
	int i, j, w, h;

#if 0
	PCX_LoadRaw("colormap.pcx", NULL, NULL, tb);

	for(i=0; i<64; i++)
	{
		for(j=0; j<4; j++)
			printf("%3d, %3d, %3d,  ",
				tb[(i*4+j)*3+0],
				tb[(i*4+j)*3+1],
				tb[(i*4+j)*3+2]);
		printf("\n");
	}
#endif

	strcpy(tb, argv[1]);
	base=tb+strlen((char *)tb);
	while(base>tb)
	{
		if(*base=='.')
			{ *base=0; break; }
		base--;
	}
	base=strdup(tb);

	s=base+strlen(base)-strlen("_alt");
	if(!strcmp(s, "_alt"))return(0);

	s=base+strlen(base)-strlen("_luma");
	if(!strcmp(s, "_luma"))return(0);

	printf("Base=%s\n", base);

	chain=WAL_AnimChain(base);
	if(chain)
		printf("Chain=%s\n", chain);

#if 0
	sprintf(tb, "%s.tga", base);
	buf=PDTGA_LoadRaw(tb, &w, &h);

	sprintf(tb, "%s_alt.png", base);
	PDPNG_SaveRaw(tb, buf, w, h);
#endif

#if 1
	sprintf(tb, "%s.png", base);
	buf=PDPNG_LoadRaw(tb, &w, &h);

	if(!buf)return(-1);

	wal=WAL_CreateWal(buf, w, h, q2pal);
	wal->name=strdup(base);
	if(chain)
		wal->animname=strdup(chain);

	sprintf(tb, "%s.txt", base);
	WAL_ReadInfo(tb, wal);

//	printf("%dx%d\t%08X %08X\n",
//		wal->width, wal->height,
//		wal->flags, wal->contents);

	sprintf(tb, "%s.wal", base);
	WAL_WriteFile(tb, wal);


//	sprintf(tb, "%s.q1wal", base);
//	WAL_WriteFileQ1(tb, wal);
#endif

	return(0);
}
#include <bgbbtj.h>

#include <time.h>

#ifndef FOURCC
#define FOURCC(a, b, c, d) ((a)|((b)<<8)|((c)<<16)|((d)<<24))
#endif

#define FCC_MJPG	FOURCC('M', 'J', 'P', 'G')
#define FCC_JPEG	FOURCC('J', 'P', 'E', 'G')

#define FCC_MBTJ	FOURCC('M', 'B', 'T', 'J')
#define FCC_BTJP	FOURCC('B', 'T', 'J', 'P')

#define FCC_MPNG	FOURCC('M', 'P', 'N', 'G')
#define FCC_PNG		FOURCC('P', 'N', 'G', ' ')
#define FCC_PNG1	FOURCC('P', 'N', 'G', '1')
#define FCC_png1	FOURCC('p', 'n', 'g', '1')

#define FCC_MBTC	FOURCC('M', 'B', 'T', 'C')
#define FCC_BTIC	FOURCC('B', 'T', 'I', 'C')

#define FCC_RGBA	FOURCC('R', 'G', 'B', 'A')
#define FCC_RGBT	FOURCC('R', 'G', 'B', 'T')

#define FCC_BtV0	FOURCC('B', 't', 'V', '0')

#define FCC_rpza	FOURCC('r', 'p', 'z', 'a')
#define FCC_bt1c	FOURCC('b', 't', '1', 'c')

#define FCC_THEO	FOURCC('T', 'H', 'E', 'O')
#define FCC_theo	FOURCC('t', 'h', 'e', 'o')

#define BTJ_FL_USEIPFRAME	256

int main(int argc, char *argv[])
{
	byte tb[1024];
	float exptab[256];
	float scltab[256];
	byte *buf, *lbuf, *tbuf, *tbuf1;
	byte *nvbuf, *spbuf, *lubuf;
	byte *obuf, *onvbuf, *ospbuf, *olubuf;
	byte *obuf1;
	void *ptr0, *ptr1;

//	WalInfo_t *wal;
	BGBBTJ_JPG_Context *jpctx;
	BGBBTJ_BTIC1_Context *btctx;
	BGBBTJ_AVICtx *ctx;
	byte *base, *chain, *s;
	FILE *fd;
	int cy, cu, cv, cr, cg, cb;
	int t0, t1, t2, flags, fps;
	int i, j, k, w, h, w1, h1, fcc, qf, qfl, qf2;
	float f, g;

	fcc=FCC_MJPG;
	flags=0; fps=10;
	qf=90; qfl=0;

#if 1
	base=NULL;
	for(i=1; i<argc; i++)
	{
		if(argv[i][0]=='-')
		{
			if(!strcmp(argv[i], "-btv"))
				fcc=FCC_BtV0;

			if(!strcmp(argv[i], "-mpng"))
				fcc=FCC_png1;
			if(!strcmp(argv[i], "-mbtic"))
				fcc=FCC_MBTC;
			if(!strcmp(argv[i], "-mbtj"))
				fcc=FCC_MBTJ;

			if(!strcmp(argv[i], "-mrpza"))
				fcc=FCC_rpza;
			if(!strcmp(argv[i], "-mbt1c"))
				fcc=FCC_bt1c;
			if(!strcmp(argv[i], "-mtheora"))
				fcc=FCC_THEO;
//				fcc=FCC_theo;

			if(!strcmp(argv[i], "-mrgba"))
				fcc=FCC_RGBA;
			if(!strcmp(argv[i], "-mrgbt"))
				fcc=FCC_RGBT;

			if(!strcmp(argv[i], "-dectst"))
				flags|=1;
			if(!strcmp(argv[i], "-dxttst"))
				flags|=2;
			if(!strcmp(argv[i], "-btictst"))
				flags|=4;
			if(!strcmp(argv[i], "-jfetst"))
				flags|=8;
			if(!strcmp(argv[i], "-pngftst"))
				flags|=16;
			if(!strcmp(argv[i], "-pngdtst"))
				flags|=32;
			if(!strcmp(argv[i], "-rpzatst"))
				flags|=64;

			if(!strcmp(argv[i], "-ipframe"))
				flags|=BTJ_FL_USEIPFRAME;

			if(!strcmp(argv[i], "-rdct"))
				qfl|=BGBBTJ_QFL_RDCT;
			if(!strcmp(argv[i], "-s444"))
				qfl|=BGBBTJ_QFL_444;
			if(!strcmp(argv[i], "-crct"))
				qfl|=BGBBTJ_QFL_ORCT;
			if(!strcmp(argv[i], "-crgb"))
				qfl|=BGBBTJ_QFL_RGB;
			if(!strcmp(argv[i], "-s410"))
				qfl|=BGBBTJ_QFL_410;

			if(!strcmp(argv[i], "-bitalpha"))
				qfl|=BGBBTJ_QFL_BITALPHA;
				
			if(!strcmp(argv[i], "-q"))
			{
				qf=atoi(argv[i+1]);
				i++; continue;
			}

			if(!strcmp(argv[i], "-qblkzi"))
				{ qfl|=BGBBTJ_BTIC1C_QFL_BLOCKZI; }
			if(!strcmp(argv[i], "-qdiffclr"))
				{ qfl|=BGBBTJ_BTIC1C_QFL_DIFFCLR; }
			if(!strcmp(argv[i], "-qblkidx"))
				{ qfl|=BGBBTJ_QFL_BLOCKINDEX; }
			if(!strcmp(argv[i], "-qblkmotion"))
				{ qfl|=BGBBTJ_QFL_BLOCKMOTION; }
			if(!strcmp(argv[i], "-qextmodes"))
				{ qfl|=BGBBTJ_BTIC1C_QFL_EXTMODES; }
			if(!strcmp(argv[i], "-qindexclr"))
				{ qfl|=BGBBTJ_BTIC1C_QFL_INDEXCLR; }

			if(!strcmp(argv[i], "-fps"))
			{
				fps=atoi(argv[i+1]);
				i++; continue;
			}

		}else
		{
			if(!base)
				base=argv[i];
		}
	}

	strcpy(tb, base);
	base=tb+strlen((char *)tb);
	while(base>tb)
	{
		if(*base=='.')
			{ *base=0; break; }
		base--;
	}
	base=strdup(tb);
#endif

	qf|=qfl;

	printf("Base=%s\n", base);

#if 1
	//base image, used for size
	sprintf(tb, "%s.png", base);
	buf=BGBBTJ_PNG_LoadRaw(tb, &w, &h);

	if(!buf)
	{
		printf("Failed Load %s\n", tb);
		return(-1);
	}

#if 1
	nvbuf=malloc(w*h*4);
	spbuf=malloc(w*h*4);
	lubuf=malloc(w*h*4);
	memset(nvbuf, 128, w*h*4);
	memset(spbuf, 128, w*h*4);
	memset(lubuf, 128, w*h*4);

	if(AWAL_LoadNormalMap(base, -1, nvbuf, w, h)<=0)
		{ free(nvbuf); nvbuf=NULL; }
	if(AWAL_LoadSpecularMap(base, -1, spbuf, w, h)<=0)
		{ free(spbuf); spbuf=NULL; }
	if(AWAL_LoadLumaMap(base, -1, lubuf, w, h)<=0)
		{ free(lubuf); lubuf=NULL; }

//	AWAL_LoadSpecularMap(base, i, nvbuf, w, h);
#endif

	printf("Img: %dx%d\n", w, h);

	tbuf=malloc(1<<24);
	i=BGBBTJ_JPG_EncodeComponent(
		buf, nvbuf, spbuf, lubuf,
		tbuf, w, h, qf); //90

	sprintf(tb, "%s_dump.jpg", base);
	fd=fopen(tb, "wb");
	if(fd)
	{
		fwrite(tbuf, 1, i, fd);
		fclose(fd);
	}

#if 1
	if(flags&1)
	{
		obuf=malloc(w*h*4);
		onvbuf=malloc(w*h*4);
		ospbuf=malloc(w*h*4);
		olubuf=malloc(w*h*4);
		memcpy(obuf, buf, w*h*4);
		if(nvbuf)memcpy(onvbuf, nvbuf, w*h*4);
		if(spbuf)memcpy(ospbuf, spbuf, w*h*4);
		if(lubuf)memcpy(olubuf, lubuf, w*h*4);

		memset(buf, 0, w*h*4);
		if(nvbuf)memset(nvbuf, 0, w*h*4);
		if(spbuf)memset(spbuf, 0, w*h*4);
		if(lubuf)memset(lubuf, 0, w*h*4);

		jpctx=BGBBTJ_JPG_AllocContext();

		printf("Decode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;

			j=0;
//			BGBBTJ_JPG_DecodeCtxClrs(jpctx, tbuf, i,
//				BGBBTJ_JPG_BC1, &w1, &h1);
	
			j=BGBBTJ_JPG_DecodeComponent(tbuf, i,
				buf, nvbuf, spbuf, lubuf,
				&w1, &h1);

//			j=BGBBTJ_JPG_DecodeComponentClrs(tbuf, i,
//				BGBBTJ_JPG_BC3,
//				buf, nvbuf, spbuf, lubuf,
//				&w1, &h1);

			k++;

			printf("Decoded %d times, ret=%d, dt=%.4fs "
					"rate=%.4f/s  %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("Decoded %d times\n", k);

		i=!memcmp(buf, obuf, w*h*4);
		printf("Lossless RGBA %s\n", i?"Yes":"No");
		if(!i)imgstat(buf, obuf, w*h);

		if(nvbuf)
		{
			i=!memcmp(nvbuf, onvbuf, w*h*4);
			printf("Lossless Norm %s\n", i?"Yes":"No");
			if(!i)imgstat(nvbuf, onvbuf, w*h);
		}

		if(spbuf)
		{
			i=!memcmp(spbuf, ospbuf, w*h*4);
			printf("Lossless Specular %s\n", i?"Yes":"No");
			if(!i)imgstat(spbuf, ospbuf, w*h);
		}

		if(lubuf)
		{
			i=!memcmp(lubuf, olubuf, w*h*4);
			printf("Lossless Luma %s\n", i?"Yes":"No");
			if(!i)imgstat(lubuf, olubuf, w*h);
		}

#if 1
		i=BGBBTJ_JPG_EncodeComponent(
			buf, nvbuf, spbuf, lubuf,
			tbuf, w, h, qf); //90

		sprintf(tb, "%s_dump2.jpg", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif
	}
#endif

#if 1
	if(flags&2)
	{
		obuf=malloc(w*h*4);
		obuf1=malloc(w*h*4);

#if 1
		BGBBTJ_BCn_EncodeImageDXT5(obuf, buf, w, h, 4);
		BGBBTJ_BCn_DecodeImageDXT5(obuf, obuf1, w, h, 4);
		i=!memcmp(obuf1, buf, w*h*4);
		printf("Lossless DXT5 %s\n", i?"Yes":"No");
		if(!i)imgstat(obuf1, buf, w*h);
#endif

#if 1
		BGBBTJ_BCn_EncodeImageDXT5_UVAY(obuf, buf, w, h, 4);
		BGBBTJ_BCn_DecodeImageDXT5_UVAY(obuf, obuf1, w, h, 4);
		i=!memcmp(obuf1, buf, w*h*4);
		printf("Lossless DXT5 UVAY %s\n", i?"Yes":"No");
		if(!i)imgstat(obuf1, buf, w*h);
#endif

		printf("DXT Encode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;

//			BGBBTJ_BCn_EncodeImageDXT1F(obuf, buf, w, h, 4);
//			BGBBTJ_BCn_EncodeImageDXT1(obuf, buf, w, h, 4);
//			BGBBTJ_BCn_EncodeImageDXT5(obuf, buf, w, h, 4);
			BGBBTJ_BCn_EncodeImageDXT5_UVAY(obuf, buf, w, h, 4);

//			BGBBTJ_BCn_EncodeImageDXT1F_YUV(obuf, buf, w, h, 4);
	
//			j=BGBBTJ_JPG_DecodeComponent(tbuf, i,
//				buf, nvbuf, spbuf, lubuf,
//				&w1, &h1);
			k++;

			printf("Encoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nEncoded %d times\n", k);

#if 1
		i=(w/4)*(h/4);
		j=BGBBTJ_PackBCn_EncodeBlocksDXT5(obuf1, obuf, i);

		memset(obuf, 0x55, i*16);
		memset(buf, 0x55, w*h*4);

		printf("Encoded Pack %d -> %d\n", i*16, j);

		printf("PackDXT Decode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;
			k++;

			j=BGBBTJ_PackBCn_DecodeBlocksDXT5(obuf1, obuf, i);

			printf("Decoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nDecoded %d times\n", k);
#endif

//		BGBBTJ_BCn_DecodeImageDXT5(obuf, buf, w, h, 4);
		BGBBTJ_BCn_DecodeImageDXT5_UVAY(obuf, buf, w, h, 4);

#if 1
		i=BGBBTJ_JPG_EncodeComponent(
			buf, nvbuf, spbuf, lubuf,
			tbuf, w, h, 95); //90

		sprintf(tb, "%s_dump_dxt1.jpg", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif
	}
#endif

#if 1
	if(flags&4)
	{
		obuf=malloc(w*h*4);
		obuf1=malloc(w*h*4);

#if 1
		BGBBTJ_FiltLBR_FilterImage(obuf1, buf, w, h, qf);

		i=BTIC1_EncodeComponent(
			obuf1, nvbuf, spbuf, lubuf,
			tbuf, w, h, 95); //90
#endif

#if 0
		i=BTIC1_EncodeComponent(
			buf, nvbuf, spbuf, lubuf,
			tbuf, w, h, qf); //90
#endif

		sprintf(tb, "%s_dump.btic", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}


		j=BTIC1_DecodeComponent(tbuf, i,
			obuf, nvbuf, spbuf, lubuf,
			&w1, &h1, BGBBTJ_JPG_RGBA);

		i=!memcmp(obuf, buf, w*h*4);
		printf("Lossless BTIC1 DXT5 %s\n", i?"Yes":"No");
		if(!i)imgstat(obuf, buf, w*h);

#if 1
		memset(obuf, 0x55, i*16);
		memset(buf, 0x55, w*h*4);

		printf("BTIC1 Decode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;
			k++;

//			j=BTIC1_DecodeComponent(tbuf, i,
//				obuf, nvbuf, spbuf, lubuf,
//				&w1, &h1, BGBBTJ_JPG_RGBA);

			j=BTIC1_DecodeComponent(tbuf, i,
				obuf1, nvbuf, spbuf, lubuf,
				&w1, &h1, BGBBTJ_JPG_BC3);

			printf("Decoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nDecoded %d times\n", k);
#endif

#if 1
//		i=BGBBTJ_JPG_EncodeComponent(
//			obuf, nvbuf, spbuf, lubuf,
//			tbuf, w, h, 95); //90

		i=BGBBTJ_BufPNG_Encode(tbuf, 1<<20, obuf, w, h);

//		sprintf(tb, "%s_dump_btic1.jpg", base);
		sprintf(tb, "%s_dump_btic1.png", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif

#if 0
		BGBBTJ_FiltLBR_FilterImage(obuf1, buf, w, h, qf);

		i=!memcmp(obuf1, buf, w*h*4);
		printf("Lossless LBR %s\n", i?"Yes":"No");
		if(!i)imgstat(obuf1, buf, w*h);

#if 1
		i=BGBBTJ_JPG_EncodeComponent(
			obuf1, NULL, NULL, NULL,
			tbuf, w, h, qf); //90

		sprintf(tb, "%s_dump_flbr1.jpg", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif
#endif

#if 0
		BGBBTJ_BCn_EncodeImageDXT5(obuf, buf, w, h, 4);
		BGBBTJ_BCn_DecodeImageDXT5(obuf, obuf1, w, h, 4);
		i=!memcmp(obuf1, buf, w*h*4);
		printf("Lossless DXT5 %s\n", i?"Yes":"No");
		if(!i)imgstat(obuf1, buf, w*h);
#endif

#if 1

		tbuf1=malloc(1<<24);

#if 1
		btctx=BTIC1_AllocContext();

		i=BTIC1_EncodeComponentCtx(btctx,
			obuf, nvbuf, spbuf, lubuf,
			tbuf, w, h, 95|BGBBTJ_QFL_IFRAME);

		j=BTIC1_EncodeComponentCtx(btctx,
			obuf, nvbuf, spbuf, lubuf,
			tbuf1, w, h, 95|BGBBTJ_QFL_PFRAME);
			
		BTIC1_FreeContext(btctx);
#endif

		printf("BTIC1 I-Frame Test, Sz=%d\n", i);
		printf("BTIC1 P-Frame Test, Sz=%d\n", j);

		sprintf(tb, "%s_dump_pf.btic", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf1, 1, j, fd);
			fclose(fd);
		}

		memset(obuf1, 0, w*h*4);

		btctx=BTIC1_AllocContext();

		BTIC1_DecodeComponentCtx(btctx, tbuf, i,
			obuf1, nvbuf, spbuf, lubuf,
			&w1, &h1, BGBBTJ_JPG_RGBA);

		memset(obuf1, 0, w*h*4);

		j=BTIC1_DecodeComponentCtx(btctx, tbuf1, j,
			obuf1, nvbuf, spbuf, lubuf,
			&w1, &h1, BGBBTJ_JPG_RGBA);

		i=BGBBTJ_BufPNG_Encode(tbuf, 1<<20, obuf1, w, h);
		sprintf(tb, "%s_dump_pf_btic1.png", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}

#endif

	}
#endif


#if 1
	if(flags&8)
	{
		obuf=malloc(w*h*4);
		obuf1=malloc(w*h*4);

		printf("JFE Encode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;
			k++;

			j=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf, BGBBTJ_JPG_RGBA);

			printf("Encoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nEncoded %d times\n", k);

#if 1
//		i=BGBBTJ_JPG_EncodeComponent(
//			obuf, nvbuf, spbuf, lubuf,
//			tbuf, w, h, 95); //90

		i=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf, BGBBTJ_JPG_RGBA);

		sprintf(tb, "%s_dump_jhe1.jpg", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif

		j=BGBBTJ_BitArith_EncodeTestData(tbuf, i, obuf, 1<<20);
		printf("%d -> %d\n", i, j);
	}
#endif

#if 1
	if(flags&16)
	{
		obuf=malloc(w*h*4);
		obuf1=malloc(w*h*4);

		printf("PNG-Fast Encode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;
			k++;

//			j=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf);
			j=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, buf, w, h);

			printf("Encoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nEncoded %d times\n", k);

#if 1
//		i=BGBBTJ_JPG_EncodeComponent(
//			obuf, nvbuf, spbuf, lubuf,
//			tbuf, w, h, 95); //90

//		i=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf);
		i=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, buf, w, h);

		sprintf(tb, "%s_dump_pngf.png", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif
	}
#endif

#if 1
	if(flags&32)
	{
		obuf=malloc(w*h*4);
//		obuf1=malloc(w*h*4);

//		i=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, buf, w, h);
		i=BGBBTJ_BufPNG_Encode(tbuf, 1<<20, buf, w, h);

		printf("PNG Decode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
//			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;
			k++;

//			j=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf);
//			j=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, buf, w, h);
//			obuf1=BGBBTJ_BufPNG_Decode(tbuf, j, &w2, &h2);
//			memcpy(obuf, obuf1, w2*h2*4);
			j=BGBBTJ_BufPNG_DecodeOBuf(tbuf, i, obuf, &w1, &h1);

			printf("Decoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s    \r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nEncoded %d times\n", k);

#if 1
//		i=BGBBTJ_JPG_EncodeComponent(
//			obuf, nvbuf, spbuf, lubuf,
//			tbuf, w, h, 95); //90

//		i=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf);
//		i=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, obuf, w, h);
		i=BGBBTJ_BufPNG_Encode(tbuf, 1<<20, obuf, w, h);

		sprintf(tb, "%s_dump_pngd.png", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif
	}
#endif

#if 1
	if(flags&64)
	{
		obuf=malloc(w*h*4);
		obuf1=malloc(w*h*4);

		ptr0=BGBBTJ_RPZA_AllocContext();

		printf("RPZA Encode Test\n");
		t0=clock(); k=0;
		while(1)
		{
			t1=clock();
			t2=t1-t0;
			if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
//			if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
				break;
			k++;

//			j=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf);
//			j=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, buf, w, h);

			j=BGBBTJ_RPZA_EncodeImage(ctx, buf, tbuf, 1<<20, w, h, qf, 0);

			printf("Encoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s %.4fMp/s\r", k, j,
				t2/(float)CLOCKS_PER_SEC,
				k/(t2/(float)CLOCKS_PER_SEC),
				(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
			if(j<0)break;
		}
		printf("\nEncoded %d times\n", k);

#if 0
//		i=BGBBTJ_JPG_EncodeComponent(
//			obuf, nvbuf, spbuf, lubuf,
//			tbuf, w, h, 95); //90

//		i=BTJ_JFE_EncodeFast(buf, tbuf, w, h, qf);
		i=BGBBTJ_BufPNG_EncodeFast(tbuf, 1<<20, buf, w, h);

		sprintf(tb, "%s_dump_rpaz.png", base);
		fd=fopen(tb, "wb");
		if(fd)
		{
			fwrite(tbuf, 1, i, fd);
			fclose(fd);
		}
#endif
	}
#endif


//	*(int *)-1=-1;

	sprintf(tb, "%s.avi", base);
//	ctx=BGBBTJ_AVI_OpenOutStream(tb, w, h, 10, fcc);
//	ctx=BGBBTJ_AVI_OpenOutStream(tb, w, h, fps, fcc);
	ctx=BGBBTJ_AVI_OpenOutStream2(tb, w, h, fps, fcc, 0);

//	free(buf);	//don't need

	lbuf=malloc(w*h*4);
	memset(lbuf, 0, w*h*4);
	tbuf=malloc(w*h*4);

	for(i=0; i<1024; i++)
	{
		sprintf(tb, "%s_%d.png", base, i);
		buf=BGBBTJ_PNG_LoadRaw(tb, &w1, &h1);
		if(!buf)break;
		
		printf("Got %s %dx%d\n", tb, w1, h1);

		k=0;
		if(!i)k=15;

		if(AWAL_LoadNormalMap(base, i, nvbuf, w, h)>0)k|=1;
		if(AWAL_LoadSpecularMap(base, i, spbuf, w, h)>0)k|=2;
		if(AWAL_LoadLumaMap(base, i, lubuf, w, h)>0)k|=4;

		if(k)printf("\t k=%d\n", k);

		ctx->accDt2=1.0/ctx->fps;
//		BGBBTJ_AVI_EncodeFrame(ctx, buf, w1, h1);
//		BGBBTJ_AVI_EncodeComponentFrame(ctx,
//			buf, (k&1)?nvbuf:NULL,
//			(k&2)?spbuf:NULL, (k&4)?lubuf:NULL,
//			w1, h1);

		qf2=qf;
		if(flags&BTJ_FL_USEIPFRAME)
		{
			if(!(i%16))
				{ qf2|=BGBBTJ_QFL_IFRAME; }
			else
				{ qf2|=BGBBTJ_QFL_PFRAME; }
		}

		BGBBTJ_AVI_EncodeComponentFrame2(ctx,
			buf, (k&1)?nvbuf:NULL,
			(k&2)?spbuf:NULL, (k&4)?lubuf:NULL,
			w1, h1, qf2, BGBBTJ_JPG_RGBA);
//		free(buf);
	}

	BGBBTJ_AVI_CloseOutStream(ctx);

//	sprintf(tb, "%s.wal", base);
//	AWAL_WriteFile(tb, wal);
#endif

	return(0);
}
#include <bgbbtj.h>

#include <time.h>

#ifndef FOURCC
#define FOURCC(a, b, c, d) ((a)|((b)<<8)|((c)<<16)|((d)<<24))
#endif

#define FCC_MJPG	FOURCC('M', 'J', 'P', 'G')
#define FCC_JPEG	FOURCC('J', 'P', 'E', 'G')

#define FCC_RGBA	FOURCC('R', 'G', 'B', 'A')
#define FCC_RGBT	FOURCC('R', 'G', 'B', 'T')

#define FCC_BtV0	FOURCC('B', 't', 'V', '0')

byte *animavi_framergba;

int main(int argc, char *argv[])
{
	byte tb[1024];
	byte *buf, *lbuf, *tbuf, *tbuf1;
	byte *nvbuf, *spbuf, *lubuf;
	byte *obuf, *onvbuf, *ospbuf, *olubuf;

//	WalInfo_t *wal;
	BGBBTJ_AVI_Context *ctx;
	byte *base, *chain, *s;
	byte *fdbuf;
	FILE *fd;
	int cy, cu, cv, cr, cg, cb;
	int t0, t1, t2, flags;
	int i, j, k, w, h, w1, h1, fcc, qf;
	float f, g;

	fcc=FCC_MJPG;
	flags=0;
	qf=90;

#if 1
	base=NULL;
	for(i=1; i<argc; i++)
	{
		if(argv[i][0]=='-')
		{
//			if(!strcmp(argv[i], "-btv"))
//				fcc=FCC_BtV0;

//			if(!strcmp(argv[i], "-dectst"))
//				flags|=1;
				
			if(!strcmp(argv[i], "-q"))
			{
				qf=atoi(argv[i+1]);
				i++; continue;
			}

		}else
		{
			if(!base)
				base=argv[i];
		}
	}

	strcpy(tb, base);
	base=tb+strlen((char *)tb);
	while(base>tb)
	{
		if(*base=='.')
			{ *base=0; break; }
		base--;
	}
	base=strdup(tb);
#endif

	printf("Base=%s\n", base);

	sprintf(tb, "%s.avi", base);
	ctx=BGBBTJ_AVI_LoadAVI(tb);

	w=ctx->bmihead->biWidth;
	h=ctx->bmihead->biHeight;

	while(ctx->cindex>=0)
	{
		fdbuf=BGBBTJ_AVI_DecodeFrame(ctx);

		sprintf(tb, "%s_%d.png", base, ctx->frnum-1);
		BGBBTJ_PNG_SaveRaw(tb, fdbuf, w, h);
	}

#if 1
	printf("Decode Test\n");
	t0=clock(); k=0;
	while(1)
	{
		t1=clock();
		t2=t1-t0;
		if((t2<0) || (t2>(30*CLOCKS_PER_SEC)))
//		if((t2<0) || (t2>(10*CLOCKS_PER_SEC)))
			break;

		j=0;

		fdbuf=BGBBTJ_AVI_DecodeFrame2(ctx, 0, BGBBTJ_JPG_BC1);

		k++;

		printf("Decoded %d times, ret=%d, dt=%.4fs "
				"rate=%.4f/s  %.4fMp/s\r", k, j,
			t2/(float)CLOCKS_PER_SEC,
			k/(t2/(float)CLOCKS_PER_SEC),
			(1.0/1000000)*w*h*(k/(t2/(float)CLOCKS_PER_SEC)));
		if(j<0)break;
	}
	printf("Decoded %d times\n", k);
#endif

	return(0);
}
#include <bgbbtj.h>

#include <time.h>

#ifndef FOURCC
#define FOURCC(a, b, c, d) ((a)|((b)<<8)|((c)<<16)|((d)<<24))
#endif

#define FCC_MJPG	FOURCC('M', 'J', 'P', 'G')
#define FCC_JPEG	FOURCC('J', 'P', 'E', 'G')

#define FCC_RGBA	FOURCC('R', 'G', 'B', 'A')
#define FCC_RGBT	FOURCC('R', 'G', 'B', 'T')

#define FCC_BtV0	FOURCC('B', 't', 'V', '0')

byte *animavi_framergba;

int main(int argc, char *argv[])
{
	byte tb[1024];
	float exptab[256];
	float scltab[256];
	byte *buf, *lbuf, *tbuf, *tbuf1;
	byte *nvbuf, *spbuf, *lubuf;
	byte *obuf, *onvbuf, *ospbuf, *olubuf;

//	WalInfo_t *wal;
	BGBBTJ_AVICtx *ctx;
	byte *base, *chain, *s;
	FILE *fd;
	int cy, cu, cv, cr, cg, cb;
	int t0, t1, t2, flags;
	int i, j, k, w, h, w1, h1, fcc, qf;
	float f, g;

	fcc=FCC_MJPG;
	flags=0;
	qf=90;

#if 1
	base=NULL;
	for(i=1; i<argc; i++)
	{
		if(argv[i][0]=='-')
		{
			if(!strcmp(argv[i], "-btv"))
				fcc=FCC_BtV0;

			if(!strcmp(argv[i], "-dectst"))
				flags|=1;
				
			if(!strcmp(argv[i], "-q"))
			{
				qf=atoi(argv[i+1]);
				i++; continue;
			}

		}else
		{
			if(!base)
				base=argv[i];
		}
	}

	strcpy(tb, base);
	base=tb+strlen((char *)tb);
	while(base>tb)
	{
		if(*base=='.')
			{ *base=0; break; }
		base--;
	}
	base=strdup(tb);
#endif

	printf("Base=%s\n", base);

#if 1
	//base image, used for size
	sprintf(tb, "%s.png", base);
	buf=BGBBTJ_PNG_LoadRaw(tb, &w, &h);

	if(!buf)
	{
		printf("Failed Load %s\n", tb);
		return(-1);
	}

#if 1
	nvbuf=malloc(w*h*4);
	spbuf=malloc(w*h*4);
	lubuf=malloc(w*h*4);
	memset(nvbuf, 128, w*h*4);
	memset(spbuf, 128, w*h*4);
	memset(lubuf, 128, w*h*4);
#endif

#if 0
	if(AWAL_LoadNormalMap(base, -1, nvbuf, w, h)<=0)
		{ free(nvbuf); nvbuf=NULL; }
	if(AWAL_LoadSpecularMap(base, -1, spbuf, w, h)<=0)
		{ free(spbuf); spbuf=NULL; }
	if(AWAL_LoadLumaMap(base, -1, lubuf, w, h)<=0)
		{ free(lubuf); lubuf=NULL; }

//	AWAL_LoadSpecularMap(base, i, nvbuf, w, h);
#endif

	printf("Img: %dx%d\n", w, h);

#if 0
	tbuf=malloc(1<<22);
	i=BGBBTJ_JPG_EncodeComponent(
		buf, nvbuf, spbuf, lubuf,
		tbuf, w, h, qf); //90

	sprintf(tb, "%s_dump.jpg", base);
	fd=fopen(tb, "wb");
	if(fd)
	{
		fwrite(tbuf, 1, i, fd);
		fclose(fd);
	}
#endif

	sprintf(tb, "%s.avi", base);
	ctx=BGBBTJ_AVI_OpenOutStream(tb, w, h, 10, fcc);

	free(buf);	//don't need


	animavi_framergba=malloc(w*h*4);

	lbuf=malloc(w*h*4);
	memset(lbuf, 0, w*h*4);
	tbuf=malloc(w*h*4);

	for(i=0; i<1024; i++)
	{
		sprintf(tb, "%s_%d.png", base, i);
		buf=BGBBTJ_PNG_LoadRaw(tb, &w1, &h1);
		if(buf)
		{
			memcpy(animavi_framergba, buf, w*h*4);
//			break;
		}
		
//		memset(animavi_framergba, 128, w*h*4);
		
		if(!buf)break;
		
		printf("Got %s %dx%d\n", tb, w1, h1);

		k=0;
		if(!i)k=15;

//		if(AWAL_LoadNormalMap(base, i, nvbuf, w, h)>0)k|=1;
//		if(AWAL_LoadSpecularMap(base, i, spbuf, w, h)>0)k|=2;
//		if(AWAL_LoadLumaMap(base, i, lubuf, w, h)>0)k|=4;

		if(k)printf("\t k=%d\n", k);

		ctx->accDt2=1.0/ctx->fps;
		BGBBTJ_AVI_EncodeFrame(ctx, animavi_framergba, w, h);
//		BGBBTJ_AVI_EncodeComponentFrame(ctx,
//			buf, (k&1)?nvbuf:NULL,
//			(k&2)?spbuf:NULL, (k&4)?lubuf:NULL,
//			w1, h1);
		free(buf);
	}

	BGBBTJ_AVI_CloseOutStream(ctx);
#endif

	return(0);
}
/*
Written by Brendan G Bohannon
This tool is placed into the public domain.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int doc, pds, amod, prx;

int symchar(int c) //AH:proxy
{
	if((c>='a') && (c<='z'))return(1);
	if((c>='A') && (c<='Z'))return(1);
	if((c>='0') && (c<='9'))return(1);
	if(c=='_')return(1);
	return(0);
}

char *id_arch()
{
#ifdef __i386__
	return("x86");
#endif
#ifdef __x86_64__
	return("x64");
#endif
#ifdef _M_IX86
	return("x86");
#endif
#ifdef _M_X64
	return("x64");
#endif
#ifdef _M_PPC
	return("ppc");
#endif
	return("unk");
}

char *id_wsuf()
{
#ifdef __i386__
	return("32");
#endif
#ifdef __x86_64__
	return("64");
#endif
#ifdef _M_IX86
	return("32");
#endif
#ifdef _M_X64
	return("64");
#endif
#ifdef _M_PPC
	return("P32");
#endif
#ifdef _M_PPC64
	return("P64");
#endif
	return("");
}

void prx_def(char *buf)
{
	char tb[256], tbn[256], tty[256];
	char *s, *t, *t1, *sa;
	int ind;

	s=buf; t=tb;

#ifdef _MSC_VER
	sprintf(t, "__declspec(dllexport) "); t+=strlen(t);
#endif

	t1=tty;
	while(symchar(*s))*t1++=*s++;
	*t1++=0;
	sprintf(t, "%s", tty); t+=strlen(t);

	while(*s && (*s<=' '))*t++=*s++;

	ind=0;
	while(*s=='*') { *t++=*s++; ind++; }

	t1=tbn;
	while(*s && symchar(*s))*t1++=*s++;
	*t1++=0;

	sprintf(t, "(*_iproxy_%s)", tbn); t+=strlen(t);

	sa=s;
	while(*s)*t++=*s++;
	*t++=0;

	printf("%s;\n", tb);

	t=tb;
	sprintf(tb, "%s\n\t{ ", buf); t+=strlen(t);
	if(strcmp(tty, "void") || ind)
		{ sprintf(t, "return "); t+=strlen(t); }
	sprintf(t, "_iproxy_%s(", tbn); t+=strlen(t);

	s=sa;
	while(s && *s!=')')
	{
		while(*s && (*s!=')') && (*s!=','))s++;
		while(!symchar(*(s-1)))s--;
		while(symchar(*(s-1)))s--;
		if(!strncmp(s, "void)", 5))break;
		while(symchar(*s))*t++=*s++;
		while(*s && (*s!=')') && (*s!=','))s++;
		if(*s==',') { s++; *t++=','; *t++=' '; }
	}

	sprintf(t, "); }\n"); t+=strlen(t);
	printf("%s\n", tb);
}

int main(int argc, char *argv[])
{
	int i, j, l, isapi;
	FILE *fd;
	char *buf, *buf2, *buf3, *buf4;
	char *s, *s2, *t;
	char *cat, *api;

	buf=malloc(16384);
	buf2=malloc(16384);
	buf3=malloc(256);
	buf4=malloc(256);

	doc=0; pds=0; amod=0; prx=0;
	api=NULL;

	for(i=1; i<argc; i++)
	{
		if(argv[i][0]=='-')
		{
			if(!strcmp(argv[i], "-doc"))
			{
				doc=1;
				cat=argv[i+1];
				i++;
				continue;
			}
			if(!strcmp(argv[i], "-pds"))
			{
				pds=1;
				cat=argv[i+1];
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-api"))
			{
				api=argv[i+1];
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-apionly"))
			{
				api=argv[i+1]; amod=1;
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-noapi"))
			{
				api=argv[i+1]; amod=2;
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-proxy"))
			{
				prx=1;
				continue;
			}

			if(!strcmp(argv[i], "-idarch"))
			{
				printf("%s", id_arch());
				exit(0);
			}
			if(!strcmp(argv[i], "-idwsuf"))
			{
				printf("%s", id_wsuf());
				exit(0);
			}

			fprintf(stderr, "Unknown option '%s'\n", argv[i]);
			exit(-1);
		}

		fd=fopen(argv[i], "rt");
		if(!fd)continue;

		printf("//AHSRC:%s\n", argv[i]);
		l=0;
		while(!feof(fd))
		{
			memset(buf, 0, 256);
			fgets(buf, 255, fd);
			l++;

			s=buf;
			while(*s && (*s!='\r') && (*s!='\n'))s++;
			if(*s=='\r')*s=0;
			if(*s=='\n')*s=0;

			s=buf;
			while(*s && (*s<=' '))s++;
			if(!strncmp(s, "//AH:", 5))
			{
//				fprintf(stderr, "//AH tag %s %d\n",
//					argv[i], l);
				s+=5;
				while(*s && (*s<=' '))s++;
				if(!strcmp(s, "skip"))break;
			}

			if(pds)if(!strncmp(s, "//PDSCAT:", 9))
			{
				s+=9;
				t=buf3;
				while(*s)*t++=*s++;
				*t++=0;

				cat=strdup(buf3);
			}

			if(pds)if(!strncmp(s, "//PDS:", 6))
			{
				s+=6;
				while(*s && (*s<=' '))s++;

				t=buf3;
				while(*s && strncmp(s, "::", 2))
				{
					if((s[0]=='\\') && (s[1]<=' '))
					{
						fgets(buf, 255, fd);
						s=buf;
						while(*s && (*s<=' '))s++;
						if(!strncmp(s, "//", 2))s+=2;
						continue;
					}
					if(*s=='\r')break;
					if(*s=='\n')break;
					*t++=*s++;
				}
				*t++=0;

				if(!strncmp(s, "::", 2))s+=2;

				t=buf4;
				while(*s)
				{
					if((s[0]=='\\') && (s[1]<=' '))
					{
						fgets(buf, 255, fd);
						s=buf;
						while(*s && (*s<=' '))s++;
						if(!strncmp(s, "//", 2))s+=2;
						continue;
					}
					if(*s=='\r')break;
					if(*s=='\n')break;
					*t++=*s++;
				}
				*t++=0;

				printf(
					"/*--\n"
					"Cat %s\n"
					"Text\n"
					"\t%s\n"
					"\t%s\n"
					"--*/\n",
					cat, buf3, buf4);
			}

			if(pds)continue;

			s=buf;
			isapi=0;

			if(api)
			{
				if(!strncmp(s, api, strlen(api)))
				{
					if(amod==2)continue;

					s+=strlen(api);
					while(*s && (*s<=' '))s++;
					isapi=1;
				}else
				{
					if(amod==1)continue;
				}
			}

			if(!strncmp(s, "static", strlen("static")))
				continue;

			if(*s<=' ')continue;
			while(symchar(*s))s++;
			while(*s && (*s<=' '))s++;

			while(*s=='*')s++;
			if(!*s || (*s=='('))continue;
			while(*s && symchar(*s))s++;

			if(((*s=='=') || (*s==';')) && isapi)
			{
				//special case: API variables are exported
				t=s;
				while(*s && (*s!='/'))s++;
				if(!strncmp(s, "//AH:", 5))
				{
					s+=5;
					while(*s && (*s<=' '))s++;
					if(!strcmp(s, "ignore"))continue;
				}
				s=t;

				*s=0;
				if(!doc)printf("%s;\n", buf);

				continue;
			}

			if(*s==' ')s++;
			if(*s!='(')continue;

			t=s;
			while(*s && (*s!='/'))s++;
			if(!strncmp(s, "//AH:", 5))
			{
//				fprintf(stderr, "//AH tag %s %d\n",
//					argv[i], l);
				s+=5;
				while(*s && (*s<=' '))s++;
				if(!strcmp(s, "ignore"))continue;
			}
			s=t;

			if(*s=='(')s++;
			j=1;
			while(j)
			{
				if(!*s)
				{
					memset(buf2, 0, 256);
					fgets(buf2, 255, fd);
					l++;

					t=buf2;
					while(*t && (*t<=' '))t++;

					s2=t;
					t=s;
					while(*s2 && (*s2!='\n'))*t++=*s2++;
					*t++=' ';
					*t++=0;
				}else
				{
					if(*s=='(')j++;
					if(*s==')')j--;
					s++;
				}
			}
			t=s;
			while(*s && (*s!='/'))s++;
			if(!strncmp(s, "//AH:", 5))
			{
				fprintf(stderr, "//AH tag %s %d\n",
					argv[i], l);
				s+=5;
				while(*s && (*s<=' '))s++;
				if(!strncmp(s, "ignore", 6))continue;

				if(prx && strncmp(s, "proxy", 5))continue;
				if(!strncmp(s, "proxy", 5))isapi=2;
			}else
			{
				if(prx)continue;
			}
			s=t;

			if(*s==')')s++;
			*s=0;

			if(doc)
			{
				printf(
					"/*--\n"
					"Cat %s\n"
					"Text\n"
					"\t%s;\n"
					"\t%s:%d\n"
					"--*/\n",
					cat, buf, argv[i], l);
			}else
			{
				if(prx) { prx_def(buf); continue; }
				if(isapi==2) printf("/*AHPRX:*/ ", buf);
				printf("%s;\n", buf);
			}
		}
		fclose(fd);
	}
	return(0);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <math.h>

#include <time.h>

#include <bgbbtj.h>
#include <zpack.h>
// #include <bgbmid.h>

static int bgbmid_fdcopy(FILE *ifd, FILE *ofd)
{
	char buf[256];
	int i;

	printf("bgbmid_fdcopy\n");

	while(!feof(ifd))
	{
		i=fread(buf, 1, 256, ifd);
		fwrite(buf, 1, i, ofd);
	}
}

int bgbmid_extwav(char *str)
{
	char *s;

	s=str+strlen(str);
	while((s>str) && (*s!='.'))s--;

	if(!strcmp(s, ".wav"))return(1);
	if(!strcmp(s, ".WAV"))return(1);
	return(0);
}

int bgbmid_extpng(char *str)
{
	char *s;

	s=str+strlen(str);
	while((s>str) && (*s!='.'))s--;

	if(!strcmp(s, ".png"))return(1);
	if(!strcmp(s, ".PNG"))return(1);
	return(0);
}

int bgbmid_extskip(char *str)
{
	char *s;

	s=str+strlen(str);
	while((s>str) && (*s!='.'))s--;

	if(!strcmp(s, ".pdn"))return(1);
	if(!strcmp(s, ".PDN"))return(1);

	if(!strcmp(s, ".xcf"))return(1);
	if(!strcmp(s, ".XCF"))return(1);

	if(!strcmp(s, ".psd"))return(1);
	if(!strcmp(s, ".PSD"))return(1);

	if(!strcmp(s, ".db"))return(1);
	if(!strcmp(s, ".DB"))return(1);

	return(0);
}

int help(char *arg0)
{
	printf("Usage: %s <opts*> -o <pack> [-L <dir>] <files*>\n", arg0);
	printf("-o <name>		Indicates output PACK fike\n");
	printf("-L <dir>		Indicates base-directory for input files\n");
	printf("--splitstereo	Store audio in split-stereo format\n");
	printf("--centermono	Store audio in center-mono format\n");
	printf("--blk256		Use 256-sample blocks (176kbps SQ)\n");
	printf("--blk256lq		Use 256-sample blocks (88kbps LQ)\n");
	printf("--blk256hq		Use 256-sample blocks (352kbps HQ)\n");
	return(0);
}

#if 1

u32 ZPACK_FromCTime(time_t *tp)
{
	struct tm *tmp;
	u32 i;

	tmp=localtime(tp);
	i=(tmp->tm_sec/2)+(tmp->tm_min*32)+(tmp->tm_hour*2048)+
		(tmp->tm_mday*65536)+(tmp->tm_mon*2097152)+
		((tmp->tm_year-80)*33554432);
	return(i);
}

time_t ZPACK_ToCTime(u32 t)
{
	struct tm tmp;

	tmp.tm_year=80+t/33554432;
	tmp.tm_mon=(t/2097152)%12;
	tmp.tm_mday=(t/65536)%31;
	tmp.tm_hour=(t/2048)%24;
	tmp.tm_min=(t/32)%60;
	tmp.tm_sec=(t*2)%60;

	return(mktime(&tmp));
}

char *ZPACK_TimeStr(u32 t)
{
	static char buf[64];

	sprintf(buf, "%04d-%02d-%02d %02d:%02d:%02d",
		1980+t/33554432, (t/2097152)%12, (t/65536)%31,
		(t/2048)%24, (t/32)%60, (t*2)%60);
	return(buf);
}

u32 ZPACK_TimeFunc()
{
	time_t t;
	u32 i;

	t=time(NULL);
	i=ZPACK_FromCTime(&t);
	return(i);
}

#endif

void ZPACK_AddFile(ZPACK_Context *ctx, char *name, char *fname)
{
	static byte buffer[16384];
//	struct stat fst;
	ZPACK_STAT st;
	ZPACK_FILE *zfd;
	FILE *fd;
	char *s;
	int i;

	printf("Add: %s\n", name);

//	return;

	fd=fopen(fname, "rb");
	if(!fd)
	{
		printf("Fail Open: %s\n", fname);
		return;
	}

	zfd=ZPACK_OpenFile(ctx, name, "wb");
	if(!zfd)
	{
		printf("Fail Add: %s\n", name);
		return;
	}

	while(!feof(fd))
	{
		i=fread(buffer, 1, 16384, fd);
		ZPACK_Write(zfd, buffer, i);
	}

	fclose(fd);
	ZPACK_Close(zfd);

//	i=stat(name, &fst);
//	if(i>=0)
//	{
//		i=ZPACK_FromCTime(&fst.st_mtime);
//		ZPACK_SetFileTime(ctx, name, i);
//		s=ZPACK_TimeStr(i);
//		printf("Time: %s\n", s);
//	}

	i=ZPACK_StatFile(ctx, name, &st);
	if(i<0)
	{
		printf("Failed to Add: %s\n", name);
		return;
	}

	s="unknown";
	if(st.method==0)s="stored";
	if(st.method==8)s="deflated";
	if(st.method==9)s="deflated(64k)";
	printf("%s %d->%d (%d%%) %08X @%08X..%08X\n",
		s, st.usize, st.csize, 100-((100*st.csize)/st.usize),
		st.crc32,
		st.offset, st.offset+st.csize);
}

void BTJPACK_AddPNG(ZPACK_Context *ctx, char *name, char *fname, int qf)
{
	char tb[256], tb2[256];
//	struct stat fst;
	ZPACK_STAT st;
	ZPACK_FILE *zfd;
	byte *buf, *ibuf;
	char *s;
	int i, j, k, l, n;
	int w, h;

	strcpy(tb, name);
	strcpy(tb2, fname);

	ibuf=BGBBTJ_PNG_LoadRaw(tb2, &w, &h);
	
	if(!ibuf)
	{
		printf("BTJPACK_AddPNG: Fail Load %s\n", tb2);
		return;
	}
	
	if((w&15) || (h&15))
	{
		BGBBTJ_PNG_Free(ibuf);

		ZPACK_AddFile(ctx, name, fname);
		return;
	}
	
	buf=malloc(1<<24);

	k=BGBBTJ_JPG_EncodeComponent(
		ibuf, NULL, NULL, NULL,
		buf, w, h, qf); //90
	BGBBTJ_PNG_Free(ibuf);

	s=tb+strlen(tb);
	while((s>tb) && (*s!='.'))s--;
	strcpy(s, ".jpg");

	zfd=ZPACK_OpenFile(ctx, tb, "wb");
	ZPACK_Write(zfd, buf, k);
	ZPACK_Close(zfd);

	free(buf);

//	j=ftell(ofd);
//	fwrite(buf, 1, k, ofd);

//	i=stat(tb, &fst);
//	if(i>=0)
//	{
//		i=ZPACK_FromCTime(&fst.st_mtime);
//		ZPACK_SetFileTime(ctx, tb, i);
//		s=ZPACK_TimeStr(i);
//		printf("Time: %s\n", s);
//	}

	i=ZPACK_StatFile(ctx, tb, &st);
	if(i<0)
	{
		printf("Failed to Add: %s\n", tb);
		return;
	}

	s="unknown";
	if(st.method==0)s="stored";
	if(st.method==8)s="deflated";
	if(st.method==9)s="deflated(64k)";
	printf("%s %d->%d (%d%%) %08X @%08X..%08X\n",
		s, st.usize, st.csize, 100-((100*st.csize)/st.usize),
		st.crc32,
		st.offset, st.offset+st.csize);
}

int main(int argc, char *argv[])
{
	char *ifn[16384];
	char tb[256], tb2[256];
//	BGBMID_PackHead hdr;
//	BGBMID_PackDirEnt *dir;
	ZPACK_Context *zpctx;
	ZPACK_FILE *zfd;
	FILE *ofd, *ifd;
	byte *buf, *ibuf;
	char *ofn, *lifn;
	char *ldir;
	short *bp;
	char **a;
	char *s;
	int i, j, k, l, n;
	int ch, rt, len, flags, fl, nifn, cmd;
	int w, h, qf, qfl;

	ofn=NULL; ldir=NULL; lifn=NULL;
	nifn=0; flags=0; cmd=0; qf=90; qfl=0;
	for(i=1; i<argc; i++)
	{
		if(argv[i][0]=='-')
		{
			if(!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h"))
			{
				cmd=8;
				continue;
			}

			if(!strcmp(argv[i], "-o"))
			{
				ofn=argv[i+1];
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-L"))
			{
				ldir=argv[i+1];
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-l"))
			{
				lifn=argv[i+1];
				i++;
				continue;
			}

			if(!strcmp(argv[i], "-rdct"))
				qfl|=BGBBTJ_QFL_RDCT;
			if(!strcmp(argv[i], "-s444"))
				qfl|=BGBBTJ_QFL_444;
			if(!strcmp(argv[i], "-crct"))
				qfl|=BGBBTJ_QFL_ORCT;
			if(!strcmp(argv[i], "-crgb"))
				qfl|=BGBBTJ_QFL_RGB;
			if(!strcmp(argv[i], "-s410"))
				qfl|=BGBBTJ_QFL_410;

			if(!strcmp(argv[i], "-bitalpha"))
				qfl|=BGBBTJ_QFL_BITALPHA;
				
			if(!strcmp(argv[i], "-q"))
			{
				qf=atoi(argv[i+1]);
				i++; continue;
			}

#if 0
			if(!strcmp(argv[i], "--splitstereo"))
			{
				flags|=BGBMID_BTAC_EFL_HALFMONO;
				continue;
			}

			if(!strcmp(argv[i], "--centermono"))
			{
				flags|=BGBMID_BTAC_EFL_CENTERMONO;
				continue;
			}
#endif

			if(!strcmp(argv[i], "--encode"))
			{
				cmd=1;
				continue;
			}

			if(!strcmp(argv[i], "--decode"))
			{
				cmd=2;
				continue;
			}

#if 0
			if(!strcmp(argv[i], "--blk256"))
			{
				flags|=BGBMID_BTAC_EBMODE_BLK256;
				continue;
			}

			if(!strcmp(argv[i], "--blk256lq"))
			{
				flags|=BGBMID_BTAC_EBMODE_BLK256LQ;
				continue;
			}

			if(!strcmp(argv[i], "--blk256hq"))
			{
				flags|=BGBMID_BTAC_EBMODE_BLK256HQ;
				continue;
			}
#endif

			printf("%s: unrecognized argument '%s'\n", argv[0], argv[i]);
			continue;
		}else
		{
			ifn[nifn++]=argv[i];
		}
	}

	qf|=qfl;

	if(!ofn || (cmd==8))
	{
		help(argv[0]);
		return(0);
	}

	if(lifn)
	{
		ifd=fopen(lifn, "rt");
		if(ifd)
		{
			while(!feof(ifd))
			{
				fgets(tb, 255, ifd);
				a=gcrsplit(tb);
				if(!a[0])continue;
				if(*a[0]=='#')continue;
				if(*a[0]=='/')continue;
				ifn[nifn++]=a[0];
			}
			fclose(ifd);
		}
	}

	i=ZPACK_Init();
	if(i<0)return(-1);

	ZPACK_SetTimeFunc(&ZPACK_TimeFunc);

//	ofd=fopen(ofn, "wb");
	ZPACK_CreateImage(ofn);
	zpctx=ZPACK_OpenImage(ofn, 0);

//	fwrite(&hdr, 1, 12, ofd);
//	dir=malloc((1<<16)*sizeof(BGBMID_PackDirEnt));

	buf=malloc(1<<24);

	n=0;
	for(i=0; i<nifn; i++)
	{
		if(ldir)
		{
			sprintf(tb2, "%s/%s", ldir, ifn[i]);
		}else
		{
			strcpy(tb2, ifn[i]);
		}
	
//		strcpy(tb, argv[i]);
		strcpy(tb, ifn[i]);

		if(bgbmid_extskip(tb2))
			{ continue; }

		if(bgbmid_extpng(tb2))
		{
			BTJPACK_AddPNG(zpctx, tb, tb2, qf);
		}else
#if 0
		if(bgbmid_extwav(tb2))
		{
			printf("WAV %s\n", tb2);

			s=tb+strlen(tb);
			while((s>tb) && (*s!='.'))s--;
			strcpy(s, ".btac");

//			bp=BGBMID_LoadWAV_Mono16(ifn[i], &rt, &len);
			bp=BGBMID_LoadWAV16(tb2, &ch, &rt, &len);
			if(!bp)continue;
			
			fl=flags;
			
//			k=SGWZ_Encode(bp, rt, len, buf);
			k=BGBMID_BTAC_Encode(bp, ch, rt, len, fl, buf, 1<<24);

			j=ftell(ofd);
			fwrite(buf, 1, k, ofd);

			bgbmid_free(bp);
		}else
#endif
		{
			ZPACK_AddFile(zpctx, tb, tb2);
			
#if 0
			printf("RAW %s\n", tb2);
			ifd=fopen(tb2, "rb");
			if(!ifd)continue;

			j=ftell(ofd);
			bgbmid_fdcopy(ifd, ofd);
			k=ftell(ofd)-j;

			fclose(ifd);
#endif
		}

#if 0
		if(strlen(tb)>=56)
		{
			l=ftell(ofd);
			fwrite(tb, 1, strlen(tb)+1, ofd);
			sprintf(tb, "@@0x%08X", l);
		}

		strcpy(dir[n].name, tb);
		*(int *)(dir[n].offs)=j;
		*(int *)(dir[n].size)=k;
		n++;

		printf("%-56s %10d %10d\n", tb, j, k);
#endif
	}

#if 0
	j=ftell(ofd);
	fwrite(dir, 64, n, ofd);

	*(int *)(hdr.offs)=j;
	*(int *)(hdr.ents)=n;

	hdr.fcc[0]='P';
	hdr.fcc[1]='A';
	hdr.fcc[2]='C';
	hdr.fcc[3]='K';

	fseek(ofd, 0, 0);
	fwrite(&hdr, 1, 12, ofd);
	fclose(ofd);
#endif

	ZPACK_CloseImage(zpctx);
}
/*
load/store wal files
 */

#include <bgbbtj.h>

uint WAL_ReadInt32LE(FILE *fd)
{
	uint i;

	i=fgetc(fd);
	i|=fgetc(fd)<<8;
	i|=fgetc(fd)<<16;
	i|=fgetc(fd)<<24;
	return(i);
}

uint WAL_ReadFourcc(FILE *fd)
{
	uint i;

	i=fgetc(fd);
	i|=fgetc(fd)<<8;
	i|=fgetc(fd)<<16;
	i|=fgetc(fd)<<24;
	return(i);
}

void WAL_Set32LE(byte *t, int val)
{
	t[0]=val;
	t[1]=val>>8;
	t[2]=val>>16;
	t[3]=val>>24;
}

int WAL_Write(FILE *fd, WalInfo_t *inf)
{
	byte tb[256];
	int i;

	memset(tb, 0, 256);
	if(inf->name)
		strcpy(tb+ 0, inf->name);
	if(inf->animname)
		strcpy(tb+56, inf->animname);

	WAL_Set32LE(tb+32, inf->width);
	WAL_Set32LE(tb+36, inf->height);
	WAL_Set32LE(tb+88, inf->flags);
	WAL_Set32LE(tb+92, inf->contents);
	WAL_Set32LE(tb+96, inf->value);

	i=100;
	WAL_Set32LE(tb+40, i);
	i+=inf->width*inf->height;

	WAL_Set32LE(tb+44, i);
	i+=(inf->width/2)*(inf->height/2);

	WAL_Set32LE(tb+48, i);
	i+=(inf->width/4)*(inf->height/4);

	WAL_Set32LE(tb+52, i);
	i+=(inf->width/8)*(inf->height/8);

	fwrite(tb, 1, 100, fd);

	i=inf->width*inf->height;
	fwrite(inf->data[0], 1, i, fd);

	i=(inf->width/2)*(inf->height/2);
	fwrite(inf->data[1], 1, i, fd);

	i=(inf->width/4)*(inf->height/4);
	fwrite(inf->data[2], 1, i, fd);

	i=(inf->width/8)*(inf->height/8);
	fwrite(inf->data[3], 1, i, fd);

	return(0);
}

char *WAL_Q1Name(char *name)
{
	char tb[64];
	char *s, *t;

	s=name+strlen(name);
	while((s>name) && (*s!='/'))s--;
	if(*s=='/')s++;

	t=tb;
	while(*s)
	{
		*t=*s++;
		if(*t=='#')*t='*';
		if((*t>='a') && (*t<='z'))
			*t=(*t-'a')+'A';
		t++;
	}
	*t++=0;

	return(strdup(tb));
}

int WAL_WriteQ1(FILE *fd, WalInfo_t *inf)
{
	byte tb[256];
	int i;

	memset(tb, 0, 256);
	if(inf->name)
		strcpy(tb+ 0, WAL_Q1Name(inf->name));

	WAL_Set32LE(tb+16, inf->width);
	WAL_Set32LE(tb+20, inf->height);

	i=40;
	WAL_Set32LE(tb+24, i);
	i+=inf->width*inf->height;

	WAL_Set32LE(tb+28, i);
	i+=(inf->width/2)*(inf->height/2);

	WAL_Set32LE(tb+32, i);
	i+=(inf->width/4)*(inf->height/4);

	WAL_Set32LE(tb+36, i);
	i+=(inf->width/8)*(inf->height/8);

	fwrite(tb, 1, 40, fd);

	i=inf->width*inf->height;
	fwrite(inf->data[0], 1, i, fd);

	i=(inf->width/2)*(inf->height/2);
	fwrite(inf->data[1], 1, i, fd);

	i=(inf->width/4)*(inf->height/4);
	fwrite(inf->data[2], 1, i, fd);

	i=(inf->width/8)*(inf->height/8);
	fwrite(inf->data[3], 1, i, fd);

	return(0);
}

int WAL_WriteFile(char *name, WalInfo_t *inf)
{
	FILE *fd;

	fd=fopen(name, "wb");
	if(!fd)return(-1);
	WAL_Write(fd, inf);
	fclose(fd);
	return(-1);
}

int WAL_WriteFileQ1(char *name, WalInfo_t *inf)
{
	FILE *fd;

	fd=fopen(name, "wb");
	if(!fd)return(-1);
	WAL_WriteQ1(fd, inf);
	fclose(fd);
	return(-1);
}

void WAL_Conv32to8(byte *ibuf, byte *obuf, int width, int height,
	char *pal)
{
	byte *cs, *ct;
	int i, j, k, n;
	int dr, dg, db;
	int bi, bd;

	if(!ibuf || !obuf || !pal)
		return;

	cs=ibuf; ct=obuf;
	n=width*height;
	for(i=0; i<n; i++)
	{
		bi=0; bd=262144;
		for(j=0; j<256; j++)
		{
			dr=pal[j*3+0]-cs[0];
			dg=pal[j*3+1]-cs[1];
			db=pal[j*3+2]-cs[2];
			k=dr*dr+dg*dg+db*db;
			if(k<bd) { bi=j; bd=k; }
		}

		cs+=4;
		*ct++=bi;
	}
}

int WAL_HalfSample(byte *src, int w, int h)
{
	int i, j, w2, h2, i2, j2;

	w2=w>>1;
	h2=h>>1;
	for(i=0;i<h2; i++)
		for(j=0; j<w2; j++)
	{
		i2=i<<1;
		j2=j<<1;
		src[((i*w2+j)<<2)+0]=
			(src[((i2*w+j2)<<2)+0]+		src[((i2*w+(j2+1))<<2)+0]+
			src[(((i2+1)*w+j2)<<2)+0]+	src[(((i2+1)*w+(j2+1))<<2)+0])>>2;

		src[((i*w2+j)<<2)+1]=
			(src[((i2*w+j2)<<2)+1]+		src[((i2*w+(j2+1))<<2)+1]+
			src[(((i2+1)*w+j2)<<2)+1]+	src[(((i2+1)*w+(j2+1))<<2)+1])>>2;

		src[((i*w2+j)<<2)+2]=
			(src[((i2*w+j2)<<2)+2]+		src[((i2*w+(j2+1))<<2)+2]+
			src[(((i2+1)*w+j2)<<2)+2]+	src[(((i2+1)*w+(j2+1))<<2)+2])>>2;

		src[((i*w2+j)<<2)+3]=
			(src[((i2*w+j2)<<2)+3]+		src[((i2*w+(j2+1))<<2)+3]+
			src[(((i2+1)*w+j2)<<2)+3]+	src[(((i2+1)*w+(j2+1))<<2)+3])>>2;
	}
	return(0);
}

WalInfo_t *WAL_CreateWal(byte *img, int width, int height, char *pal)
{
	WalInfo_t *tmp;
	byte *buf0, *buf1;
	int i, j, i1;

	tmp=malloc(sizeof(WalInfo_t));
	memset(tmp, 0, sizeof(WalInfo_t));

	tmp->width=width;
	tmp->height=height;

	if(!pal)return(tmp);

	buf0=malloc(width*height*4);
	buf1=malloc(width*height);

//	memcpy(buf0, img, width*height*4);
	for(i=0; i<height; i++)
	{
		i1=height-i-1;
		for(j=0; j<width; j++)
		{
			buf0[(i*width+j)*4+0]=img[(i1*width+j)*4+0];
			buf0[(i*width+j)*4+1]=img[(i1*width+j)*4+1];
			buf0[(i*width+j)*4+2]=img[(i1*width+j)*4+2];
			buf0[(i*width+j)*4+3]=img[(i1*width+j)*4+3];
		}
	}

	WAL_Conv32to8(buf0, buf1, width, height, pal);
	i=width*height; tmp->data[0]=malloc(i);
	memcpy(tmp->data[0], buf1, i);

	WAL_HalfSample(buf0, width, height);
	WAL_Conv32to8(buf0, buf1, width/2, height/2, pal);
	i=(width/2)*(height/2); tmp->data[1]=malloc(i);
	memcpy(tmp->data[1], buf1, i);

	WAL_HalfSample(buf0, width/2, height/2);
	WAL_Conv32to8(buf0, buf1, width/4, height/4, pal);
	i=(width/4)*(height/4); tmp->data[2]=malloc(i);
	memcpy(tmp->data[2], buf1, i);

	WAL_HalfSample(buf0, width/4, height/4);
	WAL_Conv32to8(buf0, buf1, width/8, height/8, pal);
	i=(width/8)*(height/8); tmp->data[3]=malloc(i);
	memcpy(tmp->data[3], buf1, i);

	free(buf0); free(buf1);

	if(pal)
	{
		tmp->pal=malloc(768);
		memcpy(tmp->pal, pal, 768);
	}

	return(tmp);
}
#include <bgbbtj.h>

#ifndef FOURCC
#define FOURCC(a, b, c, d) ((a)|((b)<<8)|((c)<<16)|((d)<<24))
#endif


#define FCC_PNG_LOW	FOURCC(0x89, 'P', 'N', 'G')
#define FCC_PNG_HIGH	FOURCC(0x0D, 0x0A, 0x1A, 0x0A)

#define FCC_IHDR	FOURCC('I', 'H', 'D', 'R')
#define FCC_IEND	FOURCC('I', 'E', 'N', 'D')
#define FCC_IDAT	FOURCC('I', 'D', 'A', 'T')
#define FCC_PLTE	FOURCC('P', 'L', 'T', 'E')
#define FCC_tRNS	FOURCC('t', 'R', 'N', 'S')

uint BTV0_DataAdler32(void *buf, int sz, uint lcrc)
{
	byte *s;
	int i, c, s1, s2;

	s=buf;
	s1=lcrc&0xFFFF;
	s2=(lcrc>>16)&0xFFFF;
	for(i=0; i<sz; i++)
	{
		s1=(s1+(s[i]))%65521;
		s2=(s1+s2)%65521;
	}
	return((s2<<16)+s1);
}

uint BTV0_CRC32(void *buf, int sz, uint lcrc)
{
	static uint crctab[256];
	static int init=0;

	byte *s;
	uint c;
	int i, j;

	if(!init)
	{
		init=1;

		for(i=0; i<256; i++)
		{
			c=i;
			for(j=0; j<8; j++)
				if(c&1)c=0xedb88320^(c>>1);
					else c>>=1;
			crctab[i]=c;
		}
	}

	c=lcrc; s=buf; i=sz;
	while(i--)c=crctab[(c^(*s++))&0xFF]^(c>>8);
	return(c);
}

byte *BTV0_WriteInt32LE(byte *ct, uint v)
{
	*ct++=v&0xFF;
	*ct++=(v>>8)&0xFF;
	*ct++=(v>>16)&0xFF;
	*ct++=(v>>24)&0xFF;
	return(ct);
}

byte *BTV0_WriteInt32BE(byte *ct, uint v)
{
	*ct++=(v>>24)&0xFF;
	*ct++=(v>>16)&0xFF;
	*ct++=(v>>8)&0xFF;
	*ct++=v&0xFF;
	return(ct);
}

byte *BTV0_WriteFourcc(byte *ct, uint v)
{
	*ct++=v&0xFF;
	*ct++=(v>>8)&0xFF;
	*ct++=(v>>16)&0xFF;
	*ct++=(v>>24)&0xFF;
	return(ct);
}

byte *BTV0_WriteChunk(byte *ct, uint fcc, byte *buf, int len)
{
	byte tb[4];
	uint crc;

	*ct++=0x7F;
	*ct++=0xFF;
	*ct++=0xFE;
	*ct++=0x20;

//	ct=BTV0_WriteInt32BE(ct, len);
	ct=BTV0_WriteInt32LE(ct, len);
	ct=BTV0_WriteFourcc(ct, fcc);
//	fwrite(buf, 1, len, fd);
	memcpy(ct, buf, len);
	ct+=len;

	return(ct);

#if 0
	tb[0]=fcc&0xFF; tb[1]=(fcc>>8)&0xFF;
	tb[2]=(fcc>>16)&0xFF; tb[3]=(fcc>>24)&0xFF;
	crc=BTV0_CRC32(tb, 4, (uint)-1);
	crc=BTV0_CRC32(buf, len, crc);

//	printf("%s %d %X\n", BTV0_Fourcc2String(fcc), len, ~crc);

	ct=BTV0_WriteInt32BE(ct, ~crc);
#endif
}

byte *BTV0_EmitString(byte *ct, char *str)
{
	strcpy(ct, str);
	ct+=strlen(str)+1;
	return(ct);
}

byte *BTV0_EmitMarker(byte *ct, int id)
{
	*ct++=0x7F;
	*ct++=0xFF;
	*ct++=0xFE;
	*ct++=id;
	return(ct);
}

byte *BTV0_EmitMarkerTag(byte *ct, char *name, char *value)
{
	byte *ct1;
	int i;

	printf("BTV0_EmitMarkerTag: %s %s\n", name, value);

	ct=BTV0_EmitMarker(ct, 0x21);

	ct1=ct;
	*ct++=0x00;
	*ct++=0x00;
	
	ct=BTV0_EmitString(ct, name);
	ct=BTV0_EmitString(ct, value);
	
	i=ct-ct1;
	ct1[0]=i&0xFF;
	ct1[0]=(i>>8)&0xFF;
	
	return(ct);
}

#ifndef ABS
#define ABS(v)	(((v)<0)?(-(v)):(v))
#endif

int BTV0_Paeth(int a, int b, int c)
{
	int p, pa, pb, pc;

	p=a+b-c;
	pa=(p>a)?(p-a):(a-p);
	pb=(p>b)?(p-b):(b-p);
	pc=(p>c)?(p-c):(c-p);

	p=(pa<=pb)?((pa<=pc)?a:c):((pb<=pc)?b:c);
	return(p);
}

int BTV0_Mod(int x, int xs)
{
	while(x<0)x+=xs;
	while(x>=xs)x-=xs;
	return(x);
}

int BTV0_FindImageBufferBestOffset(PDBTV0_Context *ctx,
	byte *olbuf, byte *buf, int xs, int ys,
	int x, int y, int *rxo, int *ryo)
{
	int xo, yo, x2, y2, x3, y3;
	int bx, by, be;
	int a, b;
	int i, j, k, l, e;

	*rxo=0;
	*ryo=0;

	bx=0; by=0; be=xs*255*4;

	for(i=0; i<32; i++)
		for(j=0; j<32; j++)
	{
		xo=(j&1)?(-(j>>1)):(j>>1);
		yo=(i&1)?(-(i>>1)):(i>>1);
		
		x2=x+xo;
		y2=y+yo;

		y3=BTV0_Mod(ys-y2-1, ys);
		
		e=0;
		for(k=0; k<xs; k++)
		{
			x3=BTV0_Mod(x2+k, xs);
		
			for(l=0; l<4; l++)
			{
				a=buf[(((ys-y-1)*xs)+k)*4+l];
				b=olbuf[((y3*xs)+x3)*4+l];
				e+=ABS(a-b);
			}
			
			if(e>=be)break;
		}
		
		if(e<be) { bx=xo; by=yo; be=e; }
	}
	
//	printf("%dx%d ", bx, by);

	*rxo=bx;
	*ryo=by;
	return(1);
}

byte *BTV0_EncodeImageBuffer(PDBTV0_Context *ctx,
	byte *obuf, byte *buf,
	int xs, int ys, int layer)
{
	byte hbuf[64];
	int tpx[4];
	int tfmc[64];
	byte *buf2, *olbuf, *s, *t, *ct;
	int fm, sz, pa, pb, pc, pd;
	int pe, pf, pg, ph, xo, yo;
	int toy0, toy1, tox0, tox1;
	int tpr, tpg, tpb, tpy, tpu, tpv;
	int e, be, bf, am, ssz, bcs;
	int i, j, k, l;

	am=0;
	for(i=0; i<(xs*ys); i++)
		if(buf[i*4+3]<255)am=1;
	ssz=am?4:3;

	buf2=malloc(xs*ys*ssz+16*ys);

	olbuf=ctx->oldlayer[layer];
	if(!olbuf)
	{
		olbuf=malloc(xs*ys*4);
		memset(olbuf, 0, xs*ys*4);
		ctx->oldlayer[layer]=olbuf;
	}

	for(i=0; i<64; i++)tfmc[i]=0;

	t=buf2;
	for(i=0; i<ys; i++)
	{
		BTV0_FindImageBufferBestOffset(ctx, olbuf, buf, xs, ys,
			0, i, &xo, &yo);

		toy0=BTV0_Mod(ys-(i+yo), ys);
		toy1=BTV0_Mod(ys-(i+yo)-1, ys);
	
		be=ssz*xs*255; bf=0;
		for(l=0; l<24; l++)
		{
			e=0;
			for(j=0; j<xs; j++)
			{
				tox0=BTV0_Mod(j+xo, xs);
				tox1=BTV0_Mod(j+xo-1, xs);

				for(k=0; k<ssz; k++)
				{
					pd=buf[(((ys-i-1)*xs)+j)*4+k];
//					ph=olbuf[(((ys-i-1)*xs)+j)*4+k];

					pe=olbuf[((toy0*xs)+tox1)*4+k];
					pf=olbuf[((toy0*xs)+tox0)*4+k];
					pg=olbuf[((toy1*xs)+tox1)*4+k];
					ph=olbuf[((toy1*xs)+tox0)*4+k];

					if(i && j)
					{
						pa=buf[(((ys-i)*xs)+j-1)*4+k];
						pb=buf[(((ys-i)*xs)+j)*4+k];
						pc=buf[(((ys-i-1)*xs)+j-1)*4+k];

//						pe=olbuf[(((ys-i)*xs)+j-1)*4+k];
//						pf=olbuf[(((ys-i)*xs)+j)*4+k];
//						pg=olbuf[(((ys-i-1)*xs)+j-1)*4+k];
					}else if(i)
					{
						pa=0; pb=buf[(((ys-i)*xs)+j)*4+k]; pc=0;
//						pe=0; pf=olbuf[(((ys-i)*xs)+j)*4+k]; pg=0;
					}else if(j)
					{
						pa=0; pb=0; pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
//						pe=0; pf=0; pg=olbuf[(((ys-i-1)*xs)+j-1)*4+k];
					}else
					{
						pa=0; pb=0; pc=0;
//						pe=0; pf=0; pg=0;
					}

					switch(l)
					{
					case 0: e+=ABS(pd); break;
					case 1: e+=ABS(pd-pc); break;
					case 2: e+=ABS(pd-pb); break;
					case 3: e+=ABS(pd-((pc+pb)>>1)); break;
					case 4: e+=ABS(pd-BTV0_Paeth(pc, pb, pa)); break;
					case 5: e+=ABS(pd-((pb+pc)-pa)); break;
					case 8: e+=ABS(pd-ph); break;
					case 9: e+=ABS(pd-pg); break;
					case 10: e+=ABS(pd-pf); break;
					case 11: e+=ABS(pd-((pg+pf)>>1)); break;
					case 12: e+=ABS(pd-BTV0_Paeth(pg, pf, pe)); break;
					case 13: e+=ABS(pd-((pf+pg)-pe)); break;
					case 14: e+=ABS(pd-(2*((pb+pc)-pa)-ph)); break;
					case 15: e+=ABS(pd-(2*ph-((pb+pc)-pa))); break;

					case 16:
						e+=ABS(pd-((BTV0_Paeth(pc, pb, pa)+ph)>>1));
						break;
					case 17: e+=ABS(pd-(((ph+pb+pc)-pa)>>1)); break;
					
					default: e+=2*ABS(pd); break;
					}
				}
			}

			if(e<be)
			{
				be=e;
				bf=l;
			}
		}

//		printf("%d(%.2f) ", bf, ((float)be)/(ssz*xs));

		fm=bf;
		tfmc[fm]++;

		be=ssz*xs*255; bcs=0;
		for(l=0; l<16; l++)
		{
			e=0;
			for(j=0; j<xs; j++)
			{
				tox0=BTV0_Mod(j+xo, xs);
				tox1=BTV0_Mod(j+xo-1, xs);

				tpx[0]=0; tpx[1]=0;
				tpx[2]=0; tpx[3]=0;
			
				for(k=0; k<ssz; k++)
				{
					pd=buf[(((ys-i-1)*xs)+j)*4+k];
//					ph=olbuf[(((ys-i-1)*xs)+j)*4+k];

					pe=olbuf[((toy0*xs)+tox1)*4+k];
					pf=olbuf[((toy0*xs)+tox0)*4+k];
					pg=olbuf[((toy1*xs)+tox1)*4+k];
					ph=olbuf[((toy1*xs)+tox0)*4+k];

					if(i && j)
					{
						pa=buf[(((ys-i)*xs)+j-1)*4+k];
						pb=buf[(((ys-i)*xs)+j)*4+k];
						pc=buf[(((ys-i-1)*xs)+j-1)*4+k];

//						pe=olbuf[(((ys-i)*xs)+j-1)*4+k];
//						pf=olbuf[(((ys-i)*xs)+j)*4+k];
//						pg=olbuf[(((ys-i-1)*xs)+j-1)*4+k];
					}else if(i)
					{
						pa=0; pb=buf[(((ys-i)*xs)+j)*4+k]; pc=0;
//						pe=0; pf=olbuf[(((ys-i)*xs)+j)*4+k]; pg=0;
					}else if(j)
					{
						pa=0; pb=0; pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
//						pe=0; pf=0; pg=olbuf[(((ys-i-1)*xs)+j-1)*4+k];
					}else
					{
						pa=0; pb=0; pc=0;
//						pe=0; pf=0; pg=0;
					}

					switch(fm)
					{
					case 0: tpx[k]=pd; break;
					case 1: tpx[k]=pd-pc; break;
					case 2: tpx[k]=pd-pb; break;
					case 3: tpx[k]=pd-((pc+pb)>>1); break;
					case 4: tpx[k]=pd-BTV0_Paeth(pc, pb, pa); break;
					case 5: tpx[k]=pd-((pb+pc)-pa); break;
					case 8: tpx[k]=pd-ph; break;
					case 9: tpx[k]=pd-pg; break;
					case 10: tpx[k]=pd-pf; break;
					case 11: tpx[k]=pd-((pg+pf)>>1); break;
					case 12: tpx[k]=pd-BTV0_Paeth(pg, pf, pe); break;
					case 13: tpx[k]=pd-((pf+pg)-pe); break;
					case 14: tpx[k]=pd-(2*((pb+pc)-pa)-ph); break;
					case 15: tpx[k]=pd-(2*ph-((pb+pc)-pa)); break;

					case 16:
						tpx[k]=pd-((BTV0_Paeth(pc, pb, pa)+ph)>>1);
						break;
					case 17: tpx[k]=pd-(((ph+pb+pc)-pa)>>1); break;
					}
				}
				
				switch(l)
				{
				case 0: case 1:
					e+=ABS(tpx[0])+ABS(tpx[1])+ABS(tpx[2])+ABS(tpx[3]);
					break;
				case 2: case 3:
					tpy=tpx[1]; tpu=tpx[2]-tpx[1]; tpv=tpx[0]-tpx[1];
					e+=ABS(tpy)+ABS(tpu)+ABS(tpv)+ABS(tpx[3]);
					break;

#if 0
				case 8: case 9:
					tpy=0+tpx[0]*0.2857+tpx[1]*0.5714+tpx[2]*0.1429;
					tpu=0-tpx[0]*0.1429-tpx[1]*0.2857+tpx[2]*0.4286;
					tpv=0+tpx[0]*0.3571-tpx[1]*0.2857+tpx[2]*0.0714;
					e+=ABS(tpy)+ABS(tpu)+ABS(tpv)+ABS(tpx[3]);
					break;
#endif

				default: e+=4*256; break;
				}
			}

			if(e<be)
			{
				be=e;
				bcs=l;
			}
		}

		if((bcs==0) && am)bcs=1;
		if((bcs==2) && am)bcs=3;
		if((bcs==4) && am)bcs=5;

//		if(bcs!=0)
//			printf("C%d(%.2f) ", bcs, ((float)be)/(ssz*xs));

		fm=bf;
		*t++=fm;
		*t++=bcs;

		for(j=0; j<xs; j++)
		{
			tox0=BTV0_Mod(j+xo, xs);
			tox1=BTV0_Mod(j+xo-1, xs);

			tpx[0]=0; tpx[1]=0;
			tpx[2]=0; tpx[3]=0;

			for(k=0; k<ssz; k++)
			{
				pd=buf[(((ys-i-1)*xs)+j)*4+k];
//				ph=olbuf[(((ys-i-1)*xs)+j)*4+k];

				pe=olbuf[((toy0*xs)+tox1)*4+k];
				pf=olbuf[((toy0*xs)+tox0)*4+k];
				pg=olbuf[((toy1*xs)+tox1)*4+k];
				ph=olbuf[((toy1*xs)+tox0)*4+k];

				if(i && j)
				{
					pa=buf[(((ys-i)*xs)+j-1)*4+k];
					pb=buf[(((ys-i)*xs)+j)*4+k];
					pc=buf[(((ys-i-1)*xs)+j-1)*4+k];

//					pe=olbuf[(((ys-i)*xs)+j-1)*4+k];
//					pf=olbuf[(((ys-i)*xs)+j)*4+k];
//					pg=olbuf[(((ys-i-1)*xs)+j-1)*4+k];
				}else if(i)
				{
					pa=0; pb=buf[(((ys-i)*xs)+j)*4+k]; pc=0;
//					pe=0; pf=olbuf[(((ys-i)*xs)+j)*4+k]; pg=0;
				}else if(j)
				{
					pa=0; pb=0; pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
//					pe=0; pf=0; pg=olbuf[(((ys-i-1)*xs)+j-1)*4+k];
				}else
				{
					pa=0; pb=0; pc=0;
//					pe=0; pf=0; pg=0;
				}

#if 1
				switch(fm)
				{
				case 0: tpx[k]=pd; break;
				case 1: tpx[k]=pd-pc; break;
				case 2: tpx[k]=pd-pb; break;
				case 3: tpx[k]=pd-((pc+pb)>>1); break;
				case 4: tpx[k]=pd-BTV0_Paeth(pc, pb, pa); break;
				case 5: tpx[k]=pd-((pb+pc)-pa); break;
				case 8: tpx[k]=pd-ph; break;
				case 9: tpx[k]=pd-pg; break;
				case 10: tpx[k]=pd-pf; break;
				case 11: tpx[k]=pd-((pg+pf)>>1); break;
				case 12: tpx[k]=pd-BTV0_Paeth(pg, pf, pe); break;
				case 13: tpx[k]=pd-((pf+pg)-pe); break;
				case 14: tpx[k]=pd-(2*((pb+pc)-pa)-ph); break;
				case 15: tpx[k]=pd-(2*ph-((pb+pc)-pa)); break;

				case 16:
					tpx[k]=pd-((BTV0_Paeth(pc, pb, pa)+ph)>>1);
					break;
				case 17: tpx[k]=pd-(((ph+pb+pc)-pa)>>1); break;
				}
#endif

#if 0
				switch(fm)
				{
				case 0:
					*t++=pd;
					break;
				case 1:
					*t++=pd-pc;
					break;
				case 2:
					*t++=pd-pb;
					break;
				case 3:
					*t++=pd-((pc+pb)>>1);
					break;
				case 4:
					*t++=pd-BTV0_Paeth(pc, pb, pa);
					break;
				case 5:
					*t++=pd-((pb+pc)-pa);
					break;

				case 8:
					*t++=pd-ph;
					break;
				case 9:
					*t++=pd-pg;
					break;
				case 10:
					*t++=pd-pf;
					break;
				case 11:
					*t++=pd-((pg+pf)>>1);
					break;
				case 12:
					*t++=pd-BTV0_Paeth(pg, pf, pe);
					break;
				case 13:
					*t++=pd-((pf+pg)-pe);
					break;
				case 14:
					*t++=pd-(2*((pb+pc)-pa)-ph);
					break;
				case 15:
					*t++=pd-(2*ph-((pb+pc)-pa));
					break;

				default:
					break;
				}
#endif

			}

			switch(bcs)
			{
			case 0: *t++=tpx[0]; *t++=tpx[1]; *t++=tpx[2]; break;
			case 1:
				*t++=tpx[0]; *t++=tpx[1];
				*t++=tpx[2]; *t++=tpx[3]; break;
			case 2:
				tpy=tpx[1]; tpu=tpx[2]-tpx[1]; tpv=tpx[0]-tpx[1];
				*t++=tpy; *t++=tpu; *t++=tpv; break;
			case 3:
				tpy=tpx[1]; tpu=tpx[2]-tpx[1]; tpv=tpx[0]-tpx[1];
				*t++=tpy; *t++=tpu; *t++=tpv; *t++=tpx[3]; break;

#if 0
			case 8: case 9:
				tpy=0+tpx[0]*0.2857+tpx[1]*0.5714+tpx[2]*0.1429;
				tpu=0-tpx[0]*0.1429-tpx[1]*0.2857+tpx[2]*0.4286;
				tpv=0+tpx[0]*0.3571-tpx[1]*0.2857+tpx[2]*0.0714;
				e+=ABS(tpy)+ABS(tpu)+ABS(tpv)+ABS(tpx[3]);
				break;
#endif

			default: e+=4*256; break;
			}
		}
	}
//	printf("\n");

	for(i=0; i<64; i++)
	{
		if(tfmc[i])
		{
			j=tfmc[i];
			printf("Fm %d: %d/%d %.02f%%\n", i, j, ys, 100*((float)j)/ys);
		}
	}

	memcpy(olbuf, buf, xs*ys*4);

	buf=malloc(xs*ys*8);

	//zlib header
	i=(7<<12)|(8<<8)|(3<<6);
	j=i%31;
	if(j)i|=31-j;
	buf[0]=i>>8;
	buf[1]=i&0xFF;
//	printf("Zlib %04X\n", i);

	i=PDZ2_EncodeStreamLvl(buf2, buf+2, xs*ys*ssz+ys, xs*ys*8, 1);
//	i=PDZ2_EncodeStreamLvl(buf2, buf+2, xs*ys*ssz+ys, xs*ys*8, 9);
//	i=vfDeflateBufferLvl(buf+2, buf2, xs*ys*8, xs*ys*ssz+ys, 9);

	//checksum
	j=BTV0_DataAdler32(buf2, xs*ys*ssz+ys, 1);
	buf[2+i+0]=(j>>24)&0xFF;
	buf[2+i+1]=(j>>16)&0xFF;
	buf[2+i+2]=(j>>8)&0xFF;
	buf[2+i+3]=j&0xFF;

	printf("Adler32: Wrote %08X (Size=%d)\n", j, i);

	sz=i+6;
	free(buf2);

	ct=obuf;

//	BTV0_WriteFourcc(fd, FCC_PNG_LOW);
//	BTV0_WriteFourcc(fd, FCC_PNG_HIGH);

	hbuf[0]=xs>>24; hbuf[1]=xs>>16; hbuf[2]=xs>>8; hbuf[3]=xs;
	hbuf[4]=ys>>24; hbuf[5]=ys>>16; hbuf[6]=ys>>8; hbuf[7]=ys;
	hbuf[8]=8;	//8 bits/sample
	hbuf[9]=am?6:2;	//RGB(A)
	hbuf[10]=0;	//0=deflate
	hbuf[11]=0;	//no filter
	hbuf[12]=0;	//no interlace

	ct=BTV0_WriteChunk(ct, FCC_IHDR, hbuf, 13);

	s=buf; i=sz;
	while(i>65536)
	{
		ct=BTV0_WriteChunk(ct, FCC_IDAT, s, 65536);
		s+=65536;
		i-=65536;
	}
	ct=BTV0_WriteChunk(ct, FCC_IDAT, s, i);

//	ct=BTV0_WriteChunk(ct, FCC_IEND, NULL, 0);
	
	return(ct);
}

PDBTV0_Context *BTV0_AllocContext()
{
	PDBTV0_Context *ctx;
	
	ctx=malloc(sizeof(PDBTV0_Context));
	memset(ctx, 0, sizeof(PDBTV0_Context));
	return(ctx);
}

int BTV0_EncodeCtx(PDBTV0_Context *ctx,
	byte *ibuf, byte *obuf, int xs, int ys, int qf, int pf)
{
	byte *ct;
	
	ct=obuf;
	ct=BTV0_EmitMarkerTag(ct, "CompLayer", "RGBA");
	ct=BTV0_EncodeImageBuffer(ctx, ct, ibuf, xs, ys, 0);
	return(ct-obuf);
}

int BTV0_EncodeComponentCtx(
	PDBTV0_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf, int pf)
{
	byte *ct;
	
	ct=obuf;
	if(rgba)
	{
		ct=BTV0_EmitMarkerTag(ct, "CompLayer", "RGBA");
		ct=BTV0_EncodeImageBuffer(ctx, ct, rgba, xs, ys, 0);
	}
	if(norm)
	{
		ct=BTV0_EmitMarkerTag(ct, "CompLayer", "XYZD");
		ct=BTV0_EncodeImageBuffer(ctx, ct, norm, xs, ys, 1);
	}
	if(spec)
	{
		ct=BTV0_EmitMarkerTag(ct, "CompLayer", "SpRGBA");
		ct=BTV0_EncodeImageBuffer(ctx, ct, spec, xs, ys, 2);
	}
	if(luma)
	{
		ct=BTV0_EmitMarkerTag(ct, "CompLayer", "LuRGBA");
		ct=BTV0_EncodeImageBuffer(ctx, ct, luma, xs, ys, 3);
	}
	return(ct-obuf);
}
#include <bgbbtj.h>

// uint BGBBTJ_PNG_DataAdler32(void *buf, int sz, uint lcrc);
// int BGBBTJ_PNG_Paeth(int a, int b, int c);
// byte *BGBBTJ_PNG_LoadRaw(char *name, int *w, int *h);

void *bgbv86_ralloc(int sz)
{
	static byte *buf=NULL;
	static byte *bufe, *bufr;
	void *p;

	if(!buf)
	{
		buf=malloc(1<<18);
		bufe=buf+(1<<18);
		bufr=buf;
	}

	sz=(sz+15)&(~15);
	if((bufr+sz)>bufe)bufr=buf;
	p=bufr; bufr+=sz;
	memset(p, 0, sz);
	return(p);
}

char *bgbv86_rstrdup(char *str)
{
	char *t;
	t=bgbv86_ralloc(strlen(str)+1);
	strcpy(t, str);
	return(t);
}

char *bgbv86_rsprint(char *str, ...)
{
	char buf[256];
	va_list lst;
	char *t;

	va_start(lst, str);
	vsprintf(buf, str, lst);
	va_end(lst);

	t=bgbv86_rstrdup(buf);
	return(t);
}

char **bgbv86_rsplit(char *s)
{
	char **a, *t;
	int i;

	a=bgbv86_ralloc(64*sizeof(char *));
	i=0;
	while(*s)
	{
		while(*s && (*s<=' '))s++;
		if(!*s)break;
		t=bgbv86_ralloc(256);
		a[i++]=t;

		if(*s=='"')
		{
			s++;

			while(*s && (*s!='"'))
			{
				if(*s=='\\')
				{
					*t++=*s++;

					if(*s=='x')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}
					if(*s=='u')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}
					if(*s=='U')
					{
						*t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						*t++=*s++; *t++=*s++;
						continue;
					}

					*t++=*s++;
					continue;
				}

				*t++=*s++;
			}

			if(*s=='"')s++;

			*t++=0;
			*t++='\"';
			*t++=0;
			continue;
		}

		while(*s && (*s>' '))*t++=*s++;
		*t++=0;
		*t++=0;
	}
	a[i]=NULL;

	return(a);
}

int WAL_ReadInfo(char *name, WalInfo_t *wal)
{
	char tb[1024];
	char **a;
	FILE *fd;
	int i;

//	wal->flags=0;
//	*cnts=0;

	fd=fopen(name, "rt");
	if(!fd)return(-1);

	while(!feof(fd))
	{
		fgets(tb, 1023, fd);
		a=bgbv86_rsplit(tb);

		if(!a)continue;
		if(!a[0])continue;
		if(*(a[0])!='$')continue;

		if(!strcmp(a[0], "$sky"))
		{
			wal->flags|=SURF_SKY;
		}

		if(!strcmp(a[0], "$flags"))
		{
			for(i=1; a[i]; i++)
			{
				if(!strcmp(a[i], "fluid"))
					wal->contents|=CONTENTS_WATER;

				if(!strcmp(a[i], "window"))
					wal->contents|=CONTENTS_WINDOW;
				if(!strcmp(a[i], "water"))
					wal->contents|=CONTENTS_WATER;
				if(!strcmp(a[i], "lava"))
					wal->contents|=CONTENTS_LAVA;
				if(!strcmp(a[i], "slime"))
					wal->contents|=CONTENTS_SLIME;
				if(!strcmp(a[i], "sewer"))
					wal->contents|=CONTENTS_WATER;

				if(!strcmp(a[i], "mist"))
					wal->contents|=CONTENTS_MIST;
				if(!strcmp(a[i], "origin"))
					wal->contents|=CONTENTS_ORIGIN;
				if(!strcmp(a[i], "detail"))
					wal->contents|=CONTENTS_DETAIL;
				if(!strcmp(a[i], "ladder"))
					wal->contents|=CONTENTS_LADDER;

				if(!strcmp(a[i], "slick"))
					wal->flags|=SURF_SLICK;
				if(!strcmp(a[i], "sky"))
					wal->flags|=SURF_SKY;
				if(!strcmp(a[i], "warpst"))
					wal->flags|=SURF_WARP;
				if(!strcmp(a[i], "warp"))
					wal->flags|=SURF_WARP;

				if(!strcmp(a[i], "alpha33"))
					wal->flags|=SURF_TRANS33;
				if(!strcmp(a[i], "alpha66"))
					wal->flags|=SURF_TRANS66;

				if(!strcmp(a[i], "flowing"))
					wal->flags|=SURF_FLOWING;
				if(!strcmp(a[i], "nodraw"))
					wal->flags|=SURF_NODRAW;

				if(!strcmp(a[i], "light"))
				{
					wal->flags|=SURF_LIGHT;
					wal->value=250;
				}

				if(!strcmp(a[i], "clip"))
				{
					wal->flags|=SURF_NODRAW;
					wal->contents|=CONTENTS_PLAYERCLIP;
					wal->contents|=CONTENTS_MONSTERCLIP;
				}
			}
		}
	}

	if(wal->contents&CONTENTS_WATER)
	{
		if(wal->contents&CONTENTS_WINDOW)
			wal->contents&=~CONTENTS_WINDOW;

		wal->flags|=SURF_WARP;

		if(wal->contents&CONTENTS_SLIME)
		{
			wal->contents&=~CONTENTS_WATER;
			wal->flags|=SURF_TRANS66;
		}
		if(wal->contents&CONTENTS_LAVA)
			wal->contents&=~CONTENTS_WATER;

		if((wal->contents&CONTENTS_WATER) &&
			!(wal->flags&SURF_TRANS33) &&
			!(wal->flags&SURF_TRANS66))
		{
			wal->flags|=SURF_TRANS33;
		}
	}

	printf("Info %dx%d\t%08X %08X\n",
		wal->width, wal->height,
		wal->flags, wal->contents);

	fclose(fd);
	return(0);
}

byte *PDTGA_LoadRaw(char *name, int *w, int *h);

int WAL_FileExistsP(char *name)
{
	FILE *fd;
	
	fd=fopen(name, "rb");
	if(!fd)return(0);
	fclose(fd);
	return(1);
}

int WAL_ImageExistsP(char *name)
{
	char tb[256];
	
//	printf("Check Image %s\n", name);
	
	sprintf(tb, "%s.png", name);
	if(WAL_FileExistsP(tb))
		return(1);
	sprintf(tb, "%s.jpg", name);
	if(WAL_FileExistsP(tb))
		return(1);

	return(0);
}

char *WAL_AnimChain(char *name)
{
	char pf[256], sf[256];
	char tb[256];
	char *s, *t, *s0;
	int i, n;

//	if(*name!='+')
//		return(NULL);

	n=0;

	s=name+strlen(name);
	while((s>name) && (*s!='+') && (*s!='/'))s--;
	if(*s!='+')return(NULL);

	s0=name; t=pf;
	while(*s0 && (s0<s))*t++=*s0++;
	*t++=0;
//	printf("PF=%s\n", pf);

	s0=s+1;
	n=atoi(s0);
	while(*s0 && (*s0>='0') && (*s0<='9'))s0++;

	t=sf;
	while(*s0)*t++=*s0++;
	*t++=0;
//	printf("SF=%s\n", sf);

//	s=name+strlen(name)-1;
//	while((s>name) && (*(s-1)>='0') && (*(s-1)<='9'))s--;
//	s0=name; t=tb;
//	while(*s0 && (s0<s))*t++=*s0++;
//	*t++=0;
//	n=atoi(s);
	
//	return(NULL);
	
	sprintf(tb, "%s+%d%s", pf, n+1, sf);
	if(WAL_ImageExistsP(tb))
		return(strdup(tb));

	sprintf(tb, "%s+%d%s", pf, 0, sf);
	if(WAL_ImageExistsP(tb))
		return(strdup(tb));

	return(NULL);
}

void AWAL_UnFilterBuf(byte *tbuf, byte *buf, byte *lbuf,
	int xs, int ys, int fl)
{
	int i, j, k, l, v;
	int a, b, c, d;

//	tb1=malloc(xs*ys*4);
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
			for(k=0; k<4; k++)
	{
		l=lbuf[(i*xs+j)*4+k];
//		l=buf[(i*xs+j)*4+k];

		v=buf[k*(xs*ys)+(i*xs)+j];

		if(fl&1)
//		if(0)
//		if(1)
		{
			a=(j>0)?tbuf[(i*xs+(j-1))*4+k]:0;
			b=(i>0)?tbuf[((i-1)*xs+j)*4+k]:0;
			c=((i>0)&&(j>0))?tbuf[((i-1)*xs+(j-1))*4+k]:0;
			d=BGBBTJ_PNG_Paeth(a, b, c);
		}else d=0;

//		tbuf[k*(xs*ys)+(i*xs)+j]=l-d;
		tbuf[(i*xs+j)*4+k]=l+d+v;
	}
}

BGBBTJ_API void AWAL_FilterBuf(byte *tbuf, byte *buf, byte *lbuf,
	int xs, int ys, int fl)
{
//	byte *tb1;
	int i, j, k, l;
//	int lr, lg, lb, la;
//	int ar, br, cr, dr;
//	int ag, bg, cg, dg;
//	int ab, bb, cb, db;
//	int aa, ba, ca, da;
	int a, b, c, d;

#if 1
//	tb1=malloc(xs*ys*4);
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
			for(k=0; k<4; k++)
	{
		l=buf[(i*xs+j)*4+k]-lbuf[(i*xs+j)*4+k];
//		l=buf[(i*xs+j)*4+k];

		if(fl&1)
//		if(0)
//		if(1)
		{
			a=(j>0)?buf[(i*xs+(j-1))*4+k]:0;
			b=(i>0)?buf[((i-1)*xs+j)*4+k]:0;
			c=((i>0)&&(j>0))?buf[((i-1)*xs+(j-1))*4+k]:0;
			d=BGBBTJ_PNG_Paeth(a, b, c);
		}else d=0;

		tbuf[k*(xs*ys)+(i*xs)+j]=l-d;
//		tbuf[(i*xs+j)*4+k]=l-d;
	}
#endif

#if 0
//	tb1=malloc(xs*ys*4);
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		lr=buf[(i*xs+j)*4+0]-lbuf[(i*xs+j)*4+0];
		lg=buf[(i*xs+j)*4+1]-lbuf[(i*xs+j)*4+1];
		lb=buf[(i*xs+j)*4+2]-lbuf[(i*xs+j)*4+2];
		la=buf[(i*xs+j)*4+3]-lbuf[(i*xs+j)*4+3];
//		l=buf[(i*xs+j)*4+k];

//		lr-=lg;
//		lb-=lg;

		ar=(j>0)?buf[(0*(xs*ys))+(i*xs)+(j-1)]:0;
		ag=(j>0)?buf[(1*(xs*ys))+(i*xs)+(j-1)]:0;
		ab=(j>0)?buf[(2*(xs*ys))+(i*xs)+(j-1)]:0;
		aa=(j>0)?buf[(3*(xs*ys))+(i*xs)+(j-1)]:0;

		br=(i>0)?buf[(0*(xs*ys))+((i-1)*xs)+j]:0;
		bg=(i>0)?buf[(1*(xs*ys))+((i-1)*xs)+j]:0;
		bb=(i>0)?buf[(2*(xs*ys))+((i-1)*xs)+j]:0;
		ba=(i>0)?buf[(3*(xs*ys))+((i-1)*xs)+j]:0;

		cr=((i>0)&&(j>0))?buf[(0*(xs*ys))+((i-1)*xs)+(j-1)]:0;
		cg=((i>0)&&(j>0))?buf[(1*(xs*ys))+((i-1)*xs)+(j-1)]:0;
		cb=((i>0)&&(j>0))?buf[(2*(xs*ys))+((i-1)*xs)+(j-1)]:0;
		ca=((i>0)&&(j>0))?buf[(3*(xs*ys))+((i-1)*xs)+(j-1)]:0;

//		dr=BGBBTJ_PNG_Paeth(ar, br, cr);
//		dg=BGBBTJ_PNG_Paeth(ag, bg, cg);
//		db=BGBBTJ_PNG_Paeth(ab, bb, cb);
//		da=BGBBTJ_PNG_Paeth(aa, ba, ca);
		dr=0; dg=0; db=0; da=0;

		tbuf[0*(xs*ys)+(i*xs)+j]=lr-dr;
		tbuf[1*(xs*ys)+(i*xs)+j]=lg-dg;
		tbuf[2*(xs*ys)+(i*xs)+j]=lb-db;
		tbuf[3*(xs*ys)+(i*xs)+j]=la-da;
	}
#endif
}

BGBBTJ_API int AWAL_Write(FILE *fd, WalInfo_t *inf)
{
	byte tb[256];
	int i, j;

	memset(tb, 0, 256);
	if(inf->name)
		strcpy(tb+ 0, inf->name);
//	if(inf->animname)
//		strcpy(tb+56, inf->animname);

	WAL_Set32LE(tb+32, inf->width);
	WAL_Set32LE(tb+36, inf->height);
	WAL_Set32LE(tb+52, inf->flags);
	WAL_Set32LE(tb+56, inf->contents);
	WAL_Set32LE(tb+60, inf->value);

	i=100;
	WAL_Set32LE(tb+40, i);
//	WAL_Set32LE(tb+44, j);

	fwrite(tb, 1, 100, fd);

	for(i=0; i<inf->n_frames; i++)
	{
		fputc(i?2:1, fd);
		fputc(0, fd);
		fputc(0, fd);
		fputc(0, fd);

		j=inf->frames_sz[i];
		fputc(j&255, fd);
		fputc((j>>8)&255, fd);
		fputc((j>>16)&255, fd);
		fputc((j>>24)&255, fd);

		fwrite(inf->frames[i], 1, j, fd);
	}

	j=ftell(fd)-100;
	WAL_Set32LE(tb+44, j);

//	i=inf->width*inf->height;
//	fwrite(inf->data[0], 1, i, fd);

//	i=(inf->width/2)*(inf->height/2);
//	fwrite(inf->data[1], 1, i, fd);

//	i=(inf->width/4)*(inf->height/4);
//	fwrite(inf->data[2], 1, i, fd);

//	i=(inf->width/8)*(inf->height/8);
//	fwrite(inf->data[3], 1, i, fd);

	fseek(fd, 0, 0);
	fwrite(tb, 1, 100, fd);

	return(0);
}

BGBBTJ_API int AWAL_WriteFile(char *name, WalInfo_t *inf)
{
	FILE *fd;

	fd=fopen(name, "wb");
	if(!fd)return(-1);
	AWAL_Write(fd, inf);
	fclose(fd);
	return(-1);
}

BGBBTJ_API byte *AWAL_LoadScaleImageMap(char *base, char *suf,
	int frame, int w, int h)
{
	byte tb[1024];
	byte *tbuf, *buf;
	int w1, h1;

	if(frame>=0)
		{ sprintf(tb, "%s_%d_%s.png", base, frame, suf); }
	else
		{ sprintf(tb, "%s_%s.png", base, suf); }

	tbuf=BGBBTJ_PNG_LoadRaw(tb, &w1, &h1);
	if(tbuf)
	{
//		printf("\tGot Norm\n");

		if((w1==w) && (h1==h))
			return(tbuf);
		buf=malloc(w*h*4);
		BGBBTJ_Tex_ResampleSpline(tbuf, w1, h1, buf, w, h);
		free(tbuf);
		return(buf);
	}

	return(NULL);
}


BGBBTJ_API int AWAL_LoadNormalMap(char *base, int frame,
	byte *buf, int w, int h)
{
	byte *tbuf;
	int i, j, k, l, n, ret;

	if(!buf)return(0);

	ret=0;
	tbuf=AWAL_LoadScaleImageMap(base, "norm", frame, w, h);
	if(tbuf)
	{
		n=w*h; l=0;
		for(i=0; i<n; i++)
		{
			buf[i*4+0]=tbuf[i*4+0];
			buf[i*4+1]=tbuf[i*4+1];
			buf[i*4+2]=tbuf[i*4+2];
			
			j=tbuf[i*4+3];
			buf[i*4+3]=j;
			l+=j;
//			buf[i*4+3]=128;
		}
		
		l/=n;
		if(l>200)
		{
			for(i=0; i<n; i++)
			{
				j=buf[i*4+3];
				buf[i*4+3]=j*(128.0/l);
			}
		}

		free(tbuf);
		ret++;
	}

	tbuf=AWAL_LoadScaleImageMap(base, "bmp", frame, w, h);
	if(tbuf)
	{
		n=w*h;
		for(i=0; i<n; i++)
			{ buf[i*4+3]=tbuf[i*4+1]; }
		free(tbuf);
		ret++;
	}

	return(ret);
}

BGBBTJ_API int AWAL_LoadSpecularMap(char *base, int frame,
	byte *buf, int w, int h)
{
	byte *tbuf;
	int i, j, k, l, n, ret;

	if(!buf)return(0);

	ret=0;
	tbuf=AWAL_LoadScaleImageMap(base, "spec", frame, w, h);
	if(tbuf)
	{
		n=w*h; l=0;
		for(i=0; i<n; i++)
		{
			buf[i*4+0]=tbuf[i*4+0];
			buf[i*4+1]=tbuf[i*4+1];
			buf[i*4+2]=tbuf[i*4+2];
//			buf[i*4+3]=tbuf[i*4+3];
//			buf[i*4+3]=128;

			j=tbuf[i*4+3];
			buf[i*4+3]=j;
			l+=j;
		}

		l/=n;
		if(l>200)
		{
			for(i=0; i<n; i++)
			{
				j=buf[i*4+3];
				buf[i*4+3]=j*(128.0/l);
			}
		}
		free(tbuf);
		ret++;
	}

	tbuf=AWAL_LoadScaleImageMap(base, "spexp", frame, w, h);
	if(tbuf)
	{
		n=w*h;
		for(i=0; i<n; i++)
			{ buf[i*4+3]=tbuf[i*4+1]; }
		free(tbuf);
		ret++;
	}

	return(ret);
}

BGBBTJ_API int AWAL_LoadLumaMap(char *base, int frame,
	byte *buf, int w, int h)
{
	byte tb[1024];
	byte *tbuf;
	int w1, h1;

	if(!buf)return(0);

	if(frame>=0)
		{ sprintf(tb, "%s_%d_%s.png", base, frame, "luma"); }
	else
		{ sprintf(tb, "%s_%s.png", base, "luma"); }

	tbuf=BGBBTJ_PNG_LoadRaw(tb, &w1, &h1);
	if(tbuf)
	{
//		printf("\tGot Luma\n");
		BGBBTJ_Tex_ResampleSpline(tbuf, w1, h1, buf, w, h);
		free(tbuf);
		return(1);
	}
	return(0);
}

BGBBTJ_API int imgstat(byte *simg, byte *dimg, int n)
{
	float er, eg, eb, ea;
	int i, j;
	
	er=0; eg=0; eb=0; ea=0;
	for(i=0; i<n; i++)
	{
		j=dimg[i*4+0]-simg[i*4+0];	er+=j*j;
		j=dimg[i*4+1]-simg[i*4+1];	eg+=j*j;
		j=dimg[i*4+2]-simg[i*4+2];	eb+=j*j;
		j=dimg[i*4+3]-simg[i*4+3];	ea+=j*j;
	}
	
	printf("%f %f %f %f\n", sqrt(er/n), sqrt(eg/n), sqrt(eb/n), sqrt(ea/n));
	return(0);
}

BGBBTJ_API int bgbbtj_imgflip(byte *simg, byte *dimg, int xs, int ys)
{
	int i, j;
	
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		dimg[((ys-i-1)*xs+j)*4+0]=simg[(i*xs+j)*4+0];
		dimg[((ys-i-1)*xs+j)*4+1]=simg[(i*xs+j)*4+1];
		dimg[((ys-i-1)*xs+j)*4+2]=simg[(i*xs+j)*4+2];
		dimg[((ys-i-1)*xs+j)*4+3]=simg[(i*xs+j)*4+3];
	}
	return(0);
}

BGBBTJ_API int bgbbtj_imgflip_single(byte *img, int xs, int ys)
{
	byte *timg;
	
	timg=malloc(xs*ys*4);
	bgbbtj_imgflip(img, timg, xs, ys);
	memcpy(img, timg, xs*ys*4);
	free(timg);
	return(0);
}

BGBBTJ_API int BGBBTJ_BlendMagentaEncodeColor(byte *src, byte *dst)
{
	int cr, cg, cb, ca;
	int i, j, k, l;

	cr=src[0];	cg=src[1];
	cb=src[2];	ca=src[3];
	
	//Avoid Magenta in output
	i=(cr-255);
	j=(cg-0);
	k=(cb-255);
	l=i*i+j*j+k*k;
	if(l<0)l=0;
	if(l>256)l=256;

//	j=(cr+2*cg+cb)>>2;
//	cr=((cr*l)+(j*(256-k)))>>8;
//	cg=((cg*l)+(j*(256-k)))>>8;
//	cb=((cb*l)+(j*(256-k)))>>8;

//	i=(224*cr)>>8;
//	j=(224*cb)>>8;
//	cr=((cr*l)+(i*(256-l)))>>8;
//	cb=((cb*l)+(j*(256-l)))>>8;

	j=(255-ca)>>4;
	k=(255-l)>>4;
	cr=cr-(j+k);
	cb=cb-(j+k);
	
	//Blend Alpha As Magenta
	l=255-ca;
	k=255-((l*l)>>8);
//	k=(ca*ca)>>8;

	cr=((cr*k)+(255*(256-k)))>>8;
	cg=((cg*k)+(0*(256-k)))>>8;
	cb=((cb*k)+(255*(256-k)))>>8;
	
	dst[0]=cr;	dst[1]=cg;
	dst[2]=cb;	dst[3]=ca;
	return(0);
}

BGBBTJ_API int BGBBTJ_BlendMagentaDecodeColor(byte *src, byte *dst)
{
	int cr, cg, cb, ca;
	int i, j, k, l;

	cr=src[0];	cg=src[1];
	cb=src[2];	ca=src[3];
	
	i=(cr-255);
	j=(cg-0);
	k=(cb-255);
	l=i*i+j*j+k*k;
	if(l<0)l=0;
	if(l>255)l=255;

	k=(255-l)>>4;
	cr=cr+k;
	cb=cb+k;
	if(cr>255)cr=255;
	if(cb>255)cb=255;

	ca=l;

	dst[0]=cr;	dst[1]=cg;
	dst[2]=cb;	dst[3]=ca;
	return(0);
}

BGBBTJ_API void BGBBTJ_BlendMagentaEncodeImage(byte *simg, byte *dimg, int n)
{
	int i;
	for(i=0; i<n; i++)
		{ BGBBTJ_BlendMagentaEncodeColor(simg+i*4, dimg+i*4); }
}

BGBBTJ_API void BGBBTJ_BlendMagentaDecodeImage(byte *simg, byte *dimg, int n)
{
	int i;
	for(i=0; i<n; i++)
		{ BGBBTJ_BlendMagentaDecodeColor(simg+i*4, dimg+i*4); }
}

BGBBTJ_API int BGBBTJ_SuperMagenta8_PointDist(
	int cy0, int cu0, int cv0,
	int cy1, int cu1, int cv1)
{
	int i, j, k;
	
	i=cy0-cy1;
	j=cu0-cu1;
	k=cv0-cv1;
	k=(i*i)+(j*j)+(k*k);
//	if(k>255)k=255;
	return(k);
}

BGBBTJ_API int BGBBTJ_SuperMagenta8_YuvDist(int cy, int cu, int cv)
{
	int i, j, k;
	
	i=cy-255;
	j=cu-255;
	k=cv-255;
	k=(i*i)+(j*j)+(k*k);
//	if(k>255)k=255;
	return(k);
}

BGBBTJ_API int BGBBTJ_SuperMagenta8_YUV2A(int cy, int cu, int cv)
{
	int i, j, k;
	
	i=cy-255;
	j=cu-255;
	k=cv-255;
	k=(i*i)+(j*j)+(k*k);
//	k=k/4;
//	k=k/16;
	k=k/48;
	if(k>255)k=255;
	return(k);
}

BGBBTJ_API void BGBBTJ_SuperMagenta8_ConvRGBA2YUV(
	int cr, int cg, int cb, int ca,
	int *rcy, int *rcu, int *rcv)
{
//	int cr, cg, cb, ca;
	int cy, cu, cv;
	int py, pu, pv;
	int i, j, k, l;
	float f, g;

	//opaque
//	if(ca>=252)
	if(ca>=224)
//	if(1)
	{
		*rcy=(( 19595*cr + 38470*cg + 7471*cb + 32768)>>16)+0;
		*rcu=((-11056*cr - 21712*cg +32768*cb + 32768)>>16)+128;
		*rcv=(( 32768*cr - 27440*cg - 5328*cb + 32768)>>16)+128;

#if 0
		cy=( 19595*cr + 38470*cg + 7471*cb + 32768)>>16;
		cu=(-11056*cr - 21712*cg +32768*cb + 32768)>>16;
		cv=( 32768*cr - 27440*cg - 5328*cb + 32768)>>16;

		l=BGBBTJ_SuperMagenta8_YUV2A(cy, cu, cv);
		if(l<255)
		{
			cu-=sqrt(255-l);
			cv-=sqrt(255-l);
		}

		*rcy=cy;
		*rcu=cu;
		*rcv=cv;
#endif
		return;
	}
	
	//fully transparent
	if(ca<=16)
	{
		*rcy=255;
		*rcu=255;
		*rcv=255;
		return;
	}

//	cy=(( 19595*cr + 38470*cg + 7471*cb + 32768)>>16)+0;
//	cu=((-11056*cr - 21712*cg +32768*cb + 32768)>>16)+128;
//	cv=(( 32768*cr - 27440*cg - 5328*cb + 32768)>>16)+128;

//	cy=(( 27787*cr + 30278*cg + 7471*cb + 32768)>>16)+0;
//	cy=(( 25297*cr + 32768*cg + 7471*cb + 32768)>>16)+0;

//	cu=(( 16384*cr + 16384*cg - 32768*cb + 32768)>>16)+128;
//	cv=((-32768*cr + 16384*cg + 16384*cb + 32768)>>16)+128;

	cy=(( 22446*cr + 35619*cg + 7471*cb + 32768)>>16)+0;
	cu=((-11056*cr - 21712*cg +32768*cb + 32768)>>16)+128;

//	cu=128; cv=128;

#if 1
	py=(ca/4);
//	pu=((cy+cv)/2)/4;
//	pu=((3*cy+cv)/4)/4;
//	pu=((cy+(cv-128)/2))/4;
	pu=cy/4;
	pv=cu/4;

//	pu=cu/4;
//	pv=cv/4;
	
	cy=255-py;
	cu=255-pu;
	cv=255-pv;
#endif

#if 0
#if 1
	j=cy*cy+cu*cu+cv*cv;
	f=255.0/sqrt(j);
//	f=1.5-0.5*(cy/128.0);
	cy=cy*f;
	cu=cu*f;
	cv=cv*f;
#endif

//	l=255-ca;
//	k=255-((l*l)>>8);
//	k=(ca*ca)>>8;
//	k=255-((int)(4*sqrt(l)));
	k=4*sqrt(ca);

	cy=(cy*k)>>8;
	cu=(cu*k)>>8;
	cv=(cv*k)>>8;

	cy=255-cy;
	cu=255-cu;
	cv=255-cv;

//	cy=(255-k)+cy;
//	cu=(255-k)+cu;
//	cv=(255-k)+cv;

//	j=BGBBTJ_SuperMagenta8_YuvDist(cy, cu, cv);
//	j=sqrt(j);
//	cy=255-((255-cy)*(k/(float)j));
//	cu=255-((255-cu)*(k/(float)j));
//	cv=255-((255-cv)*(k/(float)j));

//	cy=((cy*k)+(255*(256-k)))>>8;
//	cu=((cu*k)+(255*(256-k)))>>8;
//	cv=((cv*k)+(255*(256-k)))>>8;
#endif

	*rcy=cy;
	*rcu=cu;
	*rcv=cv;
}

BGBBTJ_API void BGBBTJ_SuperMagenta8_ConvYUV2RGBA(
	int cy, int cu, int cv,
	int *rcr, int *rcg, int *rcb, int *rca)
{
	int pr, pg, pb, pa;
	int py, pu, pv;
	int mu, mv;
	float f, g;
	int d;

//	pa=BGBBTJ_SuperMagenta8_YUV2A(cy, cu, cv);
	d=BGBBTJ_SuperMagenta8_YuvDist(cy, cu, cv);
	
//	if(pa>=252)
//	if(1)
	if(d>=12288)
	{
		mu=cu-128; mv=cv-128;
		pr=65536*cy          +91881*mv;
		pg=65536*cy- 22554*mu-46802*mv;
		pb=65536*cy+116130*mu;
		pr>>=16; pg>>=16; pb>>=16;

		*rcr=(pr<0)?0:((pr>255)?255:pr);
		*rcg=(pg<0)?0:((pg>255)?255:pg);
		*rcb=(pb<0)?0:((pb>255)?255:pb);
		*rca=255;
		return;
	}
	
//	if(pa<=16)
//	if(0)
	if(d<=16)
	{
		*rcr=0;
		*rcg=0;
		*rcb=0;
		*rca=0;
		return;
	}

#if 0
	pu=(255-cu)*4;
	pv=(255-cv)*4;
#endif

#if 1
	py=(255-cu)*4;
//	pu=py;
//	pu=128;
	pu=(255-cv)*4;
//	pv=py;
	pv=128;
//	pv=(py+128)/2;
//	pv=((py-128)/2)+128;
#endif

//	pu=((py-128)/2)+128;
//	pv=(255-cv)*4;
	pa=(255-cy)*4;
	
#if 0
//	py=cy;
//	pu=cu;
//	pv=cv;
	
//	py=cy*(4*(256.0/pa));
//	pu=cu*(4*(256.0/pa));
//	pv=cv*(4*(256.0/pa));

	py=(255-cy)*(4*(256.0/pa));
	pu=(255-cu)*(4*(256.0/pa));
	pv=(255-cv)*(4*(256.0/pa));
	
#if 1
//	f=py/148.0;
//	f=sqrt(py/148.0);
//	f=sqrt(py/128.0);
	f=0.71+0.72*pow(py/180.0, 2);
//	f=1.0/(1.5-0.5*(py/128.0));
	py=py*f;
	pu=pu*f;
	pv=pv*f;
#endif

#if 0
	//x/sqrt(x)

//	pu=pu*sqrt()

	f=(py-128)/128.0;
	g=sqrt(f*f);
//	pu=128+pu-128/(1.0-f);
//	pv=128+pv-128/(1.0-f);

	pu=pu*(1.0-f);
	pv=pv*(1.0-f);

//	j=cy*cy+cu*cu+cv*cv;
//	f=255.0/sqrt(j);
//	cy=cy/f;
//	cu=cu/f;
//	cv=cv/f;
#endif
#endif

#if 0
	mu=pu-128; mv=pv-128;

	pr=65536*pu;
	pg=32768*pu+32768*pv;
	pb=65536*pv;
	if(pg<0)pg=-pg;
#endif

#if 0
//	pu=128; pv=128;

	mu=pu-128; mv=pv-128;
	pr=65536*py          +91881*mv;
	pg=65536*py- 22554*mu-46802*mv;
	pb=65536*py+116130*mu;

//	pr=65536*py;
//	pr=84891*py;
//	pr=50594*py;
//	pg=65536*py- 22554*mu;
//	pb=65536*py+116130*mu;

	pr>>=16; pg>>=16; pb>>=16;
#endif

#if 1
	mv=pu-128;
	pr=65536*py;
	pg=65536*py-116130*mv;
	pb=65536*py+116130*mv;
#endif

//	pr=(pr<0)?0:((pr>255)?255:pr);
//	pg=(pg<0)?0:((pg>255)?255:pg);
//	pb=(pb<0)?0:((pb>255)?255:pb);

	*rcr=(pr<0)?0:((pr>255)?255:pr);
	*rcg=(pg<0)?0:((pg>255)?255:pg);
	*rcb=(pb<0)?0:((pb>255)?255:pb);
	*rca=pa;
}


static float bgbbtj_scurve(float a)
	{ return(a*a*(3-2*a)); }

static int bgbbtj_scurvei8(int a)
{
	return((a*a*(767-2*a)+32768)>>16);
}

BGBBTJ_API int BGBBTJ_Tex_BlueScreen(byte *src, byte *dst, int w, int h)
{
	byte *tbuf;
	int cr, cg, cb, ca;
	int cr2, cg2, cb2;
	int ca0, ca1, ca2, ca3;
	int ca4, ca5, ca6, ca7, ca8;
	int k0, k1, k2, k3, k4, k5, k6, k7, k8;

	int n;
	int i, j, k, l;

	tbuf=malloc(w*h*4);

	n=w*h;
//	for(i=0; i<n; i++)
	for(i=0; i<h; i++)
		for(j=0; j<w; j++)
	{
		k=(i*w+j)*4;
		cr=src[k+0];		cg=src[k+1];
		cb=src[k+2];		ca=src[k+3];

//		if((i>8) && (j>8))
		if(0)
		{
			k0=((i-0)*w+(j-0))*4;
			k1=((i-0)*w+(j-4))*4;
			k2=((i-4)*w+(j-0))*4;
			k3=((i-4)*w+(j-4))*4;

			k4=((i-0)*w+(j-2))*4;
			k5=((i-4)*w+(j-2))*4;
			k6=((i-0)*w+(j-8))*4;
			k7=((i-4)*w+(j-8))*4;

			cr2=(src[k0+0]+src[k1+0]+src[k2+0]+src[k3+0]+
				 src[k4+0]+src[k5+0]+src[k6+0]+src[k7+0])>>3;
			cg2=(src[k0+1]+src[k1+1]+src[k2+1]+src[k3+1]+
				 src[k4+1]+src[k5+1]+src[k6+1]+src[k7+1])>>3;
			cb2=(src[k0+2]+src[k1+2]+src[k2+2]+src[k3+2]+
				 src[k4+2]+src[k5+2]+src[k6+2]+src[k7+2])>>3;

//			cr2=(src[k0+0]+src[k1+0]+
//				 src[k2+0]+src[k3+0])>>2;
//			cg2=(src[k0+1]+src[k1+1]+
//				 src[k2+1]+src[k3+1])>>2;
//			cb2=(src[k0+2]+src[k1+2]+
//				 src[k2+2]+src[k3+2])>>2;
		}else
		{
			cr2=cr; cg2=cg; cb2=cb;
		}

#if 1
//		if((cb>=(1.1*cg)) && (cb>=(1.1*cr)))
//		if((cg>=(1.1*cr)) && (cb>=(1.1*cr)))
//		if((cg>=(1.05*cr)) && (cb>=(1.05*cr)))
//		if((cg2>=(1.05*cr2)) && (cb2>=(1.05*cr2)))
//		if((cg2>=(1.025*cr2)) && (cb2>=(1.025*cr2)))
//		if((cg2>=(1.001*cr2)) && (cb2>=(1.001*cr2)))
//		if((cg2>=(1.000*cr2)) && (cb2>=(1.000*cr2)))
//		if(((cg2>=(1.025*cr2)) && (cb2>=(1.025*cr2))) &&
//			(cb>=16) && (cr<192))
		if((((cg2>=(1.01*cr2)) && (cb2>=(1.01*cr2))) ||
				(cb2>=(1.01*cr2))) &&
			(cb2>=16) && (cr2<192))
		{
//			cr=255;
//			cg=0;
//			cb=255;
			ca=0;
		}
#if 0
		else if((cb2>=16) && (cr2<192))
		{
			k=2.5*cr2-cg2-cb2;
			k=k*k;
			if(k>255)k=255;
			ca=k;
		}
#endif
#endif

		k=(i*w+j)*4;
		dst[k+0]=cr;		dst[k+1]=cg;
		dst[k+2]=cb;		dst[k+3]=ca;
	}

	for(k=0; k<4; k++)
	{
		for(i=1; i<(h-1); i++)
			for(j=1; j<(w-1); j++)
		{
//			k0=((i+0)*w+(j+0))*4;
//			k1=((i+0)*w+(j-1))*4;
//			k2=((i-1)*w+(j+0))*4;
//			k3=((i-1)*w+(j-1))*4;

//			k4=((i-1)*w+(j+1))*4;
//			k5=((i+0)*w+(j+1))*4;
//			k6=((i+1)*w+(j-1))*4;
//			k7=((i+1)*w+(j+1))*4;

			k0=((i-1)*w+(j-1))*4; k1=((i-1)*w+(j+0))*4; k2=((i-1)*w+(j+1))*4;
			k3=((i+0)*w+(j-1))*4; k4=((i+0)*w+(j+0))*4; k5=((i+0)*w+(j+1))*4;
			k6=((i+1)*w+(j-1))*4; k7=((i+1)*w+(j+0))*4; k8=((i+1)*w+(j+1))*4;
		
			ca0=dst[k0+3];	ca1=dst[k1+3];	ca2=dst[k2+3];
			ca3=dst[k3+3];	ca4=dst[k4+3];	ca5=dst[k5+3];
			ca6=dst[k6+3];	ca7=dst[k7+3];	ca8=dst[k8+3];

//			ca=(ca0+ca1+ca2+ca3)/4;
//			ca=(ca0+ca1+ca2+ca3+ca4+ca5+ca6+ca7)/8;
			ca=(	2*ca0+4*ca1+2*ca2+
					4*ca3+8*ca4+4*ca5+
					2*ca6+4*ca7+2*ca8)/32;
//			dst[k0+3]=ca;
			tbuf[k0+3]=ca;
//			if(ca<=128)
//			{
//				dst[k0+3]=0;
//			}
		}
		
		for(i=1; i<(h-1); i++)
			for(j=1; j<(w-1); j++)
		{
			k=(i*w+j)*4;
			ca=tbuf[k+3];
			dst[k+3]=ca;
		}
	}

#if 0
	for(i=0; i<h; i++)
		for(j=0; j<w; j++)
	{
		k=(i*w+j)*4;
		ca=dst[k+3];
		if(ca<192)
//		if(ca<224)
		{
			dst[k+0]=255;
			dst[k+1]=0;
			dst[k+2]=255;
			dst[k+3]=0;
		}
	}
#endif

#if 1
	for(i=0; i<h; i++)
		for(j=0; j<w; j++)
	{
		k=(i*w+j)*4;
		ca=dst[k+3];
//		ca=(ca*ca)>>8;
		ca=bgbbtj_scurvei8(ca);
		if(ca<0)ca=0;
		if(ca>255)ca=255;
		dst[k+3]=ca;

		if(ca<=0)
		{
			dst[k+0]=255;
			dst[k+1]=0;
			dst[k+2]=255;
			dst[k+3]=0;
		}
	}
#endif
	
	free(tbuf);
	return(0);
}

BGBBTJ_API int BGBBTJ_Tex_GreenScreen(byte *src, byte *dst, int w, int h)
{
	static byte *lsbuf=NULL;
	byte *tbuf;
	float f, g;
	int cr, cg, cb, ca;
	int cy, cu, cv;
	int cr2, cg2, cb2;
	int ca0, ca1, ca2, ca3;
	int ca4, ca5, ca6, ca7, ca8;

	int cy0, cy1, cy2, cy3;
	int cy4, cy5, cy6, cy7, cy8;

	int k0, k1, k2, k3, k4, k5, k6, k7, k8;
	int p0, p1, p2, p3;
	int q0, q1, q2, q3;

	int n;
	int i, j, k, l;

	if(!lsbuf)
	{
		lsbuf=malloc(w*h*4);
		memcpy(lsbuf, src, w*h*4);
	}

	tbuf=malloc(w*h*4);

	n=w*h;
//	for(i=0; i<n; i++)
	for(i=0; i<h; i++)
		for(j=0; j<w; j++)
	{
		k=(i*w+j)*4;
		cr=src[k+0];		cg=src[k+1];
		cb=src[k+2];		ca=src[k+3];
		cy=(2*cg+cr+cb)>>2;

//		cr2=(src[k+0]+lsbuf[k+0])>>1;
//		cg2=(src[k+1]+lsbuf[k+1])>>1;
//		cb2=(src[k+2]+lsbuf[k+2])>>1;

		cr2=(3*src[k+0]+lsbuf[k+0])>>2;
		cg2=(3*src[k+1]+lsbuf[k+1])>>2;
		cb2=(3*src[k+2]+lsbuf[k+2])>>2;

#if 0
//		cy1=(cy>>1);
		cy1=2*cy;
		if(!cy1)cy1=1;
		cr2=(256*cr2)/cy1;
		cg2=(256*cg2)/cy1;
		cb2=(256*cb2)/cy1;

		cr2=(cr2<0)?0:((cr2>255)?255:cr2);
		cg2=(cg2<0)?0:((cg2>255)?255:cg2);
		cb2=(cb2<0)?0:((cb2>255)?255:cb2);
#endif

		cy2=(2*cg2+cr2+cb2)>>2;

//		cr2=cr; cg2=cg; cb2=cb;

#if 0
//		if(cg2>16)
//		if(cy>24)
		if(cy>16)
		{
//			cy0=(2*cg2+cr2+cb2)>>2;
			cy0=(cr2+cb2)>>1;
			if(cy0<1)cy0=1;
//			ca2=(cg2-cr2)+(cg2-cb2);
			ca2=cg2-cy0;
//			ca2=(256*ca2)/cg2;
			ca2=(256*ca2)/cy0;
//			ca2=(128*ca2)/cy0;
//			ca2=ca2*2;
			ca2=(ca2*3)>>1;
			if(ca2<0)ca2=0;
			ca2=(ca2*ca2)>>8;
//			ca2=(ca2*ca2*ca2)>>16;
			ca=255-ca2;
			if(ca<0)ca=0;
			if(ca>255)ca=255;
		}
#endif

#if 1
//		if(((cg2>=(1.10*cr2)) && (cg2>=(1.10*cb2))) &&
//			(cg2>=16) && (cr2<192))
//		if(((cg2>=(1.30*cr2)) && (cg2>=(1.10*cb2))) &&
//		if(((cg2>=(1.30*cr2)) && (cg2>=(1.20*cb2))) &&
//			(cg2>=16) && (cr2<192) && (cb2<192))
//		if(((cg2>=(1.40*cr2)) && (cg2>=(1.30*cb2))) &&
//			(cg2>=16) && (cr2<192) && (cb2<192))
//		if(((cg2>=(1.40*cr2)) && (cg2>=(1.40*cb2))) &&
//			(cg2>=8) && (cr2<224) && (cb2<224))
//				{ ca=0; }

//		f=2.0-cy2*(0.6/32.0);
		f=2.0-cy2*(0.6/24.0);
		if(f<1.2)f=1.2;
		if(((cg2>=(f*cr2)) && (cg2>=(f*cb2))) &&
			(cg2>=8) && (cr2<224) && (cb2<224))
		{
			ca=0;
		}
#endif

		k=(i*w+j)*4;
//		dst[k+0]=cr;		dst[k+1]=cg;
//		dst[k+2]=cb;		dst[k+3]=ca;

//		tbuf[k+0]=cr;		tbuf[k+1]=cg;
//		tbuf[k+2]=cb;		tbuf[k+3]=ca;

		tbuf[k+0]=cr2;		tbuf[k+1]=cg2;
		tbuf[k+2]=cb2;		tbuf[k+3]=ca;
	}

//	memcpy(lsbuf, src, w*h*4);
#if 1
	l=w*h*4;
	for(i=0; i<l; i++)
	{
//		lsbuf[i]=lsbuf[i]*0.75+src[i]*0.25;
//		lsbuf[i]=lsbuf[i]*0.50+src[i]*0.50;
		lsbuf[i]=lsbuf[i]*0.25+src[i]*0.75;
	}
#endif

	memcpy(dst, tbuf, w*h*4);

	for(k=0; k<4; k++)
	{
		for(i=1; i<(h-1); i++)
			for(j=1; j<(w-1); j++)
		{
			k0=((i-1)*w+(j-1))*4; k1=((i-1)*w+(j+0))*4; k2=((i-1)*w+(j+1))*4;
			k3=((i+0)*w+(j-1))*4; k4=((i+0)*w+(j+0))*4; k5=((i+0)*w+(j+1))*4;
			k6=((i+1)*w+(j-1))*4; k7=((i+1)*w+(j+0))*4; k8=((i+1)*w+(j+1))*4;

//			cy0=dst[k0+1];	cy1=dst[k1+1];	cy2=dst[k2+1];
//			cy3=dst[k3+1];	cy4=dst[k4+1];	cy5=dst[k5+1];
//			cy6=dst[k6+1];	cy7=dst[k7+1];	cy8=dst[k8+1];

			cy0=(2*dst[k0+1]+dst[k0+0]+dst[k0+2])>>2;
			cy1=(2*dst[k1+1]+dst[k1+0]+dst[k1+2])>>2;
			cy2=(2*dst[k2+1]+dst[k2+0]+dst[k2+2])>>2;
			cy3=(2*dst[k3+1]+dst[k3+0]+dst[k3+2])>>2;
			cy4=(2*dst[k4+1]+dst[k4+0]+dst[k4+2])>>2;
			cy5=(2*dst[k5+1]+dst[k5+0]+dst[k5+2])>>2;
			cy6=(2*dst[k6+1]+dst[k6+0]+dst[k6+2])>>2;
			cy7=(2*dst[k7+1]+dst[k7+0]+dst[k7+2])>>2;
			cy8=(2*dst[k8+1]+dst[k8+0]+dst[k8+2])>>2;
		
//			p0=cy1-cy7; p0=abs(p0);
//			p1=cy3-cy5; p1=abs(p1);

			p0=cy1-cy4; p0=abs(p0);
			p1=cy3-cy4; p1=abs(p1);
			p2=cy5-cy4; p2=abs(p2);
			p3=cy7-cy4; p3=abs(p3);
		
			ca0=dst[k0+3];	ca1=dst[k1+3];	ca2=dst[k2+3];
			ca3=dst[k3+3];	ca4=dst[k4+3];	ca5=dst[k5+3];
			ca6=dst[k6+3];	ca7=dst[k7+3];	ca8=dst[k8+3];

//			ca=(ca0+ca1+ca2+ca3)/4;
//			ca=(ca0+ca1+ca2+ca3+ca4+ca5+ca6+ca7)/8;
#if 1
//			if((p0>64) || (p1>64) || (p2>64) || (p3>64))
//			if((p0>16) || (p1>16) || (p2>16) || (p3>16))
			if((p0>32) || (p1>32) || (p2>32) || (p3>32))
			{
				q0=256-p0*3; if(q0<0)q0=0;
				q1=256-p1*3; if(q1<0)q1=0;
				q2=256-p2*3; if(q2<0)q2=0;
				q3=256-p3*3; if(q3<0)q3=0;
			
				l=512; ca=512*ca4;
				ca+=q0*cy1; l+=q0;
				ca+=q1*cy3; l+=q1;
				ca+=q2*cy5; l+=q2;
				ca+=q3*cy7; l+=q3;
				
				ca=ca/l;
			}else
#endif
#if 0
			if((p0>64) || (p1>64) || (p2>64) || (p3>64))
			{
				l=8; ca=8*ca4;
				if(p0<64) { ca+=4*cy1; l+=4; }
				if(p1<64) { ca+=4*cy3; l+=4; }
				if(p2<64) { ca+=4*cy5; l+=4; }
				if(p3<64) { ca+=4*cy7; l+=4; }
				
				ca=ca/l;
			}else
#endif
#if 0
			if((p0>32) || (p1>32))
			{
				if((p0>32) && (p1>32))
				{
					ca=ca4;
				}else if(p0>0)
				{
					ca=(4*ca3+8*ca4+4*ca5)/16;
				}else
				{
					ca=(4*ca1+8*ca4+4*ca7)/16;
				}
			}else
#endif
			{
				ca=(	2*ca0+4*ca1+2*ca2+
						4*ca3+8*ca4+4*ca5+
						2*ca6+4*ca7+2*ca8)/32;
			}
//			dst[k0+3]=ca;
//			tbuf[k0+3]=ca;
			tbuf[k4+3]=ca;
//			if(ca<=128)
//			{
//				dst[k0+3]=0;
//			}
		}
		
		for(i=1; i<(h-1); i++)
			for(j=1; j<(w-1); j++)
		{
			k=(i*w+j)*4;
			ca=tbuf[k+3];
			dst[k+3]=ca;
		}
	}

#if 1
	for(i=0; i<h; i++)
		for(j=0; j<w; j++)
	{
		k=(i*w+j)*4;
		ca=dst[k+3];
//		ca=(ca*ca)>>8;
		ca=bgbbtj_scurvei8(ca);
		if(ca<0)ca=0;
		if(ca>255)ca=255;
		dst[k+3]=ca;

//		if(ca<=0)
		if(ca<=16)
		{
			dst[k+0]=255;
			dst[k+1]=0;
			dst[k+2]=255;
			dst[k+3]=0;
		}
	}
#endif

	free(tbuf);
	return(0);
}

BGBBTJ_API void BGBBTJ_Tex_Dither15(byte *src, byte *dst, int w, int h)
{
	u32 s;
	int r0, r1, r2, r3;
	int ra0, ra1, ra2, ra3;
	int x, y, r, le;
	int i, j, k;

	s=0x55AA55AA;
	s=s*65521;
	s=s*65521;
	
	r3=0; r2=0; r1=0; r0=0;
	
	for(y=0; y<h; y++)
		for(x=0; x<w; x++)
	{
		r3=r2; r2=r1; r1=r0;
		r0=(s>>24)&255;
		
		ra0=(r0+r1)>>1;
		ra1=(r2+r3)>>1;
		ra2=(ra0+ra1)>>1;
//		r=(ra2+2*ra0+r0)>>2;
		r=(ra2+3*ra0-ra1+r0)>>2;
		
		r=(r*r)>>8;
//		r=(r*r*224)>>16;
		r=(r&1)?(r>>1):(-(r>>1));
//		r=(r&1)?r:(-r);
		s=s*65521;

		for(i=0; i<3; i++)
		{
			j=src[(y*w+x)*4+i];
		
//			k=(j*32+128+r)>>8;
//			if(k<0)k=0;
//			if(k>31)k=31;	
//			dst[(y*w+x)*4+i]=k<<3;

//			r=r+(le>>1);
//			r=r-(le>>1);

//			k=(j*32+128+r)>>5;
			k=(j*32+16+r)>>5;
			if(k<0)k=0;
			if(k>255)k=255;	
			dst[(y*w+x)*4+i]=k;
		
			le=j-k;
		}

		j=src[(y*w+x)*4+3];
		dst[(y*w+x)*4+3]=j;
	}
}
/*
2006-03-17 Brendan G Bohannon

Single Buffer Inflater

Assumes all the input is available, and the output buffer is big enough to
store the entire decoded stream (may pass lengths as a sanity check, currently
unused).

The bitstream works by reading from the low end of the window, moving a pos up,
and shifting the window down. This is good up to 24 bits at a time.

Multi-bit elements are packed from the low bit up, starting in the low bit,
thus all that is needed is to shift and mask them.

Huffman codes are packed with the MSB in the LSB position of the byte, and are
thus transposed. This is an issue of constructing the decoder table.

This can technically handle Defltate64 as well.
*/

#include <bgbbtj.h>

//typedef unsigned char byte;
//typedef unsigned short u16;
//typedef unsigned int u32;

byte *pdunz_ibuf;	//initial input buffer
byte *pdunz_obuf;	//initial output buffer

byte *pdunz_cs;		//current input pos
byte *pdunz_cse;	//end of input buffer (trauncation)
byte *pdunz_ct;		//current output pos
byte *pdunz_ce;		//end of output buffer

u32 pdunz_win;		//bit window
int pdunz_pos;		//bit window position
int pdunz_flags;	//decoder flags

u16 pdunz_ltab_idx[256];	//literal index table
u16 pdunz_dtab_idx[256];	//distance index table

u16 pdunz_ltab_code[288];	//literal codes
u16 pdunz_ltab_mask[288];	//literal code masks
u16 pdunz_ltab_next[288];	//literal table code chains
byte pdunz_ltab_len[288];	//literal code lengths

u16 pdunz_dtab_code[32];	//distance codes
u16 pdunz_dtab_mask[32];	//distance code masks
u16 pdunz_dtab_next[32];	//distance table code chains
byte pdunz_dtab_len[32];	//distance code lengths

static int pdunz_readescape_pushback=-1;

int (*PDUNZ_ReadByte)()=PDUNZ_ReadByteBasic;

int PDUNZ_ReadByteBasic()
{
	return(*pdunz_cs++);
}

int PDUNZ_ReadByteEscape()
{
	int i, j;

#if 0
	if(pdunz_readescape_pushback>=0)
	{
		i=pdunz_readescape_pushback;
		pdunz_readescape_pushback=-1;
		return(i);
	}
#endif

	i=*pdunz_cs++;
	if(i==0xFF)
	{
		j=*pdunz_cs++;
		if(j==0x00)
		{
//			pdunz_cs++;
		}else
#if 0
		if((j>=1) && (j<=15))
		{
			pdunz_readescape_pushback=j-1;
		}else
#endif
		{
			*(int *)-1=-1;
		}
	}
	return(i);
}


int PDUNZ_ReadBit()
{
	int i;

	i=(pdunz_win>>pdunz_pos)&1;
	pdunz_pos++;
	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;
	}
	return(i);
}

int PDUNZ_Read2Bits()
{
	int i;
	i=(pdunz_win>>pdunz_pos)&3;
	pdunz_pos+=2;
	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;
	}
	return(i);
}

int PDUNZ_Read3Bits()
{
	int i;
	i=(pdunz_win>>pdunz_pos)&7;
	pdunz_pos+=3;
	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;
	}
	return(i);
}

int PDUNZ_Read4Bits()
{
	int i;
	i=(pdunz_win>>pdunz_pos)&15;
	pdunz_pos+=4;
	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;
	}
	return(i);
}

int PDUNZ_Read5Bits()
{
	int i;
	i=(pdunz_win>>pdunz_pos)&31;
	pdunz_pos+=5;
	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;
	}
	return(i);
}

int PDUNZ_ReadNBits(int n)
{
	int i;
	i=(pdunz_win>>pdunz_pos)&((1<<n)-1);
	pdunz_pos+=n;
	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;

		while(pdunz_pos>=8)
		{
//			pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
			pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
			pdunz_pos-=8;
		}
	}
	return(i);
}

void PDUNZ_SkipNBits(int n)
{
	pdunz_pos+=n;

	if(pdunz_pos>=8)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;

		while(pdunz_pos>=8)
		{
//			pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
			pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
			pdunz_pos-=8;
		}
	}
}

int PDUNZ_PeekWord()
{
	int i;
	i=(pdunz_win>>pdunz_pos)&65535;
	return(i);
}

void PDUNZ_AlignByte()
{
	while(pdunz_pos>0)
	{
//		pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
		pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
		pdunz_pos-=8;
	}
	pdunz_pos=0;
}

int PDUNZ_ReadAlignedByte()
{
	int i;
	i=pdunz_win&0xFF;
//	pdunz_win=(pdunz_win>>8)|((*pdunz_cs++)<<24);
	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
	return(i);
}

int PDUNZ_ReadAlignedWord()
{
	int i;
	i=pdunz_win&0xFFFF;
//	pdunz_win=(pdunz_win>>16)|(pdunz_cs[0]<<16)|(pdunz_cs[1]<<24);
//	pdunz_cs+=2;
	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
	return(i);
}

static int trans8[256]={
0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

int PDUNZ_TransposeByte(int v)
{
	return(trans8[v]);
}

int PDUNZ_TransposeWord(int v)
{
	int i;
	i=trans8[(v>>8)&0xFF]|(trans8[v&0xFF]<<8);
	return(i);
}

int PDUNZ_SetupTable(byte *cl, int ncl,
	u16 *tc, u16 *tm, byte *tl,
	u16 *ti, u16 *tn)
{
	int cnt[16], nc[16], nn[16], nf[16];
	int i, j, k, k2, l, ff;

	for(i=0; i<16; i++) { cnt[i]=0; nc[i]=0; nn[i]=-1; nf[i]=-1; }
	for(i=0; i<256; i++)ti[i]=0xFFFF;

	for(i=0; i<ncl; i++)cnt[cl[i]]++;
	cnt[0]=0;

#if 1
	j=cl[0];
	for(i=15; i>=1; i--)
		if(cnt[i])break;
	if(j>i)j=i;
	if(!i)return(-12);	//no codes

	j=1;
	for(i=1; i<16; i++)
	{
		j<<=1;
		j-=cnt[i];

//		printf("%d %d %d\n", i, j, cnt[i]);
		if(j<0)return(-10);	//over subscribed
	}
	if((j>0) && ((ncl-cnt[0])!=1))
		return(-11);	//incomplete set
#endif

	j=0;
	for(i=1; i<16; i++)
	{
		j=(j+cnt[i-1])<<1;
		nc[i]=j;
	}

	for(i=0; i<ncl; i++)
	{
		l=cl[i];
		if(!l)
		{
			tl[i]=cl[i];
			continue;
		}

		tl[i]=cl[i];
		tm[i]=(1<<tl[i])-1;
		tc[i]=nc[l]++;

		if(nn[l]>=0)
		{
			tn[nn[l]]=i;
			nn[l]=i;
		}else
		{
			nf[l]=i;
			nn[l]=i;
		}
	}

	j=-1; ff=-1;
	for(i=1; i<16; i++)
	{
		if(nf[i]>=0)
		{
			if(ff<0)ff=nf[i];
			if(j>=0)tn[j]=nf[i];
			j=nn[i];
		}
	}
	if(j>=0)tn[j]=0xFFFF;

	for(i=ff; i!=0xFFFF; i=tn[i])
	{
		l=cl[i];
		if(l<=8)
		{
			k2=tc[i]<<(8-l);
			j=1<<(8-l);
			while(j--)
			{
				k=PDUNZ_TransposeByte(k2++);
				if(ti[k]==0xFFFF)ti[k]=i;
			}
		}else
		{
			k2=tc[i]>>(l-8);
			k=PDUNZ_TransposeByte(k2);
			if(ti[k]==0xFFFF)ti[k]=i;
		}

		k2=(tc[i])<<(16-l);
		k=PDUNZ_TransposeWord(k2++);
		tc[i]=k;
	}

	j=0;
	for(i=0; i<256; i++)if(ti[i]==0xFFFF)
	{
		printf("table bad index %d\n", i);
		j=-9;
	}
	return(j);
}

int PDUNZ_SetupStatic()
{
	byte lcl[288], dcl[32];
	int hl, hd;
	int i, j;

	hl=288;
	for(i=0; i<144; i++)lcl[i]=8;
	for(i=144; i<256; i++)lcl[i]=9;
	for(i=256; i<280; i++)lcl[i]=7;
	for(i=280; i<288; i++)lcl[i]=8;

	hd=32;
	for(i=0; i<32; i++)dcl[i]=5;

	j=PDUNZ_SetupTable(lcl, hl,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)
	{
		printf("Static Literal/Length Table Problem %d\n", j);
		return(j);
	}

	j=PDUNZ_SetupTable(dcl, hd,
		pdunz_dtab_code, pdunz_dtab_mask, pdunz_dtab_len,
		pdunz_dtab_idx, pdunz_dtab_next);
	if(j<0)
	{
		printf("Static Distance Table Problem %d\n", j);
		return(j);
	}

	return(0);
}

int PDUNZ_DecodeSymbol()
{
	int i, j;

	i=PDUNZ_PeekWord();
	j=pdunz_ltab_idx[i&0xFF];

	if((i&pdunz_ltab_mask[j])==pdunz_ltab_code[j])
	{
		PDUNZ_SkipNBits(pdunz_ltab_len[j]);
		return(j);
	}else
	{
		j=pdunz_ltab_next[j];
	}

	while((i&pdunz_ltab_mask[j])!=pdunz_ltab_code[j])
		j=pdunz_ltab_next[j];

	PDUNZ_SkipNBits(pdunz_ltab_len[j]);
	return(j);
}

int PDUNZ_DecodeDistance()
{
	static int dbase[]={
		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
		257, 385, 513, 769, 1025, 1537, 2049, 3073,
		4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
	static int dextra[]={
		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
		7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14};

	int i, j, k;

	i=PDUNZ_PeekWord();
	j=pdunz_dtab_idx[i&0xFF];

	while((i&pdunz_dtab_mask[j])!=pdunz_dtab_code[j])
		j=pdunz_dtab_next[j];

	PDUNZ_SkipNBits(pdunz_dtab_len[j]);
	k=dbase[j]+PDUNZ_ReadNBits(dextra[j]);

	return(k);
}

int PDUNZ_DecodeCodeLengths(byte *cl, int ncl)
{
	int i, j, k;

	i=0; k=0;
	while(i<ncl)
	{
		j=PDUNZ_DecodeSymbol();
		if(j<0)return(j);

		if(j<16)
		{
			k=j;
			cl[i++]=j;
			continue;
		}

		if(j==16)
		{
			j=PDUNZ_Read2Bits()+3;
			while(j--)cl[i++]=k;
			continue;
		}

		if(j==17)
		{
			j=PDUNZ_Read3Bits()+3;
			while(j--)cl[i++]=0;
			k=0;
			continue;
		}
		if(j==18)
		{
			j=PDUNZ_ReadNBits(7)+11;
			while(j--)cl[i++]=0;
			k=0;
			continue;
		}

		return(-7);
	}
	return(0);
}

int PDUNZ_DecodeHeader()
{
	static int lorder[]={
		16, 17, 18, 0, 8,7, 9,6, 10,5, 11,4, 12,3, 13,2, 14,1, 15};

	byte hcl[32], lcl[512], dcl[32];
	int hl, hd, hc;
	int i, j;

	hl=PDUNZ_ReadNBits(5)+257;
	hd=PDUNZ_ReadNBits(5)+1;
	hc=PDUNZ_ReadNBits(4)+4;

//	printf("%d %d %d\n", hl, hd, hc);

	for(i=0; i<32; i++)hcl[i]=0;
	for(i=0; i<hc; i++)
		hcl[lorder[i]]=PDUNZ_ReadNBits(3);

//	for(i=0; i<20; i++)printf("%d:%d ", i, hcl[i]);
//	printf("\n");

	j=PDUNZ_SetupTable(hcl, 32,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)
	{
		printf("Codes Table Problem %d\n", j);
		for(i=0; i<20; i++)printf("%d:%d ", i, hcl[i]);
		printf("\n");
		return(j);
	}

	i=PDUNZ_DecodeCodeLengths(lcl, hl);
	if(i<0)return(i);
	i=PDUNZ_DecodeCodeLengths(dcl, hd);
	if(i<0)return(i);

//	for(i=0; i<hl; i++)
//	{
//		j=lcl[i];
//		if(j)printf("%d:%d ", i, j);
//	}
//	printf("\n");

//	for(i=0; i<hd; i++)printf("%d:%d ", i, dcl[i]);
//	printf("\n");

	j=PDUNZ_SetupTable(lcl, hl,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)
	{
		printf("Literal/Length Table Problem %d\n", j);
		for(i=0; i<hl; i++)printf("%d:%d ", i, lcl[i]);
		printf("\n");
		return(j);
	}

	j=PDUNZ_SetupTable(dcl, hd,
		pdunz_dtab_code, pdunz_dtab_mask, pdunz_dtab_len,
		pdunz_dtab_idx, pdunz_dtab_next);
	if(j<0)
	{
		printf("Distance Table Problem %d\n", j);
		for(i=0; i<hd; i++)printf("%d:%d ", i, dcl[i]);
		printf("\n");
		return(j);
	}

	return(0);
}


int PDUNZ_DecodeHeaderBTLZH()
{
	static int lorder[]={
		16, 17, 18, 0, 8,7, 9,6, 10,5, 11,4, 12,3, 13,2, 14,1, 15};

	byte hcl[64], lcl[512], dcl[64];
	int hl, hd, hc, hr;
	int i, j;

	hr=PDUNZ_ReadNBits(3);
	if(hr!=0)return(-1);
	
	hl=PDUNZ_ReadNBits(7)+257;
	hd=PDUNZ_ReadNBits(6)+1;
	hc=PDUNZ_ReadNBits(5)+4;

//	printf("%d %d %d\n", hl, hd, hc);

	for(i=0; i<64; i++)hcl[i]=0;
	for(i=0; i<hc; i++)
		hcl[lorder[i]]=PDUNZ_ReadNBits(3);

//	for(i=0; i<20; i++)printf("%d:%d ", i, hcl[i]);
//	printf("\n");

	j=PDUNZ_SetupTable(hcl, 64,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)
	{
		printf("Codes Table Problem %d\n", j);
		for(i=0; i<20; i++)printf("%d:%d ", i, hcl[i]);
		printf("\n");
		return(j);
	}

	i=PDUNZ_DecodeCodeLengths(lcl, hl);
	if(i<0)return(i);
	i=PDUNZ_DecodeCodeLengths(dcl, hd);
	if(i<0)return(i);

//	for(i=0; i<hl; i++)
//	{
//		j=lcl[i];
//		if(j)printf("%d:%d ", i, j);
//	}
//	printf("\n");

//	for(i=0; i<hd; i++)printf("%d:%d ", i, dcl[i]);
//	printf("\n");

	j=PDUNZ_SetupTable(lcl, hl,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)
	{
		printf("Literal/Length Table Problem %d\n", j);
		for(i=0; i<hl; i++)printf("%d:%d ", i, lcl[i]);
		printf("\n");
		return(j);
	}

	j=PDUNZ_SetupTable(dcl, hd,
		pdunz_dtab_code, pdunz_dtab_mask, pdunz_dtab_len,
		pdunz_dtab_idx, pdunz_dtab_next);
	if(j<0)
	{
		printf("Distance Table Problem %d\n", j);
		for(i=0; i<hd; i++)printf("%d:%d ", i, dcl[i]);
		printf("\n");
		return(j);
	}

	return(0);
}

int PDUNZ_DecodeRun(int sym)
{
	static int lbase1[]={
		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
		35, 43, 51, 59, 67, 83, 99, 115,
		131, 163, 195, 227, 258, 0, 0, 0};
	static int lextra1[]={
		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0};
	static int lbase2[]={
		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
		35, 43, 51, 59, 67, 83, 99, 115,
		131, 163, 195, 227, 3, 0, 0, 0};
	static int lextra2[]={
		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 16, 0, 0, 0};
	int *lbase, *lextra;
	char *s, *se;
	int i, j, k;

	if(pdunz_flags&BGBBTJ_ZFL_DEFLATE64)
		{ lbase=lbase2; lextra=lextra2; }
	else
		{ lbase=lbase1; lextra=lextra1; }

	i=sym-257;
	j=lbase[i]+PDUNZ_ReadNBits(lextra[i]);
	k=PDUNZ_DecodeDistance();
	s=pdunz_ct-k;
	i=j;

// #if defined(X86) || defined(X86_64)
#if 0
	se=s+i;
	while((s+16)<=se)
	{
		((double *)pdunz_ct)[0]=((double *)s)[0];
		((double *)pdunz_ct)[1]=((double *)s)[1];
		pdunz_ct+=16; s+=16;
	}
	if((s+8)<=se)
	{
		*((double *)pdunz_ct)++=*((double *)s)++;
	}
	if((s+4)<=se)
	{
		*((int *)pdunz_ct)++=*((int *)s)++;
	}
	while(s<se)*pdunz_ct++=*s++;
#endif

#if defined(X86) || defined(X86_64)
//#if 0
	if(k>=16)
	{
#if 1
		while(i>=16)
		{
			((double *)pdunz_ct)[0]=((double *)s)[0];
			((double *)pdunz_ct)[1]=((double *)s)[1];
			pdunz_ct+=16; s+=16;
			i-=16;
		}
#endif
#if 1
		if(i>=8)
		{
			*((double *)pdunz_ct)++=*((double *)s)++;
			i-=8;
		}
#endif
#if 1
		if(i>=4)
		{
			*((int *)pdunz_ct)++=*((int *)s)++;
			i-=4;
		}
#endif
#if 1
		if(i>=2)
		{
//			*((short *)pdunz_ct)++=*((short *)s)++;
			*pdunz_ct++=*s++;
			*pdunz_ct++=*s++;
			i-=2;
		}
#endif
		if(i)*pdunz_ct++=*s++;
	}else
	{
		while(i--)*pdunz_ct++=*s++;
	}

//	while(i--)*pdunz_ct++=*s++;
#endif
//	while(i--)*pdunz_ct++=*s++;

	return(0);
}

int PDUNZ_DecodeBlockData()
{
	int i;

	while(1)
	{
		i=PDUNZ_DecodeSymbol();
		if(i<0)return(i);

		if(i<256)
		{
			*pdunz_ct++=i;
			continue;
		}
		if(i==256)break;

		i=PDUNZ_DecodeRun(i);
		if(i<0)return(i);
	}

	return(0);
}

int PDUNZ_DecodeBlock()
{
	int fi, ty, ty2, l, nl;
	int i;

	fi=PDUNZ_ReadBit();
	ty=PDUNZ_Read2Bits();

//	printf("blk %d %d\n", fi, ty);

	switch(ty)
	{
	case 0:
		PDUNZ_AlignByte();
		l=PDUNZ_ReadAlignedWord();
		nl=(~PDUNZ_ReadAlignedWord())&0xFFFF;
		if(l!=nl)
		{
//			printf("%04X %04X(%04X)\n", l, nl, (~nl)&0xFFFF);
			return(-3);
		}

		while(l--)
		{
			i=PDUNZ_ReadAlignedByte();
			*pdunz_ct++=i;
		}
		break;
	case 1:
		i=PDUNZ_SetupStatic();
		if(i<0)return(i);
		i=PDUNZ_DecodeBlockData();
		if(i<0)return(i);
		break;
	case 2:
		i=PDUNZ_DecodeHeader();
		if(i<0)return(i);
		i=PDUNZ_DecodeBlockData();
		if(i<0)return(i);
		break;

	case 3:
		if(pdunz_flags&BGBBTJ_ZFL_ESCBTLZH)
		{
			ty2=PDUNZ_Read3Bits();
			if(ty2==7)
			{
				if(pdunz_flags&BGBBTJ_ZFL_ESCBTLZA)
					return(2);
				return(-2);
			}
			
			if(ty2==2)
			{
				i=PDUNZ_DecodeHeaderBTLZH();
				if(i<0)return(i);
				i=PDUNZ_DecodeBlockData();
				if(i<0)return(i);
				break;
			}
		}
		if(pdunz_flags&BGBBTJ_ZFL_ESCBTLZA)
			return(2);
		return(-2);
		break;

	default:
		return(-2);
		break;
	}

	return(fi);
}

BGBBTJ_API int PDUNZ_DecodeStream(byte *ibuf, byte *obuf, int isz, int osz)
{
	return(PDUNZ_DecodeStreamSz(ibuf, obuf, isz, osz, NULL, 0));
}

BGBBTJ_API int PDUNZ_DecodeStreamSz(byte *ibuf, byte *obuf, int isz,
	int osz, int *rosz, int flags)
{
	int i, k;

	if(flags&BGBBTJ_ZFL_ESCAPE_FF)
	{
		PDUNZ_ReadByte=PDUNZ_ReadByteEscape;
	}else
	{
		PDUNZ_ReadByte=PDUNZ_ReadByteBasic;
	}

	pdunz_ibuf=ibuf;
	pdunz_obuf=obuf;
//	pdunz_cs=ibuf+4;
	pdunz_cs=ibuf;
	pdunz_ct=obuf;
	pdunz_cse=ibuf+isz;
	pdunz_ce=obuf+osz;

	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);
	pdunz_win=(pdunz_win>>8)|(PDUNZ_ReadByte()<<24);

//	pdunz_win=ibuf[0]|(ibuf[1]<<8)|(ibuf[2]<<16)|(ibuf[3]<<24);
	pdunz_pos=0;
	
	pdunz_flags=flags;

	k=0;
	while(1)
	{
		i=PDUNZ_DecodeBlock();
		if(i<0)return(i);
		if(i)break;
	}

	i=pdunz_pos;
	while(i<=24)
	{
		pdunz_cs--;
		i+=8;
	}

	if(rosz)
		*rosz=pdunz_ct-pdunz_obuf;

	i=pdunz_cs-ibuf;
	return(i);
}

BGBBTJ_API int PDUNZ_DecodeStreamSzZl(byte *ibuf, byte *obuf, int isz,
	int osz, int *rosz, int flags)
{
	int i, j, cm;
	
	i=(ibuf[0]<<8)+ibuf[1];
	cm=(i>>8)&15;

	if(cm==9)
	{
		i=PDUNZ_DecodeStreamSz(ibuf+2, obuf, isz-2,
			osz, rosz, flags|BGBBTJ_ZFL_DEFLATE64);
		return(i);
	}
	if(cm==8)
	{
		i=PDUNZ_DecodeStreamSz(ibuf+2, obuf, isz-2, osz, rosz, flags);
		return(i);
	}
	return(0);
}

BGBBTJ_API int PDUNZ_DecodeStreamZl(byte *ibuf, byte *obuf, int isz, int osz)
{
	return(PDUNZ_DecodeStreamSzZl(ibuf, obuf, isz, osz, NULL, 0));
}
#include <bgbbtj.h>

//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>

#include <math.h>
//#include "tga.c"

#define DCTSZ	8
#define DCTSZ2	64

//typedef unsigned char byte;
//typedef unsigned short ushort;
//typedef unsigned int uint;

#define JPG_SOF0	0xC0
#define JPG_SOF1	0xC1
#define JPG_SOF2	0xC2
#define JPG_SOF3	0xC3
#define JPG_DHT		0xC4
#define JPG_SOF5	0xC5
#define JPG_SOF6	0xC6
#define JPG_SOF7	0xC7
#define JPG_JPG		0xC8
#define JPG_SOF9	0xC9
#define JPG_SOF10	0xCA
#define JPG_SOF11	0xCB
#define JPG_DAC		0xCC
#define JPG_SOF13	0xCD
#define JPG_SOF14	0xCE
#define JPG_SOF15	0xCF

#define JPG_RST0	0xD0
#define JPG_RST1	0xD1
#define JPG_RST2	0xD2
#define JPG_RST3	0xD3
#define JPG_RST4	0xD4
#define JPG_RST5	0xD5
#define JPG_RST6	0xD6
#define JPG_RST7	0xD7

#define JPG_SOI		0xD8
#define JPG_EOI		0xD9
#define JPG_SOS		0xDA
#define JPG_DQT		0xDB
#define JPG_DNL		0xDC
#define JPG_DRI		0xDD
#define JPG_DHP		0xDE
#define JPG_EXP		0xDF

#define JPG_APP0	0xE0
#define JPG_APP1	0xE1
#define JPG_APP2	0xE2
#define JPG_APP3	0xE3
#define JPG_APP4	0xE4
#define JPG_APP5	0xE5
#define JPG_APP6	0xE6
#define JPG_APP7	0xE7
#define JPG_APP8	0xE8
#define JPG_APP9	0xE9
#define JPG_APP10	0xEA
#define JPG_APP11	0xEB
#define JPG_APP12	0xEC
#define JPG_APP13	0xED
#define JPG_APP14	0xEE
#define JPG_APP15	0xEF

#define JPG_JPG0	0xF0
#define JPG_JPG1	0xF1
#define JPG_JPG2	0xF2
#define JPG_JPG3	0xF3
#define JPG_JPG4	0xF4
#define JPG_JPG5	0xF5
#define JPG_JPG6	0xF6
#define JPG_JPG7	0xF7
#define JPG_JPG8	0xF8
#define JPG_JPG9	0xF9
#define JPG_JPG10	0xFA
#define JPG_JPG11	0xFB
#define JPG_JPG12	0xFC
#define JPG_JPG13	0xFD
#define JPG_COM		0xFE

char *pdjpg_marker[]={
"SOF0", "SOF1", "SOF2", "SOF3", "DHT", "SOF5", "SOF6", "SOF7",
"JPG", "SOF9", "SOF10", "SOF11", "DAC", "SOF13", "SOF14", "SOF15",
"RST0", "RST1", "RST2", "RST3", "RST4", "RST5", "RST6", "RST7",
"SOI", "EOI", "SOS", "DQT", "DNL", "DRI", "DHP", "EXP",
"APP0", "APP1", "APP2", "APP3", "APP4", "APP5", "APP6", "APP7", 
"APP8", "APP9", "APP10", "APP11", "APP12", "APP13", "APP14", "APP15", 
"JPG0", "JPG1", "JPG2", "JPG3", "JPG4", "JPG5", "JPG6", "JPG7", 
"JPG8", "JPG9", "JPG10", "JPG11", "JPG12", "JPG13", "COM", ""
};

byte pdjpg_zigzag[64]={
 0,  1,  5,  6, 14, 15, 27, 28,
 2,  4,  7, 13, 16, 26, 29, 42,
 3,  8, 12, 17, 25, 30, 41, 43,
 9, 11, 18, 24, 31, 40, 44, 53,
10, 19, 23, 32, 39, 45, 52, 54,
20, 22, 33, 38, 46, 51, 55, 60,
21, 34, 37, 47, 50, 56, 59, 61,
35, 36, 48, 49, 57, 58, 62, 63
};

byte pdjpg_zigzag2[64]={
 0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63
};

ushort pdjhuff_code[8*256];
byte pdjhuff_len[8*256];

byte *pdjhuff_cs;	//current pos in bitstream (input)
byte *pdjhuff_ct;	//current pos in bitstream (output)
uint pdjhuff_win;	//bitstream window
int pdjhuff_pos;	//bitstream offset
int pdjhuff_isend;	//bitstream has broken (decoder)

byte pdjpg_qt[4][64];


//Decoder Specific

int pdjpg_xs, pdjpg_ys;
byte pdjpg_cid[16];
byte pdjpg_ch[16];
byte pdjpg_cv[16];
byte pdjpg_qid[16];
int pdjpg_cxi[16];
int pdjpg_cyi[16];
int pdjpg_nc;
int pdjpg_chm;
int pdjpg_chn;

int pdjpg_scid[4];
int pdjpg_scn[4];
short *pdjpg_scbuf[4];
byte *pdjpg_sibuf[4];

//Encoder Specific
int pdjpg_mono;


//Common

#if 1
void PDJPG_TransDCT_Horiz(byte *iblk, int *oblk)
{
	char ib[8];

	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	oblk[0]=ib[0]*91  +ib[1]*91  +ib[2]*91  +ib[3]*91  +ib[4]*91  +ib[5]*91  +ib[6]*91  +ib[7]*91;
	oblk[1]=ib[0]*126 +ib[1]*106 +ib[2]*71  +ib[3]*25  -ib[4]*25  -ib[5]*71  -ib[6]*106 -ib[7]*126;
	oblk[2]=ib[0]*118 +ib[1]*49  -ib[2]*49  -ib[3]*118 -ib[4]*118 -ib[5]*49  +ib[6]*49  +ib[7]*118;
	oblk[3]=ib[0]*106 -ib[1]*25  -ib[2]*126 -ib[3]*71  +ib[4]*71  +ib[5]*126 +ib[6]*25  -ib[7]*106;
	oblk[4]=ib[0]*91  -ib[1]*91  -ib[2]*91  +ib[3]*91  +ib[4]*91  -ib[5]*91  -ib[6]*91  +ib[7]*91;
	oblk[5]=ib[0]*71  -ib[1]*126 +ib[2]*25  +ib[3]*106 -ib[4]*106 -ib[5]*25  +ib[6]*126 -ib[7]*71;
	oblk[6]=ib[0]*49  -ib[1]*118 +ib[2]*118 -ib[3]*49  -ib[4]*49  +ib[5]*118 -ib[6]*118 +ib[7]*49;
	oblk[7]=ib[0]*25  -ib[1]*71  +ib[2]*106 -ib[3]*126 +ib[4]*126 -ib[5]*106 +ib[6]*71  -ib[7]*25;
}

void PDJPG_TransDCT_Vert(int *iblk, int *oblk)
{
	oblk[ 0]=iblk[0]*91  +iblk[8]*91  +iblk[16]*91  +iblk[24]*91  +iblk[32]*91  +iblk[40]*91  +iblk[48]*91  +iblk[56]*91;
	oblk[ 8]=iblk[0]*126 +iblk[8]*106 +iblk[16]*71  +iblk[24]*25  -iblk[32]*25  -iblk[40]*71  -iblk[48]*106 -iblk[56]*126;
	oblk[16]=iblk[0]*118 +iblk[8]*49  -iblk[16]*49  -iblk[24]*118 -iblk[32]*118 -iblk[40]*49  +iblk[48]*49  +iblk[56]*118;
	oblk[24]=iblk[0]*106 -iblk[8]*25  -iblk[16]*126 -iblk[24]*71  +iblk[32]*71  +iblk[40]*126 +iblk[48]*25  -iblk[56]*106;
	oblk[32]=iblk[0]*91  -iblk[8]*91  -iblk[16]*91  +iblk[24]*91  +iblk[32]*91  -iblk[40]*91  -iblk[48]*91  +iblk[56]*91;
	oblk[40]=iblk[0]*71  -iblk[8]*126 +iblk[16]*25  +iblk[24]*106 -iblk[32]*106 -iblk[40]*25  +iblk[48]*126 -iblk[56]*71;
	oblk[48]=iblk[0]*49  -iblk[8]*118 +iblk[16]*118 -iblk[24]*49  -iblk[32]*49  +iblk[40]*118 -iblk[48]*118 +iblk[56]*49;
	oblk[56]=iblk[0]*25  -iblk[8]*71  +iblk[16]*106 -iblk[24]*126 +iblk[32]*126 -iblk[40]*106 +iblk[48]*71  -iblk[56]*25;
}

void PDJPG_TransDCT(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransDCT_Horiz(iblk+0, s+0);
	PDJPG_TransDCT_Horiz(iblk+8, s+8);
	PDJPG_TransDCT_Horiz(iblk+16, s+16);
	PDJPG_TransDCT_Horiz(iblk+24, s+24);
	PDJPG_TransDCT_Horiz(iblk+32, s+32);
	PDJPG_TransDCT_Horiz(iblk+40, s+40);
	PDJPG_TransDCT_Horiz(iblk+48, s+48);
	PDJPG_TransDCT_Horiz(iblk+56, s+56);

	PDJPG_TransDCT_Vert(s+0, t+0);
	PDJPG_TransDCT_Vert(s+1, t+1);
	PDJPG_TransDCT_Vert(s+2, t+2);
	PDJPG_TransDCT_Vert(s+3, t+3);
	PDJPG_TransDCT_Vert(s+4, t+4);
	PDJPG_TransDCT_Vert(s+5, t+5);
	PDJPG_TransDCT_Vert(s+6, t+6);
	PDJPG_TransDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i]>>16;
}

#endif

#if 1
void PDJPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[0]* 91;	b=iblk[4]* 91;
	c=iblk[2]*118;	d=iblk[2]* 49;
	e=iblk[6]*118;	f=iblk[6]* 49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[1]*126+iblk[3]*106+iblk[5]* 71+iblk[7]* 25;
	n=iblk[1]*106-iblk[3]* 25-iblk[5]*126-iblk[7]* 71;
	o=iblk[1]* 71-iblk[3]*126+iblk[5]* 25+iblk[7]*106;
	p=iblk[1]* 25-iblk[3]* 71+iblk[5]*106-iblk[7]*126;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
}

void PDJPG_TransIDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]* 91;	b=iblk[32]*91;
	c=iblk[16]*118;	d=iblk[16]*49;
	e=iblk[48]*118;	f=iblk[48]*49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[8]*126+iblk[24]*106+iblk[40]* 71+iblk[56]* 25;
	n=iblk[8]*106-iblk[24]* 25-iblk[40]*126-iblk[56]* 71;
	o=iblk[8]* 71-iblk[24]*126+iblk[40]* 25+iblk[56]*106;
	p=iblk[8]* 25-iblk[24]* 71+iblk[40]*106-iblk[56]*126;
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

void PDJPG_TransIDCT(short *iblk, byte *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIDCT_Horiz(iblk+0, s+0);
	PDJPG_TransIDCT_Horiz(iblk+8, s+8);
	PDJPG_TransIDCT_Horiz(iblk+16, s+16);
	PDJPG_TransIDCT_Horiz(iblk+24, s+24);
	PDJPG_TransIDCT_Horiz(iblk+32, s+32);
	PDJPG_TransIDCT_Horiz(iblk+40, s+40);
	PDJPG_TransIDCT_Horiz(iblk+48, s+48);
	PDJPG_TransIDCT_Horiz(iblk+56, s+56);

	PDJPG_TransIDCT_Vert(s+0, t+0);
	PDJPG_TransIDCT_Vert(s+1, t+1);
	PDJPG_TransIDCT_Vert(s+2, t+2);
	PDJPG_TransIDCT_Vert(s+3, t+3);
	PDJPG_TransIDCT_Vert(s+4, t+4);
	PDJPG_TransIDCT_Vert(s+5, t+5);
	PDJPG_TransIDCT_Vert(s+6, t+6);
	PDJPG_TransIDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=(t[i]>>16)+128;
		oblk[i]=(j<0)?0:((j>255)?255:j);
	}
}

#endif



//Decoder

int PDJHUFF_NextByte()
{
	int i, j;

	if(pdjhuff_isend)return(0xFF);

	i=*pdjhuff_cs++;
	if(i==0xFF)
	{
		j=*pdjhuff_cs++;
		if(j)
		{
//			printf("bitstream problem\n");
			pdjhuff_isend=1;
		}
	}
	return(i);
}

int PDJHUFF_InitStream(byte *buf)
{
	pdjhuff_pos=0;
	pdjhuff_isend=0;

	pdjhuff_cs=buf;
	pdjhuff_win=PDJHUFF_NextByte();
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte();
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte();
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte();
}

int PDJHUFF_ReadBit()
{
	int i;

	i=(pdjhuff_win>>(31-pdjhuff_pos))&1;
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte();
		pdjhuff_pos-=8;
	}
	return(i);
}

int PDJHUFF_ReadNBits(int n)
{
	int i;

	i=(pdjhuff_win>>(32-n-pdjhuff_pos))&((1<<n)-1);
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte();
		pdjhuff_pos-=8;
	}
	return(i);
}

void PDJHUFF_SkipNBits(int n)
{
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte();
		pdjhuff_pos-=8;
	}
}

int PDJHUFF_PeekWord()
{
	int i;
	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
	return(i);
}

int PDJHUFF_DecodeSymbol(int tab)
{
	int i, j, k;

	tab<<=8;

	i=PDJHUFF_PeekWord();
	for(j=0; j<256; j++)
	{
		k=pdjhuff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=pdjhuff_code[tab|j])
			continue;
		PDJHUFF_SkipNBits(k);
		return(j);
	}
	return(-1);
}

int PDJHUFF_DecodeDiffDC(int tab)
{
	int i, j;

	i=PDJHUFF_DecodeSymbol(tab);
	j=PDJHUFF_ReadNBits(i);

	if(!(j&(1<<(i-1))))
		j=(-1<<i)+j+1;
	return(j);
}

int PDJHUFF_DecodeBlock(short *buf, int dctab, int actab,
	int ni, int nn)
{
	int i, j, k;

	for(i=1; i<64; i++)buf[i]=0;

	buf[0]+=PDJHUFF_DecodeDiffDC(dctab);
	for(i=1; i<64; i++)
	{
		j=PDJHUFF_DecodeSymbol(actab);
		if(!j)break;

		i+=j>>4;	//preceding 0's
		if(!(j&15))continue;

		j&=15;
		k=PDJHUFF_ReadNBits(j);
		if(!(k&(1<<(j-1))))
			k=(-1<<j)+k+1;

		j=pdjpg_zigzag2[i];
		buf[j]=k;
	}

	if(i>64)printf("bad dct block1 %02X %d/%d\n", j, ni, nn);

	return(0);
}

void PDJHUFF_QuantBlock(short *ibuf, short *obuf, int qid)
{
	int i, j;
	for(i=0; i<64; i++)
		obuf[i]=ibuf[i]/pdjpg_qt[qid][i];
}

void PDJHUFF_DequantBlock(short *ibuf, short *obuf, int qid)
{
	int i, j;
	for(i=0; i<64; i++)
		obuf[i]=ibuf[i]*pdjpg_qt[qid][i];
}

int PDJPG_MarkerSOS(byte *buf)
{
	static short dbuf[4*64];
	byte ch[4], cv[4], qid[4];
	byte step[4];
	int xi[4], yi[4], wi[4], hi[4];
	byte cdt[4], cat[4];
	int ccnt[4];

	byte *s;
	int i, j, k, l, i1, j1, k1, l1;
	int w, h, n, ns;

	l=(buf[0]<<8)|buf[1];
//	printf("ns %d\n", buf[2]);

	ns=buf[2];
	s=buf+3;
	for(i=0; i<buf[2]; i++)
	{
//		printf("%d %d %d\n", s[0], s[1]>>4, s[1]&15);

		cdt[i]=s[1]>>4;
		cat[i]=s[1]&15;

		for(j=0; j<pdjpg_nc; j++)
			if(pdjpg_cid[j]==s[0])
		{
			ch[i]=pdjpg_ch[j];
			cv[i]=pdjpg_cv[j];
			qid[i]=pdjpg_qid[j];
			xi[i]=pdjpg_cxi[j];
			yi[i]=pdjpg_cyi[j];

			step[i]=ch[i]*cv[i];
			break;
		}

		w=(xi[i]+7)/8;
		h=(yi[i]+7)/8;
		wi[i]=w;
		hi[i]=h;

		n=(w+1)*(h+2);
		pdjpg_scid[i]=s[0];
		pdjpg_scn[i]=j;
		pdjpg_scbuf[i]=malloc(n*64*sizeof(short));
		pdjpg_sibuf[i]=malloc(n*64);

//		memset(pdjpg_sibuf[i], 0, n*64);

		ccnt[i]=0;

		s+=2;
	}
	s+=3;

	i=(pdjpg_xs+pdjpg_chm*8-1)/(pdjpg_chm*8);
	j=(pdjpg_ys+pdjpg_chn*8-1)/(pdjpg_chn*8);
	n=i*j;

	PDJHUFF_InitStream(s);

	for(i=0; i<(4*64); i++)dbuf[i]=0;

	for(i=0; i<n; i++)
	{
		for(j=0; j<ns; j++)
			for(k=0; k<cv[j]; k++)
				for(l=0; l<ch[j]; l++)
		{
			i1=(i/(wi[j]/ch[j]))*ch[j];
			j1=(i%(wi[j]/ch[j]))*ch[j];
			k1=((i1+k)*wi[j])+(j1+l);

			PDJHUFF_DecodeBlock(dbuf+j*64,
				cdt[j]*2+0, cat[j]*2+1, i, n);
			PDJHUFF_DequantBlock(dbuf+j*64,
				pdjpg_scbuf[j]+k1*64, qid[j]);
			PDJPG_TransIDCT(pdjpg_scbuf[j]+k1*64,
				pdjpg_sibuf[j]+k1*64);
		}
	}
}

int PDJPG_MarkerSOF0(byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, m, n;

	l=(buf[0]<<8)|buf[1];
//	printf("p %d\n", buf[2]);

	i=(buf[3]<<8)|buf[4];
	j=(buf[5]<<8)|buf[6];

	pdjpg_xs=j;
	pdjpg_ys=i;
//	printf("size %dx%d\n", j, i);

	m=0; n=0;

	k=buf[7];
	s=buf+8;
	for(i=0; i<k; i++)
	{
		pdjpg_cid[i]=s[0];
		pdjpg_ch[i]=s[1]>>4;
		pdjpg_cv[i]=s[1]&15;
		pdjpg_qid[i]=s[2];

		if(pdjpg_ch[i]>m)m=pdjpg_ch[i];
		if(pdjpg_cv[i]>n)n=pdjpg_cv[i];

//		printf("CID %d: %d %d %d\n", pdjpg_cid[i],
//			pdjpg_ch[i], pdjpg_cv[i], pdjpg_qid[i]);
		s+=3;
	}

	pdjpg_chm=m;
	pdjpg_chn=n;

	for(i=0; i<k; i++)
	{
		pdjpg_cxi[i]=(pdjpg_ch[i]*pdjpg_xs)/m;
		pdjpg_cyi[i]=(pdjpg_cv[i]*pdjpg_ys)/n;
	}

	pdjpg_nc=k;

	return(0);
}

int PDJPG_MarkerDQT(byte *buf)
{
	byte *s, *se;
	int i, j, l;

	l=(buf[0]<<8)|buf[1];

	s=buf+2;
	se=buf+l;

	while(s<se)
	{
		i=(s[0]>>4)&15;
		if(i)
		{
//			printf("bad bits %d\n", i);
			return(-1);
		}
		i=s[0]&15;
//		printf("dest %d\n", i);

		for(j=0; j<64; j++)
			pdjpg_qt[i][pdjpg_zigzag2[j]]=s[j+1];
		s+=65;
	}
}

int PDJPG_MarkerDHT(byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, tn;

	l=(buf[0]<<8)|buf[1];

	j=(buf[2]>>4)&15;
	i=buf[2]&15;
//	printf("dest %d, type %d\n", i, j);

	tn=i*2+j;

	for(i=0; i<256; i++)
		pdjhuff_len[tn*256+i]=0;

	cnt=buf+3;
	s=cnt+16;
	k=0; l=0;
	for(i=0; i<16; i++)
	{
		k<<=1;
		for(j=0; j<cnt[i]; j++)
		{
			pdjhuff_code[tn*256+(*s)]=k++;
			pdjhuff_len[tn*256+(*s)]=i+1;
			l=i+1;
			s++;
		}
	}
//	printf("%04X %d\n", k, l);
}

int PDJPG_GetComponentPixel(int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	id=pdjpg_scn[cn];

	i=(pdjpg_ch[id]*x)/pdjpg_chm;
	j=(pdjpg_cv[id]*y)/pdjpg_chn;
	k=i/8;
	l=j/8;

	w=(pdjpg_cxi[id]+7)/8;
	h=(pdjpg_cyi[id]+7)/8;
	n=(l*w)+k;

	k=i%8;
	l=j%8;

	v=pdjpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

PDGL_API byte *PDJPG_Decode(byte *buf, int sz, int *xs, int *ys)
{
	byte *obuf;
	int i, j, k, l;
	int y, u, v, r, g, b;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
		return(NULL);

	for(i=0; i<4; i++)
	{
		pdjpg_scbuf[i]=NULL;
		pdjpg_sibuf[i]=NULL;
	}

	for(i=0; i<sz; i++)
	{
		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		{
			j=buf[i+1]-0xC0;
			if(j<0)j=63;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)PDJPG_MarkerDQT(buf+i+2);
			if(buf[i+1]==JPG_DHT)PDJPG_MarkerDHT(buf+i+2);
			if(buf[i+1]==JPG_SOF0)PDJPG_MarkerSOF0(buf+i+2);
			if(buf[i+1]==JPG_SOS)PDJPG_MarkerSOS(buf+i+2);

			if(buf[i+1]==JPG_EOI)break;
		}
	}

	obuf=malloc((pdjpg_xs+1)*(pdjpg_ys+1)*4);
	memset(obuf, 0xFF, pdjpg_xs*pdjpg_ys*4);

	for(i=0; i<pdjpg_ys; i++)
		for(j=0; j<pdjpg_xs; j++)
	{
		if(pdjpg_nc==3)
		{
			y=PDJPG_GetComponentPixel(0, j, i);
			u=PDJPG_GetComponentPixel(1, j, i);
			v=PDJPG_GetComponentPixel(2, j, i);

			r=y+				1.402*(v-128);
			g=y-	0.34414*(u-128)-	0.71414*(v-128);
			b=y+	1.772*(u-128);

			r=(r<0)?0:((r>255)?255:r);
			g=(g<0)?0:((g>255)?255:g);
			b=(b<0)?0:((b>255)?255:b);
		}else if(pdjpg_nc==1)
		{
			y=PDJPG_GetComponentPixel(0, j, i);
			r=y; g=y; b=y;
		}

		k=pdjpg_ys-1-i;

		obuf[((k*pdjpg_xs)+j)*4+0]=r;
		obuf[((k*pdjpg_xs)+j)*4+1]=g;
		obuf[((k*pdjpg_xs)+j)*4+2]=b;
	}

	for(i=0; i<4; i++)
	{
		if(pdjpg_scbuf[i])free(pdjpg_scbuf[i]);
		if(pdjpg_sibuf[i])free(pdjpg_sibuf[i]);
	}

	*xs=pdjpg_xs;
	*ys=pdjpg_ys;
	return(obuf);
}



//Encoder

void PDJHUFF_WriteBit(int i)
{
	pdjhuff_win|=i<<(31-pdjhuff_pos);
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteNBits(int i, int n)
{
	i&=(1<<n)-1;

	pdjhuff_win|=i<<((32-n)-pdjhuff_pos);
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_FlushBits()
{
	int i;
	while(pdjhuff_pos>0)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

int PDJHUFF_BalanceTree_r(short *nodes, short *nlen, int root, int h, int ml)
{
	int h0, h1, h2, h3;
	int l0, l1, l2;

	if(root<0)return(0);

	h1=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+0], h+1, ml);
	h2=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+1], h+1, ml);
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	if((h+h0)<=ml)	//depth limit not exceeded
		return(h0);

	//ok, so part of the tree is too deep
	if((h1+1)<h2)
	{
		l0=nodes[root*2+1];
		l1=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[root*2+0];
		nodes[root*2+0]=l0;
		nodes[root*2+1]=l1;
	}else if((h2+1)<h1)
	{
		l0=nodes[root*2+0];
		l1=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[root*2+1];
		nodes[root*2+0]=l1;
		nodes[root*2+1]=l0;
	}else
	{
		//rotating would be ineffective or would make things worse...
		return(h0);
	}

	//recalc depth of modified sub-tree
	l1=nodes[l0*2+0];
	l2=nodes[l0*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h3=((h1>h2)?h1:h2)+1;
	nlen[l0]=h3;

	//recalc height of root node
	l1=nodes[root*2+0];
	l2=nodes[root*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	return(h0);
}

void PDJHUFF_CalcLengths_r(short *nodes, byte *cl, int root, int h)
{
	if(root<0)
	{
		if(root==-513)return;
		cl[(-root)-1]=h;
		return;
	}

	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+0], h+1);
	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+1], h+1);
}

int PDJHUFF_BuildLengths(int *stat, int nc, byte *cl, int ml)
{
	static short nodes[1024], nlen[512];
	static short roots[512], clen[512];
	static int cnts[512];
	int nr, nn;
	int i, j, k, l;

	nr=0; nn=0;
	for(i=0; i<nc; i++)
	{
		if(!stat[i])continue;
		roots[nr]=-(i+1);
		cnts[nr]=stat[i];
		clen[nr]=0;
		nr++;
	}

	roots[nr]=-513;
	cnts[nr]=0;
	clen[nr]=0;
	nr++;


	for(i=0; i<nc; i++)cl[i]=0;
	if(!nr)return(-1);


	while(nr>1)
	{
		if(cnts[0]>=cnts[1]) { j=0; k=1; }
			else { j=1; k=0; }
		for(i=2; i<nr; i++)
		{
			if(cnts[i]<=cnts[k])
			{
				j=k; k=i;
				continue;
			}
			if(cnts[i]<=cnts[j])
			{
				j=i;
				continue;
			}
		}

		nlen[nn]=((clen[j]>clen[k])?clen[j]:clen[k])+1;
		nodes[nn*2+0]=roots[j];
		nodes[nn*2+1]=roots[k];

		roots[nr]=nn;
		cnts[nr]=cnts[j]+cnts[k];
		clen[nr]=nlen[nn];

//		printf("%d %d %d\n", cnts[j], cnts[k], cnts[nr]);

		nn++; nr++;

		l=0;
		for(i=0; i<nr; i++)
		{
			if((i==j) || (i==k))continue;
			roots[l]=roots[i];
			cnts[l]=cnts[i];
			clen[l]=clen[i];
			l++;
		}
		nr=l;
	}

	l=roots[0];
	j=clen[0];
	k=j;

	i=4;
	while((i--) && (k>ml))
		k=PDJHUFF_BalanceTree_r(nodes, nlen, l, 0, ml);
	if(k>ml)return(-2);	//failed to balance tree

	PDJHUFF_CalcLengths_r(nodes, cl, l, 0);
	return(0);
}


void PDJHUFF_EncodeSymbol(int tab, int v)
{
	tab<<=8;
	PDJHUFF_WriteNBits(pdjhuff_code[tab|v], pdjhuff_len[tab|v]);
}

void PDJHUFF_EncodeVal(int tab, int z, int v)
{
	int i, j, k;

	if(!v) { PDJHUFF_EncodeSymbol(tab, z<<4); return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		PDJHUFF_EncodeSymbol(tab, (z<<4)|i);
		PDJHUFF_WriteNBits(v, i);
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	PDJHUFF_EncodeSymbol(tab, (z<<4)|i);

	k=(1<<i)-(j+1);
	PDJHUFF_WriteNBits(k, i);
	return;
}

void PDJHUFF_StatVal(int *stat, int z, int v)
{
	int i, j, k;

	if(!v) { stat[z<<4]++; return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		stat[(z<<4)|i]++;
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	stat[(z<<4)|i]++;
}

int PDJHUFF_EncodeBlock(short *buf, int dctab, int actab)
{
	int i, j, k;

	PDJHUFF_EncodeVal(dctab, 0, buf[0]);

	for(i=1; i<64; i++)
	{
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			PDJHUFF_EncodeSymbol(actab, 0);
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_EncodeVal(actab, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
}


int PDJHUFF_StatBlock(short *buf, int *dcstat, int *acstat)
{
	int i, j, k;

	PDJHUFF_StatVal(dcstat, 0, buf[0]);
	for(i=1; i<64; i++)
	{
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			acstat[0]++;
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_StatVal(acstat, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
}

int PDJPG_GetImgBlk(char *blk, int xo, int yo, byte *img, int xs, int ys)
{
	int i, j, k;

	for(i=0; i<DCTSZ; i++)for(j=0; j<DCTSZ; j++)
	{
		k=img[(i+yo)*xs+(j+xo)];
//		blk[i*DCTSZ+j]=k-128;
		blk[i*DCTSZ+j]=k;
	}
}

int PDJPG_FilterImageDCT(byte *ibuf, short *obuf, int xs, int ys)
{
	static short tblk[DCTSZ2], tblk2[DCTSZ2];
	static char blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
		PDJPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_TransDCT(blk, obuf+k*DCTSZ2);
		k++;
	}
}

void PDJPG_EmitDQT(int n)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DQT;

	i=64+3;
	*pdjhuff_ct++=i>>8;
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=n;
	for(i=0; i<64; i++)
		*pdjhuff_ct++=pdjpg_qt[n][pdjpg_zigzag2[i]];
}

void PDJPG_EmitSOF(int xs, int ys)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOF0;

	i=8+(pdjpg_mono?1:3)*3;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=8; 	//P

	*pdjhuff_ct++=ys>>8;	//Y
	*pdjhuff_ct++=ys&0xFF;	//Y
	*pdjhuff_ct++=xs>>8;	//X
	*pdjhuff_ct++=xs&0xFF;	//X

	if(pdjpg_mono)
	{
		*pdjhuff_ct++=1;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
	}else
	{
		*pdjhuff_ct++=3;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x22;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
		*pdjhuff_ct++=2;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
		*pdjhuff_ct++=3;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
	}
}

void PDJPG_EmitSOS()
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOS;

	i=6+(pdjpg_mono?1:3)*2;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	if(!pdjpg_mono)
	{
		*pdjhuff_ct++=3; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else
	{
		*pdjhuff_ct++=1; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
	}

	*pdjhuff_ct++=0; 	//Ss
	*pdjhuff_ct++=63; 	//Se
	*pdjhuff_ct++=0x00; 	//Ah Al
}

void PDJPG_EmitDHT(int tab)
{
	byte *p;
	int i, j, k;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DHT;

//	i=8+3*1;
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	i=(tab/2)|((tab&1)<<4);
	*pdjhuff_ct++=i; 	//Tc Th

	tab<<=8;
	for(i=1; i<=16; i++)
	{
		k=0;
		for(j=0; j<256; j++)
			if(pdjhuff_len[tab|j]==i)
				k++;
		*pdjhuff_ct++=k; 	//Li
	}

	k=0;
	for(i=1; i<=16; i++)
	{
		k<<=1;
		for(j=0; j<256; j++)
			if(pdjhuff_len[tab|j]==i)
		{
			*pdjhuff_ct++=j; 	//Vi
			pdjhuff_code[tab|j]=k++;
		}
	}

//	printf("DHT %04X\n", k);

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void PDJPG_MakeQuantTabInput(short *in, int cnt, byte *tab, float q)
{
	static double deltas[DCTSZ2];
	double f, g, te;
	int i, j, k;

	for(j=0; j<DCTSZ2; j++)
		deltas[j]=0;

	for(i=0; i<cnt; i++)
		for(j=0; j<DCTSZ2; j++)
			deltas[j]+=fabs(in[i*DCTSZ2+j]);
	for(j=0; j<DCTSZ2; j++)
		deltas[j]/=cnt;

	te=0;
	for(j=0; j<DCTSZ2; j++)
		te+=deltas[j];

	for(i=0; i<DCTSZ; i++)
	{
		for(j=0; j<DCTSZ; j++)
		{
			f=deltas[i*DCTSZ+j];

			f=f/te;
			if(f<0.00001)f=0.00001;
			g=(1.0-q);
			f=10*g*g*g/f;
			k=f;
			if(k<1)k=1;
			if(k>255)k=255;

//			printf("%f/%f %d\n", deltas[i*DCTSZ+j], te, k);

//			if(f<1)f=1;
//			if(f>255)f=255;
			tab[i*DCTSZ+j]=k;
		}
	}

#if 1
	if(tab[DCTSZ2-3]>1)tab[DCTSZ2-3]*=0.75;
	if(tab[DCTSZ2-2]>1)tab[DCTSZ2-2]*=0.75;
	if(tab[DCTSZ2-1]>1)tab[DCTSZ2-1]*=0.5;
#endif
}

PDGL_API int PDJPG_Encode(byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	static byte *yb=NULL, *ub, *vb;
	static short *ydb=NULL, *udb, *vdb;
	static int lxs=0, lys=0;

	static int dcs[256], acs[256];
	static int dcsuv[256], acsuv[256];
	short *tp;
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
//	xs3=(xs2+1)/2;
//	ys3=(ys2+1)/2;

	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	pdjpg_mono=0;

	//full quality
	for(i=0; i<64; i++)pdjpg_qt[0][i]=1;
	for(i=0; i<64; i++)pdjpg_qt[1][i]=1;

	//dummy huffman tables
	for(i=0; i<256; i++)pdjhuff_len[0*256+i]=0;
	for(i=0; i<256; i++)pdjhuff_len[1*256+i]=0;
	for(i=0; i<256; i++)pdjhuff_len[2*256+i]=0;
	for(i=0; i<256; i++)pdjhuff_len[3*256+i]=0;

	for(i=0; i<16; i++)pdjhuff_len[0*256+i]=4;
	for(i=0; i<16; i++)pdjhuff_len[2*256+i]=4;
	for(i=0; i<255; i++)pdjhuff_len[1*256+i]=8;
	for(i=0; i<255; i++)pdjhuff_len[3*256+i]=8;

//	for(i=0; i<255; i++)pdjhuff_len[0*256+i]=8;
//	for(i=0; i<255; i++)pdjhuff_len[2*256+i]=8;


//	pdjhuff_len[1*256+0]=7;

//	printf("M0\n");

	if(!yb || (xs!=lxs) || (ys!=lys))
	{
		if(yb)
		{
			free(yb);
			free(ub);
			free(vb);
			free(ydb);
			free(udb);
			free(vdb);
		}

		yb=malloc(xs2*ys2);
		ub=malloc(xs2*ys2);
		vb=malloc(xs2*ys2);

		ydb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		lxs=xs;
		lys=ys;
	}


	memset(yb, 128, xs2*ys2);
	memset(ub, 128, xs2*ys2);
	memset(vb, 128, xs2*ys2);

	memset(ydb, 0, xs2*(ys2+8)*sizeof(short));
	memset(udb, 0, xs3*(ys3+8)*sizeof(short));
	memset(vdb, 0, xs3*(ys3+8)*sizeof(short));

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];

		cy=0.299*cr	+0.587*cg	+0.114*cb;
		cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
		cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;

//		cu=128; cv=128;

		cy=(cy<0)?0:((cy>255)?255:cy);
		cu=(cu<0)?0:((cu>255)?255:cu);
		cv=(cv<0)?0:((cv>255)?255:cv);

		yb[i*xs2+j]=cy; ub[i*xs2+j]=cu; vb[i*xs2+j]=cv;
	}

	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		k=ub[(i*2)*xs2+j*2]+
			ub[(i*2)*xs2+j*2+1]+
			ub[(i*2+1)*xs2+j*2]+
			ub[(i*2+1)*xs2+j*2+1];
		ub[i*xs3+j]=k/4;

		k=vb[(i*2)*xs2+j*2]+
			vb[(i*2)*xs2+j*2+1]+
			vb[(i*2+1)*xs2+j*2]+
			vb[(i*2+1)*xs2+j*2+1];
		vb[i*xs3+j]=k/4;
	}

//	printf("M1\n");


	PDJPG_FilterImageDCT(yb, ydb, xs2, ys2);
	PDJPG_FilterImageDCT(ub, udb, xs3, ys3);
	PDJPG_FilterImageDCT(vb, vdb, xs3, ys3);

	j=(xs2/8)*(ys2/8);
	PDJPG_MakeQuantTabInput(ydb, j, pdjpg_qt[0], qf/100.0);

	j=(xs3/8)*(ys3/8);
	PDJPG_MakeQuantTabInput(udb, j, pdjpg_qt[1], qf/100.0);
	PDJPG_MakeQuantTabInput(vdb, j, pdjpg_qt[2], qf/100.0);
	for(i=0; i<64; i++)pdjpg_qt[1][i]=(pdjpg_qt[1][i]+pdjpg_qt[2][i])/2;

//	free(yb);
//	free(ub);
//	free(vb);


	if(pdjpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ydb+i*64, ydb+i*64, 0);
			ydb[i*64+0]-=k; k=ydb[i*64+0]+k;
		}
	}

	if(!pdjpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(udb+i*64, udb+i*64, 1);
		PDJHUFF_QuantBlock(vdb+i*64, vdb+i*64, 1);
		udb[i*64+0]-=k; k=udb[i*64+0]+k;
		vdb[i*64+0]-=l; l=vdb[i*64+0]+l;
	}

//	printf("M2\n");

	for(i=0; i<256; i++)dcs[i]=0;
	for(i=0; i<256; i++)acs[i]=0;
	for(i=0; i<256; i++)dcsuv[i]=0;
	for(i=0; i<256; i++)acsuv[i]=0;

	j=(xs2/8)*(ys2/8);
	k=(xs3/8)*(ys3/8);
	for(i=0; i<j; i++)PDJHUFF_StatBlock(ydb+i*64, dcs, acs);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(udb+i*64, dcsuv, acsuv);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(vdb+i*64, dcsuv, acsuv);

	PDJHUFF_BuildLengths(dcs, 256, pdjhuff_len+0*256, 16);
	PDJHUFF_BuildLengths(acs, 256, pdjhuff_len+1*256, 16);
	PDJHUFF_BuildLengths(dcsuv, 256, pdjhuff_len+2*256, 16);
	PDJHUFF_BuildLengths(acsuv, 256, pdjhuff_len+3*256, 16);

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	PDJPG_EmitDQT(0);
	if(!pdjpg_mono)PDJPG_EmitDQT(1);

	PDJPG_EmitSOF(xs, ys);

	PDJPG_EmitDHT(0);
	PDJPG_EmitDHT(1);
	if(!pdjpg_mono)
	{
		PDJPG_EmitDHT(2);
		PDJPG_EmitDHT(3);
	}

	PDJPG_EmitSOS();

	if(pdjpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=((ys3)/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(vdb+k*64, 2, 3);
		}
	}

	PDJHUFF_FlushBits();

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

//	free(ydb);
//	free(udb);
//	free(vdb);

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}


PDGL_API int PDJPG_EncodeFast(byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	static byte *yb=NULL, *ub, *vb;
	static short *ydb=NULL, *udb, *vdb;
	static int lxs=0, lys=0;

	static int dcs[256], acs[256];
	static int dcsuv[256], acsuv[256];
	short *tp;
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	pdjpg_mono=0;

	//full quality
	for(i=0; i<64; i++)pdjpg_qt[0][i]=1;
	for(i=0; i<64; i++)pdjpg_qt[1][i]=1;


	if(!yb || (xs!=lxs) || (ys!=lys))
	{
		if(yb)
		{
			free(yb);
			free(ub);
			free(vb);
			free(ydb);
			free(udb);
			free(vdb);
		}

		yb=malloc(xs2*ys2);
		ub=malloc(xs2*ys2);
		vb=malloc(xs2*ys2);

		ydb=malloc((xs2+8)*(ys2+16)*sizeof(short));
		udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		lxs=xs;
		lys=ys;
	}


	memset(yb, 128, xs2*ys2);
	memset(ub, 128, xs2*ys2);
	memset(vb, 128, xs2*ys2);

	memset(ydb, 0, xs2*(ys2+8)*sizeof(short));
	memset(udb, 0, xs3*(ys3+8)*sizeof(short));
	memset(vdb, 0, xs3*(ys3+8)*sizeof(short));

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];

//		cy=0.299*cr	+0.587*cg	+0.114*cb;
//		cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
//		cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;

//		cu=128; cv=128;

//		cy=(cy<0)?0:((cy>255)?255:cy);
//		cu=(cu<0)?0:((cu>255)?255:cu);
//		cv=(cv<0)?0:((cv>255)?255:cv);

		cy= 76*cr +150*cg + 29*cb;
		cu=-43*cr - 84*cg +128*cb;
		cv=128*cr -107*cg - 20*cb;
		cy>>=8; cu=(cu>>8)+128; cv=(cv>>8)+128;

		yb[i*xs2+j]=cy; ub[i*xs2+j]=cu; vb[i*xs2+j]=cv;
	}

#if 1
	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		k=ub[(i*2)*xs2+j*2]+
			ub[(i*2)*xs2+j*2+1]+
			ub[(i*2+1)*xs2+j*2]+
			ub[(i*2+1)*xs2+j*2+1];
		ub[i*xs3+j]=k/4;

		k=vb[(i*2)*xs2+j*2]+
			vb[(i*2)*xs2+j*2+1]+
			vb[(i*2+1)*xs2+j*2]+
			vb[(i*2+1)*xs2+j*2+1];
		vb[i*xs3+j]=k/4;
	}
#endif

#if 0
	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		ub[i*xs3+j]=ub[(i*2)*xs2+j*2];
		vb[i*xs3+j]=vb[(i*2)*xs2+j*2];
	}
#endif


	PDJPG_FilterImageDCT(yb, ydb, xs2, ys2);
	PDJPG_FilterImageDCT(ub, udb, xs3, ys3);
	PDJPG_FilterImageDCT(vb, vdb, xs3, ys3);

	j=(xs2/8)*(ys2/8);
	PDJPG_MakeQuantTabInput(ydb, j, pdjpg_qt[0], qf/100.0);

	j=(xs3/8)*(ys3/8);
	PDJPG_MakeQuantTabInput(udb, j, pdjpg_qt[1], qf/100.0);
	PDJPG_MakeQuantTabInput(vdb, j, pdjpg_qt[2], qf/100.0);
	for(i=0; i<64; i++)pdjpg_qt[1][i]=(pdjpg_qt[1][i]+pdjpg_qt[2][i])/2;

//	free(yb);
//	free(ub);
//	free(vb);


	if(pdjpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ydb+i*64, ydb+i*64, 0);
			ydb[i*64+0]-=k; k=ydb[i*64+0]+k;
		}
	}

	if(!pdjpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(udb+i*64, udb+i*64, 1);
		PDJHUFF_QuantBlock(vdb+i*64, vdb+i*64, 1);
		udb[i*64+0]-=k; k=udb[i*64+0]+k;
		vdb[i*64+0]-=l; l=vdb[i*64+0]+l;
	}

//	printf("M2\n");

	for(i=0; i<256; i++)dcs[i]=0;
	for(i=0; i<256; i++)acs[i]=0;
	for(i=0; i<256; i++)dcsuv[i]=0;
	for(i=0; i<256; i++)acsuv[i]=0;

	j=(xs2/8)*(ys2/8);
	k=(xs3/8)*(ys3/8);
	for(i=0; i<j; i++)PDJHUFF_StatBlock(ydb+i*64, dcs, acs);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(udb+i*64, dcsuv, acsuv);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(vdb+i*64, dcsuv, acsuv);

	PDJHUFF_BuildLengths(dcs, 256, pdjhuff_len+0*256, 16);
	PDJHUFF_BuildLengths(acs, 256, pdjhuff_len+1*256, 16);
	PDJHUFF_BuildLengths(dcsuv, 256, pdjhuff_len+2*256, 16);
	PDJHUFF_BuildLengths(acsuv, 256, pdjhuff_len+3*256, 16);

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	PDJPG_EmitDQT(0);
	if(!pdjpg_mono)PDJPG_EmitDQT(1);

	PDJPG_EmitSOF(xs, ys);

	PDJPG_EmitDHT(0);
	PDJPG_EmitDHT(1);
	if(!pdjpg_mono)
	{
		PDJPG_EmitDHT(2);
		PDJPG_EmitDHT(3);
	}

	PDJPG_EmitSOS();

	if(pdjpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=((ys3)/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(vdb+k*64, 2, 3);
		}
	}

	PDJHUFF_FlushBits();

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

//	free(ydb);
//	free(udb);
//	free(vdb);

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

#if 1
PDGL_API byte *PDJPG_Load(VFILE *fd, int *xs, int *ys)
{
	byte *buf, *obuf;
	int fsz;

	vfseek(fd, 0, 2);
	fsz=vftell(fd);
	vfseek(fd, 0, 0);

	buf=malloc(fsz+256);
	vfread(buf, 1, fsz, fd);

	obuf=PDJPG_Decode(buf, fsz, xs, ys);
	free(buf);

	return(obuf);
}

PDGL_API int PDJPG_Store(VFILE *fd, byte *ibuf, int xs, int ys, int qf)
{
	static byte *buf=NULL;
	int fsz;

	if(!buf)buf=malloc(1<<22);

	fsz=PDJPG_Encode(ibuf, buf, xs, ys, qf);
	if(fsz<0)return(fsz);

	vfwrite(buf, 1, fsz, fd);
//	free(buf);

	return(0);
}
#endif

#if 0
byte *PDJPG_ReadImg(FILE *fd, int *xs, int *ys)
{
	byte *buf, *obuf;
	int fsz;

	printf("RM0\n");

	fseek(fd, 0, 2);
	fsz=ftell(fd);
	fseek(fd, 0, 0);

	printf("RM1\n");

	buf=malloc(2*fsz);
	fread(buf, 1, fsz, fd);

	obuf=PDJPG_Decode(buf, fsz, xs, ys);

	printf("RM2\n");

	free(buf);

	return(obuf);
}

int main(int argc, char *argv[])
{
	byte *ibuf, *obuf;
	char *s;
	FILE *fd;
	int w, h, n, fsz;
	int i, j, k, l;

	s=argv[1];
	s+=strlen(s);
	while((s>argv[1]) && (*s!='.'))s--;

	if(!strcmp(s, ".tga"))
	{
		fd=fopen(argv[1], "rb");
		if(!fd)
		{
			printf("Fail Open Input\n");
			return(-1);
		}

		ibuf=Img_LoadTGA(fd, &w, &h);
		fclose(fd);

		obuf=malloc(1<<22);
		fsz=PDJPG_Encode(ibuf, obuf, w, h, 75);

		fd=fopen(argv[2], "wb");
		if(!fd)
		{
			printf("Fail Open Output\n");
			return(-1);
		}

		fwrite(obuf, 1, fsz, fd);
		fclose(fd);
	}

	if(!strcmp(s, ".jpg"))
	{
		fd=fopen(argv[1], "rb");
		if(!fd)
		{
			printf("Fail Open Input\n");
			return(-1);
		}

		obuf=PDJPG_ReadImg(fd, &w, &h);
		fclose(fd);

		printf("RM3\n");

		fd=fopen(argv[2], "wb");
		if(!fd)
		{
			printf("Fail Open Output\n");
			return(-1);
		}

		Img_StoreTGA(fd, obuf, w, h);
		fclose(fd);
	}
}
#endif
/*
BGB Extensions:
APP11: BGBTech Tag
	FF,APP11,xx,xx,<ASCIZ TagName>, ...
	Tag-specific data until next marker.
	
	"AlphaColor":
		AlphaColor
		RGBA as string ("red green blue alpha").
		
		Specifies a "Alpha Color" extension, where any color sufficiently
		close to the given color (determined by 'alpha'), will be assumed
		to be a transparent pixel. These values are given in decimal.

	APP11 markers may indicate component layer:
		FF,APP11,xx,xx,"CompLayer\0", <layername:ASCIZ>
			"RGB": Base RGB
			"XYZ": Normal XYZ
			"SpRGB": Specular RGB
			"DASe": Depth, Alpha, Specular-Exponent
			"LuRGB": Luma RGB
			"Alpha": Mono alpha layer

	Component Layouts:
		3 component: (no marker, RGB)
		4 component: RGB+Alpha
		7 component: RGB+Alpha+LuRGB
		8 component: RGB+XYZ+DASe
		12 component: RGB+XYZ+SpRGB+DASe
		16 component: RGB+XYZ+SpRGB+DASe+LuRGB

	The APP11 tag for a layer will be followed by the layer
	(as a JPEG image), which may be placed within LDAT tags.
	
	Images lacking DHT and DQT will reuse those from the base image.

APP12: BGBTech Tag 2
	FF,APP12,xx,xx,tt,tt,tt,tt
		tt=FOURCC Tag.

	'LDAT': Layer Data.
	Gives an image/layer spread across a span of 'LDAT' tags.
	The encoded image will be split linearly across the tags.

APP11,"TagLayer":
	Allows giving a layer name to a collection of component layers.
	All images within a tag-layer will need to be the same resolution.
	Different taglayers may have different resolutions.
	
FF B0: DVFH, Define Video Frame Header
	FF B0 xx xx
	TfTd HmMt Lid ... 

	Tf = 4-bit frame-type (0=I-Frame, 1=P-Frame, 2-15=Reserved)
	Td = 4-bit delta type (0=None, 1=Subtract I-Frame YCbCr, 2-15=Reserved)
	Hm = Huffman table for motion vectors.
	Mt = Motion Vector Type (0=Default, 1=15=Reserved)
	Lid = 8-bit layer ID.

The layer ID will specify the layer used for motion compensation.
A P-Frame will refer to the last I-Frame with the same layer-ID, which will need to have both the same resolution and image-layout.

FF B1: SOMV, Start Of Motion Vectors

	Motion Vectors:
	Huffman coded values: ZcBc
	Zc = zero count
	Bc = bit-count 
*/

#include <bgbbtj.h>

//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>

#include <math.h>

#ifndef PDGL_API
#define PDGL_API
#endif

#define DCTSZ	8
#define DCTSZ2	64

//typedef unsigned char byte;
//typedef unsigned short ushort;
//typedef unsigned int uint;

#define JPG_SOF0	0xC0
#define JPG_SOF1	0xC1
#define JPG_SOF2	0xC2
#define JPG_SOF3	0xC3
#define JPG_DHT		0xC4
#define JPG_SOF5	0xC5
#define JPG_SOF6	0xC6
#define JPG_SOF7	0xC7
#define JPG_JPG		0xC8
#define JPG_SOF9	0xC9
#define JPG_SOF10	0xCA
#define JPG_SOF11	0xCB
#define JPG_DAC		0xCC
#define JPG_SOF13	0xCD
#define JPG_SOF14	0xCE
#define JPG_SOF15	0xCF

#define JPG_RST0	0xD0
#define JPG_RST1	0xD1
#define JPG_RST2	0xD2
#define JPG_RST3	0xD3
#define JPG_RST4	0xD4
#define JPG_RST5	0xD5
#define JPG_RST6	0xD6
#define JPG_RST7	0xD7

#define JPG_SOI		0xD8
#define JPG_EOI		0xD9
#define JPG_SOS		0xDA
#define JPG_DQT		0xDB
#define JPG_DNL		0xDC
#define JPG_DRI		0xDD
#define JPG_DHP		0xDE
#define JPG_EXP		0xDF

#define JPG_APP0	0xE0
#define JPG_APP1	0xE1
#define JPG_APP2	0xE2
#define JPG_APP3	0xE3
#define JPG_APP4	0xE4
#define JPG_APP5	0xE5
#define JPG_APP6	0xE6
#define JPG_APP7	0xE7
#define JPG_APP8	0xE8
#define JPG_APP9	0xE9
#define JPG_APP10	0xEA
#define JPG_APP11	0xEB
#define JPG_APP12	0xEC
#define JPG_APP13	0xED
#define JPG_APP14	0xEE
#define JPG_APP15	0xEF

#define JPG_JPG0	0xF0
#define JPG_JPG1	0xF1
#define JPG_JPG2	0xF2
#define JPG_JPG3	0xF3
#define JPG_JPG4	0xF4
#define JPG_JPG5	0xF5
#define JPG_JPG6	0xF6
#define JPG_JPG7	0xF7
#define JPG_JPG8	0xF8
#define JPG_JPG9	0xF9
#define JPG_JPG10	0xFA
#define JPG_JPG11	0xFB
#define JPG_JPG12	0xFC
#define JPG_JPG13	0xFD
#define JPG_COM		0xFE

static const char *pdjpg_marker[]={
"SOF0", "SOF1", "SOF2", "SOF3", "DHT", "SOF5", "SOF6", "SOF7",
"JPG", "SOF9", "SOF10", "SOF11", "DAC", "SOF13", "SOF14", "SOF15",
"RST0", "RST1", "RST2", "RST3", "RST4", "RST5", "RST6", "RST7",
"SOI", "EOI", "SOS", "DQT", "DNL", "DRI", "DHP", "EXP",
"APP0", "APP1", "APP2", "APP3", "APP4", "APP5", "APP6", "APP7", 
"APP8", "APP9", "APP10", "APP11", "APP12", "APP13", "APP14", "APP15", 
"JPG0", "JPG1", "JPG2", "JPG3", "JPG4", "JPG5", "JPG6", "JPG7", 
"JPG8", "JPG9", "JPG10", "JPG11", "JPG12", "JPG13", "COM", ""
};

static const int pdjpg_zigzag[64]={
 0,  1,  5,  6, 14, 15, 27, 28,
 2,  4,  7, 13, 16, 26, 29, 42,
 3,  8, 12, 17, 25, 30, 41, 43,
 9, 11, 18, 24, 31, 40, 44, 53,
10, 19, 23, 32, 39, 45, 52, 54,
20, 22, 33, 38, 46, 51, 55, 60,
21, 34, 37, 47, 50, 56, 59, 61,
35, 36, 48, 49, 57, 58, 62, 63
};

static const int pdjpg_zigzag2[64]={
 0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63
};

static float pdjpg_exptab[256];
static float pdjpg_scltab[256];

#if 0
byte *pdjhuff_cs;	//current pos in bitstream (input)
byte *pdjhuff_ct;	//current pos in bitstream (output)
uint pdjhuff_win;	//bitstream window
int pdjhuff_pos;	//bitstream offset
int pdjhuff_isend;	//bitstream has broken (decoder)
#endif

#if 1
#define pdjhuff_cs		ctx->huff_cs
#define pdjhuff_ct		ctx->huff_ct
#define pdjhuff_win		ctx->huff_win
#define pdjhuff_pos		ctx->huff_pos
#define pdjhuff_isend	ctx->huff_isend
#endif


PDGL_API PDJPG_Context *PDJPG_AllocContext();
PDGL_API void PDJPG_FreeContext(PDJPG_Context *ctx);
PDGL_API void PDJPG_SetContextAlphaColor(PDJPG_Context *ctx,
	int cr, int cg, int cb, int ca);

//Common

void PDJPG_Init()
{
	static int init=0;
	int i, j;
	float f, g;

	if(init)return;
	init=1;

	for(i=0; i<64; i++)
	{
		f=(i*i)/240.0;
		g=pow(2, f);
//		printf("%d %f %f %f\n", i, f, g, 1/g);
			
		pdjpg_exptab[192+i]=f;
		pdjpg_exptab[192-i]=-f;
		pdjpg_exptab[63+i]=-f;
		pdjpg_exptab[63-i]=f;
			
		pdjpg_scltab[192+i]=g;
		pdjpg_scltab[192-i]=1.0/g;
		pdjpg_scltab[63+i]=-1.0/g;
		pdjpg_scltab[63-i]=-g;
	}

	for(i=0; i<18; i++)
	{
		j=sqrt(i*240)+0.5;
//		printf("%d %d %d %d %d %d\n", i, j,
//			192+j, 192-j, 63-j, 63+j);

		if(j>63)continue;

		g=pow(2, i);

		pdjpg_exptab[192+j]=i;
		pdjpg_exptab[192-j]=-i;
		pdjpg_exptab[63+j]=-i;
		pdjpg_exptab[63-j]=i;

		pdjpg_scltab[192+j]=g;
		pdjpg_scltab[192-j]=1.0/g;
		pdjpg_scltab[63+j]=-1.0/g;
		pdjpg_scltab[63-j]=-g;
	}
		
//	exptab[128]=0;

#if 0
	for(i=0; i<(256/2); i++)
	{
		for(j=0; j<2; j++)
		{
			sprintf(tb, "% 3d: %.4f,%.8f", i*2+j,
				exptab[i*2+j], scltab[i*2+j]);
			printf("%-32s ", tb);
		}
		printf("\n");
	}
#endif
}

#if 1
// void PDJPG_TransDCT_Horiz(byte *iblk, int *oblk)
void PDJPG_TransDCT_Horiz(short *iblk, int *oblk, int dcbias)
{
	int ib[8];

//	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
//	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
//	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
//	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	ib[0]=iblk[0]-dcbias;	ib[1]=iblk[1]-dcbias;
	ib[2]=iblk[2]-dcbias;	ib[3]=iblk[3]-dcbias;
	ib[4]=iblk[4]-dcbias;	ib[5]=iblk[5]-dcbias;
	ib[6]=iblk[6]-dcbias;	ib[7]=iblk[7]-dcbias;

	oblk[0]=ib[0]*91  +ib[1]*91  +ib[2]*91  +ib[3]*91  
			+ib[4]*91  +ib[5]*91  +ib[6]*91  +ib[7]*91;
	oblk[1]=ib[0]*126 +ib[1]*106 +ib[2]*71  +ib[3]*25  
			-ib[4]*25  -ib[5]*71  -ib[6]*106 -ib[7]*126;
	oblk[2]=ib[0]*118 +ib[1]*49  -ib[2]*49  -ib[3]*118 
			-ib[4]*118 -ib[5]*49  +ib[6]*49  +ib[7]*118;
	oblk[3]=ib[0]*106 -ib[1]*25  -ib[2]*126 -ib[3]*71  
			+ib[4]*71  +ib[5]*126 +ib[6]*25  -ib[7]*106;
	oblk[4]=ib[0]*91  -ib[1]*91  -ib[2]*91  +ib[3]*91  
			+ib[4]*91  -ib[5]*91  -ib[6]*91  +ib[7]*91;
	oblk[5]=ib[0]*71  -ib[1]*126 +ib[2]*25  +ib[3]*106 
			-ib[4]*106 -ib[5]*25  +ib[6]*126 -ib[7]*71;
	oblk[6]=ib[0]*49  -ib[1]*118 +ib[2]*118 -ib[3]*49  
			-ib[4]*49  +ib[5]*118 -ib[6]*118 +ib[7]*49;
	oblk[7]=ib[0]*25  -ib[1]*71  +ib[2]*106 -ib[3]*126 
			+ib[4]*126 -ib[5]*106 +ib[6]*71  -ib[7]*25;
}

void PDJPG_TransDCT_Vert(int *iblk, int *oblk)
{
	oblk[ 0]=iblk[0]*91  +iblk[8]*91  
			+iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  +iblk[40]*91  
			+iblk[48]*91  +iblk[56]*91;
	oblk[ 8]=iblk[0]*126 +iblk[8]*106 
			+iblk[16]*71  +iblk[24]*25  
			-iblk[32]*25  -iblk[40]*71  
			-iblk[48]*106 -iblk[56]*126;
	oblk[16]=iblk[0]*118 +iblk[8]*49  
			-iblk[16]*49  -iblk[24]*118 
			-iblk[32]*118 -iblk[40]*49  
			+iblk[48]*49  +iblk[56]*118;
	oblk[24]=iblk[0]*106 -iblk[8]*25  
			-iblk[16]*126 -iblk[24]*71  
			+iblk[32]*71  +iblk[40]*126 
			+iblk[48]*25  -iblk[56]*106;
	oblk[32]=iblk[0]*91  -iblk[8]*91  
			-iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  -iblk[40]*91  
			-iblk[48]*91  +iblk[56]*91;
	oblk[40]=iblk[0]*71  -iblk[8]*126 
			+iblk[16]*25  +iblk[24]*106
			-iblk[32]*106 -iblk[40]*25  
			+iblk[48]*126 -iblk[56]*71;
	oblk[48]=iblk[0]*49  -iblk[8]*118
			+iblk[16]*118 -iblk[24]*49  
			-iblk[32]*49  +iblk[40]*118 
			-iblk[48]*118 +iblk[56]*49;
	oblk[56]=iblk[0]*25  -iblk[8]*71  
			+iblk[16]*106 -iblk[24]*126 
			+iblk[32]*126 -iblk[40]*106 
			+iblk[48]*71  -iblk[56]*25;
}

// void PDJPG_TransDCT(byte *iblk, short *oblk)
void PDJPG_TransDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransDCT_Horiz(iblk+0, s+0, dcbias);
	PDJPG_TransDCT_Horiz(iblk+8, s+8, dcbias);
	PDJPG_TransDCT_Horiz(iblk+16, s+16, dcbias);
	PDJPG_TransDCT_Horiz(iblk+24, s+24, dcbias);
	PDJPG_TransDCT_Horiz(iblk+32, s+32, dcbias);
	PDJPG_TransDCT_Horiz(iblk+40, s+40, dcbias);
	PDJPG_TransDCT_Horiz(iblk+48, s+48, dcbias);
	PDJPG_TransDCT_Horiz(iblk+56, s+56, dcbias);

	PDJPG_TransDCT_Vert(s+0, t+0);
	PDJPG_TransDCT_Vert(s+1, t+1);
	PDJPG_TransDCT_Vert(s+2, t+2);
	PDJPG_TransDCT_Vert(s+3, t+3);
	PDJPG_TransDCT_Vert(s+4, t+4);
	PDJPG_TransDCT_Vert(s+5, t+5);
	PDJPG_TransDCT_Vert(s+6, t+6);
	PDJPG_TransDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i]>>16;
}

#endif

#if 1
void PDJPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[0]* 91;	b=iblk[4]* 91;
	c=iblk[2]*118;	d=iblk[2]* 49;
	e=iblk[6]*118;	f=iblk[6]* 49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[1]*126+iblk[3]*106+iblk[5]* 71+iblk[7]* 25;
	n=iblk[1]*106-iblk[3]* 25-iblk[5]*126-iblk[7]* 71;
	o=iblk[1]* 71-iblk[3]*126+iblk[5]* 25+iblk[7]*106;
	p=iblk[1]* 25-iblk[3]* 71+iblk[5]*106-iblk[7]*126;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
}

void PDJPG_TransIDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]* 91;	b=iblk[32]*91;
	c=iblk[16]*118;	d=iblk[16]*49;
	e=iblk[48]*118;	f=iblk[48]*49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[8]*126+iblk[24]*106+iblk[40]* 71+iblk[56]* 25;
	n=iblk[8]*106-iblk[24]* 25-iblk[40]*126-iblk[56]* 71;
	o=iblk[8]* 71-iblk[24]*126+iblk[40]* 25+iblk[56]*106;
	p=iblk[8]* 25-iblk[24]* 71+iblk[40]*106-iblk[56]*126;
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

// void PDJPG_TransIDCT(short *iblk, byte *oblk)
void PDJPG_TransIDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIDCT_Horiz(iblk+0, s+0);
	PDJPG_TransIDCT_Horiz(iblk+8, s+8);
	PDJPG_TransIDCT_Horiz(iblk+16, s+16);
	PDJPG_TransIDCT_Horiz(iblk+24, s+24);
	PDJPG_TransIDCT_Horiz(iblk+32, s+32);
	PDJPG_TransIDCT_Horiz(iblk+40, s+40);
	PDJPG_TransIDCT_Horiz(iblk+48, s+48);
	PDJPG_TransIDCT_Horiz(iblk+56, s+56);

	PDJPG_TransIDCT_Vert(s+0, t+0);
	PDJPG_TransIDCT_Vert(s+1, t+1);
	PDJPG_TransIDCT_Vert(s+2, t+2);
	PDJPG_TransIDCT_Vert(s+3, t+3);
	PDJPG_TransIDCT_Vert(s+4, t+4);
	PDJPG_TransIDCT_Vert(s+5, t+5);
	PDJPG_TransIDCT_Vert(s+6, t+6);
	PDJPG_TransIDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=(t[i]>>16)+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
//		oblk[i]=(j<0)?0:((j>255)?255:j);
	}
}

void PDJPG_TransIDCT16(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIDCT_Horiz(iblk+0, s+0);
	PDJPG_TransIDCT_Horiz(iblk+8, s+8);
	PDJPG_TransIDCT_Horiz(iblk+16, s+16);
	PDJPG_TransIDCT_Horiz(iblk+24, s+24);
	PDJPG_TransIDCT_Horiz(iblk+32, s+32);
	PDJPG_TransIDCT_Horiz(iblk+40, s+40);
	PDJPG_TransIDCT_Horiz(iblk+48, s+48);
	PDJPG_TransIDCT_Horiz(iblk+56, s+56);

	for(i=0; i<DCTSZ2; i++)
		s[i]>>=4;

	PDJPG_TransIDCT_Vert(s+0, t+0);
	PDJPG_TransIDCT_Vert(s+1, t+1);
	PDJPG_TransIDCT_Vert(s+2, t+2);
	PDJPG_TransIDCT_Vert(s+3, t+3);
	PDJPG_TransIDCT_Vert(s+4, t+4);
	PDJPG_TransIDCT_Vert(s+5, t+5);
	PDJPG_TransIDCT_Vert(s+6, t+6);
	PDJPG_TransIDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=(t[i]>>12)+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
	}
}

#endif

#define FLTOFIX14(x)	((int)((x)*8192+0.5))
#define FIX14TOI(x)	(((x)+4096)>>13)

#if 1
//RDCT: Integer Reversible DCT (Lossless)

// void PDJPG_TransRDCT_Horiz(byte *iblk, int *oblk)
void PDJPG_TransRDCT_Horiz(short *iblk, int *oblk, int dcbias)
{
	int ib[8];

	ib[0]=iblk[2]-dcbias;	ib[1]=iblk[7]-dcbias;
	ib[2]=iblk[4]-dcbias;	ib[3]=iblk[3]-dcbias;
	ib[4]=iblk[6]-dcbias;	ib[5]=iblk[0]-dcbias;
	ib[6]=iblk[1]-dcbias;	ib[7]=iblk[5]-dcbias;

	ib[7]=(-ib[7])+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));
	ib[0]=ib[0]+FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[1]=ib[1]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[2]=ib[2]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[3]=ib[3]+FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[4]=ib[4]+FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[5]=ib[5]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[6]=ib[6]+FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[7]=ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	oblk[0]=ib[3];	oblk[1]=ib[6];
	oblk[2]=ib[4];	oblk[3]=ib[2];
	oblk[4]=ib[5];	oblk[5]=ib[7];
	oblk[6]=ib[0];	oblk[7]=ib[1];
}

void PDJPG_TransRDCT_Vert(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[16];	ib[1]=iblk[56];
	ib[2]=iblk[32];	ib[3]=iblk[24];
	ib[4]=iblk[48];	ib[5]=iblk[ 0];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	ib[7]=(-ib[7])+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));
	ib[0]=ib[0]+FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[1]=ib[1]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[2]=ib[2]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[3]=ib[3]+FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[4]=ib[4]+FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[5]=ib[5]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[6]=ib[6]+FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[7]=ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	oblk[0]=ib[3];	oblk[8]=ib[6];
	oblk[16]=ib[4];	oblk[24]=ib[2];
	oblk[32]=ib[5];	oblk[40]=ib[7];
	oblk[48]=ib[0];	oblk[56]=ib[1];
}

// void PDJPG_TransRDCT(byte *iblk, short *oblk)
void PDJPG_TransRDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransRDCT_Horiz(iblk+0, s+0, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+8, s+8, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+16, s+16, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+24, s+24, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+32, s+32, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+40, s+40, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+48, s+48, dcbias);
	PDJPG_TransRDCT_Horiz(iblk+56, s+56, dcbias);

	PDJPG_TransRDCT_Vert(s+0, t+0);
	PDJPG_TransRDCT_Vert(s+1, t+1);
	PDJPG_TransRDCT_Vert(s+2, t+2);
	PDJPG_TransRDCT_Vert(s+3, t+3);
	PDJPG_TransRDCT_Vert(s+4, t+4);
	PDJPG_TransRDCT_Vert(s+5, t+5);
	PDJPG_TransRDCT_Vert(s+6, t+6);
	PDJPG_TransRDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}
#endif

#if 0
#undef FLTOFIX14
#undef FIX14TOI
#define FLTOFIX14(x)	((int)((x)*16384+0.5))
#define FIX14TOI(x)	(((x)+8192)>>14)
#endif

#if 1
void PDJPG_TransIRDCT_Horiz(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[6];	ib[1]=iblk[7];
	ib[2]=iblk[3];	ib[3]=iblk[0];
	ib[4]=iblk[2];	ib[5]=iblk[4];
	ib[6]=iblk[1];	ib[7]=iblk[5];

	ib[7]=ib[7]-FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	ib[6]=ib[6]-FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[5]=ib[5]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[4]=ib[4]-FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[3]=ib[3]-FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[2]=ib[2]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[1]=ib[1]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[0]=ib[0]-FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[7]=-ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));

	oblk[0]=ib[5];	oblk[1]=ib[6];
	oblk[2]=ib[0];	oblk[3]=ib[3];
	oblk[4]=ib[2];	oblk[5]=ib[7];
	oblk[6]=ib[4];	oblk[7]=ib[1];
}

void PDJPG_TransIRDCT_Vert(short *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[48];	ib[1]=iblk[56];
	ib[2]=iblk[24];	ib[3]=iblk[ 0];
	ib[4]=iblk[16];	ib[5]=iblk[32];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	ib[7]=ib[7]-FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	ib[6]=ib[6]-FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[5]=ib[5]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[4]=ib[4]-FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[3]=ib[3]-FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[2]=ib[2]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[1]=ib[1]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[0]=ib[0]-FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[7]=-ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));

	oblk[ 0]=ib[5];	oblk[ 8]=ib[6];
	oblk[16]=ib[0];	oblk[24]=ib[3];
	oblk[32]=ib[2];	oblk[40]=ib[7];
	oblk[48]=ib[4];	oblk[56]=ib[1];
}

// void PDJPG_TransIRDCT(short *iblk, byte *oblk)
void PDJPG_TransIRDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIRDCT_Vert(iblk+0, s+0);
	PDJPG_TransIRDCT_Vert(iblk+1, s+1);
	PDJPG_TransIRDCT_Vert(iblk+2, s+2);
	PDJPG_TransIRDCT_Vert(iblk+3, s+3);
	PDJPG_TransIRDCT_Vert(iblk+4, s+4);
	PDJPG_TransIRDCT_Vert(iblk+5, s+5);
	PDJPG_TransIRDCT_Vert(iblk+6, s+6);
	PDJPG_TransIRDCT_Vert(iblk+7, s+7);

	PDJPG_TransIRDCT_Horiz(s+0, t+0);
	PDJPG_TransIRDCT_Horiz(s+8, t+8);
	PDJPG_TransIRDCT_Horiz(s+16, t+16);
	PDJPG_TransIRDCT_Horiz(s+24, t+24);
	PDJPG_TransIRDCT_Horiz(s+32, t+32);
	PDJPG_TransIRDCT_Horiz(s+40, t+40);
	PDJPG_TransIRDCT_Horiz(s+48, t+48);
	PDJPG_TransIRDCT_Horiz(s+56, t+56);

	for(i=0; i<64; i++)
	{
		j=(t[i])+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
	}
}
#endif


#if 0
//HAD: Hadamard Transform (Lossless)

void PDJPG_TransHAD_Horiz(byte *iblk, int *oblk)
{
	int ia[8];
	int ib[8];
	int ic[8];
	int id[8];

	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	ia[0]=ib[0]+ib[4];
	ia[1]=ib[1]+ib[5];
	ia[2]=ib[2]+ib[6];
	ia[3]=ib[3]+ib[7];
	ia[4]=(ia[0]>>1)-ib[4];
	ia[5]=(ia[1]>>1)-ib[5];
	ia[6]=(ia[2]>>1)-ib[6];
	ia[7]=(ia[3]>>1)-ib[7];

	ic[0]=ia[0]+ia[2];
	ic[1]=ia[1]+ia[3];
	ic[2]=(ic[0]>>1)-ia[2];
	ic[3]=(ic[1]>>1)-ia[3];
	ic[4]=ia[4]+ia[6];
	ic[5]=ia[5]+ia[7];
	ic[6]=(ic[4]>>1)-ia[6];
	ic[7]=(ic[5]>>1)-ia[7];

	id[0]=ic[0]+ic[1];
	id[1]=(id[0]>>1)-ic[1];
	id[2]=ic[2]+ic[3];
	id[3]=(id[2]>>1)-ic[3];
	id[4]=ic[4]+ic[5];
	id[5]=(id[4]>>1)-ic[5];
	id[6]=ic[6]+ic[7];
	id[7]=(id[6]>>1)-ic[7];

	oblk[0]=id[0];	oblk[1]=id[4];
	oblk[2]=id[6];	oblk[3]=id[2];
	oblk[4]=id[3];	oblk[5]=id[7];
	oblk[6]=id[5];	oblk[7]=id[1];
}

void PDJPG_TransHAD_Vert(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[16];	ib[1]=iblk[56];
	ib[2]=iblk[32];	ib[3]=iblk[24];
	ib[4]=iblk[48];	ib[5]=iblk[ 0];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	oblk[0]=ib[3];	oblk[8]=ib[6];
	oblk[16]=ib[4];	oblk[24]=ib[2];
	oblk[32]=ib[5];	oblk[40]=ib[7];
	oblk[48]=ib[0];	oblk[56]=ib[1];
}

void PDJPG_TransHAD(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransHAD_Horiz(iblk+0, s+0);
	PDJPG_TransHAD_Horiz(iblk+8, s+8);
	PDJPG_TransHAD_Horiz(iblk+16, s+16);
	PDJPG_TransHAD_Horiz(iblk+24, s+24);
	PDJPG_TransHAD_Horiz(iblk+32, s+32);
	PDJPG_TransHAD_Horiz(iblk+40, s+40);
	PDJPG_TransHAD_Horiz(iblk+48, s+48);
	PDJPG_TransRDCT_Horiz(iblk+56, s+56);

	PDJPG_TransRDCT_Vert(s+0, t+0);
	PDJPG_TransRDCT_Vert(s+1, t+1);
	PDJPG_TransRDCT_Vert(s+2, t+2);
	PDJPG_TransRDCT_Vert(s+3, t+3);
	PDJPG_TransRDCT_Vert(s+4, t+4);
	PDJPG_TransRDCT_Vert(s+5, t+5);
	PDJPG_TransRDCT_Vert(s+6, t+6);
	PDJPG_TransRDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}
#endif


#if 1
void PDJPG_TransQDCT_Horiz(short *iblk, int *oblk, int dcbias)
{
	int ib[8];

	ib[0]=iblk[0]-dcbias;	ib[1]=iblk[1]-dcbias;
	ib[2]=iblk[2]-dcbias;	ib[3]=iblk[3]-dcbias;
	ib[4]=iblk[4]-dcbias;	ib[5]=iblk[5]-dcbias;
	ib[6]=iblk[6]-dcbias;	ib[7]=iblk[7]-dcbias;

	oblk[0]=ib[0]+ib[1]+ib[2]+ib[3]+ib[4]+ib[5]+ib[6]+ib[7];
	oblk[1]=ib[0]+ib[1]+ib[2]+ib[3]-ib[4]-ib[5]-ib[6]-ib[7];
	oblk[2]=ib[0]+ib[1]-ib[2]-ib[3]-ib[4]-ib[5]+ib[6]+ib[7];
	oblk[3]=ib[0]-ib[1]-ib[2]-ib[3]+ib[4]+ib[5]+ib[6]-ib[7];
	oblk[4]=ib[0]-ib[1]-ib[2]+ib[3]+ib[4]-ib[5]-ib[6]+ib[7];
	oblk[5]=ib[0]-ib[1]+ib[2]+ib[3]-ib[4]-ib[5]+ib[6]-ib[7];
	oblk[6]=ib[0]-ib[1]+ib[2]-ib[3]-ib[4]+ib[5]-ib[6]+ib[7];
	oblk[7]=ib[0]-ib[1]+ib[2]-ib[3]+ib[4]-ib[5]+ib[6]-ib[7];
}

void PDJPG_TransQDCT_Vert(int *ib, int *oblk)
{
	oblk[ 0]=ib[0]+ib[8]+ib[16]+ib[24]+ib[32]+ib[40]+ib[48]+ib[56];
	oblk[ 8]=ib[0]+ib[8]+ib[16]+ib[24]-ib[32]-ib[40]-ib[48]-ib[56];
	oblk[16]=ib[0]+ib[8]-ib[16]-ib[24]-ib[32]-ib[40]+ib[48]+ib[56];
	oblk[24]=ib[0]-ib[8]-ib[16]-ib[24]+ib[32]+ib[40]+ib[48]-ib[56];
	oblk[32]=ib[0]-ib[8]-ib[16]+ib[24]+ib[32]-ib[40]-ib[48]+ib[56];
	oblk[40]=ib[0]-ib[8]+ib[16]+ib[24]-ib[32]-ib[40]+ib[48]-ib[56];
	oblk[48]=ib[0]-ib[8]+ib[16]-ib[24]-ib[32]+ib[40]-ib[48]+ib[56];
	oblk[56]=ib[0]-ib[8]+ib[16]-ib[24]+ib[32]-ib[40]+ib[48]-ib[56];
}

void PDJPG_TransQDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransQDCT_Horiz(iblk+0, s+0, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+8, s+8, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+16, s+16, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+24, s+24, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+32, s+32, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+40, s+40, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+48, s+48, dcbias);
	PDJPG_TransQDCT_Horiz(iblk+56, s+56, dcbias);

	PDJPG_TransQDCT_Vert(s+0, t+0);
	PDJPG_TransQDCT_Vert(s+1, t+1);
	PDJPG_TransQDCT_Vert(s+2, t+2);
	PDJPG_TransQDCT_Vert(s+3, t+3);
	PDJPG_TransQDCT_Vert(s+4, t+4);
	PDJPG_TransQDCT_Vert(s+5, t+5);
	PDJPG_TransQDCT_Vert(s+6, t+6);
	PDJPG_TransQDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}

#endif

#if 1
void PDJPG_TransIQDCT_Horiz(short *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[0];
	b=iblk[2];
	c=iblk[4];
	d=iblk[6];
	i=a+b+c+d;	j=a+b-c-d;
	k=a-b-c+d;	l=a-b+c-d;
	m=iblk[1]+iblk[3]+iblk[5]+iblk[7];
	n=iblk[1]-iblk[3]-iblk[5]-iblk[7];
	o=iblk[1]-iblk[3]+iblk[5]+iblk[7];
	p=iblk[1]-iblk[3]+iblk[5]-iblk[7];
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
}

void PDJPG_TransIQDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0];	b=iblk[32];
	c=iblk[16];	d=iblk[16];
	e=iblk[48];	f=iblk[48];
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[8]+iblk[24]+iblk[40]+iblk[56];
	n=iblk[8]-iblk[24]-iblk[40]-iblk[56];
	o=iblk[8]-iblk[24]+iblk[40]+iblk[56];
	p=iblk[8]-iblk[24]+iblk[40]-iblk[56];
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

void PDJPG_TransIQDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIQDCT_Horiz(iblk+0, s+0);
	PDJPG_TransIQDCT_Horiz(iblk+8, s+8);
	PDJPG_TransIQDCT_Horiz(iblk+16, s+16);
	PDJPG_TransIQDCT_Horiz(iblk+24, s+24);
	PDJPG_TransIQDCT_Horiz(iblk+32, s+32);
	PDJPG_TransIQDCT_Horiz(iblk+40, s+40);
	PDJPG_TransIQDCT_Horiz(iblk+48, s+48);
	PDJPG_TransIQDCT_Horiz(iblk+56, s+56);

	PDJPG_TransIQDCT_Vert(s+0, t+0);
	PDJPG_TransIQDCT_Vert(s+1, t+1);
	PDJPG_TransIQDCT_Vert(s+2, t+2);
	PDJPG_TransIQDCT_Vert(s+3, t+3);
	PDJPG_TransIQDCT_Vert(s+4, t+4);
	PDJPG_TransIQDCT_Vert(s+5, t+5);
	PDJPG_TransIQDCT_Vert(s+6, t+6);
	PDJPG_TransIQDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=t[i]+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
//		oblk[i]=(j<0)?0:((j>255)?255:j);
	}
}
#endif



//Decoder

int PDJHUFF_NextByte(PDJPG_Context *ctx)
{
	int i, j;

//	if(pdjhuff_isend)return(0xFF);
	if(pdjhuff_isend)return(0x00);

	i=*pdjhuff_cs++;
	if(i==0xFF)
	{
		j=*pdjhuff_cs++;
		if(j)
		{
//			printf("PDJHUFF_NextByte: Bitstream Marker %02X\n", j);
			pdjhuff_isend=1;
			return(0x00);
		}
	}
	return(i);
}

int PDJHUFF_InitStream(PDJPG_Context *ctx, byte *buf)
{
	pdjhuff_pos=0;
	pdjhuff_isend=0;

	pdjhuff_cs=buf;
	pdjhuff_win=PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	return(0);
}

int PDJHUFF_ReadBit(PDJPG_Context *ctx)
{
	int i;

	i=(pdjhuff_win>>(31-pdjhuff_pos))&1;
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

int PDJHUFF_ReadNBits(PDJPG_Context *ctx, int n)
{
	int i;

	if(n<=0)return(0);

	i=(pdjhuff_win>>(32-n-pdjhuff_pos))&((1<<n)-1);
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

void PDJHUFF_SkipNBits(PDJPG_Context *ctx, int n)
{
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
}

int PDJHUFF_PeekWord(PDJPG_Context *ctx)
{
	int i;
	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
	return(i);
}

#if 1
int PDJHUFF_DecodeSymbol(PDJPG_Context *ctx, int tab)
{
	int i, j, k, l;

//	i=PDJHUFF_PeekWord(ctx);
//	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
//	i=(u16)(pdjhuff_win>>(16-pdjhuff_pos));

	i=(byte)(pdjhuff_win>>(24-pdjhuff_pos));
	
	tab<<=8;
//	j=ctx->huff_idx[tab|k];
//	j=ctx->huff_idx[tab|(i>>8)];
	j=ctx->huff_idx[tab|i];

#if 1
//	l=tab|j;
//	k=ctx->huff_len[l];
	k=ctx->huff_len[tab|j];
//	if(0)
	if(k<=8)
//	if(k<8)
	{
		pdjhuff_pos+=k;
//		while(pdjhuff_pos>=8)
		if(pdjhuff_pos>=8)
		{
			pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
			pdjhuff_pos-=8;
		}

//		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

	i=(u16)(pdjhuff_win>>(16-pdjhuff_pos));
	j=ctx->huff_idx[tab|(i>>8)];

	while(1)
	{
		l=tab|j;
		k=ctx->huff_len[l];
		if(!k)
		{
//			printf("PDJHUFF_DecodeSymbol: Trap A\n");
			break;
		}

#if 1
		if((i>>(16-k))!=ctx->huff_code[l])
//		if((k>=8) && (i>>(16-k))!=ctx->huff_code[l])
		{
			j=ctx->huff_next[l];
//			if(!j)
			if(j<0)
			{
//				printf("PDJHUFF_DecodeSymbol: Trap B\n");
				break;
			}
			continue;
		}
#endif

		pdjhuff_pos+=k;
		while(pdjhuff_pos>=8)
//		if(pdjhuff_pos>=8)
		{
			pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
			pdjhuff_pos-=8;
		}

//		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}

#if 0
	i=PDJHUFF_PeekWord(ctx);
	for(j=0; j<256; j++)
	{
		k=ctx->huff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=ctx->huff_code[tab|j])
			continue;
		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

	return(-1);
}
#endif


#if 0
int PDJHUFF_DecodeSymbol(PDJPG_Context *ctx, int tab)
{
	int i, j, k, l;

	tab<<=8;

#if 0
	i=PDJHUFF_PeekWord(ctx);
	j=ctx->huff_idx[tab|(i>>8)];
	while(1)
	{
		l=tab|j;
		k=ctx->huff_len[l];
//		if(!k)break;

		if((i>>(16-k))!=ctx->huff_code[l])
		{
			j=ctx->huff_next[l];
			if(!j)break;
			continue;
		}
		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

#if 1
	i=PDJHUFF_PeekWord(ctx);
	for(j=0; j<256; j++)
	{
		k=ctx->huff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=ctx->huff_code[tab|j])
			continue;
		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

	return(-1);
}
#endif

int PDJHUFF_DecodeDiffDC(PDJPG_Context *ctx, int tab)
{
	int i, j;

	i=PDJHUFF_DecodeSymbol(ctx, tab);
	j=PDJHUFF_ReadNBits(ctx, i);

	if(!(j&(1<<(i-1))))
		j=(-1<<i)+j+1;
	return(j);
}

int PDJHUFF_DecodeBlock(PDJPG_Context *ctx,
	short *buf, int dctab, int actab,
	int ni, int nn)
{
	int i, j, k;

//	for(i=1; i<64; i++)buf[i]=0;
	memset(buf+1, 0, 63*sizeof(short));

	buf[0]+=PDJHUFF_DecodeDiffDC(ctx, dctab);
	for(i=1; i<64; i++)
	{
		j=PDJHUFF_DecodeSymbol(ctx, actab);
		if(j<=0)
		{
			if(j<0)
			{
				printf("bad dct block1 %02X(%d) %d/%d\n", j, j, ni, nn);
				return(-1);
			}
			break;
		}

		i+=(j>>4)&15;	//preceding 0's
		if(!(j&15))continue;
		if(i>=64)
		{
//			printf("bad dct block3 %02X(%d) len=%d %d/%d\n",
//				j, j, i, ni, nn);
			break;
		}

		j&=15;
		k=PDJHUFF_ReadNBits(ctx, j);
		if(!(k&(1<<(j-1))))
			k=(-1<<j)+k+1;

		j=pdjpg_zigzag2[i];
		buf[j]=k;
	}

#if 0
	for(j=i+1; j<64; j++)
	{
//		buf[i]=0;
		buf[pdjpg_zigzag2[j]]=0;
	}
#endif

	if(i>64)
	{
		printf("bad dct block2 %02X(%d) len=%d %d/%d\n", j, j, i, ni, nn);
		return(-1);
	}

	return(0);
}

void PDJHUFF_QuantBlock(
	PDJPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	
//	for(i=0; i<64; i++)
//		obuf[i]=ibuf[i]/ctx->jpg_qt[qid][i];

	for(i=0; i<64; i++)
		obuf[i]=(ibuf[i]*ctx->jpg_qtfp[qid][i])>>12;
}

void PDJHUFF_DequantBlock(
	PDJPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	for(i=0; i<64; i++)
		obuf[i]=ibuf[i]*ctx->jpg_qt[qid][i];
}

void PDJPG_SetupQuantTabDivFP(PDJPG_Context *ctx, int qid)
{
	int i;
	
	for(i=0; i<64; i++)
		ctx->jpg_qtfp[qid][i]=4096.0/ctx->jpg_qt[qid][i];
}

int PDJPG_MarkerSOS(PDJPG_Context *ctx, byte *buf)
{
	short dbuf[4*64];
	byte ch[4], cv[4], qid[4];
	byte step[4];
	int xi[4], yi[4], wi[4], hi[4];
	byte cdt[4], cat[4];
	int ccnt[4];

	byte *s;
	int i, j, k, l, i1, j1, k1, l1;
	int w, h, n, ns, rt;

	l=(buf[0]<<8)|buf[1];
//	printf("ns %d\n", buf[2]);

	ns=buf[2]; rt=0;
	s=buf+3;
	for(i=0; i<buf[2]; i++)
	{
//		printf("%d %d %d\n", s[0], s[1]>>4, s[1]&15);

		cdt[i]=s[1]>>4;
		cat[i]=s[1]&15;

		for(j=0; j<ctx->jpg_nc; j++)
			if(ctx->jpg_cid[j]==s[0])
		{
			ch[i]=ctx->jpg_ch[j];
			cv[i]=ctx->jpg_cv[j];
			qid[i]=ctx->jpg_qid[j];
			xi[i]=ctx->jpg_cxi[j];
			yi[i]=ctx->jpg_cyi[j];

			step[i]=ch[i]*cv[i];
			break;
		}

		w=(xi[i]+7)/8;
		h=(yi[i]+7)/8;
//		w=(xi[i]+15)/8;
//		h=(yi[i]+15)/8;
		wi[i]=w;
		hi[i]=h;

		n=(w+1)*(h+2);
		ctx->jpg_scid[i]=s[0];
		ctx->jpg_scn[i]=j;
		if(!ctx->jpg_scbuf[i])
			ctx->jpg_scbuf[i]=malloc(n*64*sizeof(short));
		if(!ctx->jpg_sibuf[i])
			ctx->jpg_sibuf[i]=malloc(n*64*sizeof(short));

//		memset(ctx->jpg_sibuf[i], 0, n*64);

		ccnt[i]=0;

		s+=2;
	}
	s+=3;

	i=(ctx->xs+ctx->jpg_chm*8-1)/(ctx->jpg_chm*8);
	j=(ctx->ys+ctx->jpg_chn*8-1)/(ctx->jpg_chn*8);
	n=i*j;

	PDJHUFF_InitStream(ctx, s);

	for(i=0; i<(4*64); i++)dbuf[i]=0;

	rt=0;
	for(i=0; i<n; i++)
	{
		for(j=0; j<ns; j++)
		{
			for(k=0; k<cv[j]; k++)
			{
				for(l=0; l<ch[j]; l++)
				{
					if(rt<0)break;

					i1=(i/(wi[j]/ch[j]))*ch[j];
					j1=(i%(wi[j]/ch[j]))*ch[j];
					k1=((i1+k)*wi[j])+(j1+l);

					rt=PDJHUFF_DecodeBlock(ctx, dbuf+j*64,
						cdt[j]*2+0, cat[j]*2+1, i, n);
					if(rt<0)break;
					PDJHUFF_DequantBlock(ctx, dbuf+j*64,
						ctx->jpg_scbuf[j]+k1*64, qid[j]);
						
					if(ctx->jpg_rdct)
					{
						PDJPG_TransIRDCT(ctx->jpg_scbuf[j]+k1*64,
							ctx->jpg_sibuf[j]+k1*64, 128);
					}else
					{
						PDJPG_TransIDCT(ctx->jpg_scbuf[j]+k1*64,
							ctx->jpg_sibuf[j]+k1*64, 128);

//						PDJPG_TransIQDCT(ctx->jpg_scbuf[j]+k1*64,
//							ctx->jpg_sibuf[j]+k1*64, 128);
					}
				}
				if(rt<0)break;
			}
			if(rt<0)break;
		}
		if(rt<0)break;
	}

	if(rt<0)
	{
		printf("PDJPG_MarkerSOS: Bad Image\n");
		return(-1);
	}

	i=ctx->huff_cs-buf;
	return(i);

//	return(0);
}

int PDJPG_MarkerSOF0(PDJPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, m, n;

	l=(buf[0]<<8)|buf[1];
//	printf("p %d\n", buf[2]);

	i=(buf[3]<<8)|buf[4];
	j=(buf[5]<<8)|buf[6];

	ctx->xs=j;
	ctx->ys=i;
//	printf("size %dx%d\n", j, i);

	m=0; n=0;

	k=buf[7];
	s=buf+8;
	for(i=0; i<k; i++)
	{
		ctx->jpg_cid[i]=s[0];
		ctx->jpg_ch[i]=s[1]>>4;
		ctx->jpg_cv[i]=s[1]&15;
		ctx->jpg_qid[i]=s[2];

		if(ctx->jpg_ch[i]>m)m=ctx->jpg_ch[i];
		if(ctx->jpg_cv[i]>n)n=ctx->jpg_cv[i];

//		printf("CID %d: %d %d %d\n", ctx->jpg_cid[i],
//			ctx->jpg_ch[i], ctx->jpg_cv[i], ctx->jpg_qid[i]);
		s+=3;
	}

	ctx->jpg_chm=m;
	ctx->jpg_chn=n;

	for(i=0; i<k; i++)
	{
		ctx->jpg_cxi[i]=(ctx->jpg_ch[i]*ctx->xs)/m;
		ctx->jpg_cyi[i]=(ctx->jpg_cv[i]*ctx->ys)/n;
	}

	ctx->jpg_nc=k;

	return(0);
}

int PDJPG_MarkerDQT(PDJPG_Context *ctx, byte *buf)
{
	byte *s, *se;
	int i, j, l;

	l=(buf[0]<<8)|buf[1];

	s=buf+2;
	se=buf+l;

	while(s<se)
	{
		i=(s[0]>>4)&15;
		if(i)
		{
//			printf("bad bits %d\n", i);
			return(-1);
		}
		i=s[0]&15;
//		printf("dest %d\n", i);

		for(j=0; j<64; j++)
			ctx->jpg_qt[i][pdjpg_zigzag2[j]]=s[j+1];
		s+=65;
	}
	
	return(s-buf);
//	return(0);
}

int PDJPG_MarkerDHT(PDJPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, tn;

	l=(buf[0]<<8)|buf[1];

	j=(buf[2]>>4)&15;
	i=buf[2]&15;
//	printf("dest %d, type %d\n", i, j);

	tn=i*2+j;

	for(i=0; i<256; i++)
	{
		ctx->huff_len[tn*256+i]=0;
		ctx->huff_next[tn*256+i]=-1;
		ctx->huff_idx[tn*256+i]=-1;
	}

	cnt=buf+3;
	s=cnt+16;
	k=0; l=0;
	for(i=0; i<16; i++)
	{
		k<<=1;
		for(j=0; j<cnt[i]; j++)
		{
			ctx->huff_code[tn*256+(*s)]=k++;
			ctx->huff_len[tn*256+(*s)]=i+1;
			ctx->huff_mask[tn*256+(*s)]=(1<<(i+1))-1;
			l=i+1;
			s++;
		}
	}
//	printf("%04X %d\n", k, l);

	//build lookup indices / chains

	for(i=0; i<256; i++)
	{
//		ctx->huff_next[tn*256+i]=0;
//		ctx->huff_idx[tn*256+i]=0;
		ctx->huff_next[tn*256+i]=-1;
		ctx->huff_idx[tn*256+i]=-1;
	}

	for(i=0; i<256; i++)
	{
		l=ctx->huff_len[tn*256+i];
		if(!l)continue;
		j=ctx->huff_code[tn*256+i];
		
		if(l<=8)
		{
			j=j<<(8-l);
			k=1<<(8-l);
			while((k--) && (j<256))
			{
				ctx->huff_idx[tn*256+j]=i;
				j++;
			}
		}else
		{
			j=j>>(l-8);
			ctx->huff_next[tn*256+i]=
				ctx->huff_idx[tn*256+j];
			ctx->huff_idx[tn*256+j]=i;
		}
	}

	return(s-buf);
//	return(0);
}

int PDJPG_MarkerAPP0(PDJPG_Context *ctx, byte *buf)
{
	return(0);
}

int PDJPG_MarkerAPP9(PDJPG_Context *ctx, byte *buf)
{
	int i;
	buf+=2;

	if(!memcmp(buf, "JPSERM", 6))
	{
		ctx->jpg_rdct=1;
		return(1);
	}
	
	return(0);
}

int PDJPG_MarkerAPP11(PDJPG_Context *ctx, byte *buf)
{
	int cr, cg, cb, ca;

	buf+=2;

	if(!strcmp((char *)buf, "AlphaColor"))
	{
		buf+=strlen((char *)buf)+1;
		sscanf(buf, "%d %d %d %d", &cr, &cg, &cb, &ca);
		PDJPG_SetContextAlphaColor(ctx, cr, cg, cb, ca);
		return(1);
	}
	
	return(0);
}

int PDJPG_MarkerAPP12(PDJPG_Context *ctx, byte *buf)
{
	int i;
	buf+=2;

	i=(buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
//	printf("PDJPG_MarkerAPP12: %08X\n", i);

	if(!memcmp(buf, "BCST", 4))
	{
		ctx->bcst_version=(buf[4]<<8)|buf[5];
		ctx->bcst_trans=buf[6];
		ctx->bcst_bpp=buf[7];
		ctx->bcst_flags=
			(buf[8]<<24)|(buf[9]<<16)|
			(buf[10]<<8)|buf[11];
		
		ctx->jpg_clrtrans=ctx->bcst_trans;
		
		if(ctx->bcst_flags&PDJPG_BCSFL_RDCT)
			ctx->jpg_rdct=1;
			
//		printf("PDJPG_MarkerAPP12: BCST %04X %02X %02X %08X\n",
//			ctx->bcst_version, ctx->bcst_trans,
//			ctx->bcst_bpp, ctx->bcst_flags);
		return(1);
	}

	return(0);
}

int PDJPG_MarkerAPP14(PDJPG_Context *ctx, byte *buf)
{
	buf+=2;

#if 0
	if(!memcmp((char *)buf, "Adobe", 5))
	{
		ctx->jpg_app14_dctversion=(buf[5]<<8)|buf[6];
		ctx->jpg_app14_flags0=(buf[7]<<8)|buf[8];
		ctx->jpg_app14_flags1=(buf[9]<<8)|buf[10];
		ctx->jpg_app14_trans=buf[11];
		
		switch(ctx->jpg_app14_trans)
		{
		case 0: ctx->jpg_clrtrans=PDJPG_CLRS_RGB; break;
		case 1: ctx->jpg_clrtrans=PDJPG_CLRS_YCBCR; break;
		case 2: ctx->jpg_clrtrans=PDJPG_CLRS_YCCK; break;
		}
		
		return(1);
	}
#endif

	return(0);
}

int PDJPG_MarkerAPPN(PDJPG_Context *ctx, byte *buf)
{
	return(0);
}

#if 0
int PDJPG_GetComponentPixel(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	id=ctx->jpg_scn[cn];

	i=x*ctx->jpg_schsc[cn];
	j=y*ctx->jpg_scvsc[cn];
//	i=(ctx->jpg_ch[id]*x)/ctx->jpg_chm;
//	j=(ctx->jpg_cv[id]*y)/ctx->jpg_chn;
	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
	h=ctx->jpg_scvs[cn];
//	w=(ctx->jpg_cxi[id]+7)/8;
//	h=(ctx->jpg_cyi[id]+7)/8;
//	w=(ctx->jpg_cxi[id]+15)/8;
//	h=(ctx->jpg_cyi[id]+15)/8;
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}
#endif

#if 1
int PDJPG_GetComponentPixel(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	i=x*ctx->jpg_schsc[cn];
//	j=y*ctx->jpg_scvsc[cn];

	i=(x*ctx->jpg_schsci[cn])>>16;
	j=(y*ctx->jpg_scvsci[cn])>>16;

	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}
#endif

#if 1
int PDJPG_GetComponentPixelS1(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	i=x>>3;
	j=y>>3;
	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(j*w)+i;

	k=x&7;
	l=y&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

int PDJPG_GetComponentPixelS2(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	i=x>>1;
	j=y>>1;

	k=i>>3;
	l=j>>3;
	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

int PDJPG_GetComponentPixelS122(PDJPG_Context *ctx, int x, int y,
	int *ry, int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	x1=x>>1; y1=y>>1;

	w0=ctx->jpg_schs[0];
	w1=ctx->jpg_schs[1];

	i=x>>3; j=y>>3;
	k=x1>>3; l=y1>>3;
	n0=(j*w0)+i;
	n1=(l*w1)+k;

	i=x&7; j=y&7;
	k=x1&7; l=y1&7;
	t0=(n0<<6)+((j<<3)+i);
	t1=(n1<<6)+((l<<3)+k);

	*ry=ctx->jpg_sibuf[0][t0];
	*ru=ctx->jpg_sibuf[1][t1];
	*rv=ctx->jpg_sibuf[2][t1];

	return(0);
}

int PDJPG_GetComponentPixelS111(PDJPG_Context *ctx, int x, int y,
	int *ry, int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	w0=ctx->jpg_schs[0];
	i=x>>3; j=y>>3;
	n0=(j*w0)+i;

	i=x&7; j=y&7;
	t0=(n0<<6)+((j<<3)+i);

	*ry=ctx->jpg_sibuf[0][t0];
	*ru=ctx->jpg_sibuf[1][t0];
	*rv=ctx->jpg_sibuf[2][t0];

	return(0);
}

int PDJPG_GetComponentPixelS420(PDJPG_Context *ctx, int x, int y,
	int *ry0, int *ry1, int *ry2, int *ry3,
	int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	x1=x>>1; y1=y>>1;

	w0=ctx->jpg_schs[0];
	w1=ctx->jpg_schs[1];

	i=x>>3; j=y>>3;
	k=x1>>3; l=y1>>3;
	n0=(j*w0)+i;
	n1=(l*w1)+k;

	i=x&7; j=y&7;
	k=x1&7; l=y1&7;
	t0=(n0<<6)+((j<<3)+i);
	t1=(n1<<6)+((l<<3)+k);

	*ry0=ctx->jpg_sibuf[0][t0];
	*ry1=ctx->jpg_sibuf[0][t0+1];
	*ry2=ctx->jpg_sibuf[0][t0+8];
	*ry3=ctx->jpg_sibuf[0][t0+9];

	*ru=ctx->jpg_sibuf[1][t1];
	*rv=ctx->jpg_sibuf[2][t1];

	return(0);
}

#endif

int PDJPG_DecodeColorTransformYCbCr420(PDJPG_Context *ctx, byte *obuf)
{
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

#if 1
		for(i=0; i<ctx->ys; i+=2)
			for(j=0; j<ctx->xs; j+=2)
		{
//			PDJPG_GetComponentPixelS122(ctx, j, i, &y0, &u, &v);
//			y1=PDJPG_GetComponentPixelS1(ctx, 0, j+1, i+0);
//			y2=PDJPG_GetComponentPixelS1(ctx, 0, j+0, i+1);
//			y3=PDJPG_GetComponentPixelS1(ctx, 0, j+1, i+1);

			PDJPG_GetComponentPixelS420(ctx, j, i,
				&y0, &y1, &y2, &y3, &u, &v);

			if(ctx->alphaClr)
			{
				a=255;

				k=y0-ctx->alphaClrY; l=k*k;
				k=y1-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				k=y2-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				k=y3-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				
//				k=y0-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				
				a=ctx->alphaClrA;
				a=(l<=(a*a))?0:255;
			}else { a=255; }

			u1=u-128; v1=v-128;
			l0=91881*v1;
			l1=-22554*u1-46802*v1;
			l2=116130*u1;

			y0<<=16; y1<<=16; y2<<=16; y3<<=16;
			r0=y0+l0; g0=y0+l1; b0=y0+l2;
			r1=y1+l0; g1=y1+l1; b1=y1+l2;
			r2=y2+l0; g2=y2+l1; b2=y2+l2;
			r3=y3+l0; g3=y3+l1; b3=y3+l2;

//			r0=65536*y0+l0; g0=65536*y0+l1; b0=65536*y0+l2;
//			r1=65536*y1+l0; g1=65536*y1+l1; b1=65536*y1+l2;
//			r2=65536*y2+l0; g2=65536*y2+l1; b2=65536*y2+l2;
//			r3=65536*y3+l0; g3=65536*y3+l1; b3=65536*y3+l2;

			r0>>=16; g0>>=16; b0>>=16;
			r1>>=16; g1>>=16; b1>>=16;
			r2>>=16; g2>>=16; b2>>=16;
			r3>>=16; g3>>=16; b3>>=16;

#if 0
			if((r0|r1|r2|r3)&(~255))
			{
				r0=(r0<0)?0:((r0>255)?255:r0);
				r1=(r1<0)?0:((r1>255)?255:r1);
				r2=(r2<0)?0:((r2>255)?255:r2);
				r3=(r3<0)?0:((r3>255)?255:r3);
			}

			if((g0|g1|g2|g3)&(~255))
			{
				g0=(g0<0)?0:((g0>255)?255:g0);
				g1=(g1<0)?0:((g1>255)?255:g1);
				g2=(g2<0)?0:((g2>255)?255:g2);
				g3=(g3<0)?0:((g3>255)?255:g3);
			}

			if((b0|b1|b2|b3)&(~255))
			{
				b0=(b0<0)?0:((b0>255)?255:b0);
				b1=(b1<0)?0:((b1>255)?255:b1);
				b2=(b2<0)?0:((b2>255)?255:b2);
				b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 1
			if((r0|r1|r2|r3)&(~255))
			{
				if(r0&(~255))r0=(r0<0)?0:((r0>255)?255:r0);
				if(r1&(~255))r1=(r1<0)?0:((r1>255)?255:r1);
				if(r2&(~255))r2=(r2<0)?0:((r2>255)?255:r2);
				if(r3&(~255))r3=(r3<0)?0:((r3>255)?255:r3);
			}

			if((g0|g1|g2|g3)&(~255))
			{
				if(g0&(~255))g0=(g0<0)?0:((g0>255)?255:g0);
				if(g1&(~255))g1=(g1<0)?0:((g1>255)?255:g1);
				if(g2&(~255))g2=(g2<0)?0:((g2>255)?255:g2);
				if(g3&(~255))g3=(g3<0)?0:((g3>255)?255:g3);
			}

			if((b0|b1|b2|b3)&(~255))
			{
				if(b0&(~255))b0=(b0<0)?0:((b0>255)?255:b0);
				if(b1&(~255))b1=(b1<0)?0:((b1>255)?255:b1);
				if(b2&(~255))b2=(b2<0)?0:((b2>255)?255:b2);
				if(b3&(~255))b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 0
			k=r0|r1|r2|r3 | g0|g1|g2|g3 | b0|b1|b2|b3;
			if(k&(~255))
			{
				if(r0&(~255))r0=(r0<0)?0:((r0>255)?255:r0);
				if(g0&(~255))g0=(g0<0)?0:((g0>255)?255:g0);
				if(b0&(~255))b0=(b0<0)?0:((b0>255)?255:b0);
				if(r1&(~255))r1=(r1<0)?0:((r1>255)?255:r1);
				if(g1&(~255))g1=(g1<0)?0:((g1>255)?255:g1);
				if(b1&(~255))b1=(b1<0)?0:((b1>255)?255:b1);
				if(r2&(~255))r2=(r2<0)?0:((r2>255)?255:r2);
				if(g2&(~255))g2=(g2<0)?0:((g2>255)?255:g2);
				if(b2&(~255))b2=(b2<0)?0:((b2>255)?255:b2);
				if(r3&(~255))r3=(r3<0)?0:((r3>255)?255:r3);
				if(g3&(~255))g3=(g3<0)?0:((g3>255)?255:g3);
				if(b3&(~255))b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 0
			r0=(!(r0&(~255)))?r0:((r0<0)?0:((r0>255)?255:r0));
			g0=(!(g0&(~255)))?g0:((g0<0)?0:((g0>255)?255:g0));
			b0=(!(b0&(~255)))?b0:((b0<0)?0:((b0>255)?255:b0));
			r1=(!(r1&(~255)))?r1:((r1<0)?0:((r1>255)?255:r1));
			g1=(!(g1&(~255)))?g1:((g1<0)?0:((g1>255)?255:g1));
			b1=(!(b1&(~255)))?b1:((b1<0)?0:((b1>255)?255:b1));
			r2=(!(r2&(~255)))?r2:((r2<0)?0:((r2>255)?255:r2));
			g2=(!(g2&(~255)))?g2:((g2<0)?0:((g2>255)?255:g2));
			b2=(!(b2&(~255)))?b2:((b2<0)?0:((b2>255)?255:b2));
			r3=(!(r3&(~255)))?r3:((r3<0)?0:((r3>255)?255:r3));
			g3=(!(g3&(~255)))?g3:((g3<0)?0:((g3>255)?255:g3));
			b3=(!(b3&(~255)))?b3:((b3<0)?0:((b3>255)?255:b3));
#endif

#if 0
			r0=(r0<0)?0:((r0>255)?255:r0);
			g0=(g0<0)?0:((g0>255)?255:g0);
			b0=(b0<0)?0:((b0>255)?255:b0);
			r1=(r1<0)?0:((r1>255)?255:r1);
			g1=(g1<0)?0:((g1>255)?255:g1);
			b1=(b1<0)?0:((b1>255)?255:b1);
			r2=(r2<0)?0:((r2>255)?255:r2);
			g2=(g2<0)?0:((g2>255)?255:g2);
			b2=(b2<0)?0:((b2>255)?255:b2);
			r3=(r3<0)?0:((r3>255)?255:r3);
			g3=(g3<0)?0:((g3>255)?255:g3);
			b3=(b3<0)?0:((b3>255)?255:b3);
#endif

			k=ctx->ys-1-i;
			l0=((k*ctx->xs)+j+0)*4;
//			l1=((k*ctx->xs)+j+1)*4;
			k=ctx->ys-2-i;
			l2=((k*ctx->xs)+j+0)*4;
//			l3=((k*ctx->xs)+j+1)*4;

//			ct=obuf+l0; *ct++=r0; *ct++=g0; *ct++=b0; *ct++=a;
//			ct=obuf+l1; *ct++=r1; *ct++=g1; *ct++=b1; *ct++=a;
//			ct=obuf+l2; *ct++=r2; *ct++=g2; *ct++=b2; *ct++=a;
//			ct=obuf+l3; *ct++=r3; *ct++=g3; *ct++=b3; *ct++=a;

			obuf[l0+0]=r0; obuf[l0+1]=g0; obuf[l0+2]=b0; obuf[l0+3]=a;
			obuf[l0+4]=r1; obuf[l0+5]=g1; obuf[l0+6]=b1; obuf[l0+7]=a;
			obuf[l2+0]=r2; obuf[l2+1]=g2; obuf[l2+2]=b2; obuf[l2+3]=a;
			obuf[l2+4]=r3; obuf[l2+5]=g3; obuf[l2+6]=b3; obuf[l2+7]=a;

//			obuf[l0+0]=r0; obuf[l0+1]=g0; obuf[l0+2]=b0; obuf[l0+3]=a;
//			obuf[l1+0]=r1; obuf[l1+1]=g1; obuf[l1+2]=b1; obuf[l1+3]=a;
//			obuf[l2+0]=r2; obuf[l2+1]=g2; obuf[l2+2]=b2; obuf[l2+3]=a;
//			obuf[l3+0]=r3; obuf[l3+1]=g3; obuf[l3+2]=b3; obuf[l3+3]=a;
		}
#endif

#if 0
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			PDJPG_GetComponentPixelS122(ctx, j, i, &y, &u, &v);

			if(ctx->alphaClr)
			{
				k=y-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				
				a=ctx->alphaClrA;
				a=(l<=(a*a))?0:255;
			}else { a=255; }

			u1=u-128; v1=v-128;
			r=65536*y          +91881*v1;
			g=65536*y- 22554*u1-46802*v1;
			b=65536*y+116130*u1;
			r>>=16; g>>=16; b>>=16;

			r=(r<0)?0:((r>255)?255:r);
			g=(g<0)?0:((g>255)?255:g);
			b=(b<0)?0:((b>255)?255:b);

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
#endif
}

/** Simulate basic decoding, but doesn't actually decode image.
  * Can be used to retrieve resolution or initialize Huffman tables
  * at a lower cost than a full decode. */
PDGL_API int PDJPG_DummyDecodeCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *obuf, *ct;
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
		return(-1);

	ctx->jpg_is420=0;
	ctx->jpg_rdct=0;
	ctx->jpg_clrtrans=0;

	ctx->bcst_version=0;
	ctx->bcst_flags=0;
	ctx->bcst_trans=0;
	ctx->bcst_bpp=0;

	for(i=0; i<4; i++)
	{
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	for(i=0; i<sz; i++)
	{
//		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		if(buf[i]==0xFF)
		{
			if(buf[i+1]==0x00)
				{ i++; continue; }
			if(buf[i+1]==0xFF)
				{ i++; continue; }

			j=buf[i+1]-0xC0;
			if(j<0)j=63;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)PDJPG_MarkerDQT(ctx, buf+i+2);
			if(buf[i+1]==JPG_DHT)PDJPG_MarkerDHT(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOF0)PDJPG_MarkerSOF0(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOS)
			{
//				j=PDJPG_MarkerSOS(ctx, buf+i+2);
//				if(j>0) { i+=j; }
				continue;
			}

			if((buf[i+1]>=JPG_APP0) && (buf[i+1]<=JPG_APP15))
			{
				if(buf[i+1]==JPG_APP0)PDJPG_MarkerAPP0(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP9)PDJPG_MarkerAPP9(ctx, buf+i+2);
				
				if(buf[i+1]==JPG_APP11)PDJPG_MarkerAPP11(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP12)PDJPG_MarkerAPP12(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP14)PDJPG_MarkerAPP14(ctx, buf+i+2);

				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j;
				continue;
			}

			if(buf[i+1]==JPG_EOI)break;
		}
	}

	*xs=ctx->xs;
	*ys=ctx->ys;

	return(0);
}


PDGL_API byte *PDJPG_DecodeCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *obuf, *ct;
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
		return(NULL);

	ctx->jpg_is420=0;
	ctx->jpg_rdct=0;
	ctx->jpg_clrtrans=0;

	ctx->bcst_version=0;
	ctx->bcst_flags=0;
	ctx->bcst_trans=0;
	ctx->bcst_bpp=0;

	for(i=0; i<4; i++)
	{
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	for(i=0; i<sz; i++)
	{
//		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		if(buf[i]==0xFF)
		{
			if(buf[i+1]==0x00)
				{ i++; continue; }
			if(buf[i+1]==0xFF)
				{ i++; continue; }

			j=buf[i+1]-0xC0;
			if(j<0)j=63;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)PDJPG_MarkerDQT(ctx, buf+i+2);
			if(buf[i+1]==JPG_DHT)PDJPG_MarkerDHT(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOF0)PDJPG_MarkerSOF0(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOS)
			{
				j=PDJPG_MarkerSOS(ctx, buf+i+2);
				if(j>0) { i+=j; }
				continue;
			}

			if((buf[i+1]>=JPG_APP0) && (buf[i+1]<=JPG_APP15))
			{
				if(buf[i+1]==JPG_APP0)PDJPG_MarkerAPP0(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP11)PDJPG_MarkerAPP11(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP12)PDJPG_MarkerAPP12(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP14)PDJPG_MarkerAPP14(ctx, buf+i+2);

				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j;
				continue;
			}

			if(buf[i+1]==JPG_EOI)break;
		}
	}

	obuf=ctx->jpg_imgbuf;
	if(!obuf || (ctx->xs!=ctx->lxs) || (ctx->ys!=ctx->lys))
	{
		if(ctx->jpg_imgbuf)
			free(ctx->jpg_imgbuf);
		
		obuf=malloc((ctx->xs+1)*(ctx->ys+1)*4);
		memset(obuf, 0xFF, ctx->xs*ctx->ys*4);
		
		ctx->jpg_imgbuf=obuf;
		ctx->lxs=ctx->xs;
		ctx->lys=ctx->ys;
	}

	for(i=0; i<ctx->jpg_nc; i++)
	{
		j=ctx->jpg_scn[i];
//		ctx->jpg_schsc[i]=ctx->jpg_ch[j]/(ctx->jpg_chm*1.0);
//		ctx->jpg_scvsc[i]=ctx->jpg_cv[j]/(ctx->jpg_chn*1.0);

		ctx->jpg_schsci[i]=(65536*ctx->jpg_ch[j])/ctx->jpg_chm;
		ctx->jpg_scvsci[i]=(65536*ctx->jpg_cv[j])/ctx->jpg_chn;

		ctx->jpg_schs[i]=(ctx->jpg_cxi[j]+7)/8;
		ctx->jpg_scvs[i]=(ctx->jpg_cyi[j]+7)/8;
		
	}

	if(ctx->jpg_nc==3)
	{
		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=32768)i=0;
		if(ctx->jpg_scvsci[1]!=32768)i=0;
		if(ctx->jpg_schsci[2]!=32768)i=0;
		if(ctx->jpg_scvsci[2]!=32768)i=0;
		ctx->jpg_is420=i;

		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=65536)i=0;
		if(ctx->jpg_scvsci[1]!=65536)i=0;
		if(ctx->jpg_schsci[2]!=65536)i=0;
		if(ctx->jpg_scvsci[2]!=65536)i=0;
		ctx->jpg_is444=i;
	}else
	{
		ctx->jpg_is420=0;
		ctx->jpg_is444=0;
	}

	if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&1) &&
		(ctx->jpg_clrtrans==PDJPG_CLRS_YCBCR))
	{
		PDJPG_DecodeColorTransformYCbCr420(ctx, obuf);
	}else
	{
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			if(ctx->jpg_nc==3)
			{
				if(ctx->jpg_is420)
				{
//					y=PDJPG_GetComponentPixelS1(ctx, 0, j, i);
//					u=PDJPG_GetComponentPixelS2(ctx, 1, j, i);
//					v=PDJPG_GetComponentPixelS2(ctx, 2, j, i);
					PDJPG_GetComponentPixelS122(ctx, j, i, &y, &u, &v);
					a=255;
				}else if(ctx->jpg_is444)
				{
					PDJPG_GetComponentPixelS111(ctx, j, i, &y, &u, &v);
					a=255;
				}else
				{
					y=PDJPG_GetComponentPixel(ctx, 0, j, i);
					u=PDJPG_GetComponentPixel(ctx, 1, j, i);
					v=PDJPG_GetComponentPixel(ctx, 2, j, i);
					a=255;
				}

				if(ctx->alphaClr)
				{
					k=y-ctx->alphaClrY; l=k*k;
					k=u-ctx->alphaClrU; l+=k*k;
					k=v-ctx->alphaClrV; l+=k*k;
				
					a=ctx->alphaClrA;
					a=(l<=(a*a))?0:255;
				
//					if(l<(16*16))
//					{
//						a=255*((16*sqrt(l))/ctx->alphaClrA);
//						a=(a<0)?0:(a>255)?255:a;
//					}
				}

//				r=y+1.40200*(v-128);
//				g=y-0.34414*(u-128)-0.71414*(v-128);
//				b=y+1.77200*(u-128);

				if(ctx->jpg_clrtrans==PDJPG_CLRS_YCBCR)
				{
					u1=u-128; v1=v-128;
					r=65536*y          +91881*v1;
					g=65536*y- 22554*u1-46802*v1;
					b=65536*y+116130*u1;
					r>>=16; g>>=16; b>>=16;
				}else if(ctx->jpg_clrtrans==PDJPG_CLRS_ORCT)
				{
					u1=u-128; v1=v-128;
					g=y-(u1+v1)/4;
					r=v1+g;
					b=u1+g;
				}else if(ctx->jpg_clrtrans==PDJPG_CLRS_RGB)
				{
					r=y;
					g=u;
					b=v;
				}

				r=(r<0)?0:((r>255)?255:r);
				g=(g<0)?0:((g>255)?255:g);
				b=(b<0)?0:((b>255)?255:b);

//				r=(r<0)?0:((r>16777215)?255:(r>>16));
//				g=(g<0)?0:((g>16777215)?255:(g>>16));
//				b=(b<0)?0:((b>16777215)?255:(b>>16));
			}else if(ctx->jpg_nc==1)
			{
				y=PDJPG_GetComponentPixel(ctx, 0, j, i);
				r=y; g=y; b=y; a=255;
			}

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
	}

	for(i=0; i<4; i++)
	{
		if(ctx->jpg_scbuf[i])free(ctx->jpg_scbuf[i]);
		if(ctx->jpg_sibuf[i])free(ctx->jpg_sibuf[i]);
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	*xs=ctx->xs;
	*ys=ctx->ys;
	return(obuf);
}

PDGL_API void PDJPG_Free(byte *buf)
{
	if(!buf)return;
	free(buf);
}

byte *PDJPG_DecodeScanForComponentLayer(byte *buf, int sz, char *name)
{
	byte *cs, *cs2, *cse;
	int i;
	
	cs=buf; cse=buf+sz;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_APP11))
		{
			i=(cs[2]<<8)|cs[3];
			cs2=cs+i+2;

			cs+=4;
			if(!strcmp((char *)cs, "CompLayer"))
			{
				cs+=strlen((char *)cs)+1;
				if(!strcmp((char *)cs, name))
				{
//					printf("Found %s\n", name);
					cs+=strlen((char *)cs)+1;
					return(cs2);
				}

				cs+=strlen((char *)cs)+1;
				continue;
			}
			cs+=i-2;
			continue;
		}
		if((cs[0]==0xFF) && (cs[1]>=JPG_APP0) && (cs[1]<=JPG_APP15))
		{
			i=(cs[2]<<8)|cs[3];
			cs+=i+2;
			continue;
		}

		cs++;
	}
	
	return(NULL);
}

PDGL_API byte *PDJPG_Decode(byte *buf, int sz, int *xs, int *ys)
{
	PDJPG_Context *ctx;
	byte *obuf;
	byte *otbuf;
	byte *csl;
	int i, n, sz1;
	
	ctx=PDJPG_AllocContext();
	obuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
	ctx->jpg_imgbuf=NULL;
	
	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
	if(csl)
	{
		sz1=sz-(csl-buf);
		otbuf=PDJPG_DecodeCtx(ctx, csl, sz1, xs, ys);
		
		n=ctx->xs*ctx->ys;
		for(i=0; i<n; i++)
		{
			obuf[i*4+3]=otbuf[i*4+1];
		}
	}

	PDJPG_FreeContext(ctx);
	return(obuf);
}

PDGL_API int PDJPG_DecodeComponentType(byte *buf, int sz)
{
	byte *csl;
	int sz1;

//	sz1=(sz>1024)?1024:sz;
//	csl=PDJPG_DecodeScanForComponentLayer(buf, sz1, "RGB");
//	if(!csl)return(0);

	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(16);
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)return(12);
		return(8);
	}else
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(7);

		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)return(4);

		return(3);
	}
}

PDGL_API byte *PDJPG_DecodeLDatCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *tbuf, *tbuf2, *cs, *ct;
	int i;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_APP12) ||
		(buf[4]!='L') || (buf[5]!='D') ||
		(buf[6]!='A') || (buf[7]!='T'))
	{
		tbuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
		return(tbuf);
	}
	
	tbuf=malloc(1<<20);
	cs=buf; ct=tbuf;

	while((cs[0]==0xFF) && (cs[1]==JPG_APP12) &&
		(cs[4]=='L') && (cs[5]=='D') &&
		(cs[6]=='A') && (cs[7]=='T'))
	{
		i=(cs[2]<<8)|cs[3];
		memcpy(ct, cs+8, i-6);
		cs+=i+2; ct+=(i-6);
	}

	i=ct-tbuf;
	i=PDJPG_EscapeDecodeSingleBuffer(tbuf, i);

	tbuf2=PDJPG_DecodeCtx(ctx, tbuf, i, xs, ys);
	free(tbuf);
	return(tbuf2);
}

PDGL_API int PDJPG_DecodeComponentCtx(PDJPG_Context *ctx,
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	return(PDJPG_DecodeComponentCtxI(ctx, buf, sz,
		rgba, norm, spec, luma, NULL,
		xs, ys));
}

PDGL_API int PDJPG_DecodeFloatComponentCtx(PDJPG_Context *ctx,
	byte *buf, int sz,
	float *rgba, float *norm, float *spec, float *luma,
	int *xs, int *ys)
{
	byte *trgba, *tnorm, *tspec, *tluma, *tlebe;
	int i, n;
	float f, g;

	PDJPG_DummyDecodeCtx(ctx, buf, sz, xs, ys);
	if(i<0)return(-1);

	n=ctx->xs*ctx->ys;
	if(!ctx->imgbuf_rgba)
		ctx->imgbuf_rgba=malloc(4*n);
	if(!ctx->imgbuf_norm)
		ctx->imgbuf_norm=malloc(4*n);
	if(!ctx->imgbuf_spec)
		ctx->imgbuf_spec=malloc(4*n);
	if(!ctx->imgbuf_luma)
		ctx->imgbuf_luma=malloc(4*n);

	if(!ctx->imgbuf_lebe)
	{
		ctx->imgbuf_lebe=malloc(4*n);
		memset(ctx->imgbuf_lebe, 192, 4*n);
	}

	i=PDJPG_DecodeComponentCtxI(ctx, buf, sz,
		ctx->imgbuf_rgba, ctx->imgbuf_norm,
		ctx->imgbuf_spec, ctx->imgbuf_luma,
		ctx->imgbuf_lebe,
		xs, ys);
	if(i<0)
	{
		return(-1);
	}
	
	trgba=ctx->imgbuf_rgba;
	tnorm=ctx->imgbuf_norm;
	tspec=ctx->imgbuf_spec;
	tluma=ctx->imgbuf_luma;
	tlebe=ctx->imgbuf_lebe;
	
	if(rgba)
	{
		for(i=0; i<n; i++)
		{
			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			rgba[i*4+0]=trgba[i*4+0]*f;
			rgba[i*4+1]=trgba[i*4+1]*f;
			rgba[i*4+2]=trgba[i*4+2]*f;
			rgba[i*4+3]=trgba[i*4+3]*(1.0/256);
		}
	}

	if(norm)
	{
		for(i=0; i<n; i++)
		{
//			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			f=1.0/256;
			g=(1.0/256)*pdjpg_scltab[tlebe[i*4+2]];
			norm[i*4+0]=tnorm[i*4+0]*f;
			norm[i*4+1]=tnorm[i*4+1]*f;
			norm[i*4+2]=tnorm[i*4+2]*f;
			norm[i*4+3]=tnorm[i*4+3]*g;
		}
	}

	if(spec)
	{
		for(i=0; i<n; i++)
		{
//			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			f=1.0/256;
			spec[i*4+0]=tspec[i*4+0]*f;
			spec[i*4+1]=tspec[i*4+1]*f;
			spec[i*4+2]=tspec[i*4+2]*f;
			spec[i*4+3]=tspec[i*4+3]*f;
		}
	}

	if(luma)
	{
		for(i=0; i<n; i++)
		{
			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+1]];
			luma[i*4+0]=tluma[i*4+0]*f;
			luma[i*4+1]=tluma[i*4+1]*f;
			luma[i*4+2]=tluma[i*4+2]*f;
			luma[i*4+3]=tluma[i*4+3]*(1.0/256);
		}
	}
}

PDGL_API int PDJPG_ExtractComponentCtx(PDJPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe)
{
	int n;
	
	n=ctx->xs*ctx->ys;
	if(rgba && ctx->imgbuf_rgba)
		memcpy(rgba, ctx->imgbuf_rgba, n*4);
	if(norm && ctx->imgbuf_norm)
		memcpy(norm, ctx->imgbuf_norm, n*4);
	if(spec && ctx->imgbuf_spec)
		memcpy(spec, ctx->imgbuf_spec, n*4);
	if(luma && ctx->imgbuf_luma)
		memcpy(luma, ctx->imgbuf_luma, n*4);
	if(lebe && ctx->imgbuf_lebe)
		memcpy(lebe, ctx->imgbuf_lebe, n*4);
}

PDGL_API int PDJPG_DecodeComponentCtxI(PDJPG_Context *ctx,
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe,
	int *xs, int *ys)
{
	byte *tbuf;
	byte *csl;
	int i, n, sz1;

	tbuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
	if(!tbuf)return(-1);

	n=ctx->xs*ctx->ys;

	for(i=0; i<n; i++)
	{
		rgba[i*4+0]=tbuf[i*4+0];
		rgba[i*4+1]=tbuf[i*4+1];
		rgba[i*4+2]=tbuf[i*4+2];
//		rgba[i*4+3]=tbuf[i*4+3];
	}

	if(norm)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "XYZ");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				norm[i*4+0]=tbuf[i*4+0];
				norm[i*4+1]=tbuf[i*4+2];
				norm[i*4+2]=tbuf[i*4+1];
//				norm[i*4+3]=tbuf[i*4+3];
			}
		}
	}

	if(spec)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				spec[i*4+0]=tbuf[i*4+0];
				spec[i*4+1]=tbuf[i*4+1];
				spec[i*4+2]=tbuf[i*4+2];
//				spec[i*4+3]=tbuf[i*4+3];
			}
		}
	}

	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		for(i=0; i<n; i++)
		{
			rgba[i*4+3]=tbuf[i*4+1];
			if(norm) { norm[i*4+3]=tbuf[i*4+0]; }
			if(spec) { spec[i*4+3]=tbuf[i*4+2]; }
		}
	}else
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
				{ rgba[i*4+3]=tbuf[i*4+1]; }
		}
		
		if(norm)
		{
			csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Depth");
			if(csl)
			{
				sz1=sz-(csl-buf);
				tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
				for(i=0; i<n; i++)
					{ norm[i*4+3]=tbuf[i*4+1]; }
			}
		}
	}
	
	if(luma)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				luma[i*4+0]=tbuf[i*4+0];
				luma[i*4+1]=tbuf[i*4+1];
				luma[i*4+2]=tbuf[i*4+2];
				luma[i*4+3]=255;
			}
		}
	}

	if(lebe)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LeBe");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				lebe[i*4+0]=tbuf[i*4+0];
				lebe[i*4+1]=tbuf[i*4+1];
				lebe[i*4+2]=tbuf[i*4+2];
			}
		}
	}

	return(0);
}

PDGL_API int PDJPG_DecodeComponent(byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	PDJPG_Context *ctx;
	int i;
	
	ctx=PDJPG_AllocContext();
	i=PDJPG_DecodeComponentCtx(ctx, buf, sz,
		rgba, norm, spec, luma, xs, ys);
//	ctx->jpg_imgbuf=NULL;
	PDJPG_FreeContext(ctx);
	return(i);
}

//Encoder

void PDJHUFF_WriteBit(PDJPG_Context *ctx, int i)
{
	pdjhuff_win|=i<<(31-pdjhuff_pos);
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteNBits(PDJPG_Context *ctx, int v, int n)
{
	int i, j, k;

	v&=(1<<n)-1;

	j=pdjhuff_pos+n;
	k=pdjhuff_win|(v<<(32-j));
	while(j>=8)
	{
		i=(k>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		k<<=8;
		j-=8;
	}
	pdjhuff_pos=j;
	pdjhuff_win=k;

//	pdjhuff_win|=i<<((32-n)-pdjhuff_pos);
//	pdjhuff_pos+=n;
//	while(pdjhuff_pos>=8)
//	{
//		i=(pdjhuff_win>>24)&0xFF;
//		*pdjhuff_ct++=i;
//		if(i==0xFF)*pdjhuff_ct++=0x00;
//		pdjhuff_win<<=8;
//		pdjhuff_pos-=8;
//	}
}

void PDJHUFF_FlushBits(PDJPG_Context *ctx)
{
	int i;
	while(pdjhuff_pos>0)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteString(PDJPG_Context *ctx, char *str)
{
	char *s;

	PDJHUFF_FlushBits(ctx);	
	s=str;
	while(*s)
		*pdjhuff_ct++=*s++;
	*pdjhuff_ct++=0;
}

int PDJHUFF_BalanceTree_r(short *nodes, short *nlen, int root, int h, int ml)
{
	int h0, h1, h2, h3;
	int l0, l1, l2;

	if(root<0)return(0);

	h1=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+0], h+1, ml);
	h2=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+1], h+1, ml);
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	if((h+h0)<=ml)	//depth limit not exceeded
		return(h0);

	//ok, so part of the tree is too deep
	if((h1+1)<h2)
	{
		l0=nodes[root*2+1];
		l1=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[root*2+0];
		nodes[root*2+0]=l0;
		nodes[root*2+1]=l1;
	}else if((h2+1)<h1)
	{
		l0=nodes[root*2+0];
		l1=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[root*2+1];
		nodes[root*2+0]=l1;
		nodes[root*2+1]=l0;
	}else
	{
		//rotating would be ineffective or would make things worse...
		return(h0);
	}

	//recalc depth of modified sub-tree
	l1=nodes[l0*2+0];
	l2=nodes[l0*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h3=((h1>h2)?h1:h2)+1;
	nlen[l0]=h3;

	//recalc height of root node
	l1=nodes[root*2+0];
	l2=nodes[root*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	return(h0);
}

void PDJHUFF_CalcLengths_r(short *nodes, byte *cl, int root, int h)
{
	if(root<0)
	{
		if(root==-513)return;
		cl[(-root)-1]=h;
		return;
	}

	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+0], h+1);
	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+1], h+1);
}

int PDJHUFF_BuildLengths(int *stat, int nc, byte *cl, int ml)
{
//	static short nodes[1024], nlen[512];
//	static short roots[512], clen[512];
//	static int cnts[512];

	short nodes[1024], nlen[512];
	short roots[512], clen[512];
	int cnts[512];
	int nr, nn;
	int i, j, k, l;

	nr=0; nn=0;
	for(i=0; i<nc; i++)
	{
		if(!stat[i])continue;
		roots[nr]=-(i+1);
		cnts[nr]=stat[i];
		clen[nr]=0;
		nr++;
	}

	roots[nr]=-513;
	cnts[nr]=0;
	clen[nr]=0;
	nr++;


	for(i=0; i<nc; i++)cl[i]=0;
	if(!nr)return(-1);


	while(nr>1)
	{
		if(cnts[0]>=cnts[1]) { j=0; k=1; }
			else { j=1; k=0; }
		for(i=2; i<nr; i++)
		{
			if(cnts[i]<=cnts[k])
			{
				j=k; k=i;
				continue;
			}
			if(cnts[i]<=cnts[j])
			{
				j=i;
				continue;
			}
		}

		nlen[nn]=((clen[j]>clen[k])?clen[j]:clen[k])+1;
		nodes[nn*2+0]=roots[j];
		nodes[nn*2+1]=roots[k];

		roots[nr]=nn;
		cnts[nr]=cnts[j]+cnts[k];
		clen[nr]=nlen[nn];

//		printf("%d %d %d\n", cnts[j], cnts[k], cnts[nr]);

		nn++; nr++;

		l=0;
		for(i=0; i<nr; i++)
		{
			if((i==j) || (i==k))continue;
			roots[l]=roots[i];
			cnts[l]=cnts[i];
			clen[l]=clen[i];
			l++;
		}
		nr=l;
	}

	l=roots[0];
	j=clen[0];
	k=j;

	i=4;
	while((i--) && (k>ml))
		k=PDJHUFF_BalanceTree_r(nodes, nlen, l, 0, ml);
	if(k>ml)return(-2);	//failed to balance tree

	PDJHUFF_CalcLengths_r(nodes, cl, l, 0);
	return(0);
}

int PDJHUFF_BuildLengthsAdjust(int *stat, int nc, byte *cl, int ml)
{
	int i, j;

	while(1)
	{
		j=PDJHUFF_BuildLengths(stat, nc, cl, ml);
		if(j<0)
			printf("PDJHUFF_BuildLengthsAdjust: Huff Fail %d\n");

		for(i=0; i<nc; i++)
			if(stat[i] && !cl[i])
				break;
		if(i>=nc)break;

		printf("PDJHUFF_BuildLengthsAdjust: Fiddle Adjust\n");
		for(i=0; i<nc; i++)
			stat[i]++;
		continue;
	}
	return(0);
}

void PDJHUFF_EncodeSymbol(PDJPG_Context *ctx, int tab, int v)
{
	tab<<=8;
	PDJHUFF_WriteNBits(ctx, ctx->huff_code[tab|v], ctx->huff_len[tab|v]);
}

void PDJHUFF_EncodeVal(PDJPG_Context *ctx, int tab, int z, int v)
{
	int i, j, k;

	if(!v) { PDJHUFF_EncodeSymbol(ctx, tab, z<<4); return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		if(i>15)
		{
			printf("PDJHUFF_EncodeVal: Overflow A\n");
			i=15;
		}
		
		PDJHUFF_EncodeSymbol(ctx, tab, (z<<4)|i);
		PDJHUFF_WriteNBits(ctx, v, i);
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	if(i>15)
	{
		printf("PDJHUFF_EncodeVal: Overflow B\n");
		i=15;
	}

	PDJHUFF_EncodeSymbol(ctx, tab, (z<<4)|i);

	k=(1<<i)-(j+1);
	PDJHUFF_WriteNBits(ctx, k, i);
	return;
}

void PDJHUFF_StatVal(int *stat, int z, int v)
{
	int i, j, k;

	if(!v) { stat[z<<4]++; return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		if(i>15)i=15;
		stat[(z<<4)|i]++;
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	if(i>15)i=15;
	stat[(z<<4)|i]++;
}

#if 1
int PDJHUFF_EncodeBlock(PDJPG_Context *ctx,
	short *buf, int dctab, int actab)
{
	int i, j, k;

	PDJHUFF_EncodeVal(ctx, dctab, 0, buf[0]);

	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			PDJHUFF_EncodeVal(ctx, actab, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			PDJHUFF_EncodeSymbol(ctx, actab, 0);
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_EncodeVal(ctx, actab, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
	return(0);
}


int PDJHUFF_StatBlock(short *buf, int *dcstat, int *acstat)
{
	int i, j, k;

	PDJHUFF_StatVal(dcstat, 0, buf[0]);
	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			PDJHUFF_StatVal(acstat, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			acstat[0]++;
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_StatVal(acstat, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
	return(0);
}
#endif

#if defined(X86) || defined(X86_64)
#define memcpy8(dst, src)	(*(double *)(dst)=*(double *)(src))
#else
#define memcpy8(dst, src)	memcpy(dst, src, 8)
#endif

#define memcpy16(dst, src)	memcpy(dst, src, 16)

#if 0
int PDJPG_GetImgBlk(char *blk, int xo, int yo, byte *img, int xs, int ys)
{
	byte *cs;
	char *ct;
	int i, j, k;

	cs=img+(yo*xs+xo); ct=blk;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); // ct+=8; cs+=xs;
	return(0);
}
#endif

#if 1
int PDJPG_GetImgBlk16(
	short *blk, int xo, int yo,
	short *img, int xs, int ys)
{
	short *cs;
	short *ct;
	int i, j, k;

	cs=img+(yo*xs+xo); ct=blk;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs);
	return(0);
}
#endif

// int PDJPG_FilterImageDCT(byte *ibuf, short *obuf, int xs, int ys)
int PDJPG_FilterImageDCT(short *ibuf, short *obuf,
	int xs, int ys, int dcbias)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
//	char blk[DCTSZ2];
	short blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
//		PDJPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_GetImgBlk16(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_TransDCT(blk, obuf+k*DCTSZ2, dcbias);
//		PDJPG_TransQDCT(blk, obuf+k*DCTSZ2, dcbias);
		k++;
	}
	return(0);
}

//int PDJPG_FilterImageRDCT(byte *ibuf, short *obuf, int xs, int ys)
int PDJPG_FilterImageRDCT(short *ibuf, short *obuf,
	int xs, int ys, int dcbias)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
//	char blk[DCTSZ2];
	short blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
//		PDJPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_GetImgBlk16(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_TransRDCT(blk, obuf+k*DCTSZ2, dcbias);
		k++;
	}
	return(0);
}

void PDJPG_EmitDQT(PDJPG_Context *ctx, int n)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DQT;

	i=64+3;
	*pdjhuff_ct++=i>>8;
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=n;
	for(i=0; i<64; i++)
		*pdjhuff_ct++=ctx->jpg_qt[n][pdjpg_zigzag2[i]];
}

void PDJPG_EmitSOF(PDJPG_Context *ctx, int xs, int ys)
{
	byte *p;
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOF0;

	i=8+(ctx->jpg_mono?1:3)*3;
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=8; 	//P

	*pdjhuff_ct++=ys>>8;	//Y
	*pdjhuff_ct++=ys&0xFF;	//Y
	*pdjhuff_ct++=xs>>8;	//X
	*pdjhuff_ct++=xs&0xFF;	//X

	if(ctx->jpg_mono)
	{
		*pdjhuff_ct++=1;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
	}else if(ctx->jpg_is420)
	{
		if(!ctx->jpg_yuvw)
		{
			//YUV 4:2:0
		
			*pdjhuff_ct++=3;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x22;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}else
		{
			//YUVW 4:2:0

			*pdjhuff_ct++=4;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x22;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=4;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}
	}else
	{
		if(!ctx->jpg_yuvw)
		{
			//YUV 4:4:4

			*pdjhuff_ct++=3;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}else
		{
			//YUVW 4:4:4

			*pdjhuff_ct++=4;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=4;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}
	}

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void PDJPG_EmitSOS(PDJPG_Context *ctx)
{
	byte *p;
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOS;

	i=6+(ctx->jpg_mono?1:3)*2;
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	if(ctx->jpg_yuvw)
	{
		*pdjhuff_ct++=4; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=4;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else if(!ctx->jpg_mono)
	{
		*pdjhuff_ct++=3; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else
	{
		*pdjhuff_ct++=1; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
	}

	*pdjhuff_ct++=0; 	//Ss
	*pdjhuff_ct++=63; 	//Se
	*pdjhuff_ct++=0x00; 	//Ah Al

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void PDJPG_EmitDHT(PDJPG_Context *ctx, int tab)
{
	byte *p;
	int i, j, k;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DHT;

	i=8+3*1;	//temp value
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	i=(tab/2)|((tab&1)<<4);
	*pdjhuff_ct++=i; 	//Tc Th

	tab<<=8;
	for(i=1; i<=16; i++)
	{
		k=0;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
				k++;
		*pdjhuff_ct++=k; 	//Li
	}

	k=0;
	for(i=1; i<=16; i++)
	{
		k<<=1;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
		{
			*pdjhuff_ct++=j; 	//Vi
			ctx->huff_code[tab|j]=k++;
		}
	}

	if(k>=65536)
		printf("PDJPG_EmitDHT: Error %04X\n", k);

//	printf("DHT %04X\n", k);

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}


static int pdjpg_ijg_qtab_y[64] = {
16, 11, 10, 16,  24,  40,  51,  61,
12, 12, 14, 19,  26,  58,  60,  55,
14, 13, 16, 24,  40,  57,  69,  56,
14, 17, 22, 29,  51,  87,  80,  62,
18, 22, 37, 56,  68, 109, 103,  77,
24, 35, 55, 64,  81, 104, 113,  92,
49, 64, 78, 87, 103, 121, 120, 101,
72, 92, 95, 98, 112, 100, 103,  99};

static int pdjpg_ijg_qtab_uv[64] = {
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
47, 66, 99, 99, 99, 99, 99, 99,
24, 26, 56, 99, 99, 99, 99, 99,
18, 21, 26, 66, 99, 99, 99, 99,
17, 18, 24, 47, 99, 99, 99, 99};

void PDJPG_MakeQuantTabFastIJG_Y(
	short *inv, int cnt, byte *tab, float qf)
{
	double s, q;
	int i, j;

	q = (qf * 100);
	s = (q < 50) ? 5000 / q : (200 - 2 * q);
	for (i = 0; i < 64; i++)
	{
		j = (int)((s * pdjpg_ijg_qtab_y[i] + 50) / 100);
		j = (j < 1) ? 1 : ((j < 256) ? j : 255);
		tab[i] = j;
	}
}

void PDJPG_MakeQuantTabFastIJG_UV(
	short *inv, int cnt, byte *tab, float qf)
{
	double s, q;
	int i, j;

	q = (qf * 100);
	s = (q < 50) ? 5000 / q : (200 - 2 * q);
	for (i = 0; i < 64; i++)
	{
		j = (int)((s * pdjpg_ijg_qtab_y[i] + 50) / 100);
		j = (j < 1) ? 1 : ((j < 256) ? j : 255);
		tab[i] = j;
	}
}

void PDJPG_MakeQuantTabInput(short *inv, int cnt, byte *tab, float q)
{
	PDJPG_MakeQuantTabInput_AA(inv, cnt, tab, q);
}

void PDJPG_MakeQuantTabInputY(short *inv, int cnt, byte *tab, float q)
{
	byte taba[64], tabb[64];
	int i;

	//PDJPG_MakeQuantTabInput_AA(inv, cnt, tab, q);
	//PDJPG_MakeQuantTabFastIJG_UV(inv, cnt, tab, q);

	PDJPG_MakeQuantTabInput_AA(inv, cnt, taba, q);
	PDJPG_MakeQuantTabFastIJG_UV(inv, cnt, tabb, q);
	for (i = 0; i < 64; i++)
		tab[i] = (taba[i] + tabb[i]) / 2;
}

void PDJPG_MakeQuantTabInputUV(short *inv, int cnt, byte *tab, float q)
{
	byte taba[64], tabb[64];
	int i;

	//PDJPG_MakeQuantTabInput_AA(inv, cnt, tab, q);
	//PDJPG_MakeQuantTabFastIJG_UV(inv, cnt, tab, q);

	PDJPG_MakeQuantTabInput_AA(inv, cnt, taba, q);
	PDJPG_MakeQuantTabFastIJG_UV(inv, cnt, tabb, q);
	for (i = 0; i < 64; i++)
		tab[i] = (taba[i] + tabb[i]) / 2;
}

void PDJPG_MakeQuantTabInput_AA(short *in, int cnt, byte *tab, float q)
{
//	static double deltas[DCTSZ2];
	double deltas[DCTSZ2];
	double f, g, te;
	int i, j, k;

	if(q>=1)
	{
		for(i=0; i<DCTSZ2; i++)
			tab[i]=1;
		return;
	}

	for(j=0; j<DCTSZ2; j++)
		deltas[j]=0;

	for(i=0; i<cnt; i++)
		for(j=0; j<DCTSZ2; j++)
	{
		f=in[i*DCTSZ2+j];
		deltas[j]+=f*f;
	}
	for(j=0; j<DCTSZ2; j++)
	{
		deltas[j]=sqrt(deltas[j]/cnt);
//		deltas[j]/=cnt;
	}

	te=0;
	for(j=0; j<DCTSZ2; j++)
		te+=deltas[j];

	for(i=0; i<DCTSZ; i++)
	{
		for(j=0; j<DCTSZ; j++)
		{
			f=deltas[i*DCTSZ+j];

			f=f/te;
			if(f<0.00001)f=0.00001;
			g=(1.0-q);
			f=10*g*g*g/f;
			k=f;
			if(k<1)k=1;
			if(k>255)k=255;

//			printf("%f/%f %d\n", deltas[i*DCTSZ+j], te, k);

//			if(f<1)f=1;
//			if(f>255)f=255;
			tab[i*DCTSZ+j]=k;
		}
	}

#if 1
	if(tab[DCTSZ2-3]>1)tab[DCTSZ2-3]*=0.75;
	if(tab[DCTSZ2-2]>1)tab[DCTSZ2-2]*=0.75;
	if(tab[DCTSZ2-1]>1)tab[DCTSZ2-1]*=0.5;
#endif
}

void PDJPG_MakeQuantTabInputFast(
	short *in, int cnt, byte *tab, float q)
{
	int i;
//	PDJPG_MakeQuantTabInput(in, cnt, tab, q);

	i=cnt/16;
	if(i<1)i=1;
	PDJPG_MakeQuantTabInputY(in, i, tab, q);
}

void PDJPG_EmitMarkerBCST(PDJPG_Context *ctx)
{
	byte *lfp;
	int i, j, k;

	if(ctx->jpg_rdct)
	{
		//Emit libjpeg SERM marker
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP9;

		lfp=pdjhuff_ct;
		*pdjhuff_ct++=0x00;	//length
		*pdjhuff_ct++=0x00;
		*pdjhuff_ct++='J';
		*pdjhuff_ct++='P';
		*pdjhuff_ct++='S';
		*pdjhuff_ct++='E';
		*pdjhuff_ct++='R';
		*pdjhuff_ct++='M';
		*pdjhuff_ct++=0;

		i=pdjhuff_ct-lfp;
		lfp[0]=i>>8;	//length
		lfp[1]=i&0xFF;
	}

	if(ctx->jpg_clrtrans==PDJPG_CLRS_RGB)
	{
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP14;

		lfp=pdjhuff_ct;
		*pdjhuff_ct++=0x00;	//length
		*pdjhuff_ct++=0x00;

		*pdjhuff_ct++='A';
		*pdjhuff_ct++='d';
		*pdjhuff_ct++='o';
		*pdjhuff_ct++='b';
		*pdjhuff_ct++='e';

		i=100;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		i=0;
		*pdjhuff_ct++=(i>>24)&0xFF;
		*pdjhuff_ct++=(i>>16)&0xFF;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		*pdjhuff_ct++=0;	//RGB
//		*pdjhuff_ct++=ctx->bcst_bpp;

		i=pdjhuff_ct-lfp;
		lfp[0]=i>>8;	//length
		lfp[1]=i&0xFF;
	}

	ctx->bcst_version=0x0100;
	ctx->bcst_flags=0;
	ctx->bcst_trans=ctx->jpg_clrtrans;
	ctx->bcst_bpp=8;

	if(ctx->jpg_rdct)
		ctx->bcst_flags|=PDJPG_BCSFL_RDCT;

	//check if not to bother with marker...
	if(!ctx->bcst_flags && !ctx->bcst_trans)
	{
//		printf("PDJPG_EmitMarkerBCST: No Emit\n");
		return;
	}

//	printf("PDJPG_EmitMarkerBCST: Emit\n");

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP12;

	lfp=pdjhuff_ct;
	*pdjhuff_ct++=0x00;	//length
	*pdjhuff_ct++=0x00;

	*pdjhuff_ct++='B';
	*pdjhuff_ct++='C';
	*pdjhuff_ct++='S';
	*pdjhuff_ct++='T';

	*pdjhuff_ct++=(ctx->bcst_version>>8)&0xFF;
	*pdjhuff_ct++=ctx->bcst_version&0xFF;

	*pdjhuff_ct++=ctx->bcst_trans;
	*pdjhuff_ct++=ctx->bcst_bpp;

	*pdjhuff_ct++=(ctx->bcst_flags>>24)&0xFF;
	*pdjhuff_ct++=(ctx->bcst_flags>>16)&0xFF;
	*pdjhuff_ct++=(ctx->bcst_flags>>8)&0xFF;
	*pdjhuff_ct++=ctx->bcst_flags&0xFF;


	i=pdjhuff_ct-lfp;
	lfp[0]=i>>8;	//length
	lfp[1]=i&0xFF;
}

PDGL_API int PDJPG_EncodeCtx_Prepare(
	PDJPG_Context *ctx, int xs, int ys, int qfl, int pf)
{
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l, qf;

	qf=qfl&255;

	ctx->jpg_is420=1;

	if((qf==110) || (qf==111) || (qfl&PDJPG_QFL_444) ||
			(qf==102) || (qf==103))
		ctx->jpg_is420=0;

//	ctx->jpg_is444=0;

	if(ctx->jpg_is420)
	{
		xs2=((xs+7)/8)*8;
		ys2=((ys+7)/8)*8;
//		xs3=(xs2+1)/2;
//		ys3=(ys2+1)/2;

		xs3=((xs+15)/16)*8;
		ys3=((ys+15)/16)*8;
		ctx->jpg_is444=0;
	}else
	{
		xs2=((xs+7)/8)*8;
		ys2=((ys+7)/8)*8;
		xs3=xs2;
		ys3=ys2;
		ctx->jpg_is444=1;
	}
	
	ctx->xs=xs;
	ctx->ys=ys;
	ctx->xs2=xs2;
	ctx->ys2=ys2;
	ctx->xs3=xs3;
	ctx->ys3=ys3;

	ctx->jpg_mono=0;
	ctx->jpg_yuvw=0;
	ctx->jpg_tabcacheframe=0;
	ctx->xs=xs;
	ctx->ys=ys;

	if(pf==PDJPG_YYYA)
		ctx->jpg_mono=1;

	ctx->jpg_rdct=0;
	if((qf==110) || (qf==111) || (qfl&PDJPG_QFL_RDCT))
		ctx->jpg_rdct=1;

	ctx->jpg_clrtrans=0;
	if((qf==110) || (qfl&PDJPG_QFL_ORCT) || (qf==101) || (qf==103))
		ctx->jpg_clrtrans=PDJPG_CLRS_ORCT;
	if((qf==111) || (qfl&PDJPG_QFL_RGB) || (qf==104))
		ctx->jpg_clrtrans=PDJPG_CLRS_RGB;

	//full quality
	for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
	for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;

	//dummy huffman tables
	for(i=0; i<256; i++)ctx->huff_len[0*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[1*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[2*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[3*256+i]=0;

	for(i=0; i<16; i++)ctx->huff_len[0*256+i]=4;
	for(i=0; i<16; i++)ctx->huff_len[2*256+i]=4;
	for(i=0; i<255; i++)ctx->huff_len[1*256+i]=8;
	for(i=0; i<255; i++)ctx->huff_len[3*256+i]=8;

//	for(i=0; i<255; i++)ctx->huff_len[0*256+i]=8;
//	for(i=0; i<255; i++)ctx->huff_len[2*256+i]=8;


//	ctx->huff_len[1*256+0]=7;

//	printf("M0\n");

	//make sure intermediate buffers are present and the correct size
	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		//W channel is rare, and so is handled specially
		if(ctx->wb)
		{
			free(ctx->wb);
			free(ctx->wdb);
		}

//		ctx->yb=malloc(xs2*ys2);
//		ctx->ub=malloc(xs2*ys2);
//		ctx->vb=malloc(xs2*ys2);

		ctx->yb=malloc(xs2*ys2*sizeof(short));
		ctx->ub=malloc(xs2*ys2*sizeof(short));
		ctx->vb=malloc(xs2*ys2*sizeof(short));

		ctx->ydb=malloc((xs2+8)*(ys2+8)*sizeof(short));
//		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
//		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->udb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		ctx->vdb=malloc((xs2+8)*(ys2+8)*sizeof(short));

		if(ctx->jpg_yuvw)
		{
			ctx->wb=malloc(xs2*ys2*sizeof(short));
			ctx->wdb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		}

		ctx->lxs=xs;
		ctx->lys=ys;
	}

//	memset(ctx->yb, 128, xs2*ys2);
//	memset(ctx->ub, 128, xs2*ys2);
//	memset(ctx->vb, 128, xs2*ys2);

	memset(ctx->yb, 128, xs2*ys2*sizeof(short));
	memset(ctx->ub, 128, xs2*ys2*sizeof(short));
	memset(ctx->vb, 128, xs2*ys2*sizeof(short));

	memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
	memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
	memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

	if(ctx->jpg_yuvw)
	{
		memset(ctx->wb, 128, xs2*ys2*sizeof(short));
		memset(ctx->wdb, 0, xs2*(ys2+8)*sizeof(short));
	}
}

PDGL_API int PDJPG_EncodeCtx_ColorTransform(
	PDJPG_Context *ctx, byte *ibuf, int xs, int ys, int pf)
{
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, ca, cy, cu, cv, cw;
	int i, j, k, l, qf;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];
		ca=ibuf[(k*xs+j)*4+2];

//		if(qf==110)
		if(ctx->jpg_clrtrans==PDJPG_CLRS_YCBCR)
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;

			cy=(cy<0)?0:((cy>255)?255:cy);
			cu=(cu<0)?0:((cu>255)?255:cu);
			cv=(cv<0)?0:((cv>255)?255:cv);
		}else if(ctx->jpg_clrtrans==PDJPG_CLRS_ORCT)
		{
//			cy=(cr+2*cg+cb)/4;
			cy=cg+(cb+cr-2*cg)/4;
			cu=(cb-cg)+128;
			cv=(cr-cg)+128;
			cw=ca;
//			k=cy-(cu+cv-256)/4;
//			cy+=cg-k;
//			if(k!=cg)cy++;

//			cu=cb-cr;
//			cv=cg-cr-0.5*cu;
//			cy=cg-0.5*cv;
//			cu+=128; cv+=128;
		}else if(ctx->jpg_clrtrans==PDJPG_CLRS_RGB)
		{
			cy=cr;
			cu=cg;
			cv=cb;
			cw=ca;
		}else
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;
		}

//		cu=128; cv=128;

//		cy=(cy<0)?0:((cy>255)?255:cy);
//		cu=(cu<0)?0:((cu>255)?255:cu);
//		cv=(cv<0)?0:((cv>255)?255:cv);

		ctx->yb[i*xs2+j]=cy;
		ctx->ub[i*xs2+j]=cu;
		ctx->vb[i*xs2+j]=cv;
		if(ctx->jpg_yuvw)
			ctx->wb[i*xs2+j]=cw;
	}

}

PDGL_API int PDJPG_EncodeCtx_ColorTransform16(
	PDJPG_Context *ctx, short *ibuf, int xs, int ys, int pf)
{
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, ca, cy, cu, cv, cw;
	int i, j, k, l, qf;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];
		ca=ibuf[(k*xs+j)*4+2];

//		if(qf==110)
		if(ctx->jpg_clrtrans==PDJPG_CLRS_YCBCR)
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;

			//cy=(cy<0)?0:((cy>255)?255:cy);
			//cu=(cu<0)?0:((cu>255)?255:cu);
			//cv=(cv<0)?0:((cv>255)?255:cv);
		}else if(ctx->jpg_clrtrans==PDJPG_CLRS_ORCT)
		{
//			cy=(cr+2*cg+cb)/4;
			cy=cg+(cb+cr-2*cg)/4;
			cu=(cb-cg)+128;
			cv=(cr-cg)+128;
			cw=ca;
		}else if(ctx->jpg_clrtrans==PDJPG_CLRS_RGB)
		{
			cy=cr; cu=cg; cv=cb; cw=ca;
		}else
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;
		}

//		cu=128; cv=128;

//		cy=(cy<0)?0:((cy>255)?255:cy);
//		cu=(cu<0)?0:((cu>255)?255:cu);
//		cv=(cv<0)?0:((cv>255)?255:cv);

		ctx->yb[i*xs2+j]=cy;
		ctx->ub[i*xs2+j]=cu;
		ctx->vb[i*xs2+j]=cv;
		if(ctx->jpg_yuvw)
			ctx->wb[i*xs2+j]=cw;
	}

}

PDGL_API int PDJPG_EncodeCtx_DownSample(PDJPG_Context *ctx)
{
	int xs2, ys2, xs3, ys3;
	int i, j, k, l;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

//	if((xs3!=xs2) || (ys3!=ys2))
	if(ctx->jpg_is420)
	{
		for(i=0; i<ys3; i++)
			for(j=0; j<xs3; j++)
		{
			k=ctx->ub[(i*2)*xs2+j*2]+
				ctx->ub[(i*2)*xs2+j*2+1]+
				ctx->ub[(i*2+1)*xs2+j*2]+
				ctx->ub[(i*2+1)*xs2+j*2+1];
			ctx->ub[i*xs3+j]=k/4;

			k=ctx->vb[(i*2)*xs2+j*2]+
				ctx->vb[(i*2)*xs2+j*2+1]+
				ctx->vb[(i*2+1)*xs2+j*2]+
				ctx->vb[(i*2+1)*xs2+j*2+1];
			ctx->vb[i*xs3+j]=k/4;

			if(ctx->jpg_yuvw)
			{
				k=ctx->wb[(i*2)*xs2+j*2]+
					ctx->wb[(i*2)*xs2+j*2+1]+
					ctx->wb[(i*2+1)*xs2+j*2]+
					ctx->wb[(i*2+1)*xs2+j*2+1];
				ctx->wb[i*xs3+j]=k/4;
			}
		}
	}
}

PDGL_API int PDJPG_EncodeCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf, int xs, int ys,
	int qfl, int pf)
{
	int i;
	PDJPG_EncodeCtx_Prepare(ctx, xs, ys, qfl, pf);
	PDJPG_EncodeCtx_ColorTransform(ctx, ibuf, xs, ys, pf);
	PDJPG_EncodeCtx_DownSample(ctx);
	i=PDJPG_EncodeCtx_Inner(ctx, obuf, xs, ys, qfl);
	return(i);
}

PDGL_API int PDJPG_EncodeCtxSS(
	PDJPG_Context *ctx, short *ibuf, byte *obuf, int xs, int ys,
	int qfl, int pf)
{
	int i;
	PDJPG_EncodeCtx_Prepare(ctx, xs, ys, qfl, pf);
	PDJPG_EncodeCtx_ColorTransform16(ctx, ibuf, xs, ys, pf);
	PDJPG_EncodeCtx_DownSample(ctx);
	i=PDJPG_EncodeCtx_Inner(ctx, obuf, xs, ys, qfl);
	return(i);
}

PDGL_API int PDJPG_EncodeCtx_Inner(
	PDJPG_Context *ctx, byte *obuf, int xs, int ys, int qfl)
{
//	static byte *yb=NULL, *ub, *vb;
//	static short *ydb=NULL, *udb, *vdb;
//	static int lxs=0, lys=0;

	int dcs[256], acs[256];
	int dcsuv[256], acsuv[256];
	short *tp;
	int xs2, ys2, xs3, ys3, qf;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l;

	qf=qfl&255;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

//	printf("M1\n");

//	if(qf==110)
	if(ctx->jpg_rdct)
	{
//		printf("PDJPG_EncodeCtx: Lossless Detect\n");
	
		PDJPG_FilterImageRDCT(ctx->yb, ctx->ydb, xs2, ys2, 128);
		PDJPG_FilterImageRDCT(ctx->ub, ctx->udb, xs3, ys3, 128);
		PDJPG_FilterImageRDCT(ctx->vb, ctx->vdb, xs3, ys3, 128);
	}else
	{
		PDJPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2, 128);
		PDJPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3, 128);
		PDJPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3, 128);
	}

	j=(xs2/8)*(ys2/8);
	PDJPG_MakeQuantTabInput(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

	j=(xs3/8)*(ys3/8);
	PDJPG_MakeQuantTabInput(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
	PDJPG_MakeQuantTabInput(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
	for(i=0; i<64; i++)ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

	PDJPG_SetupQuantTabDivFP(ctx, 0);
	PDJPG_SetupQuantTabDivFP(ctx, 1);

//	free(yb);
//	free(ub);
//	free(vb);


	if(ctx->jpg_mono || !ctx->jpg_is420)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k; k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono && ctx->jpg_is420)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

#if 0
	if(!ctx->jpg_mono && !ctx->jpg_is420)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 1);
			ctx->ydb[i*64+0]-=l; l=ctx->ydb[i*64+0]+l;
		}
	}
#endif

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		PDJHUFF_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

	if(ctx->jpg_yuvw)
	{
		j=(xs3/8)*(ys3/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->wdb+i*64, ctx->wdb+i*64, 1);
			ctx->wdb[i*64+0]-=k; k=ctx->wdb[i*64+0]+k;
		}
	}

//	printf("M2\n");

	for(i=0; i<256; i++)dcs[i]=0;
	for(i=0; i<256; i++)acs[i]=0;
	for(i=0; i<256; i++)dcsuv[i]=0;
	for(i=0; i<256; i++)acsuv[i]=0;

	j=(xs2/8)*(ys2/8);
	k=(xs3/8)*(ys3/8);
	for(i=0; i<j; i++)PDJHUFF_StatBlock(ctx->ydb+i*64, dcs, acs);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->udb+i*64, dcsuv, acsuv);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->vdb+i*64, dcsuv, acsuv);
	
	if(ctx->jpg_yuvw)
		{ for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->wdb+i*64, dcsuv, acsuv); }

//	PDJHUFF_BuildLengths(dcs, 256, ctx->huff_len+0*256, 16);
//	PDJHUFF_BuildLengths(acs, 256, ctx->huff_len+1*256, 16);
//	PDJHUFF_BuildLengths(dcsuv, 256, ctx->huff_len+2*256, 16);
//	PDJHUFF_BuildLengths(acsuv, 256, ctx->huff_len+3*256, 16);

	PDJHUFF_BuildLengthsAdjust(dcs, 256, ctx->huff_len+0*256, 16);
	PDJHUFF_BuildLengthsAdjust(acs, 256, ctx->huff_len+1*256, 16);
	PDJHUFF_BuildLengthsAdjust(dcsuv, 256, ctx->huff_len+2*256, 16);
	PDJHUFF_BuildLengthsAdjust(acsuv, 256, ctx->huff_len+3*256, 16);

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	PDJPG_EmitMarkerBCST(ctx);

	PDJPG_EmitDQT(ctx, 0);
	if(!ctx->jpg_mono)PDJPG_EmitDQT(ctx, 1);

	PDJPG_EmitSOF(ctx, xs, ys);

	PDJPG_EmitDHT(ctx, 0);
	PDJPG_EmitDHT(ctx, 1);
	if(!ctx->jpg_mono)
	{
		PDJPG_EmitDHT(ctx, 2);
		PDJPG_EmitDHT(ctx, 3);
	}

	PDJPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else if(ctx->jpg_is420)
	{
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
			if(ctx->jpg_yuvw)
				{ PDJHUFF_EncodeBlock(ctx, ctx->wdb+k*64, 2, 3); }
		}
	}else
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)
		{
			PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx, ctx->udb+i*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+i*64, 2, 3);
			if(ctx->jpg_yuvw)
				{ PDJHUFF_EncodeBlock(ctx, ctx->wdb+i*64, 2, 3); }
		}

#if 0
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->ydb+k*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
#endif
	}

	PDJHUFF_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

//	free(ydb);
//	free(udb);
//	free(vdb);

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

PDGL_API PDJPG_Context *PDJPG_AllocContext()
{
	PDJPG_Context *ctx;

	PDJPG_Init();
	ctx=malloc(sizeof(PDJPG_Context));
	memset(ctx, 0, sizeof(PDJPG_Context));
	return(ctx);
}

PDGL_API void PDJPG_FreeContext(PDJPG_Context *ctx)
{
	if(ctx->yb)
	{
		free(ctx->yb);
		free(ctx->ub);
		free(ctx->vb);
		free(ctx->ydb);
		free(ctx->udb);
		free(ctx->vdb);
	}

	if(ctx->jpg_imgbuf)
		free(ctx->jpg_imgbuf);

	if(ctx->imgbuf_rgba)
		free(ctx->imgbuf_rgba);
	if(ctx->imgbuf_norm)
		free(ctx->imgbuf_norm);
	if(ctx->imgbuf_spec)
		free(ctx->imgbuf_spec);
	if(ctx->imgbuf_luma)
		free(ctx->imgbuf_luma);
	if(ctx->imgbuf_lebe)
		free(ctx->imgbuf_lebe);

	free(ctx);
}

PDGL_API int PDJPG_Encode(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	PDJPG_Context *ctx;
	int sz;
	
	ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
	PDJPG_FreeContext(ctx);
	return(sz);
}

PDGL_API void PDJPG_FlushEncodeFast(PDJPG_Context *ctx)
{
	if(!ctx)return;
	ctx->jpg_tabcacheframe=0;	//force rebuild
	ctx->oldAlphaClr=0;
}

PDGL_API void PDJPG_SetContextAlphaColor(PDJPG_Context *ctx,
	int cr, int cg, int cb, int ca)
{
	int cy, cu, cv;
	if(!ctx)return;

	if(ca<1)
	{
		ctx->alphaClr=0;
		return;
	}

	ctx->alphaClr=cr+(cg<<8)+(cb<<16)+(ca<<24);

	cy= 19595*cr +38470*cg + 7471*cb;
	cu=-11056*cr -21712*cg +32768*cb;
	cv= 32768*cr -27440*cg - 5328*cb;
	ctx->alphaClrY=cy>>16;
	ctx->alphaClrU=(cu>>16)+128;
	ctx->alphaClrV=(cv>>16)+128;
	ctx->alphaClrA=ca;
}

#if 0
//static void pdjpg_getPixel2_RGBA(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb)
//{
//	*ra=rgb[0]; *ga=rgb[1]; *ba=rgb[2];
//	*ra=rgb[4]; *ga=rgb[5]; *ba=rgb[6];
//}
#endif

void PDJPG_ConvertImageYUV(PDJPG_Context *ctx,
	byte *ibuf, int xs, int ys, int pf,
	int xs2, int ys2, int xs3, int ys3)
{
//	void (*getPixel2)(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb);
	byte *cs, *cse;
	short *cty, *ctu, *ctv;
	byte *cs1, *cs2;
	short *cty1, *cty2;

	int cr, cg, cb, ca, cy, cu, cv;

	int cra, cga, cba, caa, cya, cua, cva;
	int crb, cgb, cbb, cab, cyb, cub, cvb;
	int crc, cgc, cbc, cac, cyc, cuc, cvc;
	int crd, cgd, cbd, cad, cyd, cud, cvd;
	int psz, psz2;

	int i, j, k, l, n;

	if((pf==PDJPG_RGBA) && !ctx->alphaClr)
	{
		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*4;
			cs1=ibuf+k; cse=cs1+xs*4;
			l=((ys-(2*i+2))*xs)*4;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
				cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2);
				crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6);
				crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2);
				crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6);

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=8; cs2+=8;
			}
		}
	}else
	if((pf==PDJPG_RGBA) || (pf==PDJPG_RGB) ||
		(pf==PDJPG_BGRA) || (pf==PDJPG_BGR))
	{
		switch(pf)
		{
		case PDJPG_RGBA: case PDJPG_BGRA:
			psz=4; break;
		case PDJPG_RGB: case PDJPG_BGR:
			psz=3; break;
		default: psz=4; break;
		}
		psz2=psz*2;

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*psz;
			cs1=ibuf+k; cse=cs1+xs*psz;
			l=((ys-(2*i+2))*xs)*psz;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case PDJPG_RGBA:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=*(cs1+3);
					crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6); cab=*(cs1+7);
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=*(cs2+3);
					crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6); cad=*(cs2+7);
					psz=8; break;
				case PDJPG_BGRA:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=*(cs1+3);
					crb=*(cs1+6); cgb=*(cs1+5); cbb=*(cs1+4); cab=*(cs1+7);
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=*(cs2+3);
					crd=*(cs2+6); cgd=*(cs2+5); cbd=*(cs2+4); cad=*(cs2+7);
					psz=8; break;
				case PDJPG_RGB:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=255;
					crb=*(cs1+3); cgb=*(cs1+4); cbb=*(cs1+5); cab=255;
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=255;
					crd=*(cs2+3); cgd=*(cs2+4); cbd=*(cs2+5); cad=255;
					psz=6; break;
				case PDJPG_BGR:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=255;
					crb=*(cs1+5); cgb=*(cs1+4); cbb=*(cs1+3); cab=255;
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=255;
					crd=*(cs2+5); cgd=*(cs2+4); cbd=*(cs2+3); cad=255;
					psz=6; break;
				}

				if(ctx->alphaClr)
				{
					ca=(caa+cab+cac+cad)>>2;
					if(ca<ctx->alphaClrA)
					{
						cy=ctx->alphaClrY;
						cu=ctx->alphaClrU;
						cv=ctx->alphaClrV;
						*cty1++=cy; *cty1++=cy;
						*cty2++=cy; *cty2++=cy;
						*ctu++=cu; *ctv++=cv;
						continue;
					}
				}

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}else
	{
		switch(pf)
		{
		case PDJPG_YUVA: psz=4; psz2=8; break;
		case PDJPG_YUV: psz=3; psz2=6; break;
		case PDJPG_YUV422: psz=2; psz2=4; break;
		case PDJPG_YUV420: psz=3; psz2=3; break;
		case PDJPG_YA: psz=2; psz2=4; break;
		case PDJPG_Y: psz=1; psz2=2; break;
		case PDJPG_YYYA: psz=4; psz2=8; break;
		default: psz=4; psz2=8; break;
		}

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			if(pf==PDJPG_YUV420)
			{
				k=(((ys-(2*i+1))*xs2)*psz2)>>1;
				cs1=ibuf+k; cse=cs1+((xs*psz2)>>1);
				l=(((ys-(2*i+2))*xs2)*psz2)>>1;
				cs2=ibuf+l;
			}else
			{
				k=((ys-(2*i+1))*xs)*psz;
				cs1=ibuf+k; cse=cs1+xs*psz;
				l=((ys-(2*i+2))*xs)*psz;
				cs2=ibuf+l;
			}

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case PDJPG_YUVA:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+4); cub=*(cs1+5); cvb=*(cs1+6);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+4); cud=*(cs2+5); cvd=*(cs2+6);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case PDJPG_YUV:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+3); cub=*(cs1+4); cvb=*(cs1+5);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+3); cud=*(cs2+4); cvd=*(cs2+5);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case PDJPG_YUV422:
					cya=*(cs1+0); cua=*(cs1+1); cyb=*(cs1+2); cva=*(cs1+3);
					cyc=*(cs2+0); cuc=*(cs2+1); cyd=*(cs2+2); cvc=*(cs2+3);
					cu=(cua+cuc)>>1; cv=(cva+cvc)>>1;
					break;
				case PDJPG_YUV420:
					cya=*(cs1+0); cyb=*(cs1+1); cu=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+1); cv=*(cs2+2);
					break;
				case PDJPG_YA:
					cya=*(cs1+0); cyb=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+2);
					cu=0; cv=0;
					break;
				case PDJPG_Y:
					cya=*(cs1+0); cyb=*(cs1+1);
					cyc=*(cs2+0); cyd=*(cs2+1);
					cu=0; cv=0;
					break;

				case PDJPG_YYYA:
					cya=*(cs1+1); cyb=*(cs1+5);
					cyc=*(cs2+1); cyd=*(cs2+5);
					cu=0; cv=0;
					break;
				}

				*cty1++=cya; *cty1++=cyb;
				*cty2++=cyc; *cty2++=cyd;
				*ctu++=cu; *ctv++=cv;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}
}

PDGL_API int PDJPG_EncodeFastCtx(PDJPG_Context *ctx,
	byte *ibuf, byte *obuf, int xs, int ys, int qf, int pf)
{
	char tb[256];
	short *tp;
//	byte *cs, *cse, *cty, *ctu, *ctv;
	int xs2, ys2, xs3, ys3;
//	int cr, cg, cb, cy, cu, cv;

//	int cra, cga, cba, cya;
//	int crb, cgb, cbb, cyb;
//	int crc, cgc, cbc, cyc;
//	int crd, cgd, cbd, cyd;
//	byte *cs1, *cs2, *cty1, *cty2;
	byte *ctt;

	int i, j, k, l, n;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	ctx->jpg_mono=0;

	if(!ctx->jpg_tabcacheframe)
	{
		//full quality
		for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
		for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;
	}

	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->yb=malloc(xs2*ys2);
		ctx->ub=malloc(xs2*ys2);
		ctx->vb=malloc(xs2*ys2);

		ctx->ydb=malloc((xs2+8)*(ys2+16)*sizeof(short));
		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;

		memset(ctx->yb, 128, xs2*ys2);
		memset(ctx->ub, 128, xs2*ys2);
		memset(ctx->vb, 128, xs2*ys2);

		memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
		memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
		memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

		ctx->jpg_tabcacheframe=0;	//force rebuild
	}

	PDJPG_ConvertImageYUV(ctx,
		ibuf, xs, ys, pf,
		xs2, ys2, xs3, ys3);

	PDJPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2, 128);
	PDJPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3, 128);
	PDJPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3, 128);

	if(ctx->jpg_tabcacheframe<=0)
	{
		j=(xs2/8)*(ys2/8);
		PDJPG_MakeQuantTabInputFast(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

		j=(xs3/8)*(ys3/8);
		PDJPG_MakeQuantTabInputFast(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
		PDJPG_MakeQuantTabInputFast(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
		for(i=0; i<64; i++)
			ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

		PDJPG_SetupQuantTabDivFP(ctx, 0);
		PDJPG_SetupQuantTabDivFP(ctx, 1);
	}

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k;
			k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		PDJHUFF_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

//	printf("M2\n");

	if(ctx->jpg_tabcacheframe<=0)
	{
		for(i=0; i<256; i++)ctx->dcs[i]=1;
		for(i=0; i<256; i++)ctx->acs[i]=1;
		for(i=0; i<256; i++)ctx->dcsuv[i]=1;
		for(i=0; i<256; i++)ctx->acsuv[i]=1;

		j=(xs2/8)*(ys2/8);
		k=(xs3/8)*(ys3/8);
		for(i=0; i<j; i++)
			PDJHUFF_StatBlock(ctx->ydb+i*64, ctx->dcs, ctx->acs);
		for(i=0; i<k; i++)
			PDJHUFF_StatBlock(ctx->udb+i*64, ctx->dcsuv, ctx->acsuv);
		for(i=0; i<k; i++)
			PDJHUFF_StatBlock(ctx->vdb+i*64, ctx->dcsuv, ctx->acsuv);

//		PDJHUFF_BuildLengths(ctx->dcs, 256, ctx->huff_len+0*256, 16);
//		PDJHUFF_BuildLengths(ctx->acs, 256, ctx->huff_len+1*256, 16);
//		PDJHUFF_BuildLengths(ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
//		PDJHUFF_BuildLengths(ctx->acsuv, 256, ctx->huff_len+3*256, 16);

		PDJHUFF_BuildLengthsAdjust(
			ctx->dcs, 256, ctx->huff_len+0*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->acs, 256, ctx->huff_len+1*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->acsuv, 256, ctx->huff_len+3*256, 16);
	}

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	if(ctx->alphaClr && (ctx->alphaClr!=ctx->oldAlphaClr))
	{
		sprintf(tb, "%d %d %d %d",
			(ctx->alphaClr&0xFF),
			((ctx->alphaClr>>8)&0xFF),
			((ctx->alphaClr>>16)&0xFF),
			((ctx->alphaClr>>24)&0xFF));
	
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP11;
		ctt=pdjhuff_ct;
		*pdjhuff_ct++=0x00;
		*pdjhuff_ct++=0x00;
		PDJHUFF_WriteString(ctx, "AlphaColor");
		PDJHUFF_WriteString(ctx, tb);
		i=(pdjhuff_ct-ctt);
		ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	}


	if(ctx->jpg_tabcacheframe<=0)
	{
		PDJPG_EmitDQT(ctx, 0);
		if(!ctx->jpg_mono)PDJPG_EmitDQT(ctx, 1);
	}

	PDJPG_EmitSOF(ctx, xs, ys);

//	if(ctx->jpg_tabcacheframe<=0)
	if(1)
	{
		PDJPG_EmitDHT(ctx, 0);
		PDJPG_EmitDHT(ctx, 1);
		if(!ctx->jpg_mono)
		{
			PDJPG_EmitDHT(ctx, 2);
			PDJPG_EmitDHT(ctx, 3);
		}
	}

	PDJPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=((ys3)/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
	}

	PDJHUFF_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

	if(ctx->jpg_tabcacheframe<=0)
	{
//		ctx->jpg_tabcacheframe=16;
		ctx->jpg_tabcacheframe=8;
	}else
	{
		ctx->jpg_tabcacheframe--;
	}

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

PDGL_API int PDJPG_EncodeFast(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	static PDJPG_Context *ctx=NULL;
	int sz;
	
	if(!ctx)ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeFastCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
//	PDJPG_FreeContext(ctx);
	return(sz);
}

byte *PDJPG_EmitComponentLayer(PDJPG_Context *ctx,
	byte *ct, char *name)
{
	byte *ctt;
	int i;

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP11;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	PDJHUFF_WriteString(ctx, "CompLayer");
	PDJHUFF_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

byte *PDJPG_EmitMarkerJFIF(PDJPG_Context *ctx, byte *ct)
{
	byte *ctt;
	int i;

	if(ctx->jpg_clrtrans!=PDJPG_CLRS_YCBCR)
		return(ct);

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP0;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	PDJHUFF_WriteString(ctx, "JFIF");

	*pdjhuff_ct++=0x01;		//version high
	*pdjhuff_ct++=0x02;		//version low

	*pdjhuff_ct++=0x00;		//no units

	*pdjhuff_ct++=0x00;		//X density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//Y density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//thumbnail
	*pdjhuff_ct++=0x00;

//	PDJHUFF_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

PDGL_API int PDJPG_EscapeEncodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if(*cs==0xFF)
		{
			cs++;
			*ct++=0xFF;
			*ct++=0x00;
			continue;
		}
		
		*ct++=*cs++;
	}
	
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

PDGL_API int PDJPG_EscapeEncodeSingleBuffer(byte *buf, int sz)
{
	byte *tbuf;
	int i;
	
	tbuf=malloc(sz*2);
	i=PDJPG_EscapeEncodeBuffer(buf, sz, tbuf, sz*2);
	if(i<0)return(i);
	memcpy(buf, tbuf, i);
	free(tbuf);
	return(i);
}

PDGL_API int PDJPG_EscapeDecodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

PDGL_API int PDJPG_EscapeDecodeSingleBuffer(byte *buf, int sz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=buf; cse=buf+sz;
	ct=buf; cte=buf+sz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-buf);
}

PDGL_API int PDJPG_EncodeLDatCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cts;
	int i, j, sz, tsz;
	
//	if(!ctx)ctx=PDJPG_AllocContext();

	tbuf=malloc(1<<20);
	sz=PDJPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);

	sz=PDJPG_EscapeEncodeSingleBuffer(tbuf, sz);

	cts=tbuf; tsz=sz;
	pdjhuff_ct=obuf; pdjhuff_win=0; pdjhuff_pos=0;
	while(tsz>=65528)
	{
		i=65529;
		if(cts[i-1]==0xFF)i--;
		j=i+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(j>>8)&0xFF;
		*pdjhuff_ct++=j&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, i);
		cts+=i; pdjhuff_ct+=i;
		tsz-=i;
	}
	
	if((tsz>0) && (tsz<65528))
	{
		i=tsz+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, tsz);
		pdjhuff_ct+=tsz;
	}

	sz=pdjhuff_ct-obuf;
	free(tbuf);
	
	return(sz);
}

PDGL_API int PDJPG_EncodeBaseCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cs, *cse, *ct;
	int sz;

	tbuf=malloc(1<<20);
	sz=PDJPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);
	
	cs=tbuf; cse=tbuf+sz; ct=obuf;
	if((cs[0]==0xFF) && (cs[1]==JPG_SOI))
		cs+=2;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_EOI))
			break;
		*ct++=*cs++;
	}
	
	free(tbuf);
	return(ct-obuf);
}

PDGL_API int PDJPG_EncodeComponentCtx(
	PDJPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	return(PDJPG_EncodeComponentCtxI(ctx,
		rgba, norm, spec, luma, NULL,
		obuf, xs, ys, qf));
}

PDGL_API int PDJPG_EncodeComponentCtxI(
	PDJPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe,
	byte *obuf, int xs, int ys, int qf)
{
	byte *tbuf;
	byte *ct;
	int i, j, k, n;

	if(!rgba)return(-1);

	n=xs*ys;
	tbuf=malloc(xs*ys*4);

	ct=obuf;

	*ct++=0xFF;
	*ct++=JPG_SOI;

	ct=PDJPG_EmitMarkerJFIF(ctx, ct);

	ct=PDJPG_EmitComponentLayer(ctx, ct, "RGB");
//	i=PDJPG_EncodeCtx(ctx, rgba, ct, xs, ys, qf, 0);
	i=PDJPG_EncodeBaseCtx(ctx, rgba, ct, xs, ys, qf, 0);
	if(i<0) { free(tbuf); return(i); }
	ct+=i;
	
//	if((ct[-2]==0xFF) && (ct[-2]==JPG_EOI))
//		{ ct-=2; }
	
	if(norm)
	{
		for(i=0; i<n; i++)
		{
			tbuf[i*4+0]=norm[i*4+0];
			tbuf[i*4+1]=norm[i*4+2];
			tbuf[i*4+2]=norm[i*4+1];
			tbuf[i*4+3]=255;
		}

		ct=PDJPG_EmitComponentLayer(ctx, ct, "XYZ");
		i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(spec)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "SpRGB");
		i=PDJPG_EncodeLDatCtx(ctx, spec, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(norm || spec)
	{
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			tbuf[i*4+0]=norm?norm[i*4+3]:j;
			tbuf[i*4+1]=rgba[i*4+3];
			tbuf[i*4+2]=spec?spec[i*4+3]:j;
			tbuf[i*4+3]=255;
		}

		ct=PDJPG_EmitComponentLayer(ctx, ct, "DASe");
		i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}else
	{
		k=0;
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			if(j!=255)k=1;
			tbuf[i*4+0]=j;
			tbuf[i*4+1]=j;
			tbuf[i*4+2]=j;
			tbuf[i*4+3]=255;
		}

		if(k)
		{
			ct=PDJPG_EmitComponentLayer(ctx, ct, "Alpha");
			i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, PDJPG_YYYA);
			if(i<0) { free(tbuf); return(i); }
			ct+=i;
		}
	}

	if(luma)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "LuRGB");
		i=PDJPG_EncodeLDatCtx(ctx, luma, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(lebe)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "LeBe");
		i=PDJPG_EncodeLDatCtx(ctx, lebe, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	*ct++=0xFF;
	*ct++=JPG_EOI;

	free(tbuf);
	return(ct-obuf);
}

PDGL_API int PDJPG_EncodeComponent(
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	PDJPG_Context *ctx;
	int sz;
	
	ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeComponentCtx(ctx,
		rgba, norm, spec, luma,
		obuf, xs, ys, qf);
	PDJPG_FreeContext(ctx);
	return(sz);
}

float pdjpg_ssqr(float f)
	{ return((f>=0)?(f*f):(-f*f)); }
float pdjpg_ssqrt(float f)
	{ return((f>=0)?sqrt(f):(-sqrt(-f))); }

int PDJPG_CalcComponentValueExponent(float val)
{
	float f, g;
	int i, j;

	if(val>=0)
	{
		f=log(val)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=192+i;
		return(j);
	}else
	{
		f=log(-val)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=63-i;
		return(j);
	}
}

void PDJPG_EncodeFloatPixel(float *ipix, byte *opix, byte *oexp)
{
	float f, g;
	int i, j, k;

	if((ipix[0]>=0) && (ipix[0]<=1) &&
		(ipix[1]>=0) && (ipix[1]<=1) &&
		(ipix[2]>=0) && (ipix[2]<=1))
	{
		*oexp=192;
		opix[0]=ipix[0]*255;
		opix[1]=ipix[1]*255;
		opix[2]=ipix[2]*255;
		return;
	}
	
	f=ipix[1];
	if(fabs(ipix[0])>fabs(f))f=ipix[0];
	if(fabs(ipix[2])>fabs(f))f=ipix[2];
	
	if(f>=0)
	{
		f=log(f)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=192+i;
		g=pdjpg_scltab[j];

		*oexp=j;
		f=255/g;
		k=ipix[0]*f; k=(k<0)?0:((k<=255)?k:255); opix[0]=k;
		k=ipix[1]*f; k=(k<0)?0:((k<=255)?k:255); opix[1]=k;
		k=ipix[2]*f; k=(k<0)?0:((k<=255)?k:255); opix[2]=k;
		return;
	}else
	{
		f=log(-f)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=63-i;
		g=pdjpg_scltab[j];

		*oexp=j;
		f=255/g;
		k=ipix[0]*f; k=(k<0)?0:((k<=255)?k:255); opix[0]=k;
		k=ipix[1]*f; k=(k<0)?0:((k<=255)?k:255); opix[1]=k;
		k=ipix[2]*f; k=(k<0)?0:((k<=255)?k:255); opix[2]=k;
		return;
	}
}

PDGL_API int PDJPG_EncodeFloatComponentCtx(PDJPG_Context *ctx,
	float *rgba, float *norm, float *spec, float *luma,
	byte *obuf, int xs, int ys, int qf)
{
	byte *trgba, *tnorm, *tspec, *tluma, *tlebe;
	int i, j, n;
	float f, g;

	n=xs*ys;
	if(!ctx->imgbuf_rgba)
		ctx->imgbuf_rgba=malloc(4*n);
	if(!ctx->imgbuf_norm)
		ctx->imgbuf_norm=malloc(4*n);
	if(!ctx->imgbuf_spec)
		ctx->imgbuf_spec=malloc(4*n);
	if(!ctx->imgbuf_luma)
		ctx->imgbuf_luma=malloc(4*n);

	if(!ctx->imgbuf_lebe)
	{
		ctx->imgbuf_lebe=malloc(4*n);
		memset(ctx->imgbuf_lebe, 192, 4*n);
	}
	
	trgba=ctx->imgbuf_rgba;
	tnorm=ctx->imgbuf_norm;
	tspec=ctx->imgbuf_spec;
	tluma=ctx->imgbuf_luma;
	tlebe=ctx->imgbuf_lebe;
	
	if(rgba)
	{
		for(i=0; i<n; i++)
		{
			PDJPG_EncodeFloatPixel(rgba, trgba+i*4, tlebe+i*4+0);
		}
	}

	if(norm)
	{
		for(i=0; i<n; i++)
		{
//			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			j=PDJPG_CalcComponentValueExponent(norm[i*4+3]);
			f=255/pdjpg_scltab[j];
			tnorm[i*4+0]=norm[i*4+0]*255;
			tnorm[i*4+1]=norm[i*4+1]*255;
			tnorm[i*4+2]=norm[i*4+2]*255;
			tnorm[i*4+3]=norm[i*4+3]*f;
			tlebe[i*4+3]=j;
		}
	}

	if(spec)
	{
		for(i=0; i<n; i++)
		{
			tspec[i*4+0]=spec[i*4+0]*255;
			tspec[i*4+1]=spec[i*4+1]*255;
			tspec[i*4+2]=spec[i*4+2]*255;
			tspec[i*4+3]=spec[i*4+3]*255;
		}
	}

	if(luma)
	{
		for(i=0; i<n; i++)
		{
			PDJPG_EncodeFloatPixel(luma, tluma+i*4, tlebe+i*4+1);
		}
	}

	i=PDJPG_EncodeComponentCtxI(ctx,
		trgba, tnorm, tspec, tluma, tlebe,
		obuf, xs, ys, qf);
	return(i);
}

#if 1
PDGL_API byte *PDJPG_Load(VFILE *fd, int *xs, int *ys)
{
	byte *buf, *obuf;
	int fsz;

	vfseek(fd, 0, 2);
	fsz=vftell(fd);
	vfseek(fd, 0, 0);

	buf=malloc(fsz+256);
	vfread(buf, 1, fsz, fd);

	obuf=PDJPG_Decode(buf, fsz, xs, ys);
	free(buf);

	return(obuf);
}

PDGL_API int PDJPG_Store(VFILE *fd, byte *ibuf, int xs, int ys, int qf)
{
	static byte *buf=NULL;
	int fsz;

	if(!buf)buf=malloc(1<<22);

	fsz=PDJPG_Encode(ibuf, buf, xs, ys, qf);
	if(fsz<0)return(fsz);

	vfwrite(buf, 1, fsz, fd);
//	free(buf);

	return(0);
}
#endif
/*
BGB Extensions:
APP11: BGBTech Tag
	FF,APP11,xx,xx,<ASCIZ TagName>, ...
	Tag-specific data until next marker.
	
	"AlphaColor":
		AlphaColor
		RGBA as string ("red green blue alpha").
		
		Specifies a "Alpha Color" extension, where any color sufficiently
		close to the given color (determined by 'alpha'), will be assumed
		to be a transparent pixel. These values are given in decimal.

	APP11 markers may indicate component layer:
		FF,APP11,xx,xx,"CompLayer\0", <layername:ASCIZ>
			"RGB": Base RGB
			"XYZ": Normal XYZ
			"SpRGB": Specular RGB
			"DASe": Depth, Alpha, Specular-Exponent
			"LuRGB": Luma RGB
			"Alpha": Mono alpha layer

	Component Layouts:
		3 component: (no marker, RGB)
		4 component: RGB+Alpha
		7 component: RGB+Alpha+LuRGB
		8 component: RGB+XYZ+DASe
		12 component: RGB+XYZ+SpRGB+DASe
		16 component: RGB+XYZ+SpRGB+DASe+LuRGB

	The APP11 tag for a layer will be followed by the layer
	(as a JPEG image), which may be placed within LDAT tags.
	
	Images lacking DHT and DQT will reuse those from the base image.

APP12: BGBTech Tag 2
	FF,APP12,xx,xx,tt,tt,tt,tt
		tt=FOURCC Tag.

	'LDAT': Layer Data.
	Gives an image/layer spread across a span of 'LDAT' tags.
	The encoded image will be split linearly across the tags.
*/

// #include <pdgl.h>
#include <walpng.h>

//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>

#include <math.h>

#ifndef PDGL_API
#define PDGL_API
#endif

#define DCTSZ	8
#define DCTSZ2	64

//typedef unsigned char byte;
//typedef unsigned short ushort;
//typedef unsigned int uint;

#define JPG_SOF0	0xC0
#define JPG_SOF1	0xC1
#define JPG_SOF2	0xC2
#define JPG_SOF3	0xC3
#define JPG_DHT		0xC4
#define JPG_SOF5	0xC5
#define JPG_SOF6	0xC6
#define JPG_SOF7	0xC7
#define JPG_JPG		0xC8
#define JPG_SOF9	0xC9
#define JPG_SOF10	0xCA
#define JPG_SOF11	0xCB
#define JPG_DAC		0xCC
#define JPG_SOF13	0xCD
#define JPG_SOF14	0xCE
#define JPG_SOF15	0xCF

#define JPG_RST0	0xD0
#define JPG_RST1	0xD1
#define JPG_RST2	0xD2
#define JPG_RST3	0xD3
#define JPG_RST4	0xD4
#define JPG_RST5	0xD5
#define JPG_RST6	0xD6
#define JPG_RST7	0xD7

#define JPG_SOI		0xD8
#define JPG_EOI		0xD9
#define JPG_SOS		0xDA
#define JPG_DQT		0xDB
#define JPG_DNL		0xDC
#define JPG_DRI		0xDD
#define JPG_DHP		0xDE
#define JPG_EXP		0xDF

#define JPG_APP0	0xE0
#define JPG_APP1	0xE1
#define JPG_APP2	0xE2
#define JPG_APP3	0xE3
#define JPG_APP4	0xE4
#define JPG_APP5	0xE5
#define JPG_APP6	0xE6
#define JPG_APP7	0xE7
#define JPG_APP8	0xE8
#define JPG_APP9	0xE9
#define JPG_APP10	0xEA
#define JPG_APP11	0xEB
#define JPG_APP12	0xEC
#define JPG_APP13	0xED
#define JPG_APP14	0xEE
#define JPG_APP15	0xEF

#define JPG_JPG0	0xF0
#define JPG_JPG1	0xF1
#define JPG_JPG2	0xF2
#define JPG_JPG3	0xF3
#define JPG_JPG4	0xF4
#define JPG_JPG5	0xF5
#define JPG_JPG6	0xF6
#define JPG_JPG7	0xF7
#define JPG_JPG8	0xF8
#define JPG_JPG9	0xF9
#define JPG_JPG10	0xFA
#define JPG_JPG11	0xFB
#define JPG_JPG12	0xFC
#define JPG_JPG13	0xFD
#define JPG_COM		0xFE

static const char *pdjpg_marker[]={
"SOF0", "SOF1", "SOF2", "SOF3", "DHT", "SOF5", "SOF6", "SOF7",
"JPG", "SOF9", "SOF10", "SOF11", "DAC", "SOF13", "SOF14", "SOF15",
"RST0", "RST1", "RST2", "RST3", "RST4", "RST5", "RST6", "RST7",
"SOI", "EOI", "SOS", "DQT", "DNL", "DRI", "DHP", "EXP",
"APP0", "APP1", "APP2", "APP3", "APP4", "APP5", "APP6", "APP7", 
"APP8", "APP9", "APP10", "APP11", "APP12", "APP13", "APP14", "APP15", 
"JPG0", "JPG1", "JPG2", "JPG3", "JPG4", "JPG5", "JPG6", "JPG7", 
"JPG8", "JPG9", "JPG10", "JPG11", "JPG12", "JPG13", "COM", ""
};

static const int pdjpg_zigzag[64]={
 0,  1,  5,  6, 14, 15, 27, 28,
 2,  4,  7, 13, 16, 26, 29, 42,
 3,  8, 12, 17, 25, 30, 41, 43,
 9, 11, 18, 24, 31, 40, 44, 53,
10, 19, 23, 32, 39, 45, 52, 54,
20, 22, 33, 38, 46, 51, 55, 60,
21, 34, 37, 47, 50, 56, 59, 61,
35, 36, 48, 49, 57, 58, 62, 63
};

static const int pdjpg_zigzag2[64]={
 0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63
};

#if 0
byte *pdjhuff_cs;	//current pos in bitstream (input)
byte *pdjhuff_ct;	//current pos in bitstream (output)
uint pdjhuff_win;	//bitstream window
int pdjhuff_pos;	//bitstream offset
int pdjhuff_isend;	//bitstream has broken (decoder)
#endif

#if 1
#define pdjhuff_cs		ctx->huff_cs
#define pdjhuff_ct		ctx->huff_ct
#define pdjhuff_win		ctx->huff_win
#define pdjhuff_pos		ctx->huff_pos
#define pdjhuff_isend	ctx->huff_isend
#endif


PDGL_API PDJPG_Context *PDJPG_AllocContext();
PDGL_API void PDJPG_FreeContext(PDJPG_Context *ctx);
PDGL_API void PDJPG_SetContextAlphaColor(PDJPG_Context *ctx,
	int cr, int cg, int cb, int ca);

//Common

#if 1
void PDJPG_TransDCT_Horiz(byte *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	oblk[0]=ib[0]*91  +ib[1]*91  +ib[2]*91  +ib[3]*91  
			+ib[4]*91  +ib[5]*91  +ib[6]*91  +ib[7]*91;
	oblk[1]=ib[0]*126 +ib[1]*106 +ib[2]*71  +ib[3]*25  
			-ib[4]*25  -ib[5]*71  -ib[6]*106 -ib[7]*126;
	oblk[2]=ib[0]*118 +ib[1]*49  -ib[2]*49  -ib[3]*118 
			-ib[4]*118 -ib[5]*49  +ib[6]*49  +ib[7]*118;
	oblk[3]=ib[0]*106 -ib[1]*25  -ib[2]*126 -ib[3]*71  
			+ib[4]*71  +ib[5]*126 +ib[6]*25  -ib[7]*106;
	oblk[4]=ib[0]*91  -ib[1]*91  -ib[2]*91  +ib[3]*91  
			+ib[4]*91  -ib[5]*91  -ib[6]*91  +ib[7]*91;
	oblk[5]=ib[0]*71  -ib[1]*126 +ib[2]*25  +ib[3]*106 
			-ib[4]*106 -ib[5]*25  +ib[6]*126 -ib[7]*71;
	oblk[6]=ib[0]*49  -ib[1]*118 +ib[2]*118 -ib[3]*49  
			-ib[4]*49  +ib[5]*118 -ib[6]*118 +ib[7]*49;
	oblk[7]=ib[0]*25  -ib[1]*71  +ib[2]*106 -ib[3]*126 
			+ib[4]*126 -ib[5]*106 +ib[6]*71  -ib[7]*25;
}

void PDJPG_TransDCT_Vert(int *iblk, int *oblk)
{
	oblk[ 0]=iblk[0]*91  +iblk[8]*91  
			+iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  +iblk[40]*91  
			+iblk[48]*91  +iblk[56]*91;
	oblk[ 8]=iblk[0]*126 +iblk[8]*106 
			+iblk[16]*71  +iblk[24]*25  
			-iblk[32]*25  -iblk[40]*71  
			-iblk[48]*106 -iblk[56]*126;
	oblk[16]=iblk[0]*118 +iblk[8]*49  
			-iblk[16]*49  -iblk[24]*118 
			-iblk[32]*118 -iblk[40]*49  
			+iblk[48]*49  +iblk[56]*118;
	oblk[24]=iblk[0]*106 -iblk[8]*25  
			-iblk[16]*126 -iblk[24]*71  
			+iblk[32]*71  +iblk[40]*126 
			+iblk[48]*25  -iblk[56]*106;
	oblk[32]=iblk[0]*91  -iblk[8]*91  
			-iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  -iblk[40]*91  
			-iblk[48]*91  +iblk[56]*91;
	oblk[40]=iblk[0]*71  -iblk[8]*126 
			+iblk[16]*25  +iblk[24]*106
			-iblk[32]*106 -iblk[40]*25  
			+iblk[48]*126 -iblk[56]*71;
	oblk[48]=iblk[0]*49  -iblk[8]*118
			+iblk[16]*118 -iblk[24]*49  
			-iblk[32]*49  +iblk[40]*118 
			-iblk[48]*118 +iblk[56]*49;
	oblk[56]=iblk[0]*25  -iblk[8]*71  
			+iblk[16]*106 -iblk[24]*126 
			+iblk[32]*126 -iblk[40]*106 
			+iblk[48]*71  -iblk[56]*25;
}

void PDJPG_TransDCT(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransDCT_Horiz(iblk+0, s+0);
	PDJPG_TransDCT_Horiz(iblk+8, s+8);
	PDJPG_TransDCT_Horiz(iblk+16, s+16);
	PDJPG_TransDCT_Horiz(iblk+24, s+24);
	PDJPG_TransDCT_Horiz(iblk+32, s+32);
	PDJPG_TransDCT_Horiz(iblk+40, s+40);
	PDJPG_TransDCT_Horiz(iblk+48, s+48);
	PDJPG_TransDCT_Horiz(iblk+56, s+56);

	PDJPG_TransDCT_Vert(s+0, t+0);
	PDJPG_TransDCT_Vert(s+1, t+1);
	PDJPG_TransDCT_Vert(s+2, t+2);
	PDJPG_TransDCT_Vert(s+3, t+3);
	PDJPG_TransDCT_Vert(s+4, t+4);
	PDJPG_TransDCT_Vert(s+5, t+5);
	PDJPG_TransDCT_Vert(s+6, t+6);
	PDJPG_TransDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i]>>16;
}

#endif

#if 1
void PDJPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[0]* 91;	b=iblk[4]* 91;
	c=iblk[2]*118;	d=iblk[2]* 49;
	e=iblk[6]*118;	f=iblk[6]* 49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[1]*126+iblk[3]*106+iblk[5]* 71+iblk[7]* 25;
	n=iblk[1]*106-iblk[3]* 25-iblk[5]*126-iblk[7]* 71;
	o=iblk[1]* 71-iblk[3]*126+iblk[5]* 25+iblk[7]*106;
	p=iblk[1]* 25-iblk[3]* 71+iblk[5]*106-iblk[7]*126;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
}

void PDJPG_TransIDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]* 91;	b=iblk[32]*91;
	c=iblk[16]*118;	d=iblk[16]*49;
	e=iblk[48]*118;	f=iblk[48]*49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[8]*126+iblk[24]*106+iblk[40]* 71+iblk[56]* 25;
	n=iblk[8]*106-iblk[24]* 25-iblk[40]*126-iblk[56]* 71;
	o=iblk[8]* 71-iblk[24]*126+iblk[40]* 25+iblk[56]*106;
	p=iblk[8]* 25-iblk[24]* 71+iblk[40]*106-iblk[56]*126;
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

void PDJPG_TransIDCT(short *iblk, byte *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIDCT_Horiz(iblk+0, s+0);
	PDJPG_TransIDCT_Horiz(iblk+8, s+8);
	PDJPG_TransIDCT_Horiz(iblk+16, s+16);
	PDJPG_TransIDCT_Horiz(iblk+24, s+24);
	PDJPG_TransIDCT_Horiz(iblk+32, s+32);
	PDJPG_TransIDCT_Horiz(iblk+40, s+40);
	PDJPG_TransIDCT_Horiz(iblk+48, s+48);
	PDJPG_TransIDCT_Horiz(iblk+56, s+56);

	PDJPG_TransIDCT_Vert(s+0, t+0);
	PDJPG_TransIDCT_Vert(s+1, t+1);
	PDJPG_TransIDCT_Vert(s+2, t+2);
	PDJPG_TransIDCT_Vert(s+3, t+3);
	PDJPG_TransIDCT_Vert(s+4, t+4);
	PDJPG_TransIDCT_Vert(s+5, t+5);
	PDJPG_TransIDCT_Vert(s+6, t+6);
	PDJPG_TransIDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=(t[i]>>16)+128;
		oblk[i]=(j<0)?0:((j>255)?255:j);
	}
}

#endif



//Decoder

int PDJHUFF_NextByte(PDJPG_Context *ctx)
{
	int i, j;

	if(pdjhuff_isend)return(0xFF);

	i=*pdjhuff_cs++;
	if(i==0xFF)
	{
		j=*pdjhuff_cs++;
		if(j)
		{
//			printf("bitstream problem\n");
			pdjhuff_isend=1;
		}
	}
	return(i);
}

int PDJHUFF_InitStream(PDJPG_Context *ctx, byte *buf)
{
	pdjhuff_pos=0;
	pdjhuff_isend=0;

	pdjhuff_cs=buf;
	pdjhuff_win=PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
}

int PDJHUFF_ReadBit(PDJPG_Context *ctx)
{
	int i;

	i=(pdjhuff_win>>(31-pdjhuff_pos))&1;
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

int PDJHUFF_ReadNBits(PDJPG_Context *ctx, int n)
{
	int i;

	i=(pdjhuff_win>>(32-n-pdjhuff_pos))&((1<<n)-1);
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

void PDJHUFF_SkipNBits(PDJPG_Context *ctx, int n)
{
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
}

int PDJHUFF_PeekWord(PDJPG_Context *ctx)
{
	int i;
	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
	return(i);
}

int PDJHUFF_DecodeSymbol(PDJPG_Context *ctx, int tab)
{
	int i, j, k;

	tab<<=8;

	i=PDJHUFF_PeekWord(ctx);
	for(j=0; j<256; j++)
	{
		k=ctx->huff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=ctx->huff_code[tab|j])
			continue;
		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
	return(-1);
}

int PDJHUFF_DecodeDiffDC(PDJPG_Context *ctx, int tab)
{
	int i, j;

	i=PDJHUFF_DecodeSymbol(ctx, tab);
	j=PDJHUFF_ReadNBits(ctx, i);

	if(!(j&(1<<(i-1))))
		j=(-1<<i)+j+1;
	return(j);
}

int PDJHUFF_DecodeBlock(PDJPG_Context *ctx,
	short *buf, int dctab, int actab,
	int ni, int nn)
{
	int i, j, k;

	for(i=1; i<64; i++)buf[i]=0;

	buf[0]+=PDJHUFF_DecodeDiffDC(ctx, dctab);
	for(i=1; i<64; i++)
	{
		j=PDJHUFF_DecodeSymbol(ctx, actab);
		if(j<=0)
		{
			if(j<0)
			{
				printf("bad dct block1 %02X %d/%d\n", j, ni, nn);
				return(-1);
			}
			break;
		}

		i+=j>>4;	//preceding 0's
		if(!(j&15))continue;

		j&=15;
		k=PDJHUFF_ReadNBits(ctx, j);
		if(!(k&(1<<(j-1))))
			k=(-1<<j)+k+1;

		j=pdjpg_zigzag2[i];
		buf[j]=k;
	}

	if(i>64)
	{
		printf("bad dct block1 %02X %d/%d\n", j, ni, nn);
		return(-1);
	}

	return(0);
}

void PDJHUFF_QuantBlock(
	PDJPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	
//	for(i=0; i<64; i++)
//		obuf[i]=ibuf[i]/ctx->jpg_qt[qid][i];

	for(i=0; i<64; i++)
		obuf[i]=(ibuf[i]*ctx->jpg_qtfp[qid][i])>>12;
}

void PDJHUFF_DequantBlock(
	PDJPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	for(i=0; i<64; i++)
		obuf[i]=ibuf[i]*ctx->jpg_qt[qid][i];
}

void PDJPG_SetupQuantTabDivFP(PDJPG_Context *ctx, int qid)
{
	int i;
	
	for(i=0; i<64; i++)
		ctx->jpg_qtfp[qid][i]=4096.0/ctx->jpg_qt[qid][i];
}

int PDJPG_MarkerSOS(PDJPG_Context *ctx, byte *buf)
{
	short dbuf[4*64];
	byte ch[4], cv[4], qid[4];
	byte step[4];
	int xi[4], yi[4], wi[4], hi[4];
	byte cdt[4], cat[4];
	int ccnt[4];

	byte *s;
	int i, j, k, l, i1, j1, k1, l1;
	int w, h, n, ns, rt;

	l=(buf[0]<<8)|buf[1];
//	printf("ns %d\n", buf[2]);

	ns=buf[2]; rt=0;
	s=buf+3;
	for(i=0; i<buf[2]; i++)
	{
//		printf("%d %d %d\n", s[0], s[1]>>4, s[1]&15);

		cdt[i]=s[1]>>4;
		cat[i]=s[1]&15;

		for(j=0; j<ctx->jpg_nc; j++)
			if(ctx->jpg_cid[j]==s[0])
		{
			ch[i]=ctx->jpg_ch[j];
			cv[i]=ctx->jpg_cv[j];
			qid[i]=ctx->jpg_qid[j];
			xi[i]=ctx->jpg_cxi[j];
			yi[i]=ctx->jpg_cyi[j];

			step[i]=ch[i]*cv[i];
			break;
		}

		w=(xi[i]+7)/8;
		h=(yi[i]+7)/8;
//		w=(xi[i]+15)/8;
//		h=(yi[i]+15)/8;
		wi[i]=w;
		hi[i]=h;

		n=(w+1)*(h+2);
		ctx->jpg_scid[i]=s[0];
		ctx->jpg_scn[i]=j;
		ctx->jpg_scbuf[i]=malloc(n*64*sizeof(short));
		ctx->jpg_sibuf[i]=malloc(n*64);

//		memset(ctx->jpg_sibuf[i], 0, n*64);

		ccnt[i]=0;

		s+=2;
	}
	s+=3;

	i=(ctx->xs+ctx->jpg_chm*8-1)/(ctx->jpg_chm*8);
	j=(ctx->ys+ctx->jpg_chn*8-1)/(ctx->jpg_chn*8);
	n=i*j;

	PDJHUFF_InitStream(ctx, s);

	for(i=0; i<(4*64); i++)dbuf[i]=0;

	rt=0;
	for(i=0; i<n; i++)
	{
		for(j=0; j<ns; j++)
			for(k=0; k<cv[j]; k++)
				for(l=0; l<ch[j]; l++)
		{
			if(rt<0)break;

			i1=(i/(wi[j]/ch[j]))*ch[j];
			j1=(i%(wi[j]/ch[j]))*ch[j];
			k1=((i1+k)*wi[j])+(j1+l);

			rt=PDJHUFF_DecodeBlock(ctx, dbuf+j*64,
				cdt[j]*2+0, cat[j]*2+1, i, n);
			if(rt<0)break;
			PDJHUFF_DequantBlock(ctx, dbuf+j*64,
				ctx->jpg_scbuf[j]+k1*64, qid[j]);
			PDJPG_TransIDCT(ctx->jpg_scbuf[j]+k1*64,
				ctx->jpg_sibuf[j]+k1*64);
		}
	}

	if(rt<0)
	{
		printf("PDJPG_MarkerSOS: Bad Image\n");
		return(-1);
	}

	return(0);
}

int PDJPG_MarkerSOF0(PDJPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, m, n;

	l=(buf[0]<<8)|buf[1];
//	printf("p %d\n", buf[2]);

	i=(buf[3]<<8)|buf[4];
	j=(buf[5]<<8)|buf[6];

	ctx->xs=j;
	ctx->ys=i;
//	printf("size %dx%d\n", j, i);

	m=0; n=0;

	k=buf[7];
	s=buf+8;
	for(i=0; i<k; i++)
	{
		ctx->jpg_cid[i]=s[0];
		ctx->jpg_ch[i]=s[1]>>4;
		ctx->jpg_cv[i]=s[1]&15;
		ctx->jpg_qid[i]=s[2];

		if(ctx->jpg_ch[i]>m)m=ctx->jpg_ch[i];
		if(ctx->jpg_cv[i]>n)n=ctx->jpg_cv[i];

//		printf("CID %d: %d %d %d\n", ctx->jpg_cid[i],
//			ctx->jpg_ch[i], ctx->jpg_cv[i], ctx->jpg_qid[i]);
		s+=3;
	}

	ctx->jpg_chm=m;
	ctx->jpg_chn=n;

	for(i=0; i<k; i++)
	{
		ctx->jpg_cxi[i]=(ctx->jpg_ch[i]*ctx->xs)/m;
		ctx->jpg_cyi[i]=(ctx->jpg_cv[i]*ctx->ys)/n;
	}

	ctx->jpg_nc=k;

	return(0);
}

int PDJPG_MarkerDQT(PDJPG_Context *ctx, byte *buf)
{
	byte *s, *se;
	int i, j, l;

	l=(buf[0]<<8)|buf[1];

	s=buf+2;
	se=buf+l;

	while(s<se)
	{
		i=(s[0]>>4)&15;
		if(i)
		{
//			printf("bad bits %d\n", i);
			return(-1);
		}
		i=s[0]&15;
//		printf("dest %d\n", i);

		for(j=0; j<64; j++)
			ctx->jpg_qt[i][pdjpg_zigzag2[j]]=s[j+1];
		s+=65;
	}
	
	return(0);
}

int PDJPG_MarkerDHT(PDJPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, tn;

	l=(buf[0]<<8)|buf[1];

	j=(buf[2]>>4)&15;
	i=buf[2]&15;
//	printf("dest %d, type %d\n", i, j);

	tn=i*2+j;

	for(i=0; i<256; i++)
		ctx->huff_len[tn*256+i]=0;

	cnt=buf+3;
	s=cnt+16;
	k=0; l=0;
	for(i=0; i<16; i++)
	{
		k<<=1;
		for(j=0; j<cnt[i]; j++)
		{
			ctx->huff_code[tn*256+(*s)]=k++;
			ctx->huff_len[tn*256+(*s)]=i+1;
			l=i+1;
			s++;
		}
	}
//	printf("%04X %d\n", k, l);

	return(0);
}

int PDJPG_MarkerAPP0(PDJPG_Context *ctx, byte *buf)
{
}

int PDJPG_MarkerAPP11(PDJPG_Context *ctx, byte *buf)
{
	int cr, cg, cb, ca;

	buf+=2;

	if(!strcmp((char *)buf, "AlphaColor"))
	{
		buf+=strlen((char *)buf)+1;
		sscanf(buf, "%d %d %d %d", &cr, &cg, &cb, &ca);
		PDJPG_SetContextAlphaColor(ctx, cr, cg, cb, ca);
		return(1);
	}
	
	return(0);
}

int PDJPG_MarkerAPPN(PDJPG_Context *ctx, byte *buf)
{
}

int PDJPG_GetComponentPixel(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	id=ctx->jpg_scn[cn];

	i=x*ctx->jpg_schsc[cn];
	j=y*ctx->jpg_scvsc[cn];
//	i=(ctx->jpg_ch[id]*x)/ctx->jpg_chm;
//	j=(ctx->jpg_cv[id]*y)/ctx->jpg_chn;
	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
	h=ctx->jpg_scvs[cn];
//	w=(ctx->jpg_cxi[id]+7)/8;
//	h=(ctx->jpg_cyi[id]+7)/8;
//	w=(ctx->jpg_cxi[id]+15)/8;
//	h=(ctx->jpg_cyi[id]+15)/8;
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

PDGL_API byte *PDJPG_DecodeCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *obuf;
	int i, j, k, l;
	int y, u, v, r, g, b, a;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
		return(NULL);

	for(i=0; i<4; i++)
	{
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	for(i=0; i<sz; i++)
	{
		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		{
			j=buf[i+1]-0xC0;
			if(j<0)j=63;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)PDJPG_MarkerDQT(ctx, buf+i+2);
			if(buf[i+1]==JPG_DHT)PDJPG_MarkerDHT(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOF0)PDJPG_MarkerSOF0(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOS)PDJPG_MarkerSOS(ctx, buf+i+2);

			if(buf[i+1]==JPG_APP0)PDJPG_MarkerAPP0(ctx, buf+i+2);
			if(buf[i+1]==JPG_APP11)PDJPG_MarkerAPP11(ctx, buf+i+2);

			if(buf[i+1]==JPG_EOI)break;
		}
	}

	obuf=ctx->jpg_imgbuf;
	if(!obuf || (ctx->xs!=ctx->lxs) || (ctx->ys!=ctx->lys))
	{
		if(ctx->jpg_imgbuf)
			free(ctx->jpg_imgbuf);
		
		obuf=malloc((ctx->xs+1)*(ctx->ys+1)*4);
		memset(obuf, 0xFF, ctx->xs*ctx->ys*4);
		
		ctx->jpg_imgbuf=obuf;
		ctx->lxs=ctx->xs;
		ctx->lys=ctx->ys;
	}

	for(i=0; i<ctx->jpg_nc; i++)
	{
		j=ctx->jpg_scn[i];
		ctx->jpg_schsc[i]=ctx->jpg_ch[j]/(ctx->jpg_chm*1.0);
		ctx->jpg_scvsc[i]=ctx->jpg_cv[j]/(ctx->jpg_chn*1.0);
		ctx->jpg_schs[i]=(ctx->jpg_cxi[j]+7)/8;
		ctx->jpg_scvs[i]=(ctx->jpg_cyi[j]+7)/8;
		
	}

	for(i=0; i<ctx->ys; i++)
		for(j=0; j<ctx->xs; j++)
	{
		if(ctx->jpg_nc==3)
		{
			y=PDJPG_GetComponentPixel(ctx, 0, j, i);
			u=PDJPG_GetComponentPixel(ctx, 1, j, i);
			v=PDJPG_GetComponentPixel(ctx, 2, j, i);
			a=255;

			if(ctx->alphaClr)
			{
				k=y-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				if(l<(16*16))
				{
					a=255*((16*sqrt(l))/ctx->alphaClrA);
					a=(a<0)?0:(a>255)?255:a;
				}
			}

			r=y+1.40200*(v-128);
			g=y-0.34414*(u-128)-0.71414*(v-128);
			b=y+1.77200*(u-128);

			r=(r<0)?0:((r>255)?255:r);
			g=(g<0)?0:((g>255)?255:g);
			b=(b<0)?0:((b>255)?255:b);
		}else if(ctx->jpg_nc==1)
		{
			y=PDJPG_GetComponentPixel(ctx, 0, j, i);
			r=y; g=y; b=y; a=255;
		}

		k=ctx->ys-1-i;
		l=((k*ctx->xs)+j)*4;

		obuf[l+0]=r;
		obuf[l+1]=g;
		obuf[l+2]=b;
		obuf[l+3]=a;
	}

	for(i=0; i<4; i++)
	{
		if(ctx->jpg_scbuf[i])free(ctx->jpg_scbuf[i]);
		if(ctx->jpg_sibuf[i])free(ctx->jpg_sibuf[i]);
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	*xs=ctx->xs;
	*ys=ctx->ys;
	return(obuf);
}

PDGL_API void PDJPG_Free(byte *buf)
{
	if(!buf)return;
	free(buf);
}

byte *PDJPG_DecodeScanForComponentLayer(byte *buf, int sz, char *name)
{
	byte *cs, *cse;
	
	cs=buf; cse=buf+sz;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_APP11))
		{
			cs+=4;
			if(!strcmp((char *)cs, "CompLayer"))
			{
				cs+=strlen((char *)cs)+1;
				if(!strcmp((char *)cs, name))
				{
					cs+=strlen((char *)cs)+1;
					return(cs);
				}

				cs+=strlen((char *)cs)+1;
				continue;
			}
			continue;
		}
		cs++;
	}
	
	return(NULL);
}

PDGL_API byte *PDJPG_Decode(byte *buf, int sz, int *xs, int *ys)
{
	PDJPG_Context *ctx;
	byte *obuf;
	byte *otbuf;
	byte *csl;
	int i, n, sz1;
	
	ctx=PDJPG_AllocContext();
	obuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
	ctx->jpg_imgbuf=NULL;
	
	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
	if(csl)
	{
		sz1=sz-(csl-buf);
		otbuf=PDJPG_DecodeCtx(ctx, csl, sz1, xs, ys);
		
		n=ctx->xs*ctx->ys;
		for(i=0; i<n; i++)
		{
			obuf[i*4+3]=otbuf[i*4+1];
		}
	}

	PDJPG_FreeContext(ctx);
	return(obuf);
}

PDGL_API int PDJPG_DecodeComponentType(byte *buf, int sz)
{
	byte *csl;
	int sz1;

//	sz1=(sz>1024)?1024:sz;
//	csl=PDJPG_DecodeScanForComponentLayer(buf, sz1, "RGB");
//	if(!csl)return(0);

	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(16);
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)return(12);
		return(8);
	}else
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(7);

		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)return(4);

		return(3);
	}
}

PDGL_API byte *PDJPG_DecodeLDatCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *tbuf, *tbuf2, *cs, *ct;
	int i;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_APP12) ||
		(buf[4]!='L') || (buf[5]!='D') ||
		(buf[6]!='A') || (buf[7]!='T'))
	{
		tbuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
		return(tbuf);
	}
	
	tbuf=malloc(1<<20);
	cs=buf; ct=tbuf;

	while((cs[0]==0xFF) && (cs[1]==JPG_APP12) &&
		(cs[4]=='L') && (cs[5]=='D') &&
		(cs[6]=='A') && (cs[7]=='T'))
	{
		i=(cs[2]<<8)|cs[3];
		memcpy(ct, cs+8, i-6);
		cs+=i; ct+=(i-6);
	}

	i=ct-tbuf;
	i=PDJPG_EscapeDecodeSingleBuffer(tbuf, i);

	tbuf2=PDJPG_DecodeCtx(ctx, tbuf, i, xs, ys);
	free(tbuf);
	return(tbuf2);
}

PDGL_API int PDJPG_DecodeComponentCtx(PDJPG_Context *ctx,
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	byte *tbuf;
	byte *csl;
	int i, n, sz1;

	tbuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
	if(!tbuf)return(-1);

	n=ctx->xs*ctx->ys;

	for(i=0; i<n; i++)
	{
		rgba[i*4+0]=tbuf[i*4+0];
		rgba[i*4+1]=tbuf[i*4+1];
		rgba[i*4+2]=tbuf[i*4+2];
	}

	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		for(i=0; i<n; i++)
		{
			rgba[i*4+3]=tbuf[i*4+1];
			if(norm) { norm[i*4+3]=tbuf[i*4+0]; }
			if(spec) { spec[i*4+2]=tbuf[i*4+2]; }
		}
	}else
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
				{ rgba[i*4+3]=tbuf[i*4+1]; }
		}
	}

	if(norm)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "XYZ");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				norm[i*4+0]=tbuf[i*4+0];
				norm[i*4+1]=tbuf[i*4+2];
				norm[i*4+2]=tbuf[i*4+1];
			}
		}
	}

	if(spec)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				spec[i*4+0]=tbuf[i*4+0];
				spec[i*4+1]=tbuf[i*4+1];
				spec[i*4+2]=tbuf[i*4+2];
			}
		}
	}
	
	if(luma)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				luma[i*4+0]=tbuf[i*4+0];
				luma[i*4+1]=tbuf[i*4+1];
				luma[i*4+2]=tbuf[i*4+2];
			}
		}
	}
	return(0);
}

PDGL_API int PDJPG_DecodeComponent(byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	PDJPG_Context *ctx;
	int i;
	
	ctx=PDJPG_AllocContext();
	i=PDJPG_DecodeComponentCtx(ctx, buf, sz,
		rgba, norm, spec, luma, xs, ys);
//	ctx->jpg_imgbuf=NULL;
	PDJPG_FreeContext(ctx);
	return(i);
}

//Encoder

void PDJHUFF_WriteBit(PDJPG_Context *ctx, int i)
{
	pdjhuff_win|=i<<(31-pdjhuff_pos);
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteNBits(PDJPG_Context *ctx, int v, int n)
{
	int i, j, k;

	v&=(1<<n)-1;

	j=pdjhuff_pos+n;
	k=pdjhuff_win|(v<<(32-j));
	while(j>=8)
	{
		i=(k>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		k<<=8;
		j-=8;
	}
	pdjhuff_pos=j;
	pdjhuff_win=k;

//	pdjhuff_win|=i<<((32-n)-pdjhuff_pos);
//	pdjhuff_pos+=n;
//	while(pdjhuff_pos>=8)
//	{
//		i=(pdjhuff_win>>24)&0xFF;
//		*pdjhuff_ct++=i;
//		if(i==0xFF)*pdjhuff_ct++=0x00;
//		pdjhuff_win<<=8;
//		pdjhuff_pos-=8;
//	}
}

void PDJHUFF_FlushBits(PDJPG_Context *ctx)
{
	int i;
	while(pdjhuff_pos>0)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteString(PDJPG_Context *ctx, char *str)
{
	char *s;

	PDJHUFF_FlushBits(ctx);	
	s=str;
	while(*s)
		*pdjhuff_ct++=*s++;
	*pdjhuff_ct++=0;
}

int PDJHUFF_BalanceTree_r(short *nodes, short *nlen, int root, int h, int ml)
{
	int h0, h1, h2, h3;
	int l0, l1, l2;

	if(root<0)return(0);

	h1=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+0], h+1, ml);
	h2=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+1], h+1, ml);
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	if((h+h0)<=ml)	//depth limit not exceeded
		return(h0);

	//ok, so part of the tree is too deep
	if((h1+1)<h2)
	{
		l0=nodes[root*2+1];
		l1=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[root*2+0];
		nodes[root*2+0]=l0;
		nodes[root*2+1]=l1;
	}else if((h2+1)<h1)
	{
		l0=nodes[root*2+0];
		l1=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[root*2+1];
		nodes[root*2+0]=l1;
		nodes[root*2+1]=l0;
	}else
	{
		//rotating would be ineffective or would make things worse...
		return(h0);
	}

	//recalc depth of modified sub-tree
	l1=nodes[l0*2+0];
	l2=nodes[l0*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h3=((h1>h2)?h1:h2)+1;
	nlen[l0]=h3;

	//recalc height of root node
	l1=nodes[root*2+0];
	l2=nodes[root*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	return(h0);
}

void PDJHUFF_CalcLengths_r(short *nodes, byte *cl, int root, int h)
{
	if(root<0)
	{
		if(root==-513)return;
		cl[(-root)-1]=h;
		return;
	}

	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+0], h+1);
	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+1], h+1);
}

int PDJHUFF_BuildLengths(int *stat, int nc, byte *cl, int ml)
{
//	static short nodes[1024], nlen[512];
//	static short roots[512], clen[512];
//	static int cnts[512];

	short nodes[1024], nlen[512];
	short roots[512], clen[512];
	int cnts[512];
	int nr, nn;
	int i, j, k, l;

	nr=0; nn=0;
	for(i=0; i<nc; i++)
	{
		if(!stat[i])continue;
		roots[nr]=-(i+1);
		cnts[nr]=stat[i];
		clen[nr]=0;
		nr++;
	}

	roots[nr]=-513;
	cnts[nr]=0;
	clen[nr]=0;
	nr++;


	for(i=0; i<nc; i++)cl[i]=0;
	if(!nr)return(-1);


	while(nr>1)
	{
		if(cnts[0]>=cnts[1]) { j=0; k=1; }
			else { j=1; k=0; }
		for(i=2; i<nr; i++)
		{
			if(cnts[i]<=cnts[k])
			{
				j=k; k=i;
				continue;
			}
			if(cnts[i]<=cnts[j])
			{
				j=i;
				continue;
			}
		}

		nlen[nn]=((clen[j]>clen[k])?clen[j]:clen[k])+1;
		nodes[nn*2+0]=roots[j];
		nodes[nn*2+1]=roots[k];

		roots[nr]=nn;
		cnts[nr]=cnts[j]+cnts[k];
		clen[nr]=nlen[nn];

//		printf("%d %d %d\n", cnts[j], cnts[k], cnts[nr]);

		nn++; nr++;

		l=0;
		for(i=0; i<nr; i++)
		{
			if((i==j) || (i==k))continue;
			roots[l]=roots[i];
			cnts[l]=cnts[i];
			clen[l]=clen[i];
			l++;
		}
		nr=l;
	}

	l=roots[0];
	j=clen[0];
	k=j;

	i=4;
	while((i--) && (k>ml))
		k=PDJHUFF_BalanceTree_r(nodes, nlen, l, 0, ml);
	if(k>ml)return(-2);	//failed to balance tree

	PDJHUFF_CalcLengths_r(nodes, cl, l, 0);
	return(0);
}

int PDJHUFF_BuildLengthsAdjust(int *stat, int nc, byte *cl, int ml)
{
	int i, j;

	while(1)
	{
		j=PDJHUFF_BuildLengths(stat, nc, cl, ml);
		if(j<0)
			printf("PDJHUFF_BuildLengthsAdjust: Huff Fail %d\n");

		for(i=0; i<nc; i++)
			if(stat[i] && !cl[i])
				break;
		if(i>=nc)break;

		printf("PDJHUFF_BuildLengthsAdjust: Fiddle Adjust\n");
		for(i=0; i<nc; i++)
			stat[i]++;
		continue;
	}
}

void PDJHUFF_EncodeSymbol(PDJPG_Context *ctx, int tab, int v)
{
	tab<<=8;
	PDJHUFF_WriteNBits(ctx, ctx->huff_code[tab|v], ctx->huff_len[tab|v]);
}

void PDJHUFF_EncodeVal(PDJPG_Context *ctx, int tab, int z, int v)
{
	int i, j, k;

	if(!v) { PDJHUFF_EncodeSymbol(ctx, tab, z<<4); return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		PDJHUFF_EncodeSymbol(ctx, tab, (z<<4)|i);
		PDJHUFF_WriteNBits(ctx, v, i);
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	PDJHUFF_EncodeSymbol(ctx, tab, (z<<4)|i);

	k=(1<<i)-(j+1);
	PDJHUFF_WriteNBits(ctx, k, i);
	return;
}

void PDJHUFF_StatVal(int *stat, int z, int v)
{
	int i, j, k;

	if(!v) { stat[z<<4]++; return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		stat[(z<<4)|i]++;
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	stat[(z<<4)|i]++;
}

#if 1
int PDJHUFF_EncodeBlock(PDJPG_Context *ctx,
	short *buf, int dctab, int actab)
{
	int i, j, k;

	PDJHUFF_EncodeVal(ctx, dctab, 0, buf[0]);

	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			PDJHUFF_EncodeVal(ctx, actab, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			PDJHUFF_EncodeSymbol(ctx, actab, 0);
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_EncodeVal(ctx, actab, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
}


int PDJHUFF_StatBlock(short *buf, int *dcstat, int *acstat)
{
	int i, j, k;

	PDJHUFF_StatVal(dcstat, 0, buf[0]);
	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			PDJHUFF_StatVal(acstat, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			acstat[0]++;
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_StatVal(acstat, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
}
#endif

#if defined(X86) || defined(X86_64)
#define memcpy8(dst, src)	(*(double *)(dst)=*(double *)(src))
#else
#define memcpy8(dst, src)	memcpy(dst, src, 8)
#endif

#if 1
int PDJPG_GetImgBlk(char *blk, int xo, int yo, byte *img, int xs, int ys)
{
	byte *cs;
	char *ct;
	int i, j, k;

	cs=img+(yo*xs+xo); ct=blk;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); // ct+=8; cs+=xs;
}
#endif

int PDJPG_FilterImageDCT(byte *ibuf, short *obuf, int xs, int ys)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
	char blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
		PDJPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_TransDCT(blk, obuf+k*DCTSZ2);
		k++;
	}
}

void PDJPG_EmitDQT(PDJPG_Context *ctx, int n)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DQT;

	i=64+3;
	*pdjhuff_ct++=i>>8;
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=n;
	for(i=0; i<64; i++)
		*pdjhuff_ct++=ctx->jpg_qt[n][pdjpg_zigzag2[i]];
}

void PDJPG_EmitSOF(PDJPG_Context *ctx, int xs, int ys)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOF0;

	i=8+(ctx->jpg_mono?1:3)*3;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=8; 	//P

	*pdjhuff_ct++=ys>>8;	//Y
	*pdjhuff_ct++=ys&0xFF;	//Y
	*pdjhuff_ct++=xs>>8;	//X
	*pdjhuff_ct++=xs&0xFF;	//X

	if(ctx->jpg_mono)
	{
		*pdjhuff_ct++=1;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
	}else
	{
		*pdjhuff_ct++=3;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x22;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
		*pdjhuff_ct++=2;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
		*pdjhuff_ct++=3;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
	}
}

void PDJPG_EmitSOS(PDJPG_Context *ctx)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOS;

	i=6+(ctx->jpg_mono?1:3)*2;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	if(!ctx->jpg_mono)
	{
		*pdjhuff_ct++=3; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else
	{
		*pdjhuff_ct++=1; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
	}

	*pdjhuff_ct++=0; 	//Ss
	*pdjhuff_ct++=63; 	//Se
	*pdjhuff_ct++=0x00; 	//Ah Al
}

void PDJPG_EmitDHT(PDJPG_Context *ctx, int tab)
{
	byte *p;
	int i, j, k;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DHT;

//	i=8+3*1;
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	i=(tab/2)|((tab&1)<<4);
	*pdjhuff_ct++=i; 	//Tc Th

	tab<<=8;
	for(i=1; i<=16; i++)
	{
		k=0;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
				k++;
		*pdjhuff_ct++=k; 	//Li
	}

	k=0;
	for(i=1; i<=16; i++)
	{
		k<<=1;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
		{
			*pdjhuff_ct++=j; 	//Vi
			ctx->huff_code[tab|j]=k++;
		}
	}

	if(k>=65536)
		printf("PDJPG_EmitDHT: Error %04X\n", k);

//	printf("DHT %04X\n", k);

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void PDJPG_MakeQuantTabInput(short *in, int cnt, byte *tab, float q)
{
//	static double deltas[DCTSZ2];
	double deltas[DCTSZ2];
	double f, g, te;
	int i, j, k;

	for(j=0; j<DCTSZ2; j++)
		deltas[j]=0;

	for(i=0; i<cnt; i++)
		for(j=0; j<DCTSZ2; j++)
			deltas[j]+=fabs(in[i*DCTSZ2+j]);
	for(j=0; j<DCTSZ2; j++)
		deltas[j]/=cnt;

	te=0;
	for(j=0; j<DCTSZ2; j++)
		te+=deltas[j];

	for(i=0; i<DCTSZ; i++)
	{
		for(j=0; j<DCTSZ; j++)
		{
			f=deltas[i*DCTSZ+j];

			f=f/te;
			if(f<0.00001)f=0.00001;
			g=(1.0-q);
			f=10*g*g*g/f;
			k=f;
			if(k<1)k=1;
			if(k>255)k=255;

//			printf("%f/%f %d\n", deltas[i*DCTSZ+j], te, k);

//			if(f<1)f=1;
//			if(f>255)f=255;
			tab[i*DCTSZ+j]=k;
		}
	}

#if 1
	if(tab[DCTSZ2-3]>1)tab[DCTSZ2-3]*=0.75;
	if(tab[DCTSZ2-2]>1)tab[DCTSZ2-2]*=0.75;
	if(tab[DCTSZ2-1]>1)tab[DCTSZ2-1]*=0.5;
#endif
}

void PDJPG_MakeQuantTabInputFast(
	short *in, int cnt, byte *tab, float q)
{
	int i;
//	PDJPG_MakeQuantTabInput(in, cnt, tab, q);

	i=cnt/16;
	if(i<1)i=1;
	PDJPG_MakeQuantTabInput(in, i, tab, q);
}

PDGL_API int PDJPG_EncodeCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf, int xs, int ys,
	int qf, int pf)
{
//	static byte *yb=NULL, *ub, *vb;
//	static short *ydb=NULL, *udb, *vdb;
//	static int lxs=0, lys=0;

	int dcs[256], acs[256];
	int dcsuv[256], acsuv[256];
	short *tp;
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
//	xs3=(xs2+1)/2;
//	ys3=(ys2+1)/2;

	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	ctx->jpg_mono=0;
	ctx->jpg_tabcacheframe=0;
	ctx->xs=xs;
	ctx->ys=ys;

	if(pf==PDJPG_YYYA)
		ctx->jpg_mono=1;

	//full quality
	for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
	for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;

	//dummy huffman tables
	for(i=0; i<256; i++)ctx->huff_len[0*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[1*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[2*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[3*256+i]=0;

	for(i=0; i<16; i++)ctx->huff_len[0*256+i]=4;
	for(i=0; i<16; i++)ctx->huff_len[2*256+i]=4;
	for(i=0; i<255; i++)ctx->huff_len[1*256+i]=8;
	for(i=0; i<255; i++)ctx->huff_len[3*256+i]=8;

//	for(i=0; i<255; i++)ctx->huff_len[0*256+i]=8;
//	for(i=0; i<255; i++)ctx->huff_len[2*256+i]=8;


//	ctx->huff_len[1*256+0]=7;

//	printf("M0\n");

	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->yb=malloc(xs2*ys2);
		ctx->ub=malloc(xs2*ys2);
		ctx->vb=malloc(xs2*ys2);

		ctx->ydb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;
	}


	memset(ctx->yb, 128, xs2*ys2);
	memset(ctx->ub, 128, xs2*ys2);
	memset(ctx->vb, 128, xs2*ys2);

	memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
	memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
	memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];

		cy=0.299*cr	+0.587*cg	+0.114*cb;
		cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
		cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;

//		cu=128; cv=128;

		cy=(cy<0)?0:((cy>255)?255:cy);
		cu=(cu<0)?0:((cu>255)?255:cu);
		cv=(cv<0)?0:((cv>255)?255:cv);

		ctx->yb[i*xs2+j]=cy;
		ctx->ub[i*xs2+j]=cu;
		ctx->vb[i*xs2+j]=cv;
	}

	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		k=ctx->ub[(i*2)*xs2+j*2]+
			ctx->ub[(i*2)*xs2+j*2+1]+
			ctx->ub[(i*2+1)*xs2+j*2]+
			ctx->ub[(i*2+1)*xs2+j*2+1];
		ctx->ub[i*xs3+j]=k/4;

		k=ctx->vb[(i*2)*xs2+j*2]+
			ctx->vb[(i*2)*xs2+j*2+1]+
			ctx->vb[(i*2+1)*xs2+j*2]+
			ctx->vb[(i*2+1)*xs2+j*2+1];
		ctx->vb[i*xs3+j]=k/4;
	}

//	printf("M1\n");


	PDJPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2);
	PDJPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3);
	PDJPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3);

	j=(xs2/8)*(ys2/8);
	PDJPG_MakeQuantTabInput(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

	j=(xs3/8)*(ys3/8);
	PDJPG_MakeQuantTabInput(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
	PDJPG_MakeQuantTabInput(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
	for(i=0; i<64; i++)ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

	PDJPG_SetupQuantTabDivFP(ctx, 0);
	PDJPG_SetupQuantTabDivFP(ctx, 1);

//	free(yb);
//	free(ub);
//	free(vb);


	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k; k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		PDJHUFF_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

//	printf("M2\n");

	for(i=0; i<256; i++)dcs[i]=0;
	for(i=0; i<256; i++)acs[i]=0;
	for(i=0; i<256; i++)dcsuv[i]=0;
	for(i=0; i<256; i++)acsuv[i]=0;

	j=(xs2/8)*(ys2/8);
	k=(xs3/8)*(ys3/8);
	for(i=0; i<j; i++)PDJHUFF_StatBlock(ctx->ydb+i*64, dcs, acs);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->udb+i*64, dcsuv, acsuv);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->vdb+i*64, dcsuv, acsuv);

//	PDJHUFF_BuildLengths(dcs, 256, ctx->huff_len+0*256, 16);
//	PDJHUFF_BuildLengths(acs, 256, ctx->huff_len+1*256, 16);
//	PDJHUFF_BuildLengths(dcsuv, 256, ctx->huff_len+2*256, 16);
//	PDJHUFF_BuildLengths(acsuv, 256, ctx->huff_len+3*256, 16);

	PDJHUFF_BuildLengthsAdjust(dcs, 256, ctx->huff_len+0*256, 16);
	PDJHUFF_BuildLengthsAdjust(acs, 256, ctx->huff_len+1*256, 16);
	PDJHUFF_BuildLengthsAdjust(dcsuv, 256, ctx->huff_len+2*256, 16);
	PDJHUFF_BuildLengthsAdjust(acsuv, 256, ctx->huff_len+3*256, 16);

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	PDJPG_EmitDQT(ctx, 0);
	if(!ctx->jpg_mono)PDJPG_EmitDQT(ctx, 1);

	PDJPG_EmitSOF(ctx, xs, ys);

	PDJPG_EmitDHT(ctx, 0);
	PDJPG_EmitDHT(ctx, 1);
	if(!ctx->jpg_mono)
	{
		PDJPG_EmitDHT(ctx, 2);
		PDJPG_EmitDHT(ctx, 3);
	}

	PDJPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
	}

	PDJHUFF_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

//	free(ydb);
//	free(udb);
//	free(vdb);

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

PDGL_API PDJPG_Context *PDJPG_AllocContext()
{
	PDJPG_Context *ctx;
	
	ctx=malloc(sizeof(PDJPG_Context));
	memset(ctx, 0, sizeof(PDJPG_Context));
	return(ctx);
}

PDGL_API void PDJPG_FreeContext(PDJPG_Context *ctx)
{
	if(ctx->yb)
	{
		free(ctx->yb);
		free(ctx->ub);
		free(ctx->vb);
		free(ctx->ydb);
		free(ctx->udb);
		free(ctx->vdb);
	}

	if(ctx->jpg_imgbuf)
		free(ctx->jpg_imgbuf);

	free(ctx);
}

PDGL_API int PDJPG_Encode(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	PDJPG_Context *ctx;
	int sz;
	
	ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
	PDJPG_FreeContext(ctx);
	return(sz);
}

PDGL_API void PDJPG_FlushEncodeFast(PDJPG_Context *ctx)
{
	if(!ctx)return;
	ctx->jpg_tabcacheframe=0;	//force rebuild
	ctx->oldAlphaClr=0;
}

PDGL_API void PDJPG_SetContextAlphaColor(PDJPG_Context *ctx,
	int cr, int cg, int cb, int ca)
{
	int cy, cu, cv;
	if(!ctx)return;

	if(ca<1)
	{
		ctx->alphaClr=0;
		return;
	}

	ctx->alphaClr=cr+(cg<<8)+(cb<<16)+(ca<<24);

	cy= 19595*cr +38470*cg + 7471*cb;
	cu=-11056*cr -21712*cg +32768*cb;
	cv= 32768*cr -27440*cg - 5328*cb;
	ctx->alphaClrY=cy>>16;
	ctx->alphaClrU=(cu>>16)+128;
	ctx->alphaClrV=(cv>>16)+128;
	ctx->alphaClrA=ca;
}

#if 0
//static void pdjpg_getPixel2_RGBA(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb)
//{
//	*ra=rgb[0]; *ga=rgb[1]; *ba=rgb[2];
//	*ra=rgb[4]; *ga=rgb[5]; *ba=rgb[6];
//}
#endif

void PDJPG_ConvertImageYUV(PDJPG_Context *ctx,
	byte *ibuf, int xs, int ys, int pf,
	int xs2, int ys2, int xs3, int ys3)
{
//	void (*getPixel2)(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb);
	byte *cs, *cse, *cty, *ctu, *ctv;
	byte *cs1, *cs2, *cty1, *cty2;

	int cr, cg, cb, ca, cy, cu, cv;

	int cra, cga, cba, caa, cya, cua, cva;
	int crb, cgb, cbb, cab, cyb, cub, cvb;
	int crc, cgc, cbc, cac, cyc, cuc, cvc;
	int crd, cgd, cbd, cad, cyd, cud, cvd;
	int psz, psz2;

	int i, j, k, l, n;

	if((pf==PDJPG_RGBA) && !ctx->alphaClr)
	{
		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*4;
			cs1=ibuf+k; cse=cs1+xs*4;
			l=((ys-(2*i+2))*xs)*4;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
				cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2);
				crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6);
				crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2);
				crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6);

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=8; cs2+=8;
			}
		}
	}else
	if((pf==PDJPG_RGBA) || (pf==PDJPG_RGB) ||
		(pf==PDJPG_BGRA) || (pf==PDJPG_BGR))
	{
		switch(pf)
		{
		case PDJPG_RGBA: case PDJPG_BGRA:
			psz=4; break;
		case PDJPG_RGB: case PDJPG_BGR:
			psz=3; break;
		default: psz=4; break;
		}
		psz2=psz*2;

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*psz;
			cs1=ibuf+k; cse=cs1+xs*psz;
			l=((ys-(2*i+2))*xs)*psz;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case PDJPG_RGBA:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=*(cs1+3);
					crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6); cab=*(cs1+7);
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=*(cs2+3);
					crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6); cad=*(cs2+7);
					psz=8; break;
				case PDJPG_BGRA:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=*(cs1+3);
					crb=*(cs1+6); cgb=*(cs1+5); cbb=*(cs1+4); cab=*(cs1+7);
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=*(cs2+3);
					crd=*(cs2+6); cgd=*(cs2+5); cbd=*(cs2+4); cad=*(cs2+7);
					psz=8; break;
				case PDJPG_RGB:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=255;
					crb=*(cs1+3); cgb=*(cs1+4); cbb=*(cs1+5); cab=255;
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=255;
					crd=*(cs2+3); cgd=*(cs2+4); cbd=*(cs2+5); cad=255;
					psz=6; break;
				case PDJPG_BGR:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=255;
					crb=*(cs1+5); cgb=*(cs1+4); cbb=*(cs1+3); cab=255;
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=255;
					crd=*(cs2+5); cgd=*(cs2+4); cbd=*(cs2+3); cad=255;
					psz=6; break;
				}

				if(ctx->alphaClr)
				{
					ca=(caa+cab+cac+cad)>>2;
					if(ca<ctx->alphaClrA)
					{
						cy=ctx->alphaClrY;
						cu=ctx->alphaClrU;
						cv=ctx->alphaClrV;
						*cty1++=cy; *cty1++=cy;
						*cty2++=cy; *cty2++=cy;
						*ctu++=cu; *ctv++=cv;
						continue;
					}
				}

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}else
	{
		switch(pf)
		{
		case PDJPG_YUVA: psz=4; psz2=8; break;
		case PDJPG_YUV: psz=3; psz2=6; break;
		case PDJPG_YUV422: psz=2; psz2=4; break;
		case PDJPG_YUV420: psz=3; psz2=3; break;
		case PDJPG_YA: psz=2; psz2=4; break;
		case PDJPG_Y: psz=1; psz2=2; break;
		case PDJPG_YYYA: psz=4; psz2=8; break;
		default: psz=4; psz2=8; break;
		}

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			if(pf==PDJPG_YUV420)
			{
				k=(((ys-(2*i+1))*xs2)*psz2)>>1;
				cs1=ibuf+k; cse=cs1+((xs*psz2)>>1);
				l=(((ys-(2*i+2))*xs2)*psz2)>>1;
				cs2=ibuf+l;
			}else
			{
				k=((ys-(2*i+1))*xs)*psz;
				cs1=ibuf+k; cse=cs1+xs*psz;
				l=((ys-(2*i+2))*xs)*psz;
				cs2=ibuf+l;
			}

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case PDJPG_YUVA:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+4); cub=*(cs1+5); cvb=*(cs1+6);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+4); cud=*(cs2+5); cvd=*(cs2+6);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case PDJPG_YUV:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+3); cub=*(cs1+4); cvb=*(cs1+5);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+3); cud=*(cs2+4); cvd=*(cs2+5);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case PDJPG_YUV422:
					cya=*(cs1+0); cua=*(cs1+1); cyb=*(cs1+2); cva=*(cs1+3);
					cyc=*(cs2+0); cuc=*(cs2+1); cyd=*(cs2+2); cvc=*(cs2+3);
					cu=(cua+cuc)>>1; cv=(cva+cvc)>>1;
					break;
				case PDJPG_YUV420:
					cya=*(cs1+0); cyb=*(cs1+1); cu=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+1); cv=*(cs2+2);
					break;
				case PDJPG_YA:
					cya=*(cs1+0); cyb=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+2);
					cu=0; cv=0;
					break;
				case PDJPG_Y:
					cya=*(cs1+0); cyb=*(cs1+1);
					cyc=*(cs2+0); cyd=*(cs2+1);
					cu=0; cv=0;
					break;

				case PDJPG_YYYA:
					cya=*(cs1+1); cyb=*(cs1+5);
					cyc=*(cs2+1); cyd=*(cs2+5);
					cu=0; cv=0;
					break;
				}

				*cty1++=cya; *cty1++=cyb;
				*cty2++=cyc; *cty2++=cyd;
				*ctu++=cu; *ctv++=cv;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}
}

PDGL_API int PDJPG_EncodeFastCtx(PDJPG_Context *ctx,
	byte *ibuf, byte *obuf, int xs, int ys, int qf, int pf)
{
	char tb[256];
	short *tp;
//	byte *cs, *cse, *cty, *ctu, *ctv;
	int xs2, ys2, xs3, ys3;
//	int cr, cg, cb, cy, cu, cv;

//	int cra, cga, cba, cya;
//	int crb, cgb, cbb, cyb;
//	int crc, cgc, cbc, cyc;
//	int crd, cgd, cbd, cyd;
//	byte *cs1, *cs2, *cty1, *cty2;
	byte *ctt;

	int i, j, k, l, n;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	ctx->jpg_mono=0;

	if(!ctx->jpg_tabcacheframe)
	{
		//full quality
		for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
		for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;
	}

	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->yb=malloc(xs2*ys2);
		ctx->ub=malloc(xs2*ys2);
		ctx->vb=malloc(xs2*ys2);

		ctx->ydb=malloc((xs2+8)*(ys2+16)*sizeof(short));
		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;

		memset(ctx->yb, 128, xs2*ys2);
		memset(ctx->ub, 128, xs2*ys2);
		memset(ctx->vb, 128, xs2*ys2);

		memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
		memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
		memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

		ctx->jpg_tabcacheframe=0;	//force rebuild
	}

	PDJPG_ConvertImageYUV(ctx,
		ibuf, xs, ys, pf,
		xs2, ys2, xs3, ys3);

	PDJPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2);
	PDJPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3);
	PDJPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3);

	if(ctx->jpg_tabcacheframe<=0)
	{
		j=(xs2/8)*(ys2/8);
		PDJPG_MakeQuantTabInputFast(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

		j=(xs3/8)*(ys3/8);
		PDJPG_MakeQuantTabInputFast(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
		PDJPG_MakeQuantTabInputFast(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
		for(i=0; i<64; i++)
			ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

		PDJPG_SetupQuantTabDivFP(ctx, 0);
		PDJPG_SetupQuantTabDivFP(ctx, 1);
	}

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k;
			k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		PDJHUFF_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

//	printf("M2\n");

	if(ctx->jpg_tabcacheframe<=0)
	{
		for(i=0; i<256; i++)ctx->dcs[i]=1;
		for(i=0; i<256; i++)ctx->acs[i]=1;
		for(i=0; i<256; i++)ctx->dcsuv[i]=1;
		for(i=0; i<256; i++)ctx->acsuv[i]=1;

		j=(xs2/8)*(ys2/8);
		k=(xs3/8)*(ys3/8);
		for(i=0; i<j; i++)
			PDJHUFF_StatBlock(ctx->ydb+i*64, ctx->dcs, ctx->acs);
		for(i=0; i<k; i++)
			PDJHUFF_StatBlock(ctx->udb+i*64, ctx->dcsuv, ctx->acsuv);
		for(i=0; i<k; i++)
			PDJHUFF_StatBlock(ctx->vdb+i*64, ctx->dcsuv, ctx->acsuv);

//		PDJHUFF_BuildLengths(ctx->dcs, 256, ctx->huff_len+0*256, 16);
//		PDJHUFF_BuildLengths(ctx->acs, 256, ctx->huff_len+1*256, 16);
//		PDJHUFF_BuildLengths(ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
//		PDJHUFF_BuildLengths(ctx->acsuv, 256, ctx->huff_len+3*256, 16);

		PDJHUFF_BuildLengthsAdjust(
			ctx->dcs, 256, ctx->huff_len+0*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->acs, 256, ctx->huff_len+1*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->acsuv, 256, ctx->huff_len+3*256, 16);
	}

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	if(ctx->alphaClr && (ctx->alphaClr!=ctx->oldAlphaClr))
	{
		sprintf(tb, "%d %d %d %d",
			(ctx->alphaClr&0xFF),
			((ctx->alphaClr>>8)&0xFF),
			((ctx->alphaClr>>16)&0xFF),
			((ctx->alphaClr>>24)&0xFF));
	
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP11;
		ctt=pdjhuff_ct;
		*pdjhuff_ct++=0x00;
		*pdjhuff_ct++=0x00;
		PDJHUFF_WriteString(ctx, "AlphaColor");
		PDJHUFF_WriteString(ctx, tb);
		i=(pdjhuff_ct-ctt);
		ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	}


	if(ctx->jpg_tabcacheframe<=0)
	{
		PDJPG_EmitDQT(ctx, 0);
		if(!ctx->jpg_mono)PDJPG_EmitDQT(ctx, 1);
	}

	PDJPG_EmitSOF(ctx, xs, ys);

	if(ctx->jpg_tabcacheframe<=0)
	{
		PDJPG_EmitDHT(ctx, 0);
		PDJPG_EmitDHT(ctx, 1);
		if(!ctx->jpg_mono)
		{
			PDJPG_EmitDHT(ctx, 2);
			PDJPG_EmitDHT(ctx, 3);
		}
	}

	PDJPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=((ys3)/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
	}

	PDJHUFF_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

	if(ctx->jpg_tabcacheframe<=0)
	{
//		ctx->jpg_tabcacheframe=16;
		ctx->jpg_tabcacheframe=8;
	}else
	{
		ctx->jpg_tabcacheframe--;
	}

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

PDGL_API int PDJPG_EncodeFast(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	static PDJPG_Context *ctx=NULL;
	int sz;
	
	if(!ctx)ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeFastCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
//	PDJPG_FreeContext(ctx);
	return(sz);
}

byte *PDJPG_EmitComponentLayer(PDJPG_Context *ctx,
	byte *ct, char *name)
{
	byte *ctt;
	int i;

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP11;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	PDJHUFF_WriteString(ctx, "CompLayer");
	PDJHUFF_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

byte *PDJPG_EmitMarkerJFIF(PDJPG_Context *ctx, byte *ct)
{
	byte *ctt;
	int i;

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP0;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	PDJHUFF_WriteString(ctx, "JFIF");

	*pdjhuff_ct++=0x01;		//version high
	*pdjhuff_ct++=0x02;		//version low

	*pdjhuff_ct++=0x00;		//no units

	*pdjhuff_ct++=0x00;		//X density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//Y density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//thumbnail
	*pdjhuff_ct++=0x00;

//	PDJHUFF_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

PDGL_API int PDJPG_EscapeEncodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if(*cs==0xFF)
		{
			cs++;
			*ct++=0xFF;
			*ct++=0x00;
			continue;
		}
		
		*ct++=*cs++;
	}
	
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

PDGL_API int PDJPG_EscapeEncodeSingleBuffer(byte *buf, int sz)
{
	byte *tbuf;
	int i;
	
	tbuf=malloc(sz*2);
	i=PDJPG_EscapeEncodeBuffer(buf, sz, tbuf, sz*2);
	if(i<0)return(i);
	memcpy(buf, tbuf, i);
	free(tbuf);
	return(i);
}

PDGL_API int PDJPG_EscapeDecodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

PDGL_API int PDJPG_EscapeDecodeSingleBuffer(byte *buf, int sz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=buf; cse=buf+sz;
	ct=buf; cte=buf+sz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-buf);
}

PDGL_API int PDJPG_EncodeLDatCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cts;
	int i, j, sz, tsz;
	
//	if(!ctx)ctx=PDJPG_AllocContext();

	tbuf=malloc(1<<20);
	sz=PDJPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);

	sz=PDJPG_EscapeEncodeSingleBuffer(tbuf, sz);

	cts=tbuf; tsz=sz;
	pdjhuff_ct=obuf; pdjhuff_win=0; pdjhuff_pos=0;
	while(tsz>=65528)
	{
		i=65529;
		if(cts[i-1]==0xFF)i--;
		j=i+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(j>>8)&0xFF;
		*pdjhuff_ct++=j&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, i);
		cts+=i; pdjhuff_ct+=i;
	}
	
	if((tsz>0) && (tsz<65528))
	{
		i=sz+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, tsz);
		pdjhuff_ct+=sz;
	}

	sz=pdjhuff_ct-obuf;
	free(tbuf);
	
	return(sz);
}

PDGL_API int PDJPG_EncodeBaseCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cs, *cse, *ct;
	int sz;

	tbuf=malloc(1<<20);
	sz=PDJPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);
	
	cs=tbuf; cse=tbuf+sz; ct=obuf;
	if((cs[0]==0xFF) && (cs[1]==JPG_SOI))
		cs+=2;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_EOI))
			break;
		*ct++=*cs++;
	}
	
	free(tbuf);
	return(ct-obuf);
}

PDGL_API int PDJPG_EncodeComponentCtx(
	PDJPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	byte *tbuf;
	byte *ct;
	int i, j, k, n;

	if(!rgba)return(-1);

	n=xs*ys;
	tbuf=malloc(xs*ys*4);

	ct=obuf;

	*ct++=0xFF;
	*ct++=JPG_SOI;

	ct=PDJPG_EmitMarkerJFIF(ctx, ct);

	ct=PDJPG_EmitComponentLayer(ctx, ct, "RGB");
//	i=PDJPG_EncodeCtx(ctx, rgba, ct, xs, ys, qf, 0);
	i=PDJPG_EncodeBaseCtx(ctx, rgba, ct, xs, ys, qf, 0);
	if(i<0) { free(tbuf); return(i); }
	ct+=i;
	
//	if((ct[-2]==0xFF) && (ct[-2]==JPG_EOI))
//		{ ct-=2; }
	
	if(norm)
	{
		for(i=0; i<n; i++)
		{
			tbuf[i*4+0]=norm[i*4+0];
			tbuf[i*4+1]=norm[i*4+2];
			tbuf[i*4+2]=norm[i*4+1];
			tbuf[i*4+3]=255;
		}

		ct=PDJPG_EmitComponentLayer(ctx, ct, "XYZ");
		i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(spec)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "SpRGB");
		i=PDJPG_EncodeLDatCtx(ctx, spec, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(norm || spec)
	{
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			tbuf[i*4+0]=norm?norm[i*4+3]:j;
			tbuf[i*4+1]=rgba[i*4+3];
			tbuf[i*4+2]=spec?spec[i*4+3]:j;
			tbuf[i*4+3]=255;
		}

		ct=PDJPG_EmitComponentLayer(ctx, ct, "DASe");
		i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}else
	{
		k=0;
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			if(j!=255)k=1;
			tbuf[i*4+0]=j;
			tbuf[i*4+1]=j;
			tbuf[i*4+2]=j;
			tbuf[i*4+3]=255;
		}

		if(k)
		{
			ct=PDJPG_EmitComponentLayer(ctx, ct, "Alpha");
			i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, PDJPG_YYYA);
			if(i<0) { free(tbuf); return(i); }
			ct+=i;
		}
	}

	if(luma)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "LuRGB");
		i=PDJPG_EncodeLDatCtx(ctx, luma, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	*ct++=0xFF;
	*ct++=JPG_EOI;

	free(tbuf);
	return(ct-obuf);
}

PDGL_API int PDJPG_EncodeComponent(
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	PDJPG_Context *ctx;
	int sz;
	
	ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeComponentCtx(ctx,
		rgba, norm, spec, luma,
		obuf, xs, ys, qf);
	PDJPG_FreeContext(ctx);
	return(sz);
}

#if 1
PDGL_API byte *PDJPG_Load(VFILE *fd, int *xs, int *ys)
{
	byte *buf, *obuf;
	int fsz;

	vfseek(fd, 0, 2);
	fsz=vftell(fd);
	vfseek(fd, 0, 0);

	buf=malloc(fsz+256);
	vfread(buf, 1, fsz, fd);

	obuf=PDJPG_Decode(buf, fsz, xs, ys);
	free(buf);

	return(obuf);
}

PDGL_API int PDJPG_Store(VFILE *fd, byte *ibuf, int xs, int ys, int qf)
{
	static byte *buf=NULL;
	int fsz;

	if(!buf)buf=malloc(1<<22);

	fsz=PDJPG_Encode(ibuf, buf, xs, ys, qf);
	if(fsz<0)return(fsz);

	vfwrite(buf, 1, fsz, fd);
//	free(buf);

	return(0);
}
#endif
/*
BGB Extensions:
APP11: BGBTech Tag
	FF,APP11,xx,xx,<ASCIZ TagName>, ...
	Tag-specific data until next marker.
	
	"AlphaColor":
		AlphaColor
		RGBA as string ("red green blue alpha").
		
		Specifies a "Alpha Color" extension, where any color sufficiently
		close to the given color (determined by 'alpha'), will be assumed
		to be a transparent pixel. These values are given in decimal.

	APP11 markers may indicate component layer:
		FF,APP11,xx,xx,"CompLayer\0", <layername:ASCIZ>
			"RGB": Base RGB
			"XYZ": Normal XYZ
			"SpRGB": Specular RGB
			"DASe": Depth, Alpha, Specular-Exponent
			"LuRGB": Luma RGB
			"Alpha": Mono alpha layer

	Component Layouts:
		3 component: (no marker, RGB)
		4 component: RGB+Alpha
		7 component: RGB+Alpha+LuRGB
		8 component: RGB+XYZ+DASe
		12 component: RGB+XYZ+SpRGB+DASe
		16 component: RGB+XYZ+SpRGB+DASe+LuRGB

	The APP11 tag for a layer will be followed by the layer
	(as a JPEG image), which may be placed within LDAT tags.
	
	Images lacking DHT and DQT will reuse those from the base image.

APP12: BGBTech Tag 2
	FF,APP12,xx,xx,tt,tt,tt,tt
		tt=FOURCC Tag.

	'LDAT': Layer Data.
	Gives an image/layer spread across a span of 'LDAT' tags.
	The encoded image will be split linearly across the tags.
*/

// #include <pdgl.h>
#include <walpng.h>

//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>

#include <math.h>

#ifndef PDGL_API
#define PDGL_API
#endif

#define DCTSZ	8
#define DCTSZ2	64

//typedef unsigned char byte;
//typedef unsigned short ushort;
//typedef unsigned int uint;

#define JPG_SOF0	0xC0
#define JPG_SOF1	0xC1
#define JPG_SOF2	0xC2
#define JPG_SOF3	0xC3
#define JPG_DHT		0xC4
#define JPG_SOF5	0xC5
#define JPG_SOF6	0xC6
#define JPG_SOF7	0xC7
#define JPG_JPG		0xC8
#define JPG_SOF9	0xC9
#define JPG_SOF10	0xCA
#define JPG_SOF11	0xCB
#define JPG_DAC		0xCC
#define JPG_SOF13	0xCD
#define JPG_SOF14	0xCE
#define JPG_SOF15	0xCF

#define JPG_RST0	0xD0
#define JPG_RST1	0xD1
#define JPG_RST2	0xD2
#define JPG_RST3	0xD3
#define JPG_RST4	0xD4
#define JPG_RST5	0xD5
#define JPG_RST6	0xD6
#define JPG_RST7	0xD7

#define JPG_SOI		0xD8
#define JPG_EOI		0xD9
#define JPG_SOS		0xDA
#define JPG_DQT		0xDB
#define JPG_DNL		0xDC
#define JPG_DRI		0xDD
#define JPG_DHP		0xDE
#define JPG_EXP		0xDF

#define JPG_APP0	0xE0
#define JPG_APP1	0xE1
#define JPG_APP2	0xE2
#define JPG_APP3	0xE3
#define JPG_APP4	0xE4
#define JPG_APP5	0xE5
#define JPG_APP6	0xE6
#define JPG_APP7	0xE7
#define JPG_APP8	0xE8
#define JPG_APP9	0xE9
#define JPG_APP10	0xEA
#define JPG_APP11	0xEB
#define JPG_APP12	0xEC
#define JPG_APP13	0xED
#define JPG_APP14	0xEE
#define JPG_APP15	0xEF

#define JPG_JPG0	0xF0
#define JPG_JPG1	0xF1
#define JPG_JPG2	0xF2
#define JPG_JPG3	0xF3
#define JPG_JPG4	0xF4
#define JPG_JPG5	0xF5
#define JPG_JPG6	0xF6
#define JPG_JPG7	0xF7
#define JPG_JPG8	0xF8
#define JPG_JPG9	0xF9
#define JPG_JPG10	0xFA
#define JPG_JPG11	0xFB
#define JPG_JPG12	0xFC
#define JPG_JPG13	0xFD
#define JPG_COM		0xFE

static const char *pdjpg_marker[]={
"SOF0", "SOF1", "SOF2", "SOF3", "DHT", "SOF5", "SOF6", "SOF7",
"JPG", "SOF9", "SOF10", "SOF11", "DAC", "SOF13", "SOF14", "SOF15",
"RST0", "RST1", "RST2", "RST3", "RST4", "RST5", "RST6", "RST7",
"SOI", "EOI", "SOS", "DQT", "DNL", "DRI", "DHP", "EXP",
"APP0", "APP1", "APP2", "APP3", "APP4", "APP5", "APP6", "APP7", 
"APP8", "APP9", "APP10", "APP11", "APP12", "APP13", "APP14", "APP15", 
"JPG0", "JPG1", "JPG2", "JPG3", "JPG4", "JPG5", "JPG6", "JPG7", 
"JPG8", "JPG9", "JPG10", "JPG11", "JPG12", "JPG13", "COM", ""
};

static const int pdjpg_zigzag[64]={
 0,  1,  5,  6, 14, 15, 27, 28,
 2,  4,  7, 13, 16, 26, 29, 42,
 3,  8, 12, 17, 25, 30, 41, 43,
 9, 11, 18, 24, 31, 40, 44, 53,
10, 19, 23, 32, 39, 45, 52, 54,
20, 22, 33, 38, 46, 51, 55, 60,
21, 34, 37, 47, 50, 56, 59, 61,
35, 36, 48, 49, 57, 58, 62, 63
};

static const int pdjpg_zigzag2[64]={
 0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63
};

#if 0
byte *pdjhuff_cs;	//current pos in bitstream (input)
byte *pdjhuff_ct;	//current pos in bitstream (output)
uint pdjhuff_win;	//bitstream window
int pdjhuff_pos;	//bitstream offset
int pdjhuff_isend;	//bitstream has broken (decoder)
#endif

#if 1
#define pdjhuff_cs		ctx->huff_cs
#define pdjhuff_ct		ctx->huff_ct
#define pdjhuff_win		ctx->huff_win
#define pdjhuff_pos		ctx->huff_pos
#define pdjhuff_isend	ctx->huff_isend
#endif


PDGL_API PDJPG_Context *PDJPG_AllocContext();
PDGL_API void PDJPG_FreeContext(PDJPG_Context *ctx);
PDGL_API void PDJPG_SetContextAlphaColor(PDJPG_Context *ctx,
	int cr, int cg, int cb, int ca);

//Common

#if 1
void PDJPG_TransDCT_Horiz(byte *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	oblk[0]=ib[0]*91  +ib[1]*91  +ib[2]*91  +ib[3]*91  
			+ib[4]*91  +ib[5]*91  +ib[6]*91  +ib[7]*91;
	oblk[1]=ib[0]*126 +ib[1]*106 +ib[2]*71  +ib[3]*25  
			-ib[4]*25  -ib[5]*71  -ib[6]*106 -ib[7]*126;
	oblk[2]=ib[0]*118 +ib[1]*49  -ib[2]*49  -ib[3]*118 
			-ib[4]*118 -ib[5]*49  +ib[6]*49  +ib[7]*118;
	oblk[3]=ib[0]*106 -ib[1]*25  -ib[2]*126 -ib[3]*71  
			+ib[4]*71  +ib[5]*126 +ib[6]*25  -ib[7]*106;
	oblk[4]=ib[0]*91  -ib[1]*91  -ib[2]*91  +ib[3]*91  
			+ib[4]*91  -ib[5]*91  -ib[6]*91  +ib[7]*91;
	oblk[5]=ib[0]*71  -ib[1]*126 +ib[2]*25  +ib[3]*106 
			-ib[4]*106 -ib[5]*25  +ib[6]*126 -ib[7]*71;
	oblk[6]=ib[0]*49  -ib[1]*118 +ib[2]*118 -ib[3]*49  
			-ib[4]*49  +ib[5]*118 -ib[6]*118 +ib[7]*49;
	oblk[7]=ib[0]*25  -ib[1]*71  +ib[2]*106 -ib[3]*126 
			+ib[4]*126 -ib[5]*106 +ib[6]*71  -ib[7]*25;
}

void PDJPG_TransDCT_Vert(int *iblk, int *oblk)
{
	oblk[ 0]=iblk[0]*91  +iblk[8]*91  
			+iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  +iblk[40]*91  
			+iblk[48]*91  +iblk[56]*91;
	oblk[ 8]=iblk[0]*126 +iblk[8]*106 
			+iblk[16]*71  +iblk[24]*25  
			-iblk[32]*25  -iblk[40]*71  
			-iblk[48]*106 -iblk[56]*126;
	oblk[16]=iblk[0]*118 +iblk[8]*49  
			-iblk[16]*49  -iblk[24]*118 
			-iblk[32]*118 -iblk[40]*49  
			+iblk[48]*49  +iblk[56]*118;
	oblk[24]=iblk[0]*106 -iblk[8]*25  
			-iblk[16]*126 -iblk[24]*71  
			+iblk[32]*71  +iblk[40]*126 
			+iblk[48]*25  -iblk[56]*106;
	oblk[32]=iblk[0]*91  -iblk[8]*91  
			-iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  -iblk[40]*91  
			-iblk[48]*91  +iblk[56]*91;
	oblk[40]=iblk[0]*71  -iblk[8]*126 
			+iblk[16]*25  +iblk[24]*106
			-iblk[32]*106 -iblk[40]*25  
			+iblk[48]*126 -iblk[56]*71;
	oblk[48]=iblk[0]*49  -iblk[8]*118
			+iblk[16]*118 -iblk[24]*49  
			-iblk[32]*49  +iblk[40]*118 
			-iblk[48]*118 +iblk[56]*49;
	oblk[56]=iblk[0]*25  -iblk[8]*71  
			+iblk[16]*106 -iblk[24]*126 
			+iblk[32]*126 -iblk[40]*106 
			+iblk[48]*71  -iblk[56]*25;
}

void PDJPG_TransDCT(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransDCT_Horiz(iblk+0, s+0);
	PDJPG_TransDCT_Horiz(iblk+8, s+8);
	PDJPG_TransDCT_Horiz(iblk+16, s+16);
	PDJPG_TransDCT_Horiz(iblk+24, s+24);
	PDJPG_TransDCT_Horiz(iblk+32, s+32);
	PDJPG_TransDCT_Horiz(iblk+40, s+40);
	PDJPG_TransDCT_Horiz(iblk+48, s+48);
	PDJPG_TransDCT_Horiz(iblk+56, s+56);

	PDJPG_TransDCT_Vert(s+0, t+0);
	PDJPG_TransDCT_Vert(s+1, t+1);
	PDJPG_TransDCT_Vert(s+2, t+2);
	PDJPG_TransDCT_Vert(s+3, t+3);
	PDJPG_TransDCT_Vert(s+4, t+4);
	PDJPG_TransDCT_Vert(s+5, t+5);
	PDJPG_TransDCT_Vert(s+6, t+6);
	PDJPG_TransDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i]>>16;
}

#endif

#if 1
void PDJPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[0]* 91;	b=iblk[4]* 91;
	c=iblk[2]*118;	d=iblk[2]* 49;
	e=iblk[6]*118;	f=iblk[6]* 49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[1]*126+iblk[3]*106+iblk[5]* 71+iblk[7]* 25;
	n=iblk[1]*106-iblk[3]* 25-iblk[5]*126-iblk[7]* 71;
	o=iblk[1]* 71-iblk[3]*126+iblk[5]* 25+iblk[7]*106;
	p=iblk[1]* 25-iblk[3]* 71+iblk[5]*106-iblk[7]*126;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
}

void PDJPG_TransIDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]* 91;	b=iblk[32]*91;
	c=iblk[16]*118;	d=iblk[16]*49;
	e=iblk[48]*118;	f=iblk[48]*49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[8]*126+iblk[24]*106+iblk[40]* 71+iblk[56]* 25;
	n=iblk[8]*106-iblk[24]* 25-iblk[40]*126-iblk[56]* 71;
	o=iblk[8]* 71-iblk[24]*126+iblk[40]* 25+iblk[56]*106;
	p=iblk[8]* 25-iblk[24]* 71+iblk[40]*106-iblk[56]*126;
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

void PDJPG_TransIDCT(short *iblk, byte *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIDCT_Horiz(iblk+0, s+0);
	PDJPG_TransIDCT_Horiz(iblk+8, s+8);
	PDJPG_TransIDCT_Horiz(iblk+16, s+16);
	PDJPG_TransIDCT_Horiz(iblk+24, s+24);
	PDJPG_TransIDCT_Horiz(iblk+32, s+32);
	PDJPG_TransIDCT_Horiz(iblk+40, s+40);
	PDJPG_TransIDCT_Horiz(iblk+48, s+48);
	PDJPG_TransIDCT_Horiz(iblk+56, s+56);

	PDJPG_TransIDCT_Vert(s+0, t+0);
	PDJPG_TransIDCT_Vert(s+1, t+1);
	PDJPG_TransIDCT_Vert(s+2, t+2);
	PDJPG_TransIDCT_Vert(s+3, t+3);
	PDJPG_TransIDCT_Vert(s+4, t+4);
	PDJPG_TransIDCT_Vert(s+5, t+5);
	PDJPG_TransIDCT_Vert(s+6, t+6);
	PDJPG_TransIDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=(t[i]>>16)+128;
		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
//		oblk[i]=(j<0)?0:((j>255)?255:j);
	}
}

#endif

#define FLTOFIX14(x)	((int)((x)*16384+0.5))
#define FIX14TOI(x)	(((x)+8192)>>14)

#if 1
//RDCT: Integer Reversible DCT (Lossless)

void PDJPG_TransRDCT_Horiz(byte *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[2]-128;	ib[1]=iblk[7]-128;
	ib[2]=iblk[4]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[6]-128;	ib[5]=iblk[0]-128;
	ib[6]=iblk[1]-128;	ib[7]=iblk[5]-128;

	ib[7]=(-ib[7])+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));
	ib[0]=ib[0]+FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[1]=ib[1]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[2]=ib[2]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[3]=ib[3]+FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[4]=ib[4]+FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[5]=ib[5]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[6]=ib[6]+FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[7]=ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	oblk[0]=ib[3];	oblk[1]=ib[6];
	oblk[2]=ib[4];	oblk[3]=ib[2];
	oblk[4]=ib[5];	oblk[5]=ib[7];
	oblk[6]=ib[0];	oblk[7]=ib[1];
}

void PDJPG_TransRDCT_Vert(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[16];	ib[1]=iblk[56];
	ib[2]=iblk[32];	ib[3]=iblk[24];
	ib[4]=iblk[48];	ib[5]=iblk[ 0];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	ib[7]=(-ib[7])+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));
	ib[0]=ib[0]+FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[1]=ib[1]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[2]=ib[2]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[3]=ib[3]+FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[4]=ib[4]+FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[5]=ib[5]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[6]=ib[6]+FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[7]=ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	oblk[0]=ib[3];	oblk[8]=ib[6];
	oblk[16]=ib[4];	oblk[24]=ib[2];
	oblk[32]=ib[5];	oblk[40]=ib[7];
	oblk[48]=ib[0];	oblk[56]=ib[1];
}

void PDJPG_TransRDCT(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransRDCT_Horiz(iblk+0, s+0);
	PDJPG_TransRDCT_Horiz(iblk+8, s+8);
	PDJPG_TransRDCT_Horiz(iblk+16, s+16);
	PDJPG_TransRDCT_Horiz(iblk+24, s+24);
	PDJPG_TransRDCT_Horiz(iblk+32, s+32);
	PDJPG_TransRDCT_Horiz(iblk+40, s+40);
	PDJPG_TransRDCT_Horiz(iblk+48, s+48);
	PDJPG_TransRDCT_Horiz(iblk+56, s+56);

	PDJPG_TransRDCT_Vert(s+0, t+0);
	PDJPG_TransRDCT_Vert(s+1, t+1);
	PDJPG_TransRDCT_Vert(s+2, t+2);
	PDJPG_TransRDCT_Vert(s+3, t+3);
	PDJPG_TransRDCT_Vert(s+4, t+4);
	PDJPG_TransRDCT_Vert(s+5, t+5);
	PDJPG_TransRDCT_Vert(s+6, t+6);
	PDJPG_TransRDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}
#endif

#if 1
void PDJPG_TransIRDCT_Horiz(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[6];	ib[1]=iblk[7];
	ib[2]=iblk[3];	ib[3]=iblk[0];
	ib[4]=iblk[2];	ib[5]=iblk[4];
	ib[6]=iblk[1];	ib[7]=iblk[5];

	ib[7]=ib[7]-FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	ib[6]=ib[6]-FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[5]=ib[5]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[4]=ib[4]-FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[3]=ib[3]-FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[2]=ib[2]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[1]=ib[1]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[0]=ib[0]-FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[7]=-ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));

	oblk[0]=ib[5];	oblk[1]=ib[6];
	oblk[2]=ib[0];	oblk[3]=ib[3];
	oblk[4]=ib[2];	oblk[5]=ib[7];
	oblk[6]=ib[4];	oblk[7]=ib[1];
}

void PDJPG_TransIRDCT_Vert(short *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[48];	ib[1]=iblk[56];
	ib[2]=iblk[24];	ib[3]=iblk[ 0];
	ib[4]=iblk[16];	ib[5]=iblk[32];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	ib[7]=ib[7]-FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	ib[6]=ib[6]-FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[5]=ib[5]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[4]=ib[4]-FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[3]=ib[3]-FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[2]=ib[2]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[1]=ib[1]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[0]=ib[0]-FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[7]=-ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));

	oblk[ 0]=ib[5];	oblk[ 8]=ib[6];
	oblk[16]=ib[0];	oblk[24]=ib[3];
	oblk[32]=ib[2];	oblk[40]=ib[7];
	oblk[48]=ib[4];	oblk[56]=ib[1];
}

void PDJPG_TransIRDCT(short *iblk, byte *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransIRDCT_Vert(iblk+0, s+0);
	PDJPG_TransIRDCT_Vert(iblk+1, s+1);
	PDJPG_TransIRDCT_Vert(iblk+2, s+2);
	PDJPG_TransIRDCT_Vert(iblk+3, s+3);
	PDJPG_TransIRDCT_Vert(iblk+4, s+4);
	PDJPG_TransIRDCT_Vert(iblk+5, s+5);
	PDJPG_TransIRDCT_Vert(iblk+6, s+6);
	PDJPG_TransIRDCT_Vert(iblk+7, s+7);

	PDJPG_TransIRDCT_Horiz(s+0, t+0);
	PDJPG_TransIRDCT_Horiz(s+8, t+8);
	PDJPG_TransIRDCT_Horiz(s+16, t+16);
	PDJPG_TransIRDCT_Horiz(s+24, t+24);
	PDJPG_TransIRDCT_Horiz(s+32, t+32);
	PDJPG_TransIRDCT_Horiz(s+40, t+40);
	PDJPG_TransIRDCT_Horiz(s+48, t+48);
	PDJPG_TransIRDCT_Horiz(s+56, t+56);

	for(i=0; i<64; i++)
	{
		j=(t[i])+128;
		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
	}
}
#endif


#if 0
//HAD: Hadamard Transform (Lossless)

void PDJPG_TransHAD_Horiz(byte *iblk, int *oblk)
{
	int ia[8];
	int ib[8];
	int ic[8];
	int id[8];

	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	ia[0]=ib[0]+ib[4];
	ia[1]=ib[1]+ib[5];
	ia[2]=ib[2]+ib[6];
	ia[3]=ib[3]+ib[7];
	ia[4]=(ia[0]>>1)-ib[4];
	ia[5]=(ia[1]>>1)-ib[5];
	ia[6]=(ia[2]>>1)-ib[6];
	ia[7]=(ia[3]>>1)-ib[7];

	ic[0]=ia[0]+ia[2];
	ic[1]=ia[1]+ia[3];
	ic[2]=(ic[0]>>1)-ia[2];
	ic[3]=(ic[1]>>1)-ia[3];
	ic[4]=ia[4]+ia[6];
	ic[5]=ia[5]+ia[7];
	ic[6]=(ic[4]>>1)-ia[6];
	ic[7]=(ic[5]>>1)-ia[7];

	id[0]=ic[0]+ic[1];
	id[1]=(id[0]>>1)-ic[1];
	id[2]=ic[2]+ic[3];
	id[3]=(id[2]>>1)-ic[3];
	id[4]=ic[4]+ic[5];
	id[5]=(id[4]>>1)-ic[5];
	id[6]=ic[6]+ic[7];
	id[7]=(id[6]>>1)-ic[7];

	oblk[0]=id[0];	oblk[1]=id[4];
	oblk[2]=id[6];	oblk[3]=id[2];
	oblk[4]=id[3];	oblk[5]=id[7];
	oblk[6]=id[5];	oblk[7]=id[1];
}

void PDJPG_TransHAD_Vert(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[16];	ib[1]=iblk[56];
	ib[2]=iblk[32];	ib[3]=iblk[24];
	ib[4]=iblk[48];	ib[5]=iblk[ 0];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	oblk[0]=ib[3];	oblk[8]=ib[6];
	oblk[16]=ib[4];	oblk[24]=ib[2];
	oblk[32]=ib[5];	oblk[40]=ib[7];
	oblk[48]=ib[0];	oblk[56]=ib[1];
}

void PDJPG_TransHAD(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	PDJPG_TransHAD_Horiz(iblk+0, s+0);
	PDJPG_TransHAD_Horiz(iblk+8, s+8);
	PDJPG_TransHAD_Horiz(iblk+16, s+16);
	PDJPG_TransHAD_Horiz(iblk+24, s+24);
	PDJPG_TransHAD_Horiz(iblk+32, s+32);
	PDJPG_TransHAD_Horiz(iblk+40, s+40);
	PDJPG_TransHAD_Horiz(iblk+48, s+48);
	PDJPG_TransRDCT_Horiz(iblk+56, s+56);

	PDJPG_TransRDCT_Vert(s+0, t+0);
	PDJPG_TransRDCT_Vert(s+1, t+1);
	PDJPG_TransRDCT_Vert(s+2, t+2);
	PDJPG_TransRDCT_Vert(s+3, t+3);
	PDJPG_TransRDCT_Vert(s+4, t+4);
	PDJPG_TransRDCT_Vert(s+5, t+5);
	PDJPG_TransRDCT_Vert(s+6, t+6);
	PDJPG_TransRDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}
#endif




//Decoder

int PDJHUFF_NextByte(PDJPG_Context *ctx)
{
	int i, j;

	if(pdjhuff_isend)return(0xFF);

	i=*pdjhuff_cs++;
	if(i==0xFF)
	{
		j=*pdjhuff_cs++;
		if(j)
		{
//			printf("bitstream problem\n");
			pdjhuff_isend=1;
		}
	}
	return(i);
}

int PDJHUFF_InitStream(PDJPG_Context *ctx, byte *buf)
{
	pdjhuff_pos=0;
	pdjhuff_isend=0;

	pdjhuff_cs=buf;
	pdjhuff_win=PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
	return(0);
}

int PDJHUFF_ReadBit(PDJPG_Context *ctx)
{
	int i;

	i=(pdjhuff_win>>(31-pdjhuff_pos))&1;
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

int PDJHUFF_ReadNBits(PDJPG_Context *ctx, int n)
{
	int i;

	i=(pdjhuff_win>>(32-n-pdjhuff_pos))&((1<<n)-1);
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

void PDJHUFF_SkipNBits(PDJPG_Context *ctx, int n)
{
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
		pdjhuff_pos-=8;
	}
}

int PDJHUFF_PeekWord(PDJPG_Context *ctx)
{
	int i;
	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
	return(i);
}

#if 1
int PDJHUFF_DecodeSymbol(PDJPG_Context *ctx, int tab)
{
	int i, j, k, l;

//	i=PDJHUFF_PeekWord(ctx);
//	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
//	i=(u16)(pdjhuff_win>>(16-pdjhuff_pos));

	i=(byte)(pdjhuff_win>>(24-pdjhuff_pos));
	
	tab<<=8;
//	j=ctx->huff_idx[tab|k];
//	j=ctx->huff_idx[tab|(i>>8)];
	j=ctx->huff_idx[tab|i];

#if 1
//	l=tab|j;
//	k=ctx->huff_len[l];
	k=ctx->huff_len[tab|j];
	if(k<=8)
	{
		pdjhuff_pos+=k;
//		while(pdjhuff_pos>=8)
		if(pdjhuff_pos>=8)
		{
			pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
			pdjhuff_pos-=8;
		}

//		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

	i=(u16)(pdjhuff_win>>(16-pdjhuff_pos));

	while(1)
	{
		l=tab|j;
		k=ctx->huff_len[l];
//		if(!k)break;

#if 1
		if((i>>(16-k))!=ctx->huff_code[l])
//		if((k>=8) && (i>>(16-k))!=ctx->huff_code[l])
		{
			j=ctx->huff_next[l];
			if(!j)break;
			continue;
		}
#endif

		pdjhuff_pos+=k;
		while(pdjhuff_pos>=8)
//		if(pdjhuff_pos>=8)
		{
			pdjhuff_win=(pdjhuff_win<<8)|PDJHUFF_NextByte(ctx);
			pdjhuff_pos-=8;
		}

//		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}

	return(-1);
}
#endif


#if 0
int PDJHUFF_DecodeSymbol(PDJPG_Context *ctx, int tab)
{
	int i, j, k, l;

	tab<<=8;

#if 1
	i=PDJHUFF_PeekWord(ctx);
	j=ctx->huff_idx[tab|(i>>8)];
	while(1)
	{
		l=tab|j;
		k=ctx->huff_len[l];
//		if(!k)break;

		if((i>>(16-k))!=ctx->huff_code[l])
		{
			j=ctx->huff_next[l];
			if(!j)break;
			continue;
		}
		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

#if 0
	i=PDJHUFF_PeekWord(ctx);
	for(j=0; j<256; j++)
	{
		k=ctx->huff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=ctx->huff_code[tab|j])
			continue;
		PDJHUFF_SkipNBits(ctx, k);
		return(j);
	}
#endif

	return(-1);
}
#endif

int PDJHUFF_DecodeDiffDC(PDJPG_Context *ctx, int tab)
{
	int i, j;

	i=PDJHUFF_DecodeSymbol(ctx, tab);
	j=PDJHUFF_ReadNBits(ctx, i);

	if(!(j&(1<<(i-1))))
		j=(-1<<i)+j+1;
	return(j);
}

int PDJHUFF_DecodeBlock(PDJPG_Context *ctx,
	short *buf, int dctab, int actab,
	int ni, int nn)
{
	int i, j, k;

//	for(i=1; i<64; i++)buf[i]=0;
	memset(buf+1, 0, 63*sizeof(short));

	buf[0]+=PDJHUFF_DecodeDiffDC(ctx, dctab);
	for(i=1; i<64; i++)
	{
		j=PDJHUFF_DecodeSymbol(ctx, actab);
		if(j<=0)
		{
			if(j<0)
			{
				printf("bad dct block1 %02X %d/%d\n", j, ni, nn);
				return(-1);
			}
			break;
		}

		i+=j>>4;	//preceding 0's
		if(!(j&15))continue;

		j&=15;
		k=PDJHUFF_ReadNBits(ctx, j);
		if(!(k&(1<<(j-1))))
			k=(-1<<j)+k+1;

		j=pdjpg_zigzag2[i];
		buf[j]=k;
	}

#if 0
	for(j=i+1; j<64; j++)
	{
//		buf[i]=0;
		buf[pdjpg_zigzag2[j]]=0;
	}
#endif

	if(i>64)
	{
		printf("bad dct block1 %02X %d/%d\n", j, ni, nn);
		return(-1);
	}

	return(0);
}

void PDJHUFF_QuantBlock(
	PDJPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	
//	for(i=0; i<64; i++)
//		obuf[i]=ibuf[i]/ctx->jpg_qt[qid][i];

	for(i=0; i<64; i++)
		obuf[i]=(ibuf[i]*ctx->jpg_qtfp[qid][i])>>12;
}

void PDJHUFF_DequantBlock(
	PDJPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	for(i=0; i<64; i++)
		obuf[i]=ibuf[i]*ctx->jpg_qt[qid][i];
}

void PDJPG_SetupQuantTabDivFP(PDJPG_Context *ctx, int qid)
{
	int i;
	
	for(i=0; i<64; i++)
		ctx->jpg_qtfp[qid][i]=4096.0/ctx->jpg_qt[qid][i];
}

int PDJPG_MarkerSOS(PDJPG_Context *ctx, byte *buf)
{
	short dbuf[4*64];
	byte ch[4], cv[4], qid[4];
	byte step[4];
	int xi[4], yi[4], wi[4], hi[4];
	byte cdt[4], cat[4];
	int ccnt[4];

	byte *s;
	int i, j, k, l, i1, j1, k1, l1;
	int w, h, n, ns, rt;

	l=(buf[0]<<8)|buf[1];
//	printf("ns %d\n", buf[2]);

	ns=buf[2]; rt=0;
	s=buf+3;
	for(i=0; i<buf[2]; i++)
	{
//		printf("%d %d %d\n", s[0], s[1]>>4, s[1]&15);

		cdt[i]=s[1]>>4;
		cat[i]=s[1]&15;

		for(j=0; j<ctx->jpg_nc; j++)
			if(ctx->jpg_cid[j]==s[0])
		{
			ch[i]=ctx->jpg_ch[j];
			cv[i]=ctx->jpg_cv[j];
			qid[i]=ctx->jpg_qid[j];
			xi[i]=ctx->jpg_cxi[j];
			yi[i]=ctx->jpg_cyi[j];

			step[i]=ch[i]*cv[i];
			break;
		}

		w=(xi[i]+7)/8;
		h=(yi[i]+7)/8;
//		w=(xi[i]+15)/8;
//		h=(yi[i]+15)/8;
		wi[i]=w;
		hi[i]=h;

		n=(w+1)*(h+2);
		ctx->jpg_scid[i]=s[0];
		ctx->jpg_scn[i]=j;
		if(!ctx->jpg_scbuf[i])
			ctx->jpg_scbuf[i]=malloc(n*64*sizeof(short));
		if(!ctx->jpg_sibuf[i])
			ctx->jpg_sibuf[i]=malloc(n*64);

//		memset(ctx->jpg_sibuf[i], 0, n*64);

		ccnt[i]=0;

		s+=2;
	}
	s+=3;

	i=(ctx->xs+ctx->jpg_chm*8-1)/(ctx->jpg_chm*8);
	j=(ctx->ys+ctx->jpg_chn*8-1)/(ctx->jpg_chn*8);
	n=i*j;

	PDJHUFF_InitStream(ctx, s);

	for(i=0; i<(4*64); i++)dbuf[i]=0;

	rt=0;
	for(i=0; i<n; i++)
	{
		for(j=0; j<ns; j++)
		{
			for(k=0; k<cv[j]; k++)
			{
				for(l=0; l<ch[j]; l++)
				{
					if(rt<0)break;

					i1=(i/(wi[j]/ch[j]))*ch[j];
					j1=(i%(wi[j]/ch[j]))*ch[j];
					k1=((i1+k)*wi[j])+(j1+l);

					rt=PDJHUFF_DecodeBlock(ctx, dbuf+j*64,
						cdt[j]*2+0, cat[j]*2+1, i, n);
					if(rt<0)break;
					PDJHUFF_DequantBlock(ctx, dbuf+j*64,
						ctx->jpg_scbuf[j]+k1*64, qid[j]);
						
					if(ctx->jpg_rdct)
					{
						PDJPG_TransIRDCT(ctx->jpg_scbuf[j]+k1*64,
							ctx->jpg_sibuf[j]+k1*64);
					}else
					{
						PDJPG_TransIDCT(ctx->jpg_scbuf[j]+k1*64,
							ctx->jpg_sibuf[j]+k1*64);
					}
				}
				if(rt<0)break;
			}
			if(rt<0)break;
		}
		if(rt<0)break;
	}

	if(rt<0)
	{
		printf("PDJPG_MarkerSOS: Bad Image\n");
		return(-1);
	}

	i=ctx->huff_cs-buf;
	return(i);

//	return(0);
}

int PDJPG_MarkerSOF0(PDJPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, m, n;

	l=(buf[0]<<8)|buf[1];
//	printf("p %d\n", buf[2]);

	i=(buf[3]<<8)|buf[4];
	j=(buf[5]<<8)|buf[6];

	ctx->xs=j;
	ctx->ys=i;
//	printf("size %dx%d\n", j, i);

	m=0; n=0;

	k=buf[7];
	s=buf+8;
	for(i=0; i<k; i++)
	{
		ctx->jpg_cid[i]=s[0];
		ctx->jpg_ch[i]=s[1]>>4;
		ctx->jpg_cv[i]=s[1]&15;
		ctx->jpg_qid[i]=s[2];

		if(ctx->jpg_ch[i]>m)m=ctx->jpg_ch[i];
		if(ctx->jpg_cv[i]>n)n=ctx->jpg_cv[i];

//		printf("CID %d: %d %d %d\n", ctx->jpg_cid[i],
//			ctx->jpg_ch[i], ctx->jpg_cv[i], ctx->jpg_qid[i]);
		s+=3;
	}

	ctx->jpg_chm=m;
	ctx->jpg_chn=n;

	for(i=0; i<k; i++)
	{
		ctx->jpg_cxi[i]=(ctx->jpg_ch[i]*ctx->xs)/m;
		ctx->jpg_cyi[i]=(ctx->jpg_cv[i]*ctx->ys)/n;
	}

	ctx->jpg_nc=k;

	return(0);
}

int PDJPG_MarkerDQT(PDJPG_Context *ctx, byte *buf)
{
	byte *s, *se;
	int i, j, l;

	l=(buf[0]<<8)|buf[1];

	s=buf+2;
	se=buf+l;

	while(s<se)
	{
		i=(s[0]>>4)&15;
		if(i)
		{
//			printf("bad bits %d\n", i);
			return(-1);
		}
		i=s[0]&15;
//		printf("dest %d\n", i);

		for(j=0; j<64; j++)
			ctx->jpg_qt[i][pdjpg_zigzag2[j]]=s[j+1];
		s+=65;
	}
	
	return(s-buf);
//	return(0);
}

int PDJPG_MarkerDHT(PDJPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, tn;

	l=(buf[0]<<8)|buf[1];

	j=(buf[2]>>4)&15;
	i=buf[2]&15;
//	printf("dest %d, type %d\n", i, j);

	tn=i*2+j;

	for(i=0; i<256; i++)
		ctx->huff_len[tn*256+i]=0;

	cnt=buf+3;
	s=cnt+16;
	k=0; l=0;
	for(i=0; i<16; i++)
	{
		k<<=1;
		for(j=0; j<cnt[i]; j++)
		{
			ctx->huff_code[tn*256+(*s)]=k++;
			ctx->huff_len[tn*256+(*s)]=i+1;
			ctx->huff_mask[tn*256+(*s)]=(1<<(i+1))-1;
			l=i+1;
			s++;
		}
	}
//	printf("%04X %d\n", k, l);

	//build lookup indices / chains

	for(i=0; i<256; i++)
	{
		ctx->huff_next[tn*256+i]=0;
		ctx->huff_idx[tn*256+i]=0;
	}

	for(i=0; i<256; i++)
	{
		l=ctx->huff_len[tn*256+i];
		if(!l)continue;
		j=ctx->huff_code[tn*256+i];
		
		if(l<=8)
		{
			j=j<<(8-l);
			k=1<<(8-l);
			while((k--) && (j<256))
			{
				ctx->huff_idx[tn*256+j]=i;
				j++;
			}
		}else
		{
			j=j>>(l-8);
			ctx->huff_next[tn*256+i]=
				ctx->huff_idx[tn*256+j];
			ctx->huff_idx[tn*256+j]=i;
		}
	}

	return(s-buf);
//	return(0);
}

int PDJPG_MarkerAPP0(PDJPG_Context *ctx, byte *buf)
{
	return(0);
}

int PDJPG_MarkerAPP11(PDJPG_Context *ctx, byte *buf)
{
	int cr, cg, cb, ca;

	buf+=2;

	if(!strcmp((char *)buf, "AlphaColor"))
	{
		buf+=strlen((char *)buf)+1;
		sscanf(buf, "%d %d %d %d", &cr, &cg, &cb, &ca);
		PDJPG_SetContextAlphaColor(ctx, cr, cg, cb, ca);
		return(1);
	}
	
	return(0);
}

int PDJPG_MarkerAPP12(PDJPG_Context *ctx, byte *buf)
{
	int i;
	buf+=2;

	i=(buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
//	printf("PDJPG_MarkerAPP12: %08X\n", i);

	if(!memcmp(buf, "BCST", 4))
	{
		ctx->bcst_version=(buf[4]<<8)|buf[5];
		ctx->bcst_trans=buf[6];
		ctx->bcst_bpp=buf[7];
		ctx->bcst_flags=
			(buf[8]<<24)|(buf[9]<<16)|
			(buf[10]<<8)|buf[11];
		
		ctx->jpg_clrtrans=ctx->bcst_trans;
		
		if(ctx->bcst_flags&PDJPG_BCSFL_RDCT)
			ctx->jpg_rdct=1;
			
//		printf("PDJPG_MarkerAPP12: BCST %04X %02X %02X %08X\n",
//			ctx->bcst_version, ctx->bcst_trans,
//			ctx->bcst_bpp, ctx->bcst_flags);
		return(1);
	}

	return(0);
}

int PDJPG_MarkerAPP14(PDJPG_Context *ctx, byte *buf)
{
	buf+=2;

#if 0
	if(!memcmp((char *)buf, "Adobe", 5))
	{
		ctx->jpg_app14_dctversion=(buf[5]<<8)|buf[6];
		ctx->jpg_app14_flags0=(buf[7]<<8)|buf[8];
		ctx->jpg_app14_flags1=(buf[9]<<8)|buf[10];
		ctx->jpg_app14_trans=buf[11];
		
		switch(ctx->jpg_app14_trans)
		{
		case 0: ctx->jpg_clrtrans=PDJPG_CLRS_RGB; break;
		case 1: ctx->jpg_clrtrans=PDJPG_CLRS_YCBCR; break;
		case 2: ctx->jpg_clrtrans=PDJPG_CLRS_YCCK; break;
		}
		
		return(1);
	}
#endif

	return(0);
}

int PDJPG_MarkerAPPN(PDJPG_Context *ctx, byte *buf)
{
	return(0);
}

#if 0
int PDJPG_GetComponentPixel(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	id=ctx->jpg_scn[cn];

	i=x*ctx->jpg_schsc[cn];
	j=y*ctx->jpg_scvsc[cn];
//	i=(ctx->jpg_ch[id]*x)/ctx->jpg_chm;
//	j=(ctx->jpg_cv[id]*y)/ctx->jpg_chn;
	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
	h=ctx->jpg_scvs[cn];
//	w=(ctx->jpg_cxi[id]+7)/8;
//	h=(ctx->jpg_cyi[id]+7)/8;
//	w=(ctx->jpg_cxi[id]+15)/8;
//	h=(ctx->jpg_cyi[id]+15)/8;
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}
#endif

#if 1
int PDJPG_GetComponentPixel(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	i=x*ctx->jpg_schsc[cn];
//	j=y*ctx->jpg_scvsc[cn];

	i=(x*ctx->jpg_schsci[cn])>>16;
	j=(y*ctx->jpg_scvsci[cn])>>16;

	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}
#endif

#if 1
int PDJPG_GetComponentPixelS1(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	i=x>>3;
	j=y>>3;
	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(j*w)+i;

	k=x&7;
	l=y&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

int PDJPG_GetComponentPixelS2(PDJPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	i=x>>1;
	j=y>>1;

	k=i>>3;
	l=j>>3;
	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

int PDJPG_GetComponentPixelS122(PDJPG_Context *ctx, int x, int y,
	int *ry, int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	x1=x>>1; y1=y>>1;

	w0=ctx->jpg_schs[0];
	w1=ctx->jpg_schs[1];

	i=x>>3; j=y>>3;
	k=x1>>3; l=y1>>3;
	n0=(j*w0)+i;
	n1=(l*w1)+k;

	i=x&7; j=y&7;
	k=x1&7; l=y1&7;
	t0=(n0<<6)+((j<<3)+i);
	t1=(n1<<6)+((l<<3)+k);

	*ry=ctx->jpg_sibuf[0][t0];
	*ru=ctx->jpg_sibuf[1][t1];
	*rv=ctx->jpg_sibuf[2][t1];

	return(0);
}

int PDJPG_GetComponentPixelS420(PDJPG_Context *ctx, int x, int y,
	int *ry0, int *ry1, int *ry2, int *ry3,
	int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	x1=x>>1; y1=y>>1;

	w0=ctx->jpg_schs[0];
	w1=ctx->jpg_schs[1];

	i=x>>3; j=y>>3;
	k=x1>>3; l=y1>>3;
	n0=(j*w0)+i;
	n1=(l*w1)+k;

	i=x&7; j=y&7;
	k=x1&7; l=y1&7;
	t0=(n0<<6)+((j<<3)+i);
	t1=(n1<<6)+((l<<3)+k);

	*ry0=ctx->jpg_sibuf[0][t0];
	*ry1=ctx->jpg_sibuf[0][t0+1];
	*ry2=ctx->jpg_sibuf[0][t0+8];
	*ry3=ctx->jpg_sibuf[0][t0+9];

	*ru=ctx->jpg_sibuf[1][t1];
	*rv=ctx->jpg_sibuf[2][t1];

	return(0);
}

#endif

int PDJPG_DecodeColorTransformYCbCr420(PDJPG_Context *ctx, byte *obuf)
{
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

#if 1
		for(i=0; i<ctx->ys; i+=2)
			for(j=0; j<ctx->xs; j+=2)
		{
//			PDJPG_GetComponentPixelS122(ctx, j, i, &y0, &u, &v);
//			y1=PDJPG_GetComponentPixelS1(ctx, 0, j+1, i+0);
//			y2=PDJPG_GetComponentPixelS1(ctx, 0, j+0, i+1);
//			y3=PDJPG_GetComponentPixelS1(ctx, 0, j+1, i+1);

			PDJPG_GetComponentPixelS420(ctx, j, i,
				&y0, &y1, &y2, &y3, &u, &v);

			if(ctx->alphaClr)
			{
				a=255;

				k=y0-ctx->alphaClrY; l=k*k;
				k=y1-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				k=y2-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				k=y3-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				
//				k=y0-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				
				a=ctx->alphaClrA;
				a=(l<=(a*a))?0:255;
			}else { a=255; }

			u1=u-128; v1=v-128;
			l0=91881*v1;
			l1=-22554*u1-46802*v1;
			l2=116130*u1;

			y0<<=16; y1<<=16; y2<<=16; y3<<=16;
			r0=y0+l0; g0=y0+l1; b0=y0+l2;
			r1=y1+l0; g1=y1+l1; b1=y1+l2;
			r2=y2+l0; g2=y2+l1; b2=y2+l2;
			r3=y3+l0; g3=y3+l1; b3=y3+l2;

//			r0=65536*y0+l0; g0=65536*y0+l1; b0=65536*y0+l2;
//			r1=65536*y1+l0; g1=65536*y1+l1; b1=65536*y1+l2;
//			r2=65536*y2+l0; g2=65536*y2+l1; b2=65536*y2+l2;
//			r3=65536*y3+l0; g3=65536*y3+l1; b3=65536*y3+l2;

			r0>>=16; g0>>=16; b0>>=16;
			r1>>=16; g1>>=16; b1>>=16;
			r2>>=16; g2>>=16; b2>>=16;
			r3>>=16; g3>>=16; b3>>=16;

#if 0
			if((r0|r1|r2|r3)&(~255))
			{
				r0=(r0<0)?0:((r0>255)?255:r0);
				r1=(r1<0)?0:((r1>255)?255:r1);
				r2=(r2<0)?0:((r2>255)?255:r2);
				r3=(r3<0)?0:((r3>255)?255:r3);
			}

			if((g0|g1|g2|g3)&(~255))
			{
				g0=(g0<0)?0:((g0>255)?255:g0);
				g1=(g1<0)?0:((g1>255)?255:g1);
				g2=(g2<0)?0:((g2>255)?255:g2);
				g3=(g3<0)?0:((g3>255)?255:g3);
			}

			if((b0|b1|b2|b3)&(~255))
			{
				b0=(b0<0)?0:((b0>255)?255:b0);
				b1=(b1<0)?0:((b1>255)?255:b1);
				b2=(b2<0)?0:((b2>255)?255:b2);
				b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 1
			if((r0|r1|r2|r3)&(~255))
			{
				if(r0&(~255))r0=(r0<0)?0:((r0>255)?255:r0);
				if(r1&(~255))r1=(r1<0)?0:((r1>255)?255:r1);
				if(r2&(~255))r2=(r2<0)?0:((r2>255)?255:r2);
				if(r3&(~255))r3=(r3<0)?0:((r3>255)?255:r3);
			}

			if((g0|g1|g2|g3)&(~255))
			{
				if(g0&(~255))g0=(g0<0)?0:((g0>255)?255:g0);
				if(g1&(~255))g1=(g1<0)?0:((g1>255)?255:g1);
				if(g2&(~255))g2=(g2<0)?0:((g2>255)?255:g2);
				if(g3&(~255))g3=(g3<0)?0:((g3>255)?255:g3);
			}

			if((b0|b1|b2|b3)&(~255))
			{
				if(b0&(~255))b0=(b0<0)?0:((b0>255)?255:b0);
				if(b1&(~255))b1=(b1<0)?0:((b1>255)?255:b1);
				if(b2&(~255))b2=(b2<0)?0:((b2>255)?255:b2);
				if(b3&(~255))b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 0
			k=r0|r1|r2|r3 | g0|g1|g2|g3 | b0|b1|b2|b3;
			if(k&(~255))
			{
				if(r0&(~255))r0=(r0<0)?0:((r0>255)?255:r0);
				if(g0&(~255))g0=(g0<0)?0:((g0>255)?255:g0);
				if(b0&(~255))b0=(b0<0)?0:((b0>255)?255:b0);
				if(r1&(~255))r1=(r1<0)?0:((r1>255)?255:r1);
				if(g1&(~255))g1=(g1<0)?0:((g1>255)?255:g1);
				if(b1&(~255))b1=(b1<0)?0:((b1>255)?255:b1);
				if(r2&(~255))r2=(r2<0)?0:((r2>255)?255:r2);
				if(g2&(~255))g2=(g2<0)?0:((g2>255)?255:g2);
				if(b2&(~255))b2=(b2<0)?0:((b2>255)?255:b2);
				if(r3&(~255))r3=(r3<0)?0:((r3>255)?255:r3);
				if(g3&(~255))g3=(g3<0)?0:((g3>255)?255:g3);
				if(b3&(~255))b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 0
			r0=(!(r0&(~255)))?r0:((r0<0)?0:((r0>255)?255:r0));
			g0=(!(g0&(~255)))?g0:((g0<0)?0:((g0>255)?255:g0));
			b0=(!(b0&(~255)))?b0:((b0<0)?0:((b0>255)?255:b0));
			r1=(!(r1&(~255)))?r1:((r1<0)?0:((r1>255)?255:r1));
			g1=(!(g1&(~255)))?g1:((g1<0)?0:((g1>255)?255:g1));
			b1=(!(b1&(~255)))?b1:((b1<0)?0:((b1>255)?255:b1));
			r2=(!(r2&(~255)))?r2:((r2<0)?0:((r2>255)?255:r2));
			g2=(!(g2&(~255)))?g2:((g2<0)?0:((g2>255)?255:g2));
			b2=(!(b2&(~255)))?b2:((b2<0)?0:((b2>255)?255:b2));
			r3=(!(r3&(~255)))?r3:((r3<0)?0:((r3>255)?255:r3));
			g3=(!(g3&(~255)))?g3:((g3<0)?0:((g3>255)?255:g3));
			b3=(!(b3&(~255)))?b3:((b3<0)?0:((b3>255)?255:b3));
#endif

#if 0
			r0=(r0<0)?0:((r0>255)?255:r0);
			g0=(g0<0)?0:((g0>255)?255:g0);
			b0=(b0<0)?0:((b0>255)?255:b0);
			r1=(r1<0)?0:((r1>255)?255:r1);
			g1=(g1<0)?0:((g1>255)?255:g1);
			b1=(b1<0)?0:((b1>255)?255:b1);
			r2=(r2<0)?0:((r2>255)?255:r2);
			g2=(g2<0)?0:((g2>255)?255:g2);
			b2=(b2<0)?0:((b2>255)?255:b2);
			r3=(r3<0)?0:((r3>255)?255:r3);
			g3=(g3<0)?0:((g3>255)?255:g3);
			b3=(b3<0)?0:((b3>255)?255:b3);
#endif

			k=ctx->ys-1-i;
			l0=((k*ctx->xs)+j+0)*4;
//			l1=((k*ctx->xs)+j+1)*4;
			k=ctx->ys-2-i;
			l2=((k*ctx->xs)+j+0)*4;
//			l3=((k*ctx->xs)+j+1)*4;

//			ct=obuf+l0; *ct++=r0; *ct++=g0; *ct++=b0; *ct++=a;
//			ct=obuf+l1; *ct++=r1; *ct++=g1; *ct++=b1; *ct++=a;
//			ct=obuf+l2; *ct++=r2; *ct++=g2; *ct++=b2; *ct++=a;
//			ct=obuf+l3; *ct++=r3; *ct++=g3; *ct++=b3; *ct++=a;

			obuf[l0+0]=r0; obuf[l0+1]=g0; obuf[l0+2]=b0; obuf[l0+3]=a;
			obuf[l0+4]=r1; obuf[l0+5]=g1; obuf[l0+6]=b1; obuf[l0+7]=a;
			obuf[l2+0]=r2; obuf[l2+1]=g2; obuf[l2+2]=b2; obuf[l2+3]=a;
			obuf[l2+4]=r3; obuf[l2+5]=g3; obuf[l2+6]=b3; obuf[l2+7]=a;

//			obuf[l0+0]=r0; obuf[l0+1]=g0; obuf[l0+2]=b0; obuf[l0+3]=a;
//			obuf[l1+0]=r1; obuf[l1+1]=g1; obuf[l1+2]=b1; obuf[l1+3]=a;
//			obuf[l2+0]=r2; obuf[l2+1]=g2; obuf[l2+2]=b2; obuf[l2+3]=a;
//			obuf[l3+0]=r3; obuf[l3+1]=g3; obuf[l3+2]=b3; obuf[l3+3]=a;
		}
#endif

#if 0
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			PDJPG_GetComponentPixelS122(ctx, j, i, &y, &u, &v);

			if(ctx->alphaClr)
			{
				k=y-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				
				a=ctx->alphaClrA;
				a=(l<=(a*a))?0:255;
			}else { a=255; }

			u1=u-128; v1=v-128;
			r=65536*y          +91881*v1;
			g=65536*y- 22554*u1-46802*v1;
			b=65536*y+116130*u1;
			r>>=16; g>>=16; b>>=16;

			r=(r<0)?0:((r>255)?255:r);
			g=(g<0)?0:((g>255)?255:g);
			b=(b<0)?0:((b>255)?255:b);

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
#endif
}

PDGL_API byte *PDJPG_DecodeCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *obuf, *ct;
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
		return(NULL);

	ctx->jpg_is420=0;
	ctx->jpg_rdct=0;
	ctx->jpg_clrtrans=0;

	ctx->bcst_version=0;
	ctx->bcst_flags=0;
	ctx->bcst_trans=0;
	ctx->bcst_bpp=0;

	for(i=0; i<4; i++)
	{
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	for(i=0; i<sz; i++)
	{
//		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		if(buf[i]==0xFF)
		{
			if(buf[i+1]==0x00)
				{ i++; continue; }
			if(buf[i+1]==0xFF)
				{ i++; continue; }

			j=buf[i+1]-0xC0;
			if(j<0)j=63;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)PDJPG_MarkerDQT(ctx, buf+i+2);
			if(buf[i+1]==JPG_DHT)PDJPG_MarkerDHT(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOF0)PDJPG_MarkerSOF0(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOS)
			{
				j=PDJPG_MarkerSOS(ctx, buf+i+2);
				if(j>0) { i+=j; }
				continue;
			}

			if((buf[i+1]>=JPG_APP0) && (buf[i+1]<=JPG_APP15))
			{
				if(buf[i+1]==JPG_APP0)PDJPG_MarkerAPP0(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP11)PDJPG_MarkerAPP11(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP12)PDJPG_MarkerAPP12(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP14)PDJPG_MarkerAPP14(ctx, buf+i+2);

				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j;
				continue;
			}

			if(buf[i+1]==JPG_EOI)break;
		}
	}

	obuf=ctx->jpg_imgbuf;
	if(!obuf || (ctx->xs!=ctx->lxs) || (ctx->ys!=ctx->lys))
	{
		if(ctx->jpg_imgbuf)
			free(ctx->jpg_imgbuf);
		
		obuf=malloc((ctx->xs+1)*(ctx->ys+1)*4);
		memset(obuf, 0xFF, ctx->xs*ctx->ys*4);
		
		ctx->jpg_imgbuf=obuf;
		ctx->lxs=ctx->xs;
		ctx->lys=ctx->ys;
	}

	for(i=0; i<ctx->jpg_nc; i++)
	{
		j=ctx->jpg_scn[i];
//		ctx->jpg_schsc[i]=ctx->jpg_ch[j]/(ctx->jpg_chm*1.0);
//		ctx->jpg_scvsc[i]=ctx->jpg_cv[j]/(ctx->jpg_chn*1.0);

		ctx->jpg_schsci[i]=(65536*ctx->jpg_ch[j])/ctx->jpg_chm;
		ctx->jpg_scvsci[i]=(65536*ctx->jpg_cv[j])/ctx->jpg_chn;

		ctx->jpg_schs[i]=(ctx->jpg_cxi[j]+7)/8;
		ctx->jpg_scvs[i]=(ctx->jpg_cyi[j]+7)/8;
		
	}

	if(ctx->jpg_nc==3)
	{
		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=32768)i=0;
		if(ctx->jpg_scvsci[1]!=32768)i=0;
		if(ctx->jpg_schsci[2]!=32768)i=0;
		if(ctx->jpg_scvsci[2]!=32768)i=0;
		ctx->jpg_is420=i;
	}else
	{
		ctx->jpg_is420=0;
	}

	if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&1) &&
		(ctx->jpg_clrtrans==PDJPG_CLRS_YCBCR))
	{
		PDJPG_DecodeColorTransformYCbCr420(ctx, obuf);
	}else
	{
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			if(ctx->jpg_nc==3)
			{
				if(ctx->jpg_is420)
				{
//					y=PDJPG_GetComponentPixelS1(ctx, 0, j, i);
//					u=PDJPG_GetComponentPixelS2(ctx, 1, j, i);
//					v=PDJPG_GetComponentPixelS2(ctx, 2, j, i);
					PDJPG_GetComponentPixelS122(ctx, j, i, &y, &u, &v);
					a=255;
				}else
				{
					y=PDJPG_GetComponentPixel(ctx, 0, j, i);
					u=PDJPG_GetComponentPixel(ctx, 1, j, i);
					v=PDJPG_GetComponentPixel(ctx, 2, j, i);
					a=255;
				}

				if(ctx->alphaClr)
				{
					k=y-ctx->alphaClrY; l=k*k;
					k=u-ctx->alphaClrU; l+=k*k;
					k=v-ctx->alphaClrV; l+=k*k;
				
					a=ctx->alphaClrA;
					a=(l<=(a*a))?0:255;
				
//					if(l<(16*16))
//					{
//						a=255*((16*sqrt(l))/ctx->alphaClrA);
//						a=(a<0)?0:(a>255)?255:a;
//					}
				}

//				r=y+1.40200*(v-128);
//				g=y-0.34414*(u-128)-0.71414*(v-128);
//				b=y+1.77200*(u-128);

				if(ctx->jpg_clrtrans==PDJPG_CLRS_YCBCR)
				{
					u1=u-128; v1=v-128;
					r=65536*y          +91881*v1;
					g=65536*y- 22554*u1-46802*v1;
					b=65536*y+116130*u1;
					r>>=16; g>>=16; b>>=16;
				}else if(ctx->jpg_clrtrans==PDJPG_CLRS_ORCT)
				{
					u1=u-128; v1=v-128;
					g=y-(u1+v1)/4;
					r=v1+g;
					b=u1+g;
				}else if(ctx->jpg_clrtrans==PDJPG_CLRS_RGB)
				{
					r=y;
					g=u;
					b=v;
				}

				r=(r<0)?0:((r>255)?255:r);
				g=(g<0)?0:((g>255)?255:g);
				b=(b<0)?0:((b>255)?255:b);

//				r=(r<0)?0:((r>16777215)?255:(r>>16));
//				g=(g<0)?0:((g>16777215)?255:(g>>16));
//				b=(b<0)?0:((b>16777215)?255:(b>>16));
			}else if(ctx->jpg_nc==1)
			{
				y=PDJPG_GetComponentPixel(ctx, 0, j, i);
				r=y; g=y; b=y; a=255;
			}

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
	}

	for(i=0; i<4; i++)
	{
		if(ctx->jpg_scbuf[i])free(ctx->jpg_scbuf[i]);
		if(ctx->jpg_sibuf[i])free(ctx->jpg_sibuf[i]);
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	*xs=ctx->xs;
	*ys=ctx->ys;
	return(obuf);
}

PDGL_API void PDJPG_Free(byte *buf)
{
	if(!buf)return;
	free(buf);
}

byte *PDJPG_DecodeScanForComponentLayer(byte *buf, int sz, char *name)
{
	byte *cs, *cse;
	
	cs=buf; cse=buf+sz;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_APP11))
		{
			cs+=4;
			if(!strcmp((char *)cs, "CompLayer"))
			{
				cs+=strlen((char *)cs)+1;
				if(!strcmp((char *)cs, name))
				{
					cs+=strlen((char *)cs)+1;
					return(cs);
				}

				cs+=strlen((char *)cs)+1;
				continue;
			}
			continue;
		}
		cs++;
	}
	
	return(NULL);
}

PDGL_API byte *PDJPG_Decode(byte *buf, int sz, int *xs, int *ys)
{
	PDJPG_Context *ctx;
	byte *obuf;
	byte *otbuf;
	byte *csl;
	int i, n, sz1;
	
	ctx=PDJPG_AllocContext();
	obuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
	ctx->jpg_imgbuf=NULL;
	
	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
	if(csl)
	{
		sz1=sz-(csl-buf);
		otbuf=PDJPG_DecodeCtx(ctx, csl, sz1, xs, ys);
		
		n=ctx->xs*ctx->ys;
		for(i=0; i<n; i++)
		{
			obuf[i*4+3]=otbuf[i*4+1];
		}
	}

	PDJPG_FreeContext(ctx);
	return(obuf);
}

PDGL_API int PDJPG_DecodeComponentType(byte *buf, int sz)
{
	byte *csl;
	int sz1;

//	sz1=(sz>1024)?1024:sz;
//	csl=PDJPG_DecodeScanForComponentLayer(buf, sz1, "RGB");
//	if(!csl)return(0);

	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(16);
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)return(12);
		return(8);
	}else
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(7);

		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)return(4);

		return(3);
	}
}

PDGL_API byte *PDJPG_DecodeLDatCtx(PDJPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *tbuf, *tbuf2, *cs, *ct;
	int i;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_APP12) ||
		(buf[4]!='L') || (buf[5]!='D') ||
		(buf[6]!='A') || (buf[7]!='T'))
	{
		tbuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
		return(tbuf);
	}
	
	tbuf=malloc(1<<20);
	cs=buf; ct=tbuf;

	while((cs[0]==0xFF) && (cs[1]==JPG_APP12) &&
		(cs[4]=='L') && (cs[5]=='D') &&
		(cs[6]=='A') && (cs[7]=='T'))
	{
		i=(cs[2]<<8)|cs[3];
		memcpy(ct, cs+8, i-6);
		cs+=i; ct+=(i-6);
	}

	i=ct-tbuf;
	i=PDJPG_EscapeDecodeSingleBuffer(tbuf, i);

	tbuf2=PDJPG_DecodeCtx(ctx, tbuf, i, xs, ys);
	free(tbuf);
	return(tbuf2);
}

PDGL_API int PDJPG_DecodeComponentCtx(PDJPG_Context *ctx,
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	byte *tbuf;
	byte *csl;
	int i, n, sz1;

	tbuf=PDJPG_DecodeCtx(ctx, buf, sz, xs, ys);
	if(!tbuf)return(-1);

	n=ctx->xs*ctx->ys;

	for(i=0; i<n; i++)
	{
		rgba[i*4+0]=tbuf[i*4+0];
		rgba[i*4+1]=tbuf[i*4+1];
		rgba[i*4+2]=tbuf[i*4+2];
	}

	csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		for(i=0; i<n; i++)
		{
			rgba[i*4+3]=tbuf[i*4+1];
			if(norm) { norm[i*4+3]=tbuf[i*4+0]; }
			if(spec) { spec[i*4+2]=tbuf[i*4+2]; }
		}
	}else
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
				{ rgba[i*4+3]=tbuf[i*4+1]; }
		}
	}

	if(norm)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "XYZ");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				norm[i*4+0]=tbuf[i*4+0];
				norm[i*4+1]=tbuf[i*4+2];
				norm[i*4+2]=tbuf[i*4+1];
			}
		}
	}

	if(spec)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				spec[i*4+0]=tbuf[i*4+0];
				spec[i*4+1]=tbuf[i*4+1];
				spec[i*4+2]=tbuf[i*4+2];
			}
		}
	}
	
	if(luma)
	{
		csl=PDJPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=PDJPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				luma[i*4+0]=tbuf[i*4+0];
				luma[i*4+1]=tbuf[i*4+1];
				luma[i*4+2]=tbuf[i*4+2];
			}
		}
	}
	return(0);
}

PDGL_API int PDJPG_DecodeComponent(byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	PDJPG_Context *ctx;
	int i;
	
	ctx=PDJPG_AllocContext();
	i=PDJPG_DecodeComponentCtx(ctx, buf, sz,
		rgba, norm, spec, luma, xs, ys);
//	ctx->jpg_imgbuf=NULL;
	PDJPG_FreeContext(ctx);
	return(i);
}

//Encoder

void PDJHUFF_WriteBit(PDJPG_Context *ctx, int i)
{
	pdjhuff_win|=i<<(31-pdjhuff_pos);
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteNBits(PDJPG_Context *ctx, int v, int n)
{
	int i, j, k;

	v&=(1<<n)-1;

	j=pdjhuff_pos+n;
	k=pdjhuff_win|(v<<(32-j));
	while(j>=8)
	{
		i=(k>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		k<<=8;
		j-=8;
	}
	pdjhuff_pos=j;
	pdjhuff_win=k;

//	pdjhuff_win|=i<<((32-n)-pdjhuff_pos);
//	pdjhuff_pos+=n;
//	while(pdjhuff_pos>=8)
//	{
//		i=(pdjhuff_win>>24)&0xFF;
//		*pdjhuff_ct++=i;
//		if(i==0xFF)*pdjhuff_ct++=0x00;
//		pdjhuff_win<<=8;
//		pdjhuff_pos-=8;
//	}
}

void PDJHUFF_FlushBits(PDJPG_Context *ctx)
{
	int i;
	while(pdjhuff_pos>0)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void PDJHUFF_WriteString(PDJPG_Context *ctx, char *str)
{
	char *s;

	PDJHUFF_FlushBits(ctx);	
	s=str;
	while(*s)
		*pdjhuff_ct++=*s++;
	*pdjhuff_ct++=0;
}

int PDJHUFF_BalanceTree_r(short *nodes, short *nlen, int root, int h, int ml)
{
	int h0, h1, h2, h3;
	int l0, l1, l2;

	if(root<0)return(0);

	h1=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+0], h+1, ml);
	h2=PDJHUFF_BalanceTree_r(nodes, nlen, nodes[root*2+1], h+1, ml);
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	if((h+h0)<=ml)	//depth limit not exceeded
		return(h0);

	//ok, so part of the tree is too deep
	if((h1+1)<h2)
	{
		l0=nodes[root*2+1];
		l1=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[root*2+0];
		nodes[root*2+0]=l0;
		nodes[root*2+1]=l1;
	}else if((h2+1)<h1)
	{
		l0=nodes[root*2+0];
		l1=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[root*2+1];
		nodes[root*2+0]=l1;
		nodes[root*2+1]=l0;
	}else
	{
		//rotating would be ineffective or would make things worse...
		return(h0);
	}

	//recalc depth of modified sub-tree
	l1=nodes[l0*2+0];
	l2=nodes[l0*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h3=((h1>h2)?h1:h2)+1;
	nlen[l0]=h3;

	//recalc height of root node
	l1=nodes[root*2+0];
	l2=nodes[root*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	return(h0);
}

void PDJHUFF_CalcLengths_r(short *nodes, byte *cl, int root, int h)
{
	if(root<0)
	{
		if(root==-513)return;
		cl[(-root)-1]=h;
		return;
	}

	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+0], h+1);
	PDJHUFF_CalcLengths_r(nodes, cl, nodes[root*2+1], h+1);
}

int PDJHUFF_BuildLengths(int *stat, int nc, byte *cl, int ml)
{
//	static short nodes[1024], nlen[512];
//	static short roots[512], clen[512];
//	static int cnts[512];

	short nodes[1024], nlen[512];
	short roots[512], clen[512];
	int cnts[512];
	int nr, nn;
	int i, j, k, l;

	nr=0; nn=0;
	for(i=0; i<nc; i++)
	{
		if(!stat[i])continue;
		roots[nr]=-(i+1);
		cnts[nr]=stat[i];
		clen[nr]=0;
		nr++;
	}

	roots[nr]=-513;
	cnts[nr]=0;
	clen[nr]=0;
	nr++;


	for(i=0; i<nc; i++)cl[i]=0;
	if(!nr)return(-1);


	while(nr>1)
	{
		if(cnts[0]>=cnts[1]) { j=0; k=1; }
			else { j=1; k=0; }
		for(i=2; i<nr; i++)
		{
			if(cnts[i]<=cnts[k])
			{
				j=k; k=i;
				continue;
			}
			if(cnts[i]<=cnts[j])
			{
				j=i;
				continue;
			}
		}

		nlen[nn]=((clen[j]>clen[k])?clen[j]:clen[k])+1;
		nodes[nn*2+0]=roots[j];
		nodes[nn*2+1]=roots[k];

		roots[nr]=nn;
		cnts[nr]=cnts[j]+cnts[k];
		clen[nr]=nlen[nn];

//		printf("%d %d %d\n", cnts[j], cnts[k], cnts[nr]);

		nn++; nr++;

		l=0;
		for(i=0; i<nr; i++)
		{
			if((i==j) || (i==k))continue;
			roots[l]=roots[i];
			cnts[l]=cnts[i];
			clen[l]=clen[i];
			l++;
		}
		nr=l;
	}

	l=roots[0];
	j=clen[0];
	k=j;

	i=4;
	while((i--) && (k>ml))
		k=PDJHUFF_BalanceTree_r(nodes, nlen, l, 0, ml);
	if(k>ml)return(-2);	//failed to balance tree

	PDJHUFF_CalcLengths_r(nodes, cl, l, 0);
	return(0);
}

int PDJHUFF_BuildLengthsAdjust(int *stat, int nc, byte *cl, int ml)
{
	int i, j;

	while(1)
	{
		j=PDJHUFF_BuildLengths(stat, nc, cl, ml);
		if(j<0)
			printf("PDJHUFF_BuildLengthsAdjust: Huff Fail %d\n");

		for(i=0; i<nc; i++)
			if(stat[i] && !cl[i])
				break;
		if(i>=nc)break;

		printf("PDJHUFF_BuildLengthsAdjust: Fiddle Adjust\n");
		for(i=0; i<nc; i++)
			stat[i]++;
		continue;
	}
	return(0);
}

void PDJHUFF_EncodeSymbol(PDJPG_Context *ctx, int tab, int v)
{
	tab<<=8;
	PDJHUFF_WriteNBits(ctx, ctx->huff_code[tab|v], ctx->huff_len[tab|v]);
}

void PDJHUFF_EncodeVal(PDJPG_Context *ctx, int tab, int z, int v)
{
	int i, j, k;

	if(!v) { PDJHUFF_EncodeSymbol(ctx, tab, z<<4); return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		if(i>15)
		{
			printf("PDJHUFF_EncodeVal: Overflow A\n");
			i=15;
		}
		
		PDJHUFF_EncodeSymbol(ctx, tab, (z<<4)|i);
		PDJHUFF_WriteNBits(ctx, v, i);
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	if(i>15)
	{
		printf("PDJHUFF_EncodeVal: Overflow B\n");
		i=15;
	}

	PDJHUFF_EncodeSymbol(ctx, tab, (z<<4)|i);

	k=(1<<i)-(j+1);
	PDJHUFF_WriteNBits(ctx, k, i);
	return;
}

void PDJHUFF_StatVal(int *stat, int z, int v)
{
	int i, j, k;

	if(!v) { stat[z<<4]++; return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		if(i>15)i=15;
		stat[(z<<4)|i]++;
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	if(i>15)i=15;
	stat[(z<<4)|i]++;
}

#if 1
int PDJHUFF_EncodeBlock(PDJPG_Context *ctx,
	short *buf, int dctab, int actab)
{
	int i, j, k;

	PDJHUFF_EncodeVal(ctx, dctab, 0, buf[0]);

	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			PDJHUFF_EncodeVal(ctx, actab, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			PDJHUFF_EncodeSymbol(ctx, actab, 0);
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_EncodeVal(ctx, actab, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
	return(0);
}


int PDJHUFF_StatBlock(short *buf, int *dcstat, int *acstat)
{
	int i, j, k;

	PDJHUFF_StatVal(dcstat, 0, buf[0]);
	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			PDJHUFF_StatVal(acstat, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			acstat[0]++;
			break;
		}

		j-=i; if(j>15)j=15;
		PDJHUFF_StatVal(acstat, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
	return(0);
}
#endif

#if defined(X86) || defined(X86_64)
#define memcpy8(dst, src)	(*(double *)(dst)=*(double *)(src))
#else
#define memcpy8(dst, src)	memcpy(dst, src, 8)
#endif

#if 1
int PDJPG_GetImgBlk(char *blk, int xo, int yo, byte *img, int xs, int ys)
{
	byte *cs;
	char *ct;
	int i, j, k;

	cs=img+(yo*xs+xo); ct=blk;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); // ct+=8; cs+=xs;
	return(0);
}
#endif

int PDJPG_FilterImageDCT(byte *ibuf, short *obuf, int xs, int ys)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
	char blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
		PDJPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_TransDCT(blk, obuf+k*DCTSZ2);
		k++;
	}
	return(0);
}

int PDJPG_FilterImageRDCT(byte *ibuf, short *obuf, int xs, int ys)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
	char blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
		PDJPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		PDJPG_TransRDCT(blk, obuf+k*DCTSZ2);
		k++;
	}
	return(0);
}

void PDJPG_EmitDQT(PDJPG_Context *ctx, int n)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DQT;

	i=64+3;
	*pdjhuff_ct++=i>>8;
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=n;
	for(i=0; i<64; i++)
		*pdjhuff_ct++=ctx->jpg_qt[n][pdjpg_zigzag2[i]];
}

void PDJPG_EmitSOF(PDJPG_Context *ctx, int xs, int ys)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOF0;

	i=8+(ctx->jpg_mono?1:3)*3;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=8; 	//P

	*pdjhuff_ct++=ys>>8;	//Y
	*pdjhuff_ct++=ys&0xFF;	//Y
	*pdjhuff_ct++=xs>>8;	//X
	*pdjhuff_ct++=xs&0xFF;	//X

	if(ctx->jpg_mono)
	{
		*pdjhuff_ct++=1;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
	}else if(ctx->jpg_is420)
	{
		*pdjhuff_ct++=3;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x22;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
		*pdjhuff_ct++=2;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
		*pdjhuff_ct++=3;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
	}else
	{
		*pdjhuff_ct++=3;	//Nf
		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
		*pdjhuff_ct++=2;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
		*pdjhuff_ct++=3;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=1;	//Tqi
	}
}

void PDJPG_EmitSOS(PDJPG_Context *ctx)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOS;

	i=6+(ctx->jpg_mono?1:3)*2;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	if(!ctx->jpg_mono)
	{
		*pdjhuff_ct++=3; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else
	{
		*pdjhuff_ct++=1; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
	}

	*pdjhuff_ct++=0; 	//Ss
	*pdjhuff_ct++=63; 	//Se
	*pdjhuff_ct++=0x00; 	//Ah Al
}

void PDJPG_EmitDHT(PDJPG_Context *ctx, int tab)
{
	byte *p;
	int i, j, k;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DHT;

	i=8+3*1;	//temp value
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	i=(tab/2)|((tab&1)<<4);
	*pdjhuff_ct++=i; 	//Tc Th

	tab<<=8;
	for(i=1; i<=16; i++)
	{
		k=0;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
				k++;
		*pdjhuff_ct++=k; 	//Li
	}

	k=0;
	for(i=1; i<=16; i++)
	{
		k<<=1;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
		{
			*pdjhuff_ct++=j; 	//Vi
			ctx->huff_code[tab|j]=k++;
		}
	}

	if(k>=65536)
		printf("PDJPG_EmitDHT: Error %04X\n", k);

//	printf("DHT %04X\n", k);

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void PDJPG_MakeQuantTabInput(short *in, int cnt, byte *tab, float q)
{
//	static double deltas[DCTSZ2];
	double deltas[DCTSZ2];
	double f, g, te;
	int i, j, k;

	if(q>=1)
	{
		for(i=0; i<DCTSZ2; i++)
			tab[i]=1;
		return;
	}

	for(j=0; j<DCTSZ2; j++)
		deltas[j]=0;

	for(i=0; i<cnt; i++)
		for(j=0; j<DCTSZ2; j++)
			deltas[j]+=fabs(in[i*DCTSZ2+j]);
	for(j=0; j<DCTSZ2; j++)
		deltas[j]/=cnt;

	te=0;
	for(j=0; j<DCTSZ2; j++)
		te+=deltas[j];

	for(i=0; i<DCTSZ; i++)
	{
		for(j=0; j<DCTSZ; j++)
		{
			f=deltas[i*DCTSZ+j];

			f=f/te;
			if(f<0.00001)f=0.00001;
			g=(1.0-q);
			f=10*g*g*g/f;
			k=f;
			if(k<1)k=1;
			if(k>255)k=255;

//			printf("%f/%f %d\n", deltas[i*DCTSZ+j], te, k);

//			if(f<1)f=1;
//			if(f>255)f=255;
			tab[i*DCTSZ+j]=k;
		}
	}

#if 1
	if(tab[DCTSZ2-3]>1)tab[DCTSZ2-3]*=0.75;
	if(tab[DCTSZ2-2]>1)tab[DCTSZ2-2]*=0.75;
	if(tab[DCTSZ2-1]>1)tab[DCTSZ2-1]*=0.5;
#endif
}

void PDJPG_MakeQuantTabInputFast(
	short *in, int cnt, byte *tab, float q)
{
	int i;
//	PDJPG_MakeQuantTabInput(in, cnt, tab, q);

	i=cnt/16;
	if(i<1)i=1;
	PDJPG_MakeQuantTabInput(in, i, tab, q);
}

void PDJPG_EmitMarkerBCST(PDJPG_Context *ctx)
{
	byte *lfp;
	int i, j, k;

	ctx->bcst_version=0x0100;
	ctx->bcst_flags=0;
	ctx->bcst_trans=ctx->jpg_clrtrans;
	ctx->bcst_bpp=8;

	if(ctx->jpg_rdct)
		ctx->bcst_flags|=PDJPG_BCSFL_RDCT;

	//check if not to bother with marker...
	if(!ctx->bcst_flags && !ctx->bcst_trans)
	{
//		printf("PDJPG_EmitMarkerBCST: No Emit\n");
		return;
	}

//	printf("PDJPG_EmitMarkerBCST: Emit\n");

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP12;

	lfp=pdjhuff_ct;
	*pdjhuff_ct++=0x00;	//length
	*pdjhuff_ct++=0x00;

	*pdjhuff_ct++='B';
	*pdjhuff_ct++='C';
	*pdjhuff_ct++='S';
	*pdjhuff_ct++='T';

	*pdjhuff_ct++=(ctx->bcst_version>>8)&0xFF;
	*pdjhuff_ct++=ctx->bcst_version&0xFF;

	*pdjhuff_ct++=ctx->bcst_trans;
	*pdjhuff_ct++=ctx->bcst_bpp;

	*pdjhuff_ct++=(ctx->bcst_flags>>24)&0xFF;
	*pdjhuff_ct++=(ctx->bcst_flags>>16)&0xFF;
	*pdjhuff_ct++=(ctx->bcst_flags>>8)&0xFF;
	*pdjhuff_ct++=ctx->bcst_flags&0xFF;


	i=pdjhuff_ct-lfp;
	lfp[0]=i>>8;	//length
	lfp[1]=i&0xFF;
}

PDGL_API int PDJPG_EncodeCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf, int xs, int ys,
	int qf, int pf)
{
//	static byte *yb=NULL, *ub, *vb;
//	static short *ydb=NULL, *udb, *vdb;
//	static int lxs=0, lys=0;

	int dcs[256], acs[256];
	int dcsuv[256], acsuv[256];
	short *tp;
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l;

//	ctx->jpg_is420=1;
	ctx->jpg_is420=0;

	if(ctx->jpg_is420)
	{
		xs2=((xs+7)/8)*8;
		ys2=((ys+7)/8)*8;
//		xs3=(xs2+1)/2;
//		ys3=(ys2+1)/2;

		xs3=((xs+15)/16)*8;
		ys3=((ys+15)/16)*8;
	}else
	{
		xs2=((xs+7)/8)*8;
		ys2=((ys+7)/8)*8;
		xs3=xs2;
		ys3=ys2;
	}
	

	ctx->jpg_mono=0;
	ctx->jpg_tabcacheframe=0;
	ctx->xs=xs;
	ctx->ys=ys;

	if(pf==PDJPG_YYYA)
		ctx->jpg_mono=1;

	ctx->jpg_rdct=0;
	if(qf==110)
		ctx->jpg_rdct=1;

	ctx->jpg_clrtrans=0;
	if(qf==110)
		ctx->jpg_clrtrans=1;

	//full quality
	for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
	for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;

	//dummy huffman tables
	for(i=0; i<256; i++)ctx->huff_len[0*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[1*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[2*256+i]=0;
	for(i=0; i<256; i++)ctx->huff_len[3*256+i]=0;

	for(i=0; i<16; i++)ctx->huff_len[0*256+i]=4;
	for(i=0; i<16; i++)ctx->huff_len[2*256+i]=4;
	for(i=0; i<255; i++)ctx->huff_len[1*256+i]=8;
	for(i=0; i<255; i++)ctx->huff_len[3*256+i]=8;

//	for(i=0; i<255; i++)ctx->huff_len[0*256+i]=8;
//	for(i=0; i<255; i++)ctx->huff_len[2*256+i]=8;


//	ctx->huff_len[1*256+0]=7;

//	printf("M0\n");

	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->yb=malloc(xs2*ys2);
		ctx->ub=malloc(xs2*ys2);
		ctx->vb=malloc(xs2*ys2);

		ctx->ydb=malloc((xs2+8)*(ys2+8)*sizeof(short));
//		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
//		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->udb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		ctx->vdb=malloc((xs2+8)*(ys2+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;
	}


	memset(ctx->yb, 128, xs2*ys2);
	memset(ctx->ub, 128, xs2*ys2);
	memset(ctx->vb, 128, xs2*ys2);

	memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
	memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
	memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];

//		if(qf==110)
		if(ctx->jpg_clrtrans==1)
		{
			cy=(cr+2*cg+cb)/4;
			cu=(cb-cg)+128;
			cv=(cr-cg)+128;

//			cu=cb-cr;
//			cv=cg-cr-0.5*cu;
//			cy=cg-0.5*cv;
//			cu+=128; cv+=128;
		}else
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
		}

//		cu=128; cv=128;

		cy=(cy<0)?0:((cy>255)?255:cy);
		cu=(cu<0)?0:((cu>255)?255:cu);
		cv=(cv<0)?0:((cv>255)?255:cv);

		ctx->yb[i*xs2+j]=cy;
		ctx->ub[i*xs2+j]=cu;
		ctx->vb[i*xs2+j]=cv;
	}

//	if((xs3!=xs2) || (ys3!=ys2))
	if(ctx->jpg_is420)
	{
		for(i=0; i<ys3; i++)
			for(j=0; j<xs3; j++)
		{
			k=ctx->ub[(i*2)*xs2+j*2]+
				ctx->ub[(i*2)*xs2+j*2+1]+
				ctx->ub[(i*2+1)*xs2+j*2]+
				ctx->ub[(i*2+1)*xs2+j*2+1];
			ctx->ub[i*xs3+j]=k/4;

			k=ctx->vb[(i*2)*xs2+j*2]+
				ctx->vb[(i*2)*xs2+j*2+1]+
				ctx->vb[(i*2+1)*xs2+j*2]+
				ctx->vb[(i*2+1)*xs2+j*2+1];
			ctx->vb[i*xs3+j]=k/4;
		}
	}

//	printf("M1\n");

//	if(qf==110)
	if(ctx->jpg_rdct)
	{
		printf("PDJPG_EncodeCtx: Lossless Detect\n");
	
		PDJPG_FilterImageRDCT(ctx->yb, ctx->ydb, xs2, ys2);
		PDJPG_FilterImageRDCT(ctx->ub, ctx->udb, xs3, ys3);
		PDJPG_FilterImageRDCT(ctx->vb, ctx->vdb, xs3, ys3);
	}else
	{
		PDJPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2);
		PDJPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3);
		PDJPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3);
	}

	j=(xs2/8)*(ys2/8);
	PDJPG_MakeQuantTabInput(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

	j=(xs3/8)*(ys3/8);
	PDJPG_MakeQuantTabInput(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
	PDJPG_MakeQuantTabInput(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
	for(i=0; i<64; i++)ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

	PDJPG_SetupQuantTabDivFP(ctx, 0);
	PDJPG_SetupQuantTabDivFP(ctx, 1);

//	free(yb);
//	free(ub);
//	free(vb);


	if(ctx->jpg_mono || !ctx->jpg_is420)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k; k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono && ctx->jpg_is420)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

#if 0
	if(!ctx->jpg_mono && !ctx->jpg_is420)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 1);
			ctx->ydb[i*64+0]-=l; l=ctx->ydb[i*64+0]+l;
		}
	}
#endif

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		PDJHUFF_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

//	printf("M2\n");

	for(i=0; i<256; i++)dcs[i]=0;
	for(i=0; i<256; i++)acs[i]=0;
	for(i=0; i<256; i++)dcsuv[i]=0;
	for(i=0; i<256; i++)acsuv[i]=0;

	j=(xs2/8)*(ys2/8);
	k=(xs3/8)*(ys3/8);
	for(i=0; i<j; i++)PDJHUFF_StatBlock(ctx->ydb+i*64, dcs, acs);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->udb+i*64, dcsuv, acsuv);
	for(i=0; i<k; i++)PDJHUFF_StatBlock(ctx->vdb+i*64, dcsuv, acsuv);

//	PDJHUFF_BuildLengths(dcs, 256, ctx->huff_len+0*256, 16);
//	PDJHUFF_BuildLengths(acs, 256, ctx->huff_len+1*256, 16);
//	PDJHUFF_BuildLengths(dcsuv, 256, ctx->huff_len+2*256, 16);
//	PDJHUFF_BuildLengths(acsuv, 256, ctx->huff_len+3*256, 16);

	PDJHUFF_BuildLengthsAdjust(dcs, 256, ctx->huff_len+0*256, 16);
	PDJHUFF_BuildLengthsAdjust(acs, 256, ctx->huff_len+1*256, 16);
	PDJHUFF_BuildLengthsAdjust(dcsuv, 256, ctx->huff_len+2*256, 16);
	PDJHUFF_BuildLengthsAdjust(acsuv, 256, ctx->huff_len+3*256, 16);

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	PDJPG_EmitMarkerBCST(ctx);

	PDJPG_EmitDQT(ctx, 0);
	if(!ctx->jpg_mono)PDJPG_EmitDQT(ctx, 1);

	PDJPG_EmitSOF(ctx, xs, ys);

	PDJPG_EmitDHT(ctx, 0);
	PDJPG_EmitDHT(ctx, 1);
	if(!ctx->jpg_mono)
	{
		PDJPG_EmitDHT(ctx, 2);
		PDJPG_EmitDHT(ctx, 3);
	}

	PDJPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else if(ctx->jpg_is420)
	{
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
	}else
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)
		{
			PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx, ctx->udb+i*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+i*64, 2, 3);
		}

#if 0
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->ydb+k*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
#endif
	}

	PDJHUFF_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

//	free(ydb);
//	free(udb);
//	free(vdb);

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

PDGL_API PDJPG_Context *PDJPG_AllocContext()
{
	PDJPG_Context *ctx;
	
	ctx=malloc(sizeof(PDJPG_Context));
	memset(ctx, 0, sizeof(PDJPG_Context));
	return(ctx);
}

PDGL_API void PDJPG_FreeContext(PDJPG_Context *ctx)
{
	if(ctx->yb)
	{
		free(ctx->yb);
		free(ctx->ub);
		free(ctx->vb);
		free(ctx->ydb);
		free(ctx->udb);
		free(ctx->vdb);
	}

	if(ctx->jpg_imgbuf)
		free(ctx->jpg_imgbuf);

	free(ctx);
}

PDGL_API int PDJPG_Encode(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	PDJPG_Context *ctx;
	int sz;
	
	ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
	PDJPG_FreeContext(ctx);
	return(sz);
}

PDGL_API void PDJPG_FlushEncodeFast(PDJPG_Context *ctx)
{
	if(!ctx)return;
	ctx->jpg_tabcacheframe=0;	//force rebuild
	ctx->oldAlphaClr=0;
}

PDGL_API void PDJPG_SetContextAlphaColor(PDJPG_Context *ctx,
	int cr, int cg, int cb, int ca)
{
	int cy, cu, cv;
	if(!ctx)return;

	if(ca<1)
	{
		ctx->alphaClr=0;
		return;
	}

	ctx->alphaClr=cr+(cg<<8)+(cb<<16)+(ca<<24);

	cy= 19595*cr +38470*cg + 7471*cb;
	cu=-11056*cr -21712*cg +32768*cb;
	cv= 32768*cr -27440*cg - 5328*cb;
	ctx->alphaClrY=cy>>16;
	ctx->alphaClrU=(cu>>16)+128;
	ctx->alphaClrV=(cv>>16)+128;
	ctx->alphaClrA=ca;
}

#if 0
//static void pdjpg_getPixel2_RGBA(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb)
//{
//	*ra=rgb[0]; *ga=rgb[1]; *ba=rgb[2];
//	*ra=rgb[4]; *ga=rgb[5]; *ba=rgb[6];
//}
#endif

void PDJPG_ConvertImageYUV(PDJPG_Context *ctx,
	byte *ibuf, int xs, int ys, int pf,
	int xs2, int ys2, int xs3, int ys3)
{
//	void (*getPixel2)(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb);
	byte *cs, *cse, *cty, *ctu, *ctv;
	byte *cs1, *cs2, *cty1, *cty2;

	int cr, cg, cb, ca, cy, cu, cv;

	int cra, cga, cba, caa, cya, cua, cva;
	int crb, cgb, cbb, cab, cyb, cub, cvb;
	int crc, cgc, cbc, cac, cyc, cuc, cvc;
	int crd, cgd, cbd, cad, cyd, cud, cvd;
	int psz, psz2;

	int i, j, k, l, n;

	if((pf==PDJPG_RGBA) && !ctx->alphaClr)
	{
		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*4;
			cs1=ibuf+k; cse=cs1+xs*4;
			l=((ys-(2*i+2))*xs)*4;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
				cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2);
				crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6);
				crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2);
				crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6);

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=8; cs2+=8;
			}
		}
	}else
	if((pf==PDJPG_RGBA) || (pf==PDJPG_RGB) ||
		(pf==PDJPG_BGRA) || (pf==PDJPG_BGR))
	{
		switch(pf)
		{
		case PDJPG_RGBA: case PDJPG_BGRA:
			psz=4; break;
		case PDJPG_RGB: case PDJPG_BGR:
			psz=3; break;
		default: psz=4; break;
		}
		psz2=psz*2;

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*psz;
			cs1=ibuf+k; cse=cs1+xs*psz;
			l=((ys-(2*i+2))*xs)*psz;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case PDJPG_RGBA:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=*(cs1+3);
					crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6); cab=*(cs1+7);
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=*(cs2+3);
					crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6); cad=*(cs2+7);
					psz=8; break;
				case PDJPG_BGRA:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=*(cs1+3);
					crb=*(cs1+6); cgb=*(cs1+5); cbb=*(cs1+4); cab=*(cs1+7);
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=*(cs2+3);
					crd=*(cs2+6); cgd=*(cs2+5); cbd=*(cs2+4); cad=*(cs2+7);
					psz=8; break;
				case PDJPG_RGB:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=255;
					crb=*(cs1+3); cgb=*(cs1+4); cbb=*(cs1+5); cab=255;
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=255;
					crd=*(cs2+3); cgd=*(cs2+4); cbd=*(cs2+5); cad=255;
					psz=6; break;
				case PDJPG_BGR:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=255;
					crb=*(cs1+5); cgb=*(cs1+4); cbb=*(cs1+3); cab=255;
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=255;
					crd=*(cs2+5); cgd=*(cs2+4); cbd=*(cs2+3); cad=255;
					psz=6; break;
				}

				if(ctx->alphaClr)
				{
					ca=(caa+cab+cac+cad)>>2;
					if(ca<ctx->alphaClrA)
					{
						cy=ctx->alphaClrY;
						cu=ctx->alphaClrU;
						cv=ctx->alphaClrV;
						*cty1++=cy; *cty1++=cy;
						*cty2++=cy; *cty2++=cy;
						*ctu++=cu; *ctv++=cv;
						continue;
					}
				}

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}else
	{
		switch(pf)
		{
		case PDJPG_YUVA: psz=4; psz2=8; break;
		case PDJPG_YUV: psz=3; psz2=6; break;
		case PDJPG_YUV422: psz=2; psz2=4; break;
		case PDJPG_YUV420: psz=3; psz2=3; break;
		case PDJPG_YA: psz=2; psz2=4; break;
		case PDJPG_Y: psz=1; psz2=2; break;
		case PDJPG_YYYA: psz=4; psz2=8; break;
		default: psz=4; psz2=8; break;
		}

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			if(pf==PDJPG_YUV420)
			{
				k=(((ys-(2*i+1))*xs2)*psz2)>>1;
				cs1=ibuf+k; cse=cs1+((xs*psz2)>>1);
				l=(((ys-(2*i+2))*xs2)*psz2)>>1;
				cs2=ibuf+l;
			}else
			{
				k=((ys-(2*i+1))*xs)*psz;
				cs1=ibuf+k; cse=cs1+xs*psz;
				l=((ys-(2*i+2))*xs)*psz;
				cs2=ibuf+l;
			}

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case PDJPG_YUVA:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+4); cub=*(cs1+5); cvb=*(cs1+6);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+4); cud=*(cs2+5); cvd=*(cs2+6);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case PDJPG_YUV:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+3); cub=*(cs1+4); cvb=*(cs1+5);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+3); cud=*(cs2+4); cvd=*(cs2+5);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case PDJPG_YUV422:
					cya=*(cs1+0); cua=*(cs1+1); cyb=*(cs1+2); cva=*(cs1+3);
					cyc=*(cs2+0); cuc=*(cs2+1); cyd=*(cs2+2); cvc=*(cs2+3);
					cu=(cua+cuc)>>1; cv=(cva+cvc)>>1;
					break;
				case PDJPG_YUV420:
					cya=*(cs1+0); cyb=*(cs1+1); cu=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+1); cv=*(cs2+2);
					break;
				case PDJPG_YA:
					cya=*(cs1+0); cyb=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+2);
					cu=0; cv=0;
					break;
				case PDJPG_Y:
					cya=*(cs1+0); cyb=*(cs1+1);
					cyc=*(cs2+0); cyd=*(cs2+1);
					cu=0; cv=0;
					break;

				case PDJPG_YYYA:
					cya=*(cs1+1); cyb=*(cs1+5);
					cyc=*(cs2+1); cyd=*(cs2+5);
					cu=0; cv=0;
					break;
				}

				*cty1++=cya; *cty1++=cyb;
				*cty2++=cyc; *cty2++=cyd;
				*ctu++=cu; *ctv++=cv;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}
}

PDGL_API int PDJPG_EncodeFastCtx(PDJPG_Context *ctx,
	byte *ibuf, byte *obuf, int xs, int ys, int qf, int pf)
{
	char tb[256];
	short *tp;
//	byte *cs, *cse, *cty, *ctu, *ctv;
	int xs2, ys2, xs3, ys3;
//	int cr, cg, cb, cy, cu, cv;

//	int cra, cga, cba, cya;
//	int crb, cgb, cbb, cyb;
//	int crc, cgc, cbc, cyc;
//	int crd, cgd, cbd, cyd;
//	byte *cs1, *cs2, *cty1, *cty2;
	byte *ctt;

	int i, j, k, l, n;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	ctx->jpg_mono=0;

	if(!ctx->jpg_tabcacheframe)
	{
		//full quality
		for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
		for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;
	}

	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->yb=malloc(xs2*ys2);
		ctx->ub=malloc(xs2*ys2);
		ctx->vb=malloc(xs2*ys2);

		ctx->ydb=malloc((xs2+8)*(ys2+16)*sizeof(short));
		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;

		memset(ctx->yb, 128, xs2*ys2);
		memset(ctx->ub, 128, xs2*ys2);
		memset(ctx->vb, 128, xs2*ys2);

		memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
		memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
		memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

		ctx->jpg_tabcacheframe=0;	//force rebuild
	}

	PDJPG_ConvertImageYUV(ctx,
		ibuf, xs, ys, pf,
		xs2, ys2, xs3, ys3);

	PDJPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2);
	PDJPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3);
	PDJPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3);

	if(ctx->jpg_tabcacheframe<=0)
	{
		j=(xs2/8)*(ys2/8);
		PDJPG_MakeQuantTabInputFast(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

		j=(xs3/8)*(ys3/8);
		PDJPG_MakeQuantTabInputFast(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
		PDJPG_MakeQuantTabInputFast(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
		for(i=0; i<64; i++)
			ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

		PDJPG_SetupQuantTabDivFP(ctx, 0);
		PDJPG_SetupQuantTabDivFP(ctx, 1);
	}

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			PDJHUFF_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k;
			k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			PDJHUFF_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		PDJHUFF_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		PDJHUFF_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

//	printf("M2\n");

	if(ctx->jpg_tabcacheframe<=0)
	{
		for(i=0; i<256; i++)ctx->dcs[i]=1;
		for(i=0; i<256; i++)ctx->acs[i]=1;
		for(i=0; i<256; i++)ctx->dcsuv[i]=1;
		for(i=0; i<256; i++)ctx->acsuv[i]=1;

		j=(xs2/8)*(ys2/8);
		k=(xs3/8)*(ys3/8);
		for(i=0; i<j; i++)
			PDJHUFF_StatBlock(ctx->ydb+i*64, ctx->dcs, ctx->acs);
		for(i=0; i<k; i++)
			PDJHUFF_StatBlock(ctx->udb+i*64, ctx->dcsuv, ctx->acsuv);
		for(i=0; i<k; i++)
			PDJHUFF_StatBlock(ctx->vdb+i*64, ctx->dcsuv, ctx->acsuv);

//		PDJHUFF_BuildLengths(ctx->dcs, 256, ctx->huff_len+0*256, 16);
//		PDJHUFF_BuildLengths(ctx->acs, 256, ctx->huff_len+1*256, 16);
//		PDJHUFF_BuildLengths(ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
//		PDJHUFF_BuildLengths(ctx->acsuv, 256, ctx->huff_len+3*256, 16);

		PDJHUFF_BuildLengthsAdjust(
			ctx->dcs, 256, ctx->huff_len+0*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->acs, 256, ctx->huff_len+1*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
		PDJHUFF_BuildLengthsAdjust(
			ctx->acsuv, 256, ctx->huff_len+3*256, 16);
	}

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	if(ctx->alphaClr && (ctx->alphaClr!=ctx->oldAlphaClr))
	{
		sprintf(tb, "%d %d %d %d",
			(ctx->alphaClr&0xFF),
			((ctx->alphaClr>>8)&0xFF),
			((ctx->alphaClr>>16)&0xFF),
			((ctx->alphaClr>>24)&0xFF));
	
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP11;
		ctt=pdjhuff_ct;
		*pdjhuff_ct++=0x00;
		*pdjhuff_ct++=0x00;
		PDJHUFF_WriteString(ctx, "AlphaColor");
		PDJHUFF_WriteString(ctx, tb);
		i=(pdjhuff_ct-ctt);
		ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	}


	if(ctx->jpg_tabcacheframe<=0)
	{
		PDJPG_EmitDQT(ctx, 0);
		if(!ctx->jpg_mono)PDJPG_EmitDQT(ctx, 1);
	}

	PDJPG_EmitSOF(ctx, xs, ys);

	if(ctx->jpg_tabcacheframe<=0)
	{
		PDJPG_EmitDHT(ctx, 0);
		PDJPG_EmitDHT(ctx, 1);
		if(!ctx->jpg_mono)
		{
			PDJPG_EmitDHT(ctx, 2);
			PDJPG_EmitDHT(ctx, 3);
		}
	}

	PDJPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)PDJHUFF_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=((ys3)/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			PDJHUFF_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			PDJHUFF_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			PDJHUFF_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
	}

	PDJHUFF_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

	if(ctx->jpg_tabcacheframe<=0)
	{
//		ctx->jpg_tabcacheframe=16;
		ctx->jpg_tabcacheframe=8;
	}else
	{
		ctx->jpg_tabcacheframe--;
	}

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

PDGL_API int PDJPG_EncodeFast(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	static PDJPG_Context *ctx=NULL;
	int sz;
	
	if(!ctx)ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeFastCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
//	PDJPG_FreeContext(ctx);
	return(sz);
}

byte *PDJPG_EmitComponentLayer(PDJPG_Context *ctx,
	byte *ct, char *name)
{
	byte *ctt;
	int i;

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP11;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	PDJHUFF_WriteString(ctx, "CompLayer");
	PDJHUFF_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

byte *PDJPG_EmitMarkerJFIF(PDJPG_Context *ctx, byte *ct)
{
	byte *ctt;
	int i;

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP0;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	PDJHUFF_WriteString(ctx, "JFIF");

	*pdjhuff_ct++=0x01;		//version high
	*pdjhuff_ct++=0x02;		//version low

	*pdjhuff_ct++=0x00;		//no units

	*pdjhuff_ct++=0x00;		//X density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//Y density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//thumbnail
	*pdjhuff_ct++=0x00;

//	PDJHUFF_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

PDGL_API int PDJPG_EscapeEncodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if(*cs==0xFF)
		{
			cs++;
			*ct++=0xFF;
			*ct++=0x00;
			continue;
		}
		
		*ct++=*cs++;
	}
	
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

PDGL_API int PDJPG_EscapeEncodeSingleBuffer(byte *buf, int sz)
{
	byte *tbuf;
	int i;
	
	tbuf=malloc(sz*2);
	i=PDJPG_EscapeEncodeBuffer(buf, sz, tbuf, sz*2);
	if(i<0)return(i);
	memcpy(buf, tbuf, i);
	free(tbuf);
	return(i);
}

PDGL_API int PDJPG_EscapeDecodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

PDGL_API int PDJPG_EscapeDecodeSingleBuffer(byte *buf, int sz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=buf; cse=buf+sz;
	ct=buf; cte=buf+sz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-buf);
}

PDGL_API int PDJPG_EncodeLDatCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cts;
	int i, j, sz, tsz;
	
//	if(!ctx)ctx=PDJPG_AllocContext();

	tbuf=malloc(1<<20);
	sz=PDJPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);

	sz=PDJPG_EscapeEncodeSingleBuffer(tbuf, sz);

	cts=tbuf; tsz=sz;
	pdjhuff_ct=obuf; pdjhuff_win=0; pdjhuff_pos=0;
	while(tsz>=65528)
	{
		i=65529;
		if(cts[i-1]==0xFF)i--;
		j=i+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(j>>8)&0xFF;
		*pdjhuff_ct++=j&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, i);
		cts+=i; pdjhuff_ct+=i;
		tsz-=i;
	}
	
	if((tsz>0) && (tsz<65528))
	{
		i=tsz+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, tsz);
		pdjhuff_ct+=tsz;
	}

	sz=pdjhuff_ct-obuf;
	free(tbuf);
	
	return(sz);
}

PDGL_API int PDJPG_EncodeBaseCtx(
	PDJPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cs, *cse, *ct;
	int sz;

	tbuf=malloc(1<<20);
	sz=PDJPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);
	
	cs=tbuf; cse=tbuf+sz; ct=obuf;
	if((cs[0]==0xFF) && (cs[1]==JPG_SOI))
		cs+=2;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_EOI))
			break;
		*ct++=*cs++;
	}
	
	free(tbuf);
	return(ct-obuf);
}

PDGL_API int PDJPG_EncodeComponentCtx(
	PDJPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	byte *tbuf;
	byte *ct;
	int i, j, k, n;

	if(!rgba)return(-1);

	n=xs*ys;
	tbuf=malloc(xs*ys*4);

	ct=obuf;

	*ct++=0xFF;
	*ct++=JPG_SOI;

	ct=PDJPG_EmitMarkerJFIF(ctx, ct);

	ct=PDJPG_EmitComponentLayer(ctx, ct, "RGB");
//	i=PDJPG_EncodeCtx(ctx, rgba, ct, xs, ys, qf, 0);
	i=PDJPG_EncodeBaseCtx(ctx, rgba, ct, xs, ys, qf, 0);
	if(i<0) { free(tbuf); return(i); }
	ct+=i;
	
//	if((ct[-2]==0xFF) && (ct[-2]==JPG_EOI))
//		{ ct-=2; }
	
	if(norm)
	{
		for(i=0; i<n; i++)
		{
			tbuf[i*4+0]=norm[i*4+0];
			tbuf[i*4+1]=norm[i*4+2];
			tbuf[i*4+2]=norm[i*4+1];
			tbuf[i*4+3]=255;
		}

		ct=PDJPG_EmitComponentLayer(ctx, ct, "XYZ");
		i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(spec)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "SpRGB");
		i=PDJPG_EncodeLDatCtx(ctx, spec, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(norm || spec)
	{
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			tbuf[i*4+0]=norm?norm[i*4+3]:j;
			tbuf[i*4+1]=rgba[i*4+3];
			tbuf[i*4+2]=spec?spec[i*4+3]:j;
			tbuf[i*4+3]=255;
		}

		ct=PDJPG_EmitComponentLayer(ctx, ct, "DASe");
		i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}else
	{
		k=0;
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			if(j!=255)k=1;
			tbuf[i*4+0]=j;
			tbuf[i*4+1]=j;
			tbuf[i*4+2]=j;
			tbuf[i*4+3]=255;
		}

		if(k)
		{
			ct=PDJPG_EmitComponentLayer(ctx, ct, "Alpha");
			i=PDJPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf, PDJPG_YYYA);
			if(i<0) { free(tbuf); return(i); }
			ct+=i;
		}
	}

	if(luma)
	{
		ct=PDJPG_EmitComponentLayer(ctx, ct, "LuRGB");
		i=PDJPG_EncodeLDatCtx(ctx, luma, ct, xs, ys, qf, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	*ct++=0xFF;
	*ct++=JPG_EOI;

	free(tbuf);
	return(ct-obuf);
}

PDGL_API int PDJPG_EncodeComponent(
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	PDJPG_Context *ctx;
	int sz;
	
	ctx=PDJPG_AllocContext();
	sz=PDJPG_EncodeComponentCtx(ctx,
		rgba, norm, spec, luma,
		obuf, xs, ys, qf);
	PDJPG_FreeContext(ctx);
	return(sz);
}

#if 1
PDGL_API byte *PDJPG_Load(VFILE *fd, int *xs, int *ys)
{
	byte *buf, *obuf;
	int fsz;

	vfseek(fd, 0, 2);
	fsz=vftell(fd);
	vfseek(fd, 0, 0);

	buf=malloc(fsz+256);
	vfread(buf, 1, fsz, fd);

	obuf=PDJPG_Decode(buf, fsz, xs, ys);
	free(buf);

	return(obuf);
}

PDGL_API int PDJPG_Store(VFILE *fd, byte *ibuf, int xs, int ys, int qf)
{
	static byte *buf=NULL;
	int fsz;

	if(!buf)buf=malloc(1<<22);

	fsz=PDJPG_Encode(ibuf, buf, xs, ys, qf);
	if(fsz<0)return(fsz);

	vfwrite(buf, 1, fsz, fd);
//	free(buf);

	return(0);
}
#endif
#include <bgbbtj.h>

#ifndef BGBBTJ_DRV
#include <bgbmid.h>
#endif

#ifndef BGBBTJ_API
#define BGBBTJ_API
#endif

#ifndef FOURCC
#define FOURCC(a, b, c, d) ((a)|((b)<<8)|((c)<<16)|((d)<<24))
#endif

#define FCC_FORM	FOURCC('F', 'O', 'R', 'M')
#define FCC_RIFF	FOURCC('R', 'I', 'F', 'F')
#define FCC_RIFX	FOURCC('R', 'I', 'F', 'X')

#define FCC_LIST	FOURCC('L', 'I', 'S', 'T')
#define FCC_AVI		FOURCC('A', 'V', 'I', ' ')

#define FCC_hdrl	FOURCC('h', 'd', 'r', 'l')
#define FCC_strl	FOURCC('s', 't', 'r', 'l')
#define FCC_strh	FOURCC('s', 't', 'r', 'h')
#define FCC_strf	FOURCC('s', 't', 'r', 'f')
#define FCC_strd	FOURCC('s', 't', 'r', 'd')

#define FCC_avih	FOURCC('a', 'v', 'i', 'h')
#define FCC_movi	FOURCC('m', 'o', 'v', 'i')
#define FCC_idx1	FOURCC('i', 'd', 'x', '1')

#define FCC_vids	FOURCC('v', 'i', 'd', 's')
#define FCC_auds	FOURCC('a', 'u', 'd', 's')

#define FCC_MJPG	FOURCC('M', 'J', 'P', 'G')
#define FCC_JPEG	FOURCC('J', 'P', 'E', 'G')

#define FCC_MBTJ	FOURCC('M', 'B', 'T', 'J')
#define FCC_BTJP	FOURCC('B', 'T', 'J', 'P')

#define FCC_MPNG	FOURCC('M', 'P', 'N', 'G')
#define FCC_PNG		FOURCC('P', 'N', 'G', ' ')
#define FCC_PNG1	FOURCC('P', 'N', 'G', '1')
#define FCC_png1	FOURCC('p', 'n', 'g', '1')

#define FCC_MBTC	FOURCC('M', 'B', 'T', 'C')
#define FCC_BTIC	FOURCC('B', 'T', 'I', 'C')

#define FCC_RGBA	FOURCC('R', 'G', 'B', 'A')
#define FCC_RGBT	FOURCC('R', 'G', 'B', 'T')

#define FCC_BtV0	FOURCC('B', 't', 'V', '0')

#define FCC_00dc	FOURCC('0', '0', 'd', 'c')
#define FCC_01wb	FOURCC('0', '1', 'w', 'b')

#define FCC_rpza	RIFF_MAKETAG('r','p','z','a')
#define FCC_azpr	RIFF_MAKETAG('a','z','p','r')

#define FCC_bt1c	RIFF_MAKETAG('b','t','1','c')
#define FCC_c1tb	RIFF_MAKETAG('c','1','t','b')
#define FCC_bt1d	RIFF_MAKETAG('b','t','1','d')

volatile BGBBTJ_AVICtx *pdgl_avi_cap;

int pdgl_avi_nbase=0;
int pdgl_avi_nseq=0;

volatile int pdgl_avi_encloop=0;
volatile int pdgl_avi_enctime=0;

void *pdgl_avi_malloc(int sz)
{
	void *p;
	
	p=malloc(sz);
	memset(p, 0, sz);
	return(p);
}

BGBBTJ_API void BGBBTJ_AVI_UpdateSize(VFILE *fd, int o)
{
	int i;

	i=vftell(fd);
	vfseek(fd, o, 0);
	BGBBTJ_PNG_WriteInt32LE(fd, i-o-4);
	vfseek(fd, i, 0);
}

BGBBTJ_API BGBBTJ_AVICtx *BGBBTJ_AVI_OpenOutStream(char *name,
	int w, int h, float fps, int fcc)
{
	return(BGBBTJ_AVI_OpenOutStream2(
		name, w, h, fps, fcc, BGBBTJ_AVI_AUID_22K8BM));
}

BGBBTJ_API BGBBTJ_AVICtx *BGBBTJ_AVI_OpenOutStream2(char *name,
	int w, int h, float fps, int fcc, int auid)
{
	byte buf[512];

	VFILE *fd;
	BGBBTJ_AVICtx *ctx;
	BGBBTJ_VidCodecCTX *vcctx;
	int i, j, k;

	memset(buf, 0, 512);


	fd=vffopen(name, "w+b");
	if(!fd)return(NULL);

	ctx=gcalloc(sizeof(BGBBTJ_AVICtx));
	ctx->fd=fd;

	ctx->index=malloc(4096*sizeof(uint));
	ctx->n_index=0;
	ctx->m_index=4096/4;
	ctx->fps=fps;
	ctx->xs=w;
	ctx->ys=h;

	ctx->avih=gcalloc(sizeof(BGBBTJ_MainAVIHeader));
	ctx->vidh=gcalloc(sizeof(BGBBTJ_AVIStreamHeader));
	ctx->vidf=gcalloc(sizeof(BGBBTJ_BMPInfoHeader));


	ctx->vidh->fccType=FCC_vids;

	printf("BGBBTJ_AVI_OpenOutStream: fcc=%08X\n", fcc);

	if(fcc)
	{
		ctx->vidh->fccHandler=fcc;
	}else
	{
		fcc=FCC_MJPG;
		ctx->vidh->fccHandler=FCC_MJPG;
//		ctx->vidh->fccHandler=FCC_RGBT;
//		ctx->vidh->fccHandler=FCC_BtV0;
	}

	ctx->vidh->dwFlags=0;
	ctx->vidh->dwRate=fps*1024+0.5;
	ctx->vidh->dwScale=1024;
	ctx->vidh->dwSuggestedBufferSize=0;
	ctx->vidh->dwQuality=0;

	ctx->vidf->biSize=sizeof(BGBBTJ_BMPInfoHeader);
	ctx->vidf->biWidth=w;
	ctx->vidf->biHeight=h;
	ctx->vidf->biPlanes=1;
	ctx->vidf->biXPelsPerMeter=0;
	ctx->vidf->biYPelsPerMeter=0;

	if(fcc==FCC_MJPG)
	{
		ctx->vidf->biBitCount=24;
		ctx->vidf->biCompression=FCC_JPEG;
		ctx->vidf->biSizeImage=w*h*3;
	}else if(fcc==FCC_RGBT)
	{
		ctx->vidf->biBitCount=16;
		ctx->vidf->biSizeImage=w*h*2;

//		ctx->vidf->biBitCount=24;
//		ctx->vidf->biCompression=FCC_JPEG;
//		ctx->vidf->biCompression=FCC_RGBT;
//		ctx->vidf->biSizeImage=w*h*3;
	}else if(fcc==FCC_BtV0)
	{
		ctx->vidf->biBitCount=24;
		ctx->vidf->biCompression=FCC_BtV0;
		ctx->vidf->biSizeImage=w*h*3;
	}else if(fcc==FCC_MPNG)
	{
		ctx->vidf->biBitCount=24;
		ctx->vidf->biCompression=FCC_PNG;
		ctx->vidf->biSizeImage=w*h*3;
	}else if((fcc==FCC_PNG1) || (fcc==FCC_png1))
	{
		ctx->vidf->biBitCount=32;
		ctx->vidf->biCompression=FCC_PNG1;
		ctx->vidf->biSizeImage=w*h*4;
	}else if(fcc==FCC_MBTC)
	{
		ctx->vidf->biBitCount=24;
		ctx->vidf->biCompression=FCC_BTIC;
		ctx->vidf->biSizeImage=w*h*3;
	}else if(fcc==FCC_rpza)
	{
		ctx->vidf->biBitCount=32;
		ctx->vidf->biCompression=FCC_azpr;
		ctx->vidf->biSizeImage=w*h*4;
	}else if(fcc==FCC_bt1c)
	{
		ctx->vidh->fccHandler=FCC_BTIC;
		ctx->vidf->biCompression=FCC_bt1c;

		ctx->vidf->biBitCount=32;
//		ctx->vidf->biCompression=FCC_c1tb;
		ctx->vidf->biSizeImage=w*h*4;
	}else if(fcc==FCC_bt1d)
	{
		ctx->vidh->fccHandler=FCC_BTIC;
		ctx->vidf->biCompression=FCC_bt1d;
		ctx->vidf->biBitCount=32;
		ctx->vidf->biSizeImage=w*h*4;
	}else if(fcc==BGBBTJ_FCC_bt2c)
	{
		ctx->vidh->fccHandler=FCC_BTIC;
		ctx->vidf->biCompression=BGBBTJ_FCC_bt2c;
		ctx->vidf->biBitCount=32;
		ctx->vidf->biSizeImage=w*h*4;
	}else
	{
		ctx->vidf->biBitCount=24;
		ctx->vidf->biSizeImage=w*h*3;

		ctx->vidf->biCompression=
			ctx->vidh->fccHandler;

		vcctx=BGBBTJ_Codec_BeginCompress(
			ctx->vidh->fccHandler,
			ctx->vidf, ctx->vidf);
		ctx->vid_codec_ctx=vcctx;
		
		ctx->vidStrd=vcctx->vidStrd;
		ctx->sz_vidStrd=vcctx->sz_vidStrd;
	}

#if 1
	if(auid)
	{
		ctx->audh=gcalloc(sizeof(BGBBTJ_AVIStreamHeader));
		ctx->audf=gcalloc(sizeof(BGBBTJ_WaveFmt));

		ctx->audh->fccType=FCC_auds;
		ctx->audh->fccHandler=1;
		ctx->audh->dwFlags=0;
//		ctx->audh->dwRate=44100;
//		ctx->audh->dwRate=22050;

		switch(auid&BGBBTJ_AVI_AUID_MASK_RATE)
		{
		case BGBBTJ_AVI_AUID_8K:
			ctx->audh->dwRate=8000; break;
		case BGBBTJ_AVI_AUID_11K:
			ctx->audh->dwRate=11025; break;
		case BGBBTJ_AVI_AUID_16K:
			ctx->audh->dwRate=16000; break;
		case BGBBTJ_AVI_AUID_22K:
			ctx->audh->dwRate=22050; break;
		case BGBBTJ_AVI_AUID_32K:
			ctx->audh->dwRate=32000; break;
		case BGBBTJ_AVI_AUID_44K:
			ctx->audh->dwRate=44100; break;
		default:
			break;
		}

		ctx->audh->dwScale=1;
		ctx->audh->dwSuggestedBufferSize=0;
		ctx->audh->dwQuality=0;

		ctx->audf->wFormatTag=1;
//		ctx->audf->nChannels=2;
		ctx->audf->nChannels=1;
//		ctx->audf->nSamplesPerSec=44100;
//		ctx->audf->nAvgBytesPerSec=44100*2*2;
//		ctx->audf->nAvgBytesPerSec=44100;

		ctx->audf->nSamplesPerSec=22050;
		ctx->audf->nAvgBytesPerSec=22050;

//		ctx->audf->nBlockAlign=4;
		ctx->audf->nBlockAlign=1;
//		ctx->audf->wBitsPerSample=16;
		ctx->audf->wBitsPerSample=8;
		ctx->audf->cbSize=0;
	}
#endif

#if 0
	ctx->audh=gcalloc(sizeof(BGBBTJ_AVIStreamHeader));
	ctx->audf=gcalloc(sizeof(BGBBTJ_WaveFmt));

	ctx->audh->fccType=FCC_auds;
	ctx->audh->fccHandler=1;
	ctx->audh->dwFlags=0;
//	ctx->audh->dwRate=44100;
	ctx->audh->dwRate=22050;
	ctx->audh->dwScale=1;
	ctx->audh->dwSuggestedBufferSize=0;
	ctx->audh->dwQuality=0;

	ctx->audf->wFormatTag=1;
//	ctx->audf->nChannels=2;
	ctx->audf->nChannels=1;
//	ctx->audf->nSamplesPerSec=44100;
//	ctx->audf->nAvgBytesPerSec=44100*2*2;
//	ctx->audf->nAvgBytesPerSec=44100;

	ctx->audf->nSamplesPerSec=22050;
	ctx->audf->nAvgBytesPerSec=22050;

//	ctx->audf->nBlockAlign=4;
	ctx->audf->nBlockAlign=1;
//	ctx->audf->wBitsPerSample=16;
	ctx->audf->wBitsPerSample=8;
	ctx->audf->cbSize=0;
#endif

	ctx->avih->dwMicroSecPerFrame=1000000/fps;
	ctx->avih->dwMaxBytesPerSec=0;
	ctx->avih->dwFlags=16;
	ctx->avih->dwStreams=ctx->audh?2:1;
	ctx->avih->dwSuggestedBufferSize=0;
	ctx->avih->dwWidth=w;
	ctx->avih->dwHeight=h;
	ctx->avih->dwRate=fps*1024+0.5;
	ctx->avih->dwScale=1024;


	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_RIFF);
	ctx->osz_avi=vftell(ctx->fd);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, 0);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_AVI);

	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_LIST);
	ctx->osz_hdrl=vftell(ctx->fd);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, 0);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_hdrl);

	i=sizeof(BGBBTJ_MainAVIHeader);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_avih);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
	ctx->offs_avih=vftell(ctx->fd);
	vfwrite(ctx->avih, 1, (i&1)?(i+1):i, ctx->fd);


	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_LIST);
	ctx->osz_strl=vftell(ctx->fd);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, 0);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strl);

	i=sizeof(BGBBTJ_AVIStreamHeader);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strh);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
	ctx->offs_vidh=vftell(ctx->fd);
	vfwrite(ctx->vidh, 1, (i&1)?(i+1):i, ctx->fd);

#if 1
	i=sizeof(BGBBTJ_BMPInfoHeader);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strf);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
	ctx->offs_vidf=vftell(ctx->fd);
	vfwrite(ctx->vidf, 1, (i&1)?(i+1):i, ctx->fd);

	if(ctx->vidStrd)
	{
		i=ctx->sz_vidStrd;
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strd);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
		ctx->offs_vidStrd=vftell(ctx->fd);
		vfwrite(ctx->vidStrd, 1, (i&1)?(i+1):i, ctx->fd);
	}
#endif

#if 0
	if(ctx->vidStrd)
	{
		i=ctx->sz_vidStrd;
		i+=sizeof(BGBBTJ_BMPInfoHeader);
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strf);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
		ctx->offs_vidf=vftell(ctx->fd);
		vfwrite(ctx->vidf, 1, sizeof(BGBBTJ_BMPInfoHeader), ctx->fd);
		vfwrite(ctx->vidStrd, 1, ctx->sz_vidStrd+(i&1), ctx->fd);
	}else
	{
		i=sizeof(BGBBTJ_BMPInfoHeader);
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strf);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
		ctx->offs_vidf=vftell(ctx->fd);
		vfwrite(ctx->vidf, 1, (i&1)?(i+1):i, ctx->fd);
	}
#endif

	BGBBTJ_AVI_UpdateSize(ctx->fd, ctx->osz_strl);

#if 1
	if(ctx->audh)
	{
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_LIST);
		ctx->osz_strl=vftell(ctx->fd);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, 0);
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strl);

		i=sizeof(BGBBTJ_AVIStreamHeader);
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strh);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
		ctx->offs_audh=vftell(ctx->fd);
		vfwrite(ctx->audh, 1, (i&1)?(i+1):i, ctx->fd);

		i=sizeof(BGBBTJ_WaveFmt);
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strf);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
		ctx->offs_audf=vftell(ctx->fd);
		vfwrite(ctx->audf, 1, (i&1)?(i+1):i, ctx->fd);

		if(ctx->audStrd)
		{
			i=ctx->sz_audStrd;
			BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_strd);
			BGBBTJ_PNG_WriteInt32LE(ctx->fd, i);
			ctx->offs_audStrd=vftell(ctx->fd);
			vfwrite(ctx->audStrd, 1, (i&1)?(i+1):i, ctx->fd);
		}

		BGBBTJ_AVI_UpdateSize(ctx->fd, ctx->osz_strl);
	}
#endif

	BGBBTJ_AVI_UpdateSize(ctx->fd, ctx->osz_hdrl);

	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_LIST);
	ctx->osz_movi=vftell(ctx->fd);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, 0);
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_movi);

//	BGBBTJ_JPG_FlushEncodeFast(ctx->vidCtx);

	return(ctx);
}

BGBBTJ_API void BGBBTJ_AVI_CloseOutStream(BGBBTJ_AVICtx *ctx)
{
	int i;

	BGBBTJ_JPG_FlushEncodeFast(ctx->vidCtx);

	BGBBTJ_AVI_UpdateSize(ctx->fd, ctx->osz_movi);

#if 1
	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_idx1);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, ctx->n_index*4*4);
	for(i=0; i<ctx->n_index; i++)
	{
		BGBBTJ_PNG_WriteFourcc(ctx->fd, ctx->index[i*4+0]);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, ctx->index[i*4+1]);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, ctx->index[i*4+2]);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, ctx->index[i*4+3]);
	}
#endif


	BGBBTJ_AVI_UpdateSize(ctx->fd, ctx->osz_avi);

	if(ctx->audh)
	{
		vfseek(ctx->fd, ctx->offs_audh, 0);
		vfwrite(ctx->audh, 1, sizeof(BGBBTJ_AVIStreamHeader), ctx->fd);

		vfseek(ctx->fd, ctx->offs_audf, 0);
		vfwrite(ctx->audf, 1, sizeof(BGBBTJ_WaveFmt), ctx->fd);
	}

	vfseek(ctx->fd, ctx->offs_vidh, 0);
	vfwrite(ctx->vidh, 1, sizeof(BGBBTJ_AVIStreamHeader), ctx->fd);

	vfseek(ctx->fd, ctx->offs_vidf, 0);
	vfwrite(ctx->vidf, 1, sizeof(BGBBTJ_BMPInfoHeader), ctx->fd);

	vfseek(ctx->fd, ctx->offs_avih, 0);
	vfwrite(ctx->avih, 1, sizeof(BGBBTJ_MainAVIHeader), ctx->fd);

	gcfree(ctx->vidh);
	gcfree(ctx->vidf);
	gcfree(ctx->avih);

	if(ctx->audh)gcfree(ctx->audh);
	if(ctx->audf)gcfree(ctx->audf);

	vfclose(ctx->fd);
	gcfree(ctx);
}

int BGBBTJ_AVI_AddIndex(BGBBTJ_AVICtx *ctx, uint tag, uint len, uint fl)
{
	int i;

	i=ctx->n_index++;

	if(i>=ctx->m_index)
	{
		ctx->m_index+=ctx->m_index>>1;
		ctx->index=realloc(ctx->index, ctx->m_index*4*sizeof(uint));
	}

	ctx->index[i*4+0]=tag;
	ctx->index[i*4+1]=fl;
//	ctx->index[i*4+2]=vftell(ctx->fd);
	ctx->index[i*4+2]=vftell(ctx->fd)-(ctx->osz_movi+4);
	ctx->index[i*4+3]=len;

	return(i);
}

void BGBBTJ_AVI_EmitCodedFrame(BGBBTJ_AVICtx *ctx, byte *buf,
	int sz, int qf)
{
	int fl;

//	printf("BGBBTJ_AVI_EmitCodedFrame: Sz=%d Qf=%d  \n", sz, qf);

	fl=0;
	if(!(qf&BGBBTJ_QFL_PFRAME))
		{ fl|=16; }

	BGBBTJ_AVI_AddIndex(ctx, FCC_00dc, sz, fl);
//	BGBBTJ_AVI_AddIndex(ctx, FCC_00dc, sz, 16);

	BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_00dc);
	BGBBTJ_PNG_WriteInt32LE(ctx->fd, sz);
	vfwrite(buf, 1, (sz&1)?(sz+1):sz, ctx->fd);

	ctx->avih->dwTotalFrames++;
	ctx->avih->dwLength++;
	ctx->vidh->dwLength++;
	ctx->frnum++;
}

void BGBBTJ_AVI_EmitAudioFrame(BGBBTJ_AVICtx *ctx)
{
	static byte *tbuf=NULL;
	static s16 *tsbuf=NULL;
	int i0, i1, i2, i3;
	int j0, j1, j2, j3;
	int i, j, k, l, n, sz, bl, bsz;

	tbuf=ctx->capEncodeAuBuf;
	if(!tbuf)
	{
		tbuf=malloc(1<<18);
		ctx->capEncodeAuBuf=tbuf;
		tsbuf=(s16 *)tbuf;
	}

#if 1
	if(ctx->audh)
	{
//		l=44100/ctx->fps;
//		l=22050/ctx->fps;
		l=ctx->audf->nSamplesPerSec/ctx->fps;

//		sz=l*4;
//		sz=l;
		sz=(l*ctx->audf->nAvgBytesPerSec)/ctx->audf->nSamplesPerSec;

		if(ctx->audf->wBitsPerSample==8)
			{ memset(tbuf, 128, sz); }
		else
			{ memset(tbuf, 0, sz); }

		if(ctx->audf->wFormatTag==BGBBTJ_WAVE_FORMAT_IMAADPCM)
		{
#ifndef BGBBTJ_DRV
			bsz=ctx->audf->nBlockAlign;
			bl=BGBMID_MsImaAdpcm_StereoSamplesFromBlockSize(bsz);
			n=(l+bl-1)/bl;
			l=n*bl;
			sz=n*bsz;
			memset(tbuf, 0, sz);

			if(!ctx->audSampleBuf)
			{
				BGBBTJ_AVI_AddIndex(ctx, FCC_01wb, sz, 16);
				BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_01wb);
				BGBBTJ_PNG_WriteInt32LE(ctx->fd, sz);
				vfwrite(tbuf, 1, (sz&1)?(sz+1):sz, ctx->fd);
				ctx->audh->dwLength+=l;
				return;
			}
			
			for(i=0; i<n; i++)
			{
				j=(ctx->audSampleBufStartPos+i*bl)%
					ctx->audSampleBufSz;
				BGBMID_MsImaAdpcm_EncodeBlockStereo(
					ctx->audSampleBuf+j*2, tbuf+i*bsz, bl);
			}

			j=(ctx->audSampleBufStartPos+i*bl)%ctx->audSampleBufSz;
			ctx->audSampleBufStartPos=j;
#endif
		}
		else if(ctx->audf->wFormatTag==BGBBTJ_WAVE_FORMAT_PCM)
		{
			if(!ctx->audSampleBuf)
			{
				BGBBTJ_AVI_AddIndex(ctx, FCC_01wb, sz, 16);
				BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_01wb);
				BGBBTJ_PNG_WriteInt32LE(ctx->fd, sz);
				vfwrite(tbuf, 1, (sz&1)?(sz+1):sz, ctx->fd);
				ctx->audh->dwLength+=l;
				return;
			}

			for(i=0; i<l; i++)
			{
//				k=(ctx->audSampleBuf[j*2+0]+ctx->audSampleBuf[j*2+1])/2;
//				k=(k>>8)+128;
//				k=(k<0)?0:(k<=255)?k:255;
//				tbuf[i]=k;

//				i0=ctx->audSampleBuf[j*2+0];
//				i1=ctx->audSampleBuf[j*2+1];

				if(ctx->audf->nSamplesPerSec==22050)
				{
					j0=(ctx->audSampleBufStartPos+(2*i+0))%
						ctx->audSampleBufSz;
					j1=(ctx->audSampleBufStartPos+(2*i+1))%
						ctx->audSampleBufSz;
					if(j0==ctx->audSampleBufEndPos)break;
					if(j1==ctx->audSampleBufEndPos)break;

					i0=(ctx->audSampleBuf[j0*2+0]+
						ctx->audSampleBuf[j1*2+0])/2;
					i1=(ctx->audSampleBuf[j0*2+1]+
						ctx->audSampleBuf[j1*2+1])/2;
				}else
				{
					j=(ctx->audSampleBufStartPos+i)%
						ctx->audSampleBufSz;
					i0=ctx->audSampleBuf[j*2+0];
					i1=ctx->audSampleBuf[j*2+1];
				}
	
				if(ctx->audf->nChannels==1)
				{
					if(ctx->audf->wBitsPerSample==8)
					{
						k=(i0+i1)/2;
						k=(k>>8)+128;
						k=(k<0)?0:(k<=255)?k:255;
						tbuf[i]=k;
					}else
					{
						k=(i0+i1)/2;
						k=(k<(-32768))?(-32768):(k>32767)?32767:k;
						tsbuf[i]=k;
					}
				}else
				{
					if(ctx->audf->wBitsPerSample==8)
					{
						j0=(i0>>8)+128;
						j1=(i1>>8)+128;
						j0=(j0<0)?0:(j0<=255)?j0:255;
						j1=(j1<0)?0:(j1<=255)?j1:255;
						tbuf[i*2+0]=j0;
						tbuf[i*2+1]=j1;
					}else
					{
						tsbuf[i*2+0]=i0;
						tsbuf[i*2+1]=i1;
					}
				}
		
//				i0=((j/64)&1)?1024:-1024; i1=-i0;

//				tbuf[i*2+0]=i0;
//				tbuf[i*2+1]=i1;
			}

//			j=(ctx->audSampleBufStartPos+l)%ctx->audSampleBufSz;
//			j=(ctx->audSampleBufStartPos+i)%ctx->audSampleBufSz;
			if(ctx->audf->nSamplesPerSec==22050)
			{
				j=(ctx->audSampleBufStartPos+2*i)%ctx->audSampleBufSz;
			}else
			{
				j=(ctx->audSampleBufStartPos+i)%ctx->audSampleBufSz;
			}

			ctx->audSampleBufStartPos=j;
		}

//		for(k=0; k<8; k++)
//		{
//			tbuf[k]=(tbuf[k]-128)*(k/8.0)+128;
//			tbuf[i-k]=(tbuf[i-k]-128)*(k/8.0)+128;
//		}

		BGBBTJ_AVI_AddIndex(ctx, FCC_01wb, sz, 16);
		BGBBTJ_PNG_WriteFourcc(ctx->fd, FCC_01wb);
		BGBBTJ_PNG_WriteInt32LE(ctx->fd, sz);
		vfwrite(tbuf, 1, (sz&1)?(sz+1):sz, ctx->fd);

		ctx->audh->dwLength+=l;
	}
#endif
}

BGBBTJ_API void BGBBTJ_AVI_EncodeFrame(BGBBTJ_AVICtx *ctx,
	byte *ibuf, int w, int h)
{
	BGBBTJ_AVI_EncodeFrame2(ctx, ibuf, w, h, 90, 0);
}

BGBBTJ_API void BGBBTJ_AVI_EncodeFrame2(BGBBTJ_AVICtx *ctx,
	byte *ibuf, int w, int h, int qf, int clrs)
{
//	static byte tbuf[1<<22];
//	static byte *tbuf=NULL;
	byte *tbuf;
	int i, j, k, l, sz, fl;

	tbuf=ctx->capEncodeBuf;
	if(!tbuf)
	{
		tbuf=malloc(1<<22);
		ctx->capEncodeBuf=tbuf;
	}

//	qf=75;
//	qf=85;
//	qf=80;

	sz=-999;

	if((ctx->vidh->fccHandler==FCC_MJPG) ||
		(ctx->vidh->fccHandler==FCC_MBTJ))
	{
		if(!ctx->vidCtx)
			ctx->vidCtx=BGBBTJ_JPG_AllocContext();

//		memset(tbuf, 0, 1<<16);

//		if(!tbuf)tbuf=malloc(1<<20);
//		i=BGBBTJ_JPG_EncodeFast(ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 90); //70

//		sz=BGBBTJ_JPG_EncodeFastCtx(ctx->vidCtx, ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 90, 0); //70

//		sz=BGBBTJ_JPG_Encode(ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, qf); //70

		sz=BGBBTJ_JPG_EncodeComponentCtx(ctx->vidCtx,
			ibuf, NULL, NULL, NULL, tbuf,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

//		i=BGBBTJ_JPG_EncodeFastCtx(ctx->vidCtx, ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 100, 0); //70
	}

	if((ctx->vidh->fccHandler==FCC_MPNG) ||
		(ctx->vidh->fccHandler==FCC_PNG1) ||
		(ctx->vidh->fccHandler==FCC_png1))
	{
//		if(!ctx->vidCtx)
//			ctx->vidCtx=BTV0_AllocContext();

		sz=BGBBTJ_BufPNG_Encode(tbuf, 1<<22, ibuf, 
			ctx->avih->dwWidth, ctx->avih->dwHeight);

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

	}

	if(ctx->vidh->fccHandler==FCC_rpza)
	{
		if(!(qf&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME)))
		{
//			if(!(ctx->frnum&15))
			if(!(ctx->frnum&63))
				{ qf|=BGBBTJ_QFL_IFRAME; }
			else
				{ qf|=BGBBTJ_QFL_PFRAME; }
		}

		if(!ctx->vidCtx)
			ctx->vidCtx=BGBBTJ_RPZA_AllocContext();
		sz=BGBBTJ_RPZA_EncodeImage(ctx->vidCtx, ibuf, tbuf, 1<<22,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf, clrs);
	}

	if(ctx->vidh->fccHandler==FCC_bt1c)
	{
		if(!(qf&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME)))
		{
//			if(!(ctx->frnum&15))
			if(!(ctx->frnum&63))
				{ qf|=BGBBTJ_QFL_IFRAME; }
			else
				{ qf|=BGBBTJ_QFL_PFRAME; }
		}

		if(!ctx->vidCtx)
			ctx->vidCtx=BGBBTJ_BT1C_AllocContext();
		sz=BGBBTJ_BT1C_EncodeImage(ctx->vidCtx, ibuf, tbuf, 1<<22,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf, clrs);
	}

	if(ctx->vidh->fccHandler==FCC_MBTC)
	{
		if(!ctx->vidCtx)
			ctx->vidCtx=BTIC1_AllocContext();

		sz=BTIC1_EncodeComponentCtx(ctx->vidCtx,
			ibuf, NULL, NULL, NULL,
			tbuf,
			ctx->avih->dwWidth, ctx->avih->dwHeight, 90); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

	}

	if(ctx->vidh->fccHandler==FCC_BtV0)
	{
		if(!ctx->vidCtx)
			ctx->vidCtx=BTV0_AllocContext();

		sz=BTV0_EncodeCtx(ctx->vidCtx, ibuf, tbuf,
			ctx->avih->dwWidth, ctx->avih->dwHeight, 90, 0); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

	}

	if(ctx->vid_codec_ctx)
	{
		if(!(qf&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME)))
		{
//			if(!(ctx->frnum&15))
			if(!(ctx->frnum&63))
				{ qf|=BGBBTJ_QFL_IFRAME; }
			else
				{ qf|=BGBBTJ_QFL_PFRAME; }
		}

		sz=BGBBTJ_Codec_CompressFrame(ctx->vid_codec_ctx,
			ibuf, tbuf, 1<<22, qf, 0, &fl);
		qf&=(~(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME));
		qf|=fl&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME);
	}

	if(sz==-999)
	{
		ctx->vid_codec_ctx=BGBBTJ_Codec_BeginCompress(
			ctx->vidh->fccHandler, ctx->vidf, ctx->vidf);

		if(ctx->vid_codec_ctx)
		{
			sz=BGBBTJ_Codec_CompressFrame(ctx->vid_codec_ctx,
				ibuf, tbuf, 1<<22, qf, 0, &fl);
			qf&=(~(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME));
			qf|=fl&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME);
		}
	}

	if(ctx->vidh->fccHandler==0)
	{
//		if(!tbuf)tbuf=malloc(1<<22);

		k=w*h;
		for(i=0; i<k; i++)
		{
			tbuf[i*3+0]=ibuf[i*4+2];
			tbuf[i*3+1]=ibuf[i*4+1];
			tbuf[i*3+2]=ibuf[i*4+0];
		}
		
		sz=w*h*3;
	}

	if(ctx->vidh->fccHandler==FCC_RGBT)
	{
//		if(!tbuf)tbuf=malloc(1<<22);
		
		k=w*h;
		for(i=0; i<k; i++)
		{
			j=(ibuf[i*4+2]>>3) | ((ibuf[i*4+1]&0xF8)<<2) |
				((ibuf[i*4+0]&0xF8)<<7) |
				((ibuf[i*4+3]&0x80)<<8);
			
			tbuf[i*2+0]=j&0xFF;
			tbuf[i*2+1]=(j>>8)&0xFF;
		}
		sz=w*h*2;
	}

	if(qf&BGBBTJ_QFL_BATCHENCODE)
	{
		BGBBTJ_AVI_EmitCodedFrame(ctx, tbuf, sz, qf);
		BGBBTJ_AVI_EmitAudioFrame(ctx);
		ctx->accDt2=0;
	}else
	{
		while(ctx->accDt2>=(1.0/ctx->fps))
		{
			BGBBTJ_AVI_EmitCodedFrame(ctx, tbuf, sz, qf);
			BGBBTJ_AVI_EmitAudioFrame(ctx);
			ctx->accDt2-=1.0/ctx->fps;
		}
	}
}

BGBBTJ_API void BGBBTJ_AVI_EncodeComponentFrame(BGBBTJ_AVICtx *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int w, int h)
{
	BGBBTJ_AVI_EncodeComponentFrame2(
		ctx, rgba, norm, spec, luma, w, h,
		90, BGBBTJ_JPG_RGBA);
}

BGBBTJ_API void BGBBTJ_AVI_EncodeComponentFrame2(BGBBTJ_AVICtx *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int w, int h, int qf, int pf)
{
//	static byte tbuf[1<<22];
//	static byte *tbuf=NULL;
	byte *tbuf;
	int i, j, k, l, sz, fl;

	tbuf=ctx->capEncodeBuf;
	if(!tbuf)
	{
		tbuf=malloc(1<<22);
		ctx->capEncodeBuf=tbuf;
	}

	sz=-999;

	if(ctx->vidh->fccHandler==FCC_MJPG)
	{
		if(!ctx->vidCtx)
			ctx->vidCtx=BGBBTJ_JPG_AllocContext();

//		memset(tbuf, 0, 1<<16);

//		if(!tbuf)tbuf=malloc(1<<20);
//		i=BGBBTJ_JPG_EncodeFast(ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 90); //70

//		sz=BGBBTJ_JPG_EncodeFastCtx(ctx->vidCtx, ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 90, 0); //70

//		sz=BGBBTJ_JPG_EncodeComponentCtx(ctx->vidCtx,
//			rgba, norm, spec, luma, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 90); //70

		sz=BGBBTJ_JPG_EncodeComponentCtx(ctx->vidCtx,
			rgba, norm, spec, luma, tbuf,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

//		i=BGBBTJ_JPG_EncodeFastCtx(ctx->vidCtx, ibuf, tbuf,
//			ctx->avih->dwWidth, ctx->avih->dwHeight, 100, 0); //70
	}

	if((ctx->vidh->fccHandler==FCC_MPNG) ||
		(ctx->vidh->fccHandler==FCC_PNG1) ||
		(ctx->vidh->fccHandler==FCC_png1))
	{
//		if(!ctx->vidCtx)
//			ctx->vidCtx=BTV0_AllocContext();

		sz=BGBBTJ_BufPNG_Encode(tbuf, 1<<22, rgba, 
			ctx->avih->dwWidth, ctx->avih->dwHeight); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

	}

	if(ctx->vidh->fccHandler==FCC_rpza)
	{
		if(!(qf&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME)))
		{
//			if(!(ctx->frnum&15))
			if(!(ctx->frnum&63))
				{ qf|=BGBBTJ_QFL_IFRAME; }
			else
				{ qf|=BGBBTJ_QFL_PFRAME; }
		}

		if(!ctx->vidCtx)
			ctx->vidCtx=BGBBTJ_RPZA_AllocContext();
		sz=BGBBTJ_RPZA_EncodeImage(ctx->vidCtx, rgba, tbuf, 1<<22,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf, 0);
	}

	if(ctx->vidh->fccHandler==FCC_bt1c)
	{
		if(!(qf&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME)))
		{
//			if(!(ctx->frnum&15))
			if(!(ctx->frnum&63))
				{ qf|=BGBBTJ_QFL_IFRAME; }
			else
				{ qf|=BGBBTJ_QFL_PFRAME; }
		}

		if(!ctx->vidCtx)
			ctx->vidCtx=BGBBTJ_BT1C_AllocContext();
		sz=BGBBTJ_BT1C_EncodeImage(ctx->vidCtx, rgba, tbuf, 1<<22,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf, 0);
	}

	if(ctx->vidh->fccHandler==FCC_MBTC)
	{
		if(!ctx->vidCtx)
			ctx->vidCtx=BTIC1_AllocContext();

		sz=BTIC1_EncodeComponentCtx(ctx->vidCtx,
			rgba, norm, spec, luma,
			tbuf,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);

	}

	if(ctx->vidh->fccHandler==FCC_BtV0)
	{
		if(!ctx->vidCtx)
			ctx->vidCtx=BTV0_AllocContext();

		sz=BTV0_EncodeComponentCtx(ctx->vidCtx,
			rgba, norm, spec, luma, tbuf,
			ctx->avih->dwWidth, ctx->avih->dwHeight, qf, 0); //70

//		printf("BGBBTJ_AVI_EncodeFrame: Size=%d\n", sz);
	}

	if(ctx->vid_codec_ctx)
	{
		sz=BGBBTJ_Codec_CompressFrame(ctx->vid_codec_ctx,
			rgba, tbuf, 1<<22, qf, 0, &fl);
		qf&=(~(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME));
		qf|=fl&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME);
	}

	if(sz==-999)
	{
		ctx->vid_codec_ctx=BGBBTJ_Codec_BeginCompress(
			ctx->vidh->fccHandler, ctx->vidf, ctx->vidf);

		if(ctx->vid_codec_ctx)
		{
			sz=BGBBTJ_Codec_CompressFrame(ctx->vid_codec_ctx,
				rgba, tbuf, 1<<22, qf, 0, &fl);
			qf&=(~(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME));
			qf|=fl&(BGBBTJ_QFL_IFRAME|BGBBTJ_QFL_PFRAME);
		}
	}

	if(ctx->vidh->fccHandler==0)
	{
//		if(!tbuf)tbuf=malloc(1<<22);

		k=w*h;
		for(i=0; i<k; i++)
		{
			tbuf[i*3+0]=rgba[i*4+2];
			tbuf[i*3+1]=rgba[i*4+1];
			tbuf[i*3+2]=rgba[i*4+0];
		}
		
		sz=w*h*3;
	}

	if(ctx->vidh->fccHandler==FCC_RGBT)
	{
//		if(!tbuf)tbuf=malloc(1<<22);
		
		k=w*h;
		for(i=0; i<k; i++)
		{
			j=(rgba[i*4+2]>>3) | ((rgba[i*4+1]&0xF8)<<2) |
				((rgba[i*4+0]&0xF8)<<7) |
				((rgba[i*4+3]&0x80)<<8);
			
			tbuf[i*2+0]=j&0xFF;
			tbuf[i*2+1]=(j>>8)&0xFF;
		}
		sz=w*h*2;
	}

	while(ctx->accDt2>=(1.0/ctx->fps))
	{
		BGBBTJ_AVI_EmitCodedFrame(ctx, tbuf, sz, qf);
		BGBBTJ_AVI_EmitAudioFrame(ctx);
		ctx->accDt2-=1.0/ctx->fps;
	}
}

BGBBTJ_API int BGBBTJ_AVI_WriteContextStereoSamples(
	BGBBTJ_AVICtx *ctx, short *buf, int cnt)
{
	int i, j, k;

	if(!ctx)
		return(-1);
		
	if(!ctx->audSampleBuf)
	{
//		i=2*44100;
		i=2*65536;

		ctx->audSampleBufSz=i;
		ctx->audSampleBufStartPos=0;
		ctx->audSampleBufEndPos=0;

		ctx->audSampleBuf=malloc(i*2*sizeof(short));
	}
	
	for(i=0; i<cnt; i++)
	{
		j=(ctx->audSampleBufEndPos+i)%
			ctx->audSampleBufSz;
		ctx->audSampleBuf[j*2+0]=buf[i*2+0];
		ctx->audSampleBuf[j*2+1]=buf[i*2+1];
	}
	j=(ctx->audSampleBufEndPos+cnt)%
		ctx->audSampleBufSz;
	ctx->audSampleBufEndPos=j;
	
	return(0);
}


void BGBBTJ_AVI_Scale800x600to320x240(byte *ibuf, byte *obuf)
{
	int i, j, k, l;
	byte *sb, *tb;

#if 0
	for(i=0; i<120; i++)
		for(j=0; j<160; j++)
			for(k=0; k<3; k++)
	{
		tb=ibuf+(i*5*800+j*5)*4+k;

		l=tb[0*800*4+0]+tb[0*800*4+4]+tb[1*800*4+0]+tb[1*800*4+4];
		obuf[((i*2+0)*320+(j*2+0))*4+k]=l>>2;

		l=tb[0*800*4+12]+tb[0*800*4+16]+tb[1*800*4+12]+tb[1*800*4+16];
		obuf[((i*2+0)*320+(j*2+1))*4+k]=l>>2;

		l=tb[3*800*4+0]+tb[3*800*4+4]+tb[4*800*4+0]+tb[4*800*4+4];
		obuf[((i*2+1)*320+(j*2+0))*4+k]=l>>2;

		l=tb[3*800*4+12]+tb[3*800*4+16]+tb[4*800*4+12]+tb[4*800*4+16];
		obuf[((i*2+1)*320+(j*2+1))*4+k]=l>>2;
	}
#endif

#if 1
	for(i=0; i<120; i++)
		for(j=0; j<160; j++)
			for(k=0; k<3; k++)
	{
		sb=ibuf+(i*5*800+j*5)*4+k;
		tb=obuf+((i*2*320+j*2)*4+k);

		l=	sb[0*800*4+0]+sb[0*800*4+4]+sb[0*800*4+8]+
			sb[1*800*4+0]+sb[1*800*4+4]+sb[1*800*4+8]+
			sb[2*800*4+0]+sb[2*800*4+4]+sb[2*800*4+8];
		tb[0]=l/9;

		l=	sb[0*800*4+8]+sb[0*800*4+12]+sb[0*800*4+16]+
			sb[1*800*4+8]+sb[1*800*4+12]+sb[1*800*4+16]+
			sb[2*800*4+8]+sb[2*800*4+12]+sb[2*800*4+16];
		tb[4]=l/9;

		l=	sb[2*800*4+0]+sb[2*800*4+4]+sb[2*800*4+8]+
			sb[3*800*4+0]+sb[3*800*4+4]+sb[3*800*4+8]+
			sb[4*800*4+0]+sb[4*800*4+4]+sb[4*800*4+8];
		tb[320*4]=l/9;

		l=	sb[2*800*4+8]+sb[2*800*4+12]+sb[2*800*4+16]+
			sb[3*800*4+8]+sb[3*800*4+12]+sb[3*800*4+16]+
			sb[4*800*4+8]+sb[4*800*4+12]+sb[4*800*4+16];
		tb[320*4+4]=l/9;
	}
#endif

#if 0
	for(i=0; i<120; i++)
		for(j=0; j<160; j++)
			for(k=0; k<3; k++)
	{
		tb=ibuf+(i*5*800+j*5)*4+k;
		l=(i*2*320+j*2)*4+k;
		obuf[l]=tb[1*800*4+4];
		obuf[l+4]=tb[1*800*4+12];
		obuf[l+320*4]=tb[3*800*4+4];
		obuf[l+320*4+4]=tb[3*800*4+12];
	}
#endif

#if 0
	for(i=0; i<120; i++)
		for(j=0; j<160; j++)
			for(k=0; k<3; k++)
	{
		tb=buf+(i*5*800+j*5)*4+k;

		l=	(tb[0*800*4+0]+tb[0*800*4+4]+tb[0*800*4+8]+
			tb[1*800*4+0]+tb[1*800*4+4]+tb[1*800*4+8]+
			tb[2*800*4+0]+tb[2*800*4+4]+tb[2*800*4+8])/9;
		buf[((i*2+0)*320+(j*2+0))*4+k]=(l<0)?0:(l>255)?255:l;

		l=	(tb[0*800*4+8]+tb[0*800*4+12]+tb[0*800*4+16]+
			tb[1*800*4+8]+tb[1*800*4+12]+tb[1*800*4+16]+
			tb[2*800*4+8]+tb[2*800*4+12]+tb[2*800*4+16])/9;
		buf[((i*2+0)*320+(j*2+1))*4+k]=(l<0)?0:(l>255)?255:l;

		l=	(tb[2*800*4+0]+tb[2*800*4+4]+tb[2*800*4+8]+
			tb[3*800*4+0]+tb[3*800*4+4]+tb[3*800*4+8]+
			tb[4*800*4+0]+tb[4*800*4+4]+tb[4*800*4+8])/9;
		buf[((i*2+1)*320+(j*2+0))*4+k]=(l<0)?0:(l>255)?255:l;

		l=	(tb[2*800*4+8]+tb[2*800*4+12]+tb[2*800*4+16]+
			tb[3*800*4+8]+tb[3*800*4+12]+tb[3*800*4+16]+
			tb[4*800*4+8]+tb[4*800*4+12]+tb[4*800*4+16])/9;
		buf[((i*2+1)*320+(j*2+1))*4+k]=(l<0)?0:(l>255)?255:l;
	}
#endif

#if 0
	for(i=0; i<600; i++)
		for(j=0; j<160; j++)
			for(k=0; k<3; k++)
	{
		l=buf[(i*800+(j*5+0))*4+k];
		l+=buf[(i*800+(j*5+1))*4+k];
		l+=buf[(i*800+(j*5+2))*4+k];
		buf[(i*320+j*2+0)*4+k]=l/3;

		l=buf[(i*800+(j*5+2))*4+k];
		l+=buf[(i*800+(j*5+3))*4+k];
		l+=buf[(i*800+(j*5+4))*4+k];
		buf[(i*320+j*2+1)*4+k]=l/3;
	}

	for(i=0; i<120; i++)
		for(j=0; j<320; j++)
			for(k=0; k<3; k++)
	{
		l=buf[((i*5+0)*320+j)*4+k];
		l+=buf[((i*5+1)*320+j)*4+k];
		l+=buf[((i*5+2)*320+j)*4+k];
		buf[((i*2+0)*320+j)*4+k]=l/3;

		l=buf[((i*5+2)*320+j)*4+k];
		l+=buf[((i*5+2)*320+j)*4+k];
		l+=buf[((i*5+4)*320+j)*4+k];
		buf[((i*2+1)*320+j)*4+k]=l/3;
	}
#endif
}

#if 0
int BGBBTJ_AVI_EncoderLoop(void *p)
{
	byte *buf0, *buf1;
	int t0, t1;
	int i, j;

//	thSleep(rand()&15);

	if(pdgl_avi_encloop>0)
		return(0);
		
	i=pdgl_avi_encloop++;
	if(i>1)
	{
		pdgl_avi_encloop--;
		return(0);
	}
	
	printf("BGBBTJ_AVI_EncoderLoop\n");
	
	while(1)
	{
		if(!pdgl_avi_cap)
		{
			thSleep(10);
			continue;
//			break;
		}

#if 1
		if(vftell(pdgl_avi_cap->fd)>=((1<<30)-(1<<24)))
		{
			BGBBTJ_AVI_CloseOutStream(pdgl_avi_cap);
			pdgl_avi_cap=NULL;
			continue;
		}
#endif

		if(pdgl_avi_cap->capReqClose)
		{
			printf("BGBBTJ_AVI_EncoderLoop: Close Stream\n");

			BGBBTJ_AVI_CloseOutStream(pdgl_avi_cap);
			pdgl_avi_cap=NULL;
			pdgl_avi_nbase=0;
			pdgl_avi_nseq=0;
			continue;
		}

		if(pdgl_avi_cap->capFrameLastIdx==pdgl_avi_cap->capFrameIdx)
		{
			thSleep(5);
			continue;
		}

		if(pdgl_avi_cap->accDt2<=(1.0/pdgl_avi_cap->fps))
		{
			thSleep(5);
			continue;
		}

		t0=BGBBTJ_TimeMS();

		j=pdgl_avi_cap->xs*pdgl_avi_cap->ys;
		if(!pdgl_avi_cap->capFrameBuf2)
			pdgl_avi_cap->capFrameBuf2=malloc(j*4);
//		memcpy(pdgl_avi_cap->capFrameBuf2,
//			pdgl_avi_cap->capFrameBuf, i);

		buf0=pdgl_avi_cap->capFrameBuf;
		buf1=pdgl_avi_cap->capFrameBuf2;
		for(i=0; i<j; i++)
		{
			buf1[0]=buf0[2]; buf1[1]=buf0[1];
			buf1[2]=buf0[0]; buf1[3]=buf0[3];
			buf0+=4; buf1+=4;
		}

		BGBBTJ_AVI_EncodeFrame(pdgl_avi_cap,
			pdgl_avi_cap->capFrameBuf2,
			pdgl_avi_cap->xs, pdgl_avi_cap->ys);
		pdgl_avi_cap->capFrameLastIdx=
			pdgl_avi_cap->capFrameIdx;
			
		t1=BGBBTJ_TimeMS();
		pdgl_avi_enctime=t1-t0;

		thSleep(5);
	}

	pdgl_avi_encloop--;
	return(0);
}
#endif

BGBBTJ_API int BGBBTJ_AVI_GetEncodeTime()
	{ return(pdgl_avi_enctime); }

BGBBTJ_API int BGBBTJ_AVI_WriteStereoSamples(short *buf, int cnt)
{
	int i, j, k;

	if(!pdgl_avi_cap)
		return(-1);
		
	if(!pdgl_avi_cap->audSampleBuf)
	{
		i=44100;

		pdgl_avi_cap->audSampleBufSz=i;
		pdgl_avi_cap->audSampleBufStartPos=0;
		pdgl_avi_cap->audSampleBufEndPos=0;

		pdgl_avi_cap->audSampleBuf=malloc(i*2*sizeof(short));
	}
	
	for(i=0; i<cnt; i++)
	{
		j=(pdgl_avi_cap->audSampleBufEndPos+i)%
			pdgl_avi_cap->audSampleBufSz;
		pdgl_avi_cap->audSampleBuf[j*2+0]=buf[i*2+0];
		pdgl_avi_cap->audSampleBuf[j*2+1]=buf[i*2+1];
	}
	j=(pdgl_avi_cap->audSampleBufEndPos+cnt)%
		pdgl_avi_cap->audSampleBufSz;
	pdgl_avi_cap->audSampleBufEndPos=j;
	
	return(0);
}

#if 0
BGBBTJ_API int BGBBTJ_AVI_Screenshot()
{
	static byte *buf=NULL, *buf1=NULL;
	static int v=0;
	VFILE *fd;
	int w0, h0, w1, h1;
	int i, j, k, l;

//	GfxDrv_GetWindowSize(&w0, &h0);

	w0=pdgl_avi_cap->xs;
	h0=pdgl_avi_cap->ys;

//	w0=800; h0=600;
	w1=320;	h1=240;

	if(!buf)buf=malloc(w0*(h0+1)*4);
//	if(!buf1)buf1=malloc(w1*(h1+1)*4);

	if(!pdgl_avi_cap->capFrameBuf)
		pdgl_avi_cap->capFrameBuf=malloc(w0*(h0+1)*4);

	glFinish();
//	glReadPixels (0, 0, w0, h0, GL_RGBA, GL_UNSIGNED_BYTE, buf); 
	glReadPixels (0, 0, w0, h0, GL_BGRA, GL_UNSIGNED_BYTE, buf); 
//	glReadPixels (0, 0, w0, h0, GL_BGR, GL_UNSIGNED_BYTE, buf); 

	memcpy((void *)pdgl_avi_cap->capFrameBuf, buf, w0*h0*4);
	pdgl_avi_cap->capFrameIdx++;

#if 0
	//gamma correct
	for(i=0; i<(w0*h0); i++)
	{
		l=i*4;
		for(j=0; j<3; j++)
		{
			k=buf[l];
			k=k*1.25+32;
			if(k>255)k=255;
			buf[l++]=k;
		}
	}
#endif

//	glFinish();

//	if(v)
//	BGBBTJ_AVI_EncodeFrame(pdgl_avi_cap, buf, w0, h0);

//	BGBBTJ_AVI_Scale800x600to320x240(buf, buf1);
//	BGBBTJ_AVI_EncodeFrame(pdgl_avi_cap, buf1, w1, h1);

//	glFinish();
//	glReadPixels (0, 0, w0, h0, GL_RGBA, GL_UNSIGNED_BYTE, buf); 
//	v=1;

	return(0);
}


BGBBTJ_API int BGBBTJ_AVI_DoScreenshotFrame(float dt)
{
	static char *base;
//	static float t;
	char buf[64];
	int xs, ys;

#if 0
	if(pdgl_avi_cap)
	{
		if(vftell(pdgl_avi_cap->fd)>=((1<<30)-(1<<24)))
		{
			BGBBTJ_AVI_CloseOutStream(pdgl_avi_cap);
			pdgl_avi_cap=NULL;
		}
	}
#endif

	if(!pdgl_avi_cap)
	{
//		base=strdup(Sys_GetTimeStr2());

		if(!pdgl_avi_nbase)
			pdgl_avi_nbase=bgbrng_genvalue();

		sprintf(buf, "%08X_%d", pdgl_avi_nbase, pdgl_avi_nseq++);
		base=strdup(buf);
//		sprintf(buf, "record_%s.avi", base);
		sprintf(buf, "record/record_%s.avi", base);

		GfxDrv_GetWindowSize(&xs, &ys);

//		pdgl_avi_cap=BGBBTJ_AVI_OpenOutStream(buf, 320, 240, 10);
//		pdgl_avi_cap=BGBBTJ_AVI_OpenOutStream(buf, 800, 600, 12);
		pdgl_avi_cap=BGBBTJ_AVI_OpenOutStream(buf, xs, ys, 12);
//		t=0;
		pdgl_avi_cap->accDt=0;

		if(pdgl_avi_encloop<=0)
		{
			thThread(BGBBTJ_AVI_EncoderLoop, NULL);
			thSleep(10);
		}
	}

	if(pdgl_avi_cap)
	{
		pdgl_avi_cap->accDt+=dt;
		pdgl_avi_cap->accDt2+=dt;

//		if(t>(1.0/pdgl_avi_cap->fps))
		if(pdgl_avi_cap->accDt>=(1.0/pdgl_avi_cap->fps))
		{
			BGBBTJ_AVI_Screenshot();
//			t-=1.0/pdgl_avi_cap->fps;

//			pdgl_avi_cap->accDt=0;

			while(pdgl_avi_cap->accDt>=(1.0/pdgl_avi_cap->fps))
				pdgl_avi_cap->accDt-=1.0/pdgl_avi_cap->fps;

			//lag, drop frame
//			while(t>(1.0/(2*pdgl_avi_cap->fps)))
//				t-=1.0/pdgl_avi_cap->fps;
		}
//		pdgl_avi_cap->accDt+=dt;
//		t+=dt;
	}

	return(0);
}

BGBBTJ_API int BGBBTJ_AVI_NoCapture()
{
	if(pdgl_avi_cap)
	{
		pdgl_avi_cap->capReqClose=1;
	}

#if 0
	if(pdgl_avi_cap)
	{
		BGBBTJ_AVI_CloseOutStream(pdgl_avi_cap);
		pdgl_avi_cap=NULL;
		pdgl_avi_nbase=0;
		pdgl_avi_nseq=0;
	}
#endif
}

#endif


BGBBTJ_API int BGBBTJ_Tex_Resample(
	byte *src, int iw, int ih,
	byte *dst, int ow, int oh)
{
	float xs, ys, xc, yc;
	float ix, iy, fx, fy, fxn, fyn;
	float fxya, fxyb, fxyc, fxyd;
	int i, j, k, l, ik, il;
	int la, lb, lc, ld, iw4;

//	return(0);

	xs=((float)iw/(float)ow);
	ys=((float)ih/(float)oh);
	iw4=iw*4;

	for(i=0; i<oh; i++)
	{
		iy=i*ys;
		ik=iy; fy=iy-ik; fyn=1-fy;

		for(j=0; j<ow; j++)
		{
			ix=j*xs;
			il=ix; fx=ix-il;
			l=(ik*iw+il)*4;
			fxn=1-fx;

			fxya=fxn*fyn;	fxyb=fx*fyn;
			fxyc=fxn*fy;	fxyd=fx*fy;
			la=l;			lb=l+4;
			lc=l+iw4;		ld=l+iw4+4;

			for(k=0; k<4; k++)
				dst[k]=
					src[la+k]*fxya+
					src[lb+k]*fxyb+
					src[lc+k]*fxyc+
					src[ld+k]*fxyd;
			dst+=4;
		}
	}
	return(0);
}


BGBBTJ_API int BGBBTJ_Tex_SplinePolateRGBA8(byte *src, int w, int h,
	float x, float y, float *rgba)
{
	float tv[16], tva[4], tvb[4], tvc[4], tvd[4];
	double f, g, xf, yf, xg, yg;
	int i, j, k, l, xi, yi;
	int xi0, xi1, xi2, xi3;
	int yi0, yi1, yi2, yi3;

//	if(x<0)x=0; if(x>w)x=w;
//	if(y<0)y=0; if(y>h)y=h;

	xi=floor(x); yi=floor(y);
	xf=x-xi; yf=y-yi; xg=1-xf; yg=1-yf;

#if 0
	if((xi<1) || (xi>=(w-2)) || (yi<1) || (yi>=(h-2)))
	{
		if((xi>=(w-1)) || (yi>=(h-1)))
		{
			//far border, LERP not possible

			if((xi>=(w-1)) && (yi>=(h-1)))
			{
				k=((y-1)*w+(x-1))*4;
				rgba[0]=src[k+0]; rgba[1]=src[k+1];
				rgba[2]=src[k+2]; rgba[3]=src[k+3];
				return(0);
				//lowest corner
			}

			//at borders, use nearest pixel
			//FIX: could use H/V split here
			i=xi; j=yi;
			if(xi>=w)xi=w-1;
			if(yi>=y)yi=h-1;

			k=(j*w+i)*4;
			rgba[0]=src[k+0]; rgba[1]=src[k+1];
			rgba[2]=src[k+2]; rgba[3]=src[k+3];
			return(0);
		}

		//near edges, use LERP
		for(k=0; k<4; k++)
		{
			tv[0]=src[((yi  )*w+xi  )*4+k];
			tv[1]=src[((yi  )*w+xi+1)*4+k];
			tv[2]=src[((yi+1)*w+xi  )*4+k];
			tv[3]=src[((yi+1)*w+xi+1)*4+k];

			rgba[k]=tv[0]*xg*yg+tv[1]*xf*yg+
				tv[2]*xg*yf+tv[3]*xf*yf;
		}
		return(0);
	}

	for(k=0; k<4; k++)
	{
		tv[ 0]=src[((yi-1)*w+xi-1)*4+k];
		tv[ 1]=src[((yi-1)*w+xi  )*4+k];
		tv[ 2]=src[((yi-1)*w+xi+1)*4+k];
		tv[ 3]=src[((yi-1)*w+xi+2)*4+k];
		tv[ 4]=src[((yi  )*w+xi-1)*4+k];
		tv[ 5]=src[((yi  )*w+xi  )*4+k];
		tv[ 6]=src[((yi  )*w+xi+1)*4+k];
		tv[ 7]=src[((yi  )*w+xi+2)*4+k];
		tv[ 8]=src[((yi+1)*w+xi-1)*4+k];
		tv[ 9]=src[((yi+1)*w+xi  )*4+k];
		tv[10]=src[((yi+1)*w+xi+1)*4+k];
		tv[11]=src[((yi+1)*w+xi+2)*4+k];
		tv[12]=src[((yi+2)*w+xi-1)*4+k];
		tv[13]=src[((yi+2)*w+xi  )*4+k];
		tv[14]=src[((yi+2)*w+xi+1)*4+k];
		tv[15]=src[((yi+2)*w+xi+2)*4+k];

		tva[0]=tv[ 1]+xf*(tv[ 1]-tv[ 0]);
		tva[1]=tv[ 5]+xf*(tv[ 5]-tv[ 4]);
		tva[2]=tv[ 9]+xf*(tv[ 9]-tv[ 8]);
		tva[3]=tv[13]+xf*(tv[13]-tv[12]);

		tvb[0]=tv[ 2]+xg*(tv[ 2]-tv[ 3]);
		tvb[1]=tv[ 6]+xg*(tv[ 6]-tv[ 7]);
		tvb[2]=tv[10]+xg*(tv[10]-tv[11]);
		tvb[3]=tv[14]+xg*(tv[14]-tv[15]);

		tvc[0]=tv[ 4]+yf*(tv[ 4]-tv[ 0]);
		tvc[1]=tv[ 5]+yf*(tv[ 5]-tv[ 1]);
		tvc[2]=tv[ 6]+yf*(tv[ 6]-tv[ 2]);
		tvc[3]=tv[ 7]+yf*(tv[ 7]-tv[ 3]);

		tvd[0]=tv[ 8]+yg*(tv[ 8]-tv[12]);
		tvd[1]=tv[ 9]+yg*(tv[ 9]-tv[13]);
		tvd[2]=tv[10]+yg*(tv[10]-tv[14]);
		tvd[3]=tv[11]+yg*(tv[11]-tv[15]);


		tva[0]=tva[0]*xg+tvb[0]*xf;
		tva[1]=tva[1]*xg+tvb[1]*xf;
		tva[2]=tva[2]*xg+tvb[2]*xf;
		tva[3]=tva[3]*xg+tvb[3]*xf;

		tvb[0]=tvc[0]*yg+tvd[0]*yf;
		tvb[1]=tvc[1]*yg+tvd[1]*yf;
		tvb[2]=tvc[2]*yg+tvd[2]*yf;
		tvb[3]=tvc[3]*yg+tvd[3]*yf;

		tvc[0]=tva[1]+yf*(tva[1]-tva[0]);
		tvc[1]=tva[2]+yg*(tva[2]-tva[3]);
		tvc[2]=tvb[1]+xf*(tvb[1]-tvb[0]);
		tvc[3]=tvb[2]+xg*(tvb[2]-tvb[3]);

//		f=xf-0.5; g=yf-0.5;
//		g=1.0-(xf*xf+yf*yf);

		f=(tvc[0]*yg+tvc[1]*yf+
		   tvc[2]*xg+tvc[3]*xf)*0.5;

		rgba[k]=f;


//		f=tva[1]+yf*(tva[1]-tva[0]);
//		g=tva[2]+yg*(tva[2]-tva[3]);
//		rgba[k]=f*yg+g*yf;
	}
#endif

	xi0=xi-1; xi1=xi; xi2=xi+1; xi3=xi+2;
	yi0=yi-1; yi1=yi; yi2=yi+1; yi3=yi+2;

	if((xi<1) || (xi>=(w-2)) || (yi<1) || (yi>=(h-2)))
	{
		while(xi0<0)xi0+=w; while(xi0>=w)xi0-=w;
		while(xi1<0)xi1+=w; while(xi1>=w)xi1-=w;
		while(xi2<0)xi2+=w; while(xi2>=w)xi2-=w;
		while(xi3<0)xi3+=w; while(xi3>=w)xi3-=w;

		while(yi0<0)yi0+=h; while(yi0>=h)yi0-=h;
		while(yi1<0)yi1+=h; while(yi1>=h)yi1-=h;
		while(yi2<0)yi2+=h; while(yi2>=h)yi2-=h;
		while(yi3<0)yi3+=h; while(yi3>=h)yi3-=h;
	}

	for(k=0; k<4; k++)
	{
		tv[ 0]=src[(yi0*w+xi0)*4+k];
		tv[ 1]=src[(yi0*w+xi1)*4+k];
		tv[ 2]=src[(yi0*w+xi2)*4+k];
		tv[ 3]=src[(yi0*w+xi3)*4+k];
		tv[ 4]=src[(yi1*w+xi0)*4+k];
		tv[ 5]=src[(yi1*w+xi1)*4+k];
		tv[ 6]=src[(yi1*w+xi2)*4+k];
		tv[ 7]=src[(yi1*w+xi3)*4+k];
		tv[ 8]=src[(yi2*w+xi0)*4+k];
		tv[ 9]=src[(yi2*w+xi1)*4+k];
		tv[10]=src[(yi2*w+xi2)*4+k];
		tv[11]=src[(yi2*w+xi3)*4+k];
		tv[12]=src[(yi3*w+xi0)*4+k];
		tv[13]=src[(yi3*w+xi1)*4+k];
		tv[14]=src[(yi3*w+xi2)*4+k];
		tv[15]=src[(yi3*w+xi3)*4+k];

		tva[0]=tv[ 1]+xf*(tv[ 1]-tv[ 0]);
		tva[1]=tv[ 5]+xf*(tv[ 5]-tv[ 4]);
		tva[2]=tv[ 9]+xf*(tv[ 9]-tv[ 8]);
		tva[3]=tv[13]+xf*(tv[13]-tv[12]);

		tvb[0]=tv[ 2]+xg*(tv[ 2]-tv[ 3]);
		tvb[1]=tv[ 6]+xg*(tv[ 6]-tv[ 7]);
		tvb[2]=tv[10]+xg*(tv[10]-tv[11]);
		tvb[3]=tv[14]+xg*(tv[14]-tv[15]);

		tvc[0]=tv[ 4]+yf*(tv[ 4]-tv[ 0]);
		tvc[1]=tv[ 5]+yf*(tv[ 5]-tv[ 1]);
		tvc[2]=tv[ 6]+yf*(tv[ 6]-tv[ 2]);
		tvc[3]=tv[ 7]+yf*(tv[ 7]-tv[ 3]);

		tvd[0]=tv[ 8]+yg*(tv[ 8]-tv[12]);
		tvd[1]=tv[ 9]+yg*(tv[ 9]-tv[13]);
		tvd[2]=tv[10]+yg*(tv[10]-tv[14]);
		tvd[3]=tv[11]+yg*(tv[11]-tv[15]);


		tva[0]=tva[0]*xg+tvb[0]*xf;
		tva[1]=tva[1]*xg+tvb[1]*xf;
		tva[2]=tva[2]*xg+tvb[2]*xf;
		tva[3]=tva[3]*xg+tvb[3]*xf;

		tvb[0]=tvc[0]*yg+tvd[0]*yf;
		tvb[1]=tvc[1]*yg+tvd[1]*yf;
		tvb[2]=tvc[2]*yg+tvd[2]*yf;
		tvb[3]=tvc[3]*yg+tvd[3]*yf;

		tvc[0]=tva[1]+yf*(tva[1]-tva[0]);
		tvc[1]=tva[2]+yg*(tva[2]-tva[3]);
		tvc[2]=tvb[1]+xf*(tvb[1]-tvb[0]);
		tvc[3]=tvb[2]+xg*(tvb[2]-tvb[3]);

//		f=xf-0.5; g=yf-0.5;
//		g=1.0-(xf*xf+yf*yf);

		f=(tvc[0]*yg+tvc[1]*yf+
		   tvc[2]*xg+tvc[3]*xf)*0.5;

		rgba[k]=f;


//		f=tva[1]+yf*(tva[1]-tva[0]);
//		g=tva[2]+yg*(tva[2]-tva[3]);
//		rgba[k]=f*yg+g*yf;
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_Tex_ResampleSpline(byte *src, int iw, int ih, byte *dst, int ow, int oh)
{
	float tv[4];
	float xs, ys, xc, yc;
	float ix, iy, fx, fy;
	int i, j, k, l, ik, il;

//	return(0);

	xs=((float)iw/(float)ow);
	ys=((float)ih/(float)oh);

	for(i=0; i<oh; i++)
		for(j=0; j<ow; j++)
	{
		BGBBTJ_Tex_SplinePolateRGBA8(src, iw, ih, j*xs, i*ys, tv);
		k=tv[0]; if(k<0)k=0; if(k>255)k=255; dst[0]=k;
		k=tv[1]; if(k<0)k=0; if(k>255)k=255; dst[1]=k;
		k=tv[2]; if(k<0)k=0; if(k>255)k=255; dst[2]=k;
		k=tv[3]; if(k<0)k=0; if(k>255)k=255; dst[3]=k;

		dst+=4;
	}
	return(0);
}

#if 1
BGBBTJ_API int BGBBTJ_Tex_HalfSample(byte *src, int w, int h)
{
	int w2, h2, i2, j2;
	int a1, a2, a3, a4;
	int af1, af2, af3, af4;
	int i, j, k;

	w2=w>>1;
	h2=h>>1;
	for(i=0;i<h2; i++)
		for(j=0; j<w2; j++)
	{
		i2=i<<1;
		j2=j<<1;

		a1=src[((i2*w+j2)<<2)+3];
		a2=src[((i2*w+(j2+1))<<2)+3];
		a3=src[(((i2+1)*w+j2)<<2)+3];
		a4=src[(((i2+1)*w+(j2+1))<<2)+3];

		k=a1+a2+a3+a4;
		if(!k || (k==1020))
		{
//			af1=1023;
//			af2=1023;
//			af3=1023;
//			af4=1023;

			af1=1024;
			af2=1024;
			af3=1024;
			af4=1024;
		}else
		{
//			af1=(4095*a1)/k;
//			af2=(4095*a2)/k;
//			af3=(4095*a3)/k;
//			af4=(4095*a4)/k;

			af1=(4096*a1)/k;
			af2=(4096*a2)/k;
			af3=(4096*a3)/k;
			af4=(4096*a4)/k;
		}
		
		src[((i*w2+j)<<2)+0]=
			(src[((i2*w+j2)<<2)+0]*af1+
			src[((i2*w+(j2+1))<<2)+0]*af2+
			src[(((i2+1)*w+j2)<<2)+0]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+0]*af4)>>12;

		src[((i*w2+j)<<2)+1]=
			(src[((i2*w+j2)<<2)+1]*af1+
			src[((i2*w+(j2+1))<<2)+1]*af2+
			src[(((i2+1)*w+j2)<<2)+1]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+1]*af4)>>12;

		src[((i*w2+j)<<2)+2]=
			(src[((i2*w+j2)<<2)+2]*af1+
			src[((i2*w+(j2+1))<<2)+2]*af2+
			src[(((i2+1)*w+j2)<<2)+2]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+2]*af4)>>12;

		src[((i*w2+j)<<2)+3]=
			(src[((i2*w+j2)<<2)+3]*af1+
			src[((i2*w+(j2+1))<<2)+3]*af2+
			src[(((i2+1)*w+j2)<<2)+3]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+3]*af4)>>12;
	}
	return(0);
}
#endif

#if 1
BGBBTJ_API int BGBBTJ_Tex_HalfSampleDest(
	byte *src, byte *dst, int w, int h)
{
	int w2, h2, i2, j2;
	int a1, a2, a3, a4;
	int af1, af2, af3, af4;
	int i, j, k;

	w2=w>>1;
	h2=h>>1;
	for(i=0;i<h2; i++)
		for(j=0; j<w2; j++)
	{
		i2=i<<1;
		j2=j<<1;

		a1=src[((i2*w+j2)<<2)+3];
		a2=src[((i2*w+(j2+1))<<2)+3];
		a3=src[(((i2+1)*w+j2)<<2)+3];
		a4=src[(((i2+1)*w+(j2+1))<<2)+3];

		k=a1+a2+a3+a4;
		if(!k || (k==1020))
		{
//			af1=1023;
//			af2=1023;
//			af3=1023;
//			af4=1023;

			af1=1024;
			af2=1024;
			af3=1024;
			af4=1024;
		}else
		{
//			af1=(4095*a1)/k;
//			af2=(4095*a2)/k;
//			af3=(4095*a3)/k;
//			af4=(4095*a4)/k;

			af1=(4096*a1)/k;
			af2=(4096*a2)/k;
			af3=(4096*a3)/k;
			af4=(4096*a4)/k;
		}
		
		dst[((i*w2+j)<<2)+0]=
			(src[((i2*w+j2)<<2)+0]*af1+
			src[((i2*w+(j2+1))<<2)+0]*af2+
			src[(((i2+1)*w+j2)<<2)+0]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+0]*af4)>>12;

		dst[((i*w2+j)<<2)+1]=
			(src[((i2*w+j2)<<2)+1]*af1+
			src[((i2*w+(j2+1))<<2)+1]*af2+
			src[(((i2+1)*w+j2)<<2)+1]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+1]*af4)>>12;

		dst[((i*w2+j)<<2)+2]=
			(src[((i2*w+j2)<<2)+2]*af1+
			src[((i2*w+(j2+1))<<2)+2]*af2+
			src[(((i2+1)*w+j2)<<2)+2]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+2]*af4)>>12;

		dst[((i*w2+j)<<2)+3]=
			(src[((i2*w+j2)<<2)+3]*af1+
			src[((i2*w+(j2+1))<<2)+3]*af2+
			src[(((i2+1)*w+j2)<<2)+3]*af3+
			src[(((i2+1)*w+(j2+1))<<2)+3]*af4)>>12;
	}
	return(0);
}
#endif


#if 1
BGBBTJ_API int BGBBTJ_DoubleSample_InterpolatePoint(byte *src,
	int w, int h, int pt)
{
	int ha, hb;
	int va, vb;

	switch(pt)
	{
	case 0:
		ha=192; hb= 64;
		va=192; vb= 64;
		break;
	case 1:
		ha= 64; hb=192;
		va=192; vb= 64;
		break;
	case 2:
		ha=192; hb= 64;
		va= 64; vb=192;
		break;
	case 3:
		ha= 64; hb=192;
		va= 64; vb=192;
		break;
	}
	
	return(BGBBTJ_DoubleSample_InterpolateWeightPoint(src, w, h, hb, vb));
}

BGBBTJ_API int BGBBTJ_DoubleSample_InterpolateWeightPoint(byte *src,
	int w, int h, int hf, int vf)
{
	int r00, r01, r02, r03;
	int r10, r11, r12, r13;
	int r20, r21, r22, r23;
	int r30, r31, r32, r33;

	int s00, s01, s02, s03;
	int s10, s11, s12, s13;
	int s20, s21, s22, s23;
	int s30, s31, s32, s33;

//	int l11, l12, l13;
//	int l21, l22, l23;
//	int l31, l32, l33;
	int p0a, p0b, p0c, p0d;
	int p1a, p1b, p1c, p1d;
	int p2a, p2b, p2c, p2d;
	int p3a, p3b, p3c, p3d;

	int l0a, l0b, l0c, l0d;
	int l1a, l1b, l1c, l1d;

	int q0a, q0b, q0c, q0d;
	int q1a, q1b, q1c, q1d;
	
	int ha, hb;
	int va, vb;
	int p;

	ha=256-hf; hb=hf;
	va=256-vf; vb=vf;

	r00=src[((-1)*w+(-1))*4];	r01=src[((-1)*w+( 0))*4];
	r02=src[((-1)*w+( 1))*4];	r03=src[((-1)*w+( 2))*4];
	r10=src[(( 0)*w+(-1))*4];	r11=src[(( 0)*w+( 0))*4];
	r12=src[(( 0)*w+( 1))*4];	r13=src[(( 0)*w+( 2))*4];
	r20=src[(( 1)*w+(-1))*4];	r21=src[(( 1)*w+( 0))*4];
	r22=src[(( 1)*w+( 1))*4];	r23=src[(( 1)*w+( 2))*4];
	r30=src[(( 2)*w+(-1))*4];	r31=src[(( 2)*w+( 0))*4];
	r32=src[(( 2)*w+( 1))*4];	r33=src[(( 2)*w+( 2))*4];

#if 0
//	s00=(11*r00+2*r01+2*r10+r11+8)>>4;

//	s11=(11*r11+2*r01+2*r10+r00+8)>>4;
//	s12=(11*r12+2*r02+2*r13+r03+8)>>4;

//	s11=(2*r00+5*r01+2*r02+5*r10+32*r11+5*r12+2*r20+5*r21+2*r22+32)>>6;
//	s12=(2*r01+5*r02+2*r03+5*r11+32*r12+5*r13+2*r21+5*r22+2*r23+32)>>6;
//	s21=(2*r10+5*r11+2*r12+5*r20+32*r21+5*r22+2*r30+5*r31+2*r32+32)>>6;
//	s22=(2*r11+5*r12+2*r13+5*r21+32*r22+5*r23+2*r31+5*r32+2*r33+32)>>6;

//	s11=(1*r00+4*r01+1*r02+4*r10+40*r11+4*r12+1*r20+4*r21+1*r22+32)>>6;
//	s12=(1*r01+4*r02+1*r03+4*r11+40*r12+4*r13+1*r21+4*r22+1*r23+32)>>6;
//	s21=(1*r10+4*r11+1*r12+4*r20+40*r21+4*r22+1*r30+4*r31+1*r32+32)>>6;
//	s22=(1*r11+4*r12+1*r13+4*r21+40*r22+4*r23+1*r31+4*r32+1*r33+32)>>6;

//	s11=(1*r00+4*r01+1*r02+4*r10+44*r11+4*r12+1*r20+4*r21+1*r22+32)>>6;
//	s12=(1*r01+4*r02+1*r03+4*r11+44*r12+4*r13+1*r21+4*r22+1*r23+32)>>6;
//	s21=(1*r10+4*r11+1*r12+4*r20+44*r21+4*r22+1*r30+4*r31+1*r32+32)>>6;
//	s22=(1*r11+4*r12+1*r13+4*r21+44*r22+4*r23+1*r31+4*r32+1*r33+32)>>6;

//	s11=(4*r01+4*r10+48*r11+4*r12+4*r21+32)>>6;
//	s12=(4*r02+4*r11+48*r12+4*r13+4*r22+32)>>6;
//	s21=(4*r11+4*r20+48*r21+4*r22+4*r31+32)>>6;
//	s22=(4*r12+4*r21+48*r22+4*r23+4*r32+32)>>6;

	s11=(2*r01+2*r10+56*r11+2*r12+2*r21+32)>>6;
	s12=(2*r02+2*r11+56*r12+2*r13+2*r22+32)>>6;
	s21=(2*r11+2*r20+56*r21+2*r22+2*r31+32)>>6;
	s22=(2*r12+2*r21+56*r22+2*r23+2*r32+32)>>6;

	r11=s11;	r12=s12;
	r21=s22;	r22=s21;
#endif

	l0a=r10+r01-r00;
	l0b=r13+r02-r03;
	l0c=r20+r31-r30;
	l0d=r23+r32-r33;
	
//	l1a=(l0a+r11)>>1;
//	l1b=(l0b+r12)>>1;
//	l1c=(l0c+r21)>>1;
//	l1d=(l0d+r22)>>1;

//	l1a=(5*l0a+11*r11)>>4;
//	l1b=(5*l0b+11*r12)>>4;
//	l1c=(5*l0c+11*r21)>>4;
//	l1d=(5*l0d+11*r22)>>4;

//	l1a=(3*l0a+13*r11+8)>>4;
//	l1b=(3*l0b+13*r12+8)>>4;
//	l1c=(3*l0c+13*r21+8)>>4;
//	l1d=(3*l0d+13*r22+8)>>4;

#if 1
	l1a=2*r11-l0a;
	l1b=2*r12-l0b;
	l1c=2*r21-l0c;
	l1d=2*r22-l0d;

	l1a=(5*l1a+11*r11+8)>>4;
	l1b=(5*l1b+11*r12+8)>>4;
	l1c=(5*l1c+11*r21+8)>>4;
	l1d=(5*l1d+11*r22+8)>>4;

//	l1a=(3*l1a+13*r11+8)>>4;
//	l1b=(3*l1b+13*r12+8)>>4;
//	l1c=(3*l1c+13*r21+8)>>4;
//	l1d=(3*l1d+13*r22+8)>>4;
#endif

//	l1a=(2*l0a+14*r11+8)>>4;
//	l1b=(2*l0b+14*r12+8)>>4;
//	l1c=(2*l0c+14*r21+8)>>4;
//	l1d=(2*l0d+14*r22+8)>>4;

//	l1a=(1*l0a+15*r11+8)>>4;
//	l1b=(1*l0b+15*r12+8)>>4;
//	l1c=(1*l0c+15*r21+8)>>4;
//	l1d=(1*l0d+15*r22+8)>>4;

//	l1a=(1*l0a+63*r11+32)>>6;
//	l1b=(1*l0b+63*r12+32)>>6;
//	l1c=(1*l0c+63*r21+32)>>6;
//	l1d=(1*l0d+63*r22+32)>>6;
	
//	l0a=BGBBTJ_BufPNG_Paeth(r10, r01, r00);
//	l0b=BGBBTJ_BufPNG_Paeth(r13, r02, r03);
//	l0c=BGBBTJ_BufPNG_Paeth(r20, r31, r30);
//	l0d=BGBBTJ_BufPNG_Paeth(r23, r32, r33);

#if 0
	q0a=2*r11-r10;
	q0b=2*r12-r13;
	q0c=2*r21-r20;
	q0d=2*r22-r23;

	q1a=2*r11-r01;
	q1b=2*r12-r02;
	q1c=2*r21-r31;
	q1d=2*r22-r32;
#endif

#if 1
	q0a=2*l1a-r10;
	q0b=2*l1b-r13;
	q0c=2*l1c-r20;
	q0d=2*l1d-r23;

	q1a=2*l1a-r01;
	q1b=2*l1b-r02;
	q1c=2*l1c-r31;
	q1d=2*l1d-r32;
#endif

//	p0a=(hb*q0a+ha*r11)>>2;
//	p0b=(ha*q0b+hb*r12)>>2;
//	p0c=(hb*q0c+ha*r21)>>2;
//	p0d=(ha*q0d+hb*r22)>>2;

//	p1a=(vb*q1a+va*r11)>>2;
//	p1b=(va*q1b+vb*r12)>>2;
//	p1c=(vb*q1c+va*r21)>>2;
//	p1d=(va*q1d+vb*r22)>>2;

#if 0
	p0a=(hb*q0a+ha*l0a+128)>>8;
	p0b=(ha*q0b+hb*l0b+128)>>8;
	p0c=(hb*q0c+ha*l0c+128)>>8;
	p0d=(ha*q0d+hb*l0d+128)>>8;

	p1a=(vb*q1a+va*l0a+128)>>8;
	p1b=(va*q1b+vb*l0b+128)>>8;
	p1c=(vb*q1c+va*l0c+128)>>8;
	p1d=(va*q1d+vb*l0d+128)>>8;
#endif

#if 1
	p0a=(hb*q0a+ha*l1a+128)>>8;
	p0b=(ha*q0b+hb*l1b+128)>>8;
	p0c=(hb*q0c+ha*l1c+128)>>8;
	p0d=(ha*q0d+hb*l1d+128)>>8;

	p1a=(vb*q1a+va*l1a+128)>>8;
	p1b=(va*q1b+vb*l1b+128)>>8;
	p1c=(vb*q1c+va*l1c+128)>>8;
	p1d=(va*q1d+vb*l1d+128)>>8;
#endif

	p2a=(ha*p0a+hb*p0b+128)>>8;
	p2b=(ha*p0c+hb*p0d+128)>>8;
	p2c=(ha*p1a+hb*p1b+128)>>8;
	p2d=(ha*p1c+hb*p1d+128)>>8;
		
	p3a=(va*p2a+vb*p2b+128)>>8;
	p3b=(va*p2c+vb*p2d+128)>>8;
	
	p=(p3a+p3b)>>1;
	if(p<0)p=0;
	if(p>255)p=255;
	return(p);
}

BGBBTJ_API int BGBBTJ_DoubleSample_SoftenPoint(byte *src,
	int w, int h)
{
	int r00, r01, r02;
	int r10, r11, r12;
	int r20, r21, r22;

//	int s00, s01, s02;
//	int s10, s11, s12;
//	int s20, s21, s22;

	int p;

	r00=src[((-1)*w+(-1))*4];	r01=src[((-1)*w+( 0))*4];
	r02=src[((-1)*w+( 1))*4];
	r10=src[(( 0)*w+(-1))*4];	r11=src[(( 0)*w+( 0))*4];
	r12=src[(( 0)*w+( 1))*4];
	r20=src[(( 1)*w+(-1))*4];	r21=src[(( 1)*w+( 0))*4];
	r22=src[(( 1)*w+( 1))*4];

//	p=(1*r00+4*r01+1*r02+4*r10+44*r11+4*r12+1*r20+4*r21+1*r22+32)>>6;
	p=(1*r00+3*r01+1*r02+3*r10+48*r11+3*r12+1*r20+3*r21+1*r22+32)>>6;
//	p=(2*r01+2*r10+56*r11+2*r12+2*r21+32)>>6;

	if(p<0)p=0;
	if(p>255)p=255;
	return(p);
}

int BGBBTJ_DoubleSample_DoublePoint(
	byte *src, byte *dst, int w, int h)
{
	int r, g, b, a;
	
	r=src[0];	g=src[1];
	b=src[2];	a=src[3];
	
	dst[0]=r;	dst[1]=g;
	dst[2]=b;	dst[3]=a;
	dst[4]=r;	dst[5]=g;
	dst[6]=b;	dst[7]=a;

	dst[w*4+0]=r;	dst[w*4+1]=g;
	dst[w*4+2]=b;	dst[w*4+3]=a;
	dst[w*4+4]=r;	dst[w*4+5]=g;
	dst[w*4+6]=b;	dst[w*4+7]=a;
	return(0);
}

BGBBTJ_API int BGBBTJ_Tex_DoubleSample(byte *src, byte *dst, int w, int h)
{
	static byte *tsrc=NULL;
	static byte *tdst=NULL;
	int w2, h2, i2, j2;
//	int a1, a2, a3, a4;
//	int af1, af2, af3, af4;
	int r0, r1, r2, r3;
	int g0, g1, g2, g3;
	int b0, b1, b2, b3;
	int a0, a1, a2, a3;
	int i, j, k;

	w2=w*2;
	h2=h*2;

	if(!tsrc)
		{ tsrc=malloc(w*h*4); }
	if(!tdst)
		{ tdst=malloc(w2*h2*4); }

#if 1
	for(i=0; i<h; i++)
	{
		for(j=0; j<4; j++)
		{
			BGBBTJ_DoubleSample_DoublePoint(
				src+((i*w+j)*4),
				dst+(((i*2)*w2+(j*2))*4),
				w2, h2);
		}

		for(j=w-4; j<w; j++)
		{
			BGBBTJ_DoubleSample_DoublePoint(
				src+((i*w+j)*4),
				dst+(((i*2)*w2+(j*2))*4),
				w2, h2);
		}
	}

	for(j=0; j<w; j++)
	{
		for(i=0; i<4; i++)
		{
			BGBBTJ_DoubleSample_DoublePoint(
				src+((i*w+j)*4),
				dst+(((i*2)*w2+(j*2))*4),
				w2, h2);
		}

		for(i=h-4; i<h; i++)
		{
			BGBBTJ_DoubleSample_DoublePoint(
				src+((i*w+j)*4),
				dst+(((i*2)*w2+(j*2))*4),
				w2, h2);
		}
	}
#endif

#if 0
	for(i=0; i<h; i++)
		for(j=0; j<w; j++)
	{
		i2=i<<1;
		j2=j<<1;
		
		r0=src[((i*w+j)*4)+0];
		g0=src[((i*w+j)*4)+1];
		b0=src[((i*w+j)*4)+2];
		a0=src[((i*w+j)*4)+3];

		dst[(((i*2+0)*w2+(j*2+0))*4)+0]=r0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+0]=r0;
		dst[(((i*2+1)*w2+(j*2+0))*4)+0]=r0;
		dst[(((i*2+1)*w2+(j*2+1))*4)+0]=r0;

		dst[(((i*2+0)*w2+(j*2+0))*4)+1]=g0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+1]=g0;
		dst[(((i*2+1)*w2+(j*2+0))*4)+1]=g0;
		dst[(((i*2+1)*w2+(j*2+1))*4)+1]=g0;

		dst[(((i*2+0)*w2+(j*2+0))*4)+2]=b0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+2]=b0;
		dst[(((i*2+1)*w2+(j*2+0))*4)+2]=b0;
		dst[(((i*2+1)*w2+(j*2+1))*4)+2]=b0;

		dst[(((i*2+0)*w2+(j*2+0))*4)+3]=a0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+3]=a0;
		dst[(((i*2+1)*w2+(j*2+0))*4)+3]=a0;
		dst[(((i*2+1)*w2+(j*2+1))*4)+3]=a0;
	}
#endif

#if 1
	for(i=1; i<(h-1); i++)
		for(j=1; j<(w-1); j++)
	{
//		r0=src[(((i-1)*w+j)*4)+0];
		r0=BGBBTJ_DoubleSample_SoftenPoint(src+(i*w+j)*4+0, w, h);
		g0=BGBBTJ_DoubleSample_SoftenPoint(src+(i*w+j)*4+1, w, h);
		b0=BGBBTJ_DoubleSample_SoftenPoint(src+(i*w+j)*4+2, w, h);
		tsrc[(i*w+j)*4+0]=r0;
		tsrc[(i*w+j)*4+1]=g0;
		tsrc[(i*w+j)*4+2]=b0;
	}
#endif

	for(i=1; i<(h-2); i++)
		for(j=1; j<(w-2); j++)
	{
		i2=i<<1;
		j2=j<<1;

//		a1=src[(((i+0)*w+(j+0))*4)+3];
//		a2=src[(((i+0)*w+(j+1))*4)+3];
//		a3=src[(((i+1)*w+(j+0))*4)+3];
//		a4=src[(((i+1)*w+(j+1))*4)+3];

		a0=src[((i*w+j)*4)+3];	a1=a0;
		a2=a0; a3=a1;

#if 0
		r0=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+0, w, h, 0);
		r1=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+0, w, h, 1);
		r2=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+0, w, h, 2);
		r3=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+0, w, h, 3);
		g0=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+1, w, h, 0);
		g1=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+1, w, h, 1);
		g2=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+1, w, h, 2);
		g3=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+1, w, h, 3);
		b0=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+2, w, h, 0);
		b1=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+2, w, h, 1);
		b2=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+2, w, h, 2);
		b3=BGBBTJ_DoubleSample_InterpolatePoint(src+(i*w+j)*4+2, w, h, 3);
#endif

#if 1
		r0=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+0, w, h, 0);
		r1=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+0, w, h, 1);
		r2=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+0, w, h, 2);
		r3=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+0, w, h, 3);
		g0=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+1, w, h, 0);
		g1=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+1, w, h, 1);
		g2=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+1, w, h, 2);
		g3=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+1, w, h, 3);
		b0=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+2, w, h, 0);
		b1=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+2, w, h, 1);
		b2=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+2, w, h, 2);
		b3=BGBBTJ_DoubleSample_InterpolatePoint(tsrc+(i*w+j)*4+2, w, h, 3);
#endif

		dst[(((i*2+0)*w2+(j*2+0))*4)+0]=r0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+0]=r1;
		dst[(((i*2+1)*w2+(j*2+0))*4)+0]=r2;
		dst[(((i*2+1)*w2+(j*2+1))*4)+0]=r3;

		dst[(((i*2+0)*w2+(j*2+0))*4)+1]=g0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+1]=g1;
		dst[(((i*2+1)*w2+(j*2+0))*4)+1]=g2;
		dst[(((i*2+1)*w2+(j*2+1))*4)+1]=g3;

		dst[(((i*2+0)*w2+(j*2+0))*4)+2]=b0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+2]=b1;
		dst[(((i*2+1)*w2+(j*2+0))*4)+2]=b2;
		dst[(((i*2+1)*w2+(j*2+1))*4)+2]=b3;

		dst[(((i*2+0)*w2+(j*2+0))*4)+3]=a0;
		dst[(((i*2+0)*w2+(j*2+1))*4)+3]=a1;
		dst[(((i*2+1)*w2+(j*2+0))*4)+3]=a2;
		dst[(((i*2+1)*w2+(j*2+1))*4)+3]=a3;
	}

#if 1
	for(i=1; i<(h2-1); i++)
		for(j=1; j<(w2-1); j++)
	{
//		r0=src[(((i-1)*w+j)*4)+0];
		r0=BGBBTJ_DoubleSample_SoftenPoint(dst+(i*w2+j)*4+0, w2, h2);
		g0=BGBBTJ_DoubleSample_SoftenPoint(dst+(i*w2+j)*4+1, w2, h2);
		b0=BGBBTJ_DoubleSample_SoftenPoint(dst+(i*w2+j)*4+2, w2, h2);
		tdst[(i*w2+j)*4+0]=r0;
		tdst[(i*w2+j)*4+1]=g0;
		tdst[(i*w2+j)*4+2]=b0;
	}

	for(i=1; i<(h-1); i++)
		for(j=1; j<(w-1); j++)
	{
		r0=tdst[(i*w2+j)*4+0];
		g0=tdst[(i*w2+j)*4+1];
		b0=tdst[(i*w2+j)*4+2];
		dst[(i*w2+j)*4+0]=r0;
		dst[(i*w2+j)*4+1]=g0;
		dst[(i*w2+j)*4+2]=b0;
	}
#endif

	return(0);
}
#endif
/*
load/store pcx files
 */

#include <bgbbtj.h>

struct PcxHead_s {
unsigned char tag;	//0x0A
unsigned char version;	//typically 5
unsigned char encoding; //1=RLE
unsigned char bpp;

unsigned short minx;
unsigned short miny;
unsigned short maxx;
unsigned short maxy;

unsigned short hres;
unsigned short vres;

unsigned char map[48];	//16 color palette

unsigned char resv;	//0
unsigned char planes;	//1
unsigned short linesz;	//bytes per line
unsigned short paltype;	//0=color/bw, 1=greyscale

unsigned char resv2[58];
};

byte *BGBBTJ_PCX_Load(VFILE *fd, int *w, int *h, char *pal)
{
	struct PcxHead_s head;
	unsigned char *buf, *s;
	int i, j, sz;
	unsigned char t;
	int width, height;

	head.tag=vfgetc(fd);

	if(head.tag!=0x0A)
	{
		printf("PCX_LoadPCX: invalid tag\n");
		return(NULL);
	}

	head.version=vfgetc(fd);
	head.encoding=vfgetc(fd);
	if((head.encoding!=0) && (head.encoding!=1))
	{
		printf("PCX_LoadPCX: bad encoding\n");
		return(NULL);
	}

	head.bpp=vfgetc(fd);

	if(head.bpp!=8)
	{
		printf("PCX_LoadPCX: bpp is not 8 bits\n");
		return(NULL);
	}

	head.minx=vfgetc(fd);
	head.minx+=vfgetc(fd)<<8;
	head.miny=vfgetc(fd);
	head.miny+=vfgetc(fd)<<8;
	head.maxx=vfgetc(fd);
	head.maxx+=vfgetc(fd)<<8;
	head.maxy=vfgetc(fd);
	head.maxy+=vfgetc(fd)<<8;

	head.hres=vfgetc(fd);
	head.hres+=vfgetc(fd)<<8;
	head.vres=vfgetc(fd);
	head.vres+=vfgetc(fd)<<8;

	vfread(head.map, 1, 48, fd);

	head.resv=vfgetc(fd);
	head.planes=vfgetc(fd);

	head.linesz=vfgetc(fd);
	head.linesz+=vfgetc(fd)<<8;

	head.paltype=vfgetc(fd);
	head.paltype+=vfgetc(fd)<<8;

	vfread(head.resv2, 1, 58, fd);


	width=(head.maxx-head.minx)+1;
	height=(head.maxy-head.miny)+1;

	if(w)*w=width;
	if(h)*h=height;

	sz=width*height;
	buf=malloc(sz+256);

	if(!head.encoding)
	{
		vfread(buf, 1, sz, fd);
		return(buf);
	}

	s=buf;
	while((s-buf)<sz)
	{
		t=vfgetc(fd);
		if(t>=0xC0)
		{
			j=t&0x3F;
			t=vfgetc(fd);
			while(j--)*s++=t;
		}else *s++=t;
	}

	if(pal)
	{
		vfseek(fd, -769, 2);
		t=vfgetc(fd);
		if(t==12)
			vfread(pal, 1, 768, fd);
	}
	return(buf);
}

byte *BGBBTJ_PCX_Load32(VFILE *fd, int *w, int *h)
{
	unsigned char *buf, *buf2;
	unsigned char pal[768];
	int cw, ch;
	int i;

	buf=BGBBTJ_PCX_Load(fd, &cw, &ch, pal);
	if(!buf)return(NULL);

	if(w)*w=cw;
	if(h)*h=ch;

	buf2=malloc(cw*ch*4);
	for(i=0; i<(cw*ch); i++)
	{
		buf2[(i*4)+0]=pal[(buf[i]*3)+0];
		buf2[(i*4)+1]=pal[(buf[i]*3)+1];
		buf2[(i*4)+2]=pal[(buf[i]*3)+2];
		buf2[(i*4)+3]=255;
	}
	free(buf);

	return(buf2);
}

unsigned char *BGBBTJ_PCX_LoadRaw(char *name, int *w, int *h, char *pal)
{
	VFILE *fd;
	unsigned char *tmp;

	fd=vffopen(name, "rb");
	if(!fd)
	{
		printf("PCX_LoadRaw: can't open '%s'\n", name);
		return(NULL);
	}

	tmp=BGBBTJ_PCX_Load(fd, w, h, pal);
	vfclose(fd);

	return(tmp);
}

int BGBBTJ_PCX_Store(VFILE *fd, unsigned char *img,
	int width, int height, char *pal)
{
	struct PcxHead_s head;
	unsigned char *buf, *s;
	int i, j, l, sz;
	unsigned char t;

	memset(&head, 0, sizeof(head));

	head.tag=0x0A;
	head.version=5;
	head.encoding=1;
	head.bpp=8;

	head.minx=0;
	head.miny=0;
	head.maxx=width-1;
	head.maxy=height-1;

	head.hres=0x500;
	head.vres=0x400;

	head.planes=1;
	head.linesz=width;

	vfputc(head.tag, fd);
	vfputc(head.version, fd);
	vfputc(head.encoding, fd);
	vfputc(head.bpp, fd);

	vfputc(head.minx&0xff, fd);
	vfputc((head.minx>>8)&0xff, fd);
	vfputc(head.miny&0xff, fd);
	vfputc((head.miny>>8)&0xff, fd);

	vfputc(head.maxx&0xff, fd);
	vfputc((head.maxx>>8)&0xff, fd);
	vfputc(head.maxy&0xff, fd);
	vfputc((head.maxy>>8)&0xff, fd);

	vfputc(head.hres&0xff, fd);
	vfputc((head.hres>>8)&0xff, fd);
	vfputc(head.vres&0xff, fd);
	vfputc((head.vres>>8)&0xff, fd);

	vfwrite(head.map, 1, 48, fd);

	vfputc(head.resv, fd);
	vfputc(head.planes, fd);

	vfputc(head.linesz&0xff, fd);
	vfputc((head.linesz>>8)&0xff, fd);

	vfputc(head.paltype&0xff, fd);
	vfputc((head.paltype>>8)&0xff, fd);

	vfwrite(head.resv2, 1, 58, fd);

	sz=width*height;

	buf=img;
	s=buf;
	t=0;
	l=0;

	while((s-buf)<sz)
	{
		if(*s!=t)
		{
			if((l==1) && (t<0xC0))
			{
				vfputc(t, fd);
			}else if(l>0)
			{
				vfputc(0xC0+l, fd);
				vfputc(t, fd);
			}
			l=1;
			t=*s;
			s++;
			continue;
		}
		if(l>=15)
		{
			vfputc(0xC0+l, fd);
			vfputc(t, fd);

			l=1;
			s++;
			continue;
		}
		s++;
		l++;
	}

	if((l==1) && (t<0xC0))
	{
		vfputc(t, fd);
	}else if(l>0)
	{
		vfputc(0xC0+l, fd);
		vfputc(t, fd);
	}

	if(pal)
	{
		vfputc(12, fd);
		vfwrite(pal, 1, 768, fd);
	}else
	{
		vfputc(12, fd);
		for(i=0; i<256; i++)
		{
			vfputc(i, fd);
			vfputc(i, fd);
			vfputc(i, fd);
		}
	}

	return(0);
}

int BGBBTJ_PCX_StoreRaw(char *name, unsigned char *buf,
	int w, int h, char *pal)
{
	VFILE *fd;

	fd=vffopen(name, "wb");
	if(!fd)
	{
		printf("PCX_StoreRaw: can't open '%s'\n", name);
		return(-1);
	}

	BGBBTJ_PCX_Store(fd, buf, w, h, pal);
	vfclose(fd);

	return(0);
}
#include <bgbbtj.h>

#ifndef FOURCC
#define FOURCC(a, b, c, d) ((a)|((b)<<8)|((c)<<16)|((d)<<24))
#endif


#define FCC_PNG_LOW	FOURCC(0x89, 'P', 'N', 'G')
#define FCC_PNG_HIGH	FOURCC(0x0D, 0x0A, 0x1A, 0x0A)

#define FCC_IHDR	FOURCC('I', 'H', 'D', 'R')
#define FCC_IEND	FOURCC('I', 'E', 'N', 'D')
#define FCC_IDAT	FOURCC('I', 'D', 'A', 'T')
#define FCC_PLTE	FOURCC('P', 'L', 'T', 'E')
#define FCC_tRNS	FOURCC('t', 'R', 'N', 'S')

uint BGBBTJ_PNG_DataAdler32(void *buf, int sz, uint lcrc)
{
	byte *s;
	int i, c, s1, s2;

	s=buf;
	s1=lcrc&0xFFFF;
	s2=(lcrc>>16)&0xFFFF;
	for(i=0; i<sz; i++)
	{
		s1=(s1+(s[i]))%65521;
		s2=(s1+s2)%65521;
	}
	return((s2<<16)+s1);
}

uint BGBBTJ_PNG_CRC32(void *buf, int sz, uint lcrc)
{
	static uint crctab[256];
	static int init=0;

	byte *s;
	uint c;
	int i, j;

	if(!init)
	{
		init=1;

		for(i=0; i<256; i++)
		{
			c=i;
			for(j=0; j<8; j++)
				if(c&1)c=0xedb88320^(c>>1);
					else c>>=1;
			crctab[i]=c;
		}
	}

	c=lcrc; s=buf; i=sz;
	while(i--)c=crctab[(c^(*s++))&0xFF]^(c>>8);
	return(c);
}

char *BGBBTJ_PNG_Fourcc2String(uint fcc)
{
	static char buf[64], pos;
	int i, j;

	if(pos>56)pos=0;

	for(i=0; i<4; i++)
	{
		j=(fcc>>(i*8))&0xFF;
		if((j<' ') || (j>'~'))j='~';
		buf[pos+i]=j;
	}
	buf[pos+4]=0;
	return(buf+pos);
}

int BGBBTJ_PNG_Paeth(int a, int b, int c)
{
	int p, pa, pb, pc;

	p=a+b-c;
	pa=(p>a)?(p-a):(a-p);
	pb=(p>b)?(p-b):(b-p);
	pc=(p>c)?(p-c):(c-p);

//	if((pa<=pb) && (pa<=pc))return(a);
//	if(pb<=pc)return(b);
//	return(c);

	p=(pa<=pb)?((pa<=pc)?a:c):((pb<=pc)?b:c);
	return(p);
}

uint BGBBTJ_PNG_ReadInt32BE(VFILE *fd)
{
	uint i;

	i=vfgetc(fd)<<24;
	i|=vfgetc(fd)<<16;
	i|=vfgetc(fd)<<8;
	i|=vfgetc(fd);
	return(i);
}

uint BGBBTJ_PNG_ReadFourcc(VFILE *fd)
{
	uint i;

	i=vfgetc(fd);
	i|=vfgetc(fd)<<8;
	i|=vfgetc(fd)<<16;
	i|=vfgetc(fd)<<24;
	return(i);
}

BGBBTJ_API byte *BGBBTJ_PNG_Load(VFILE *ifd, int *w, int *h)
{
	static byte plte[768], trns[256];
	uint fcc0, fcc1, len, crc, end;
	int xs, ys, bpp, clr, cm, fm, im, ssz;
	int i, j, k, pa, pb, pc;
	byte *buf, *bufe;
	byte *buf2, *buf2e;
	byte *s, *t;

	fcc0=BGBBTJ_PNG_ReadFourcc(ifd);
	fcc1=BGBBTJ_PNG_ReadFourcc(ifd);
	if((fcc0!=FCC_PNG_LOW) || (fcc1!=FCC_PNG_HIGH))
	{
		printf("damaged fourcc or non-png\n");
		return(NULL);
	}

	memset(plte, 0, 768);
	memset(trns, 255, 256);

	while(!vfeof(ifd))
	{
		len=BGBBTJ_PNG_ReadInt32BE(ifd);
		fcc0=BGBBTJ_PNG_ReadFourcc(ifd);

		if(fcc0==FCC_IEND)
		{
			crc=BGBBTJ_PNG_ReadInt32BE(ifd);
//			printf("%s %d %X\n", BGBBTJ_PNG_Fourcc2String(fcc0),
//				len, crc);

			break;
		}

		end=vftell(ifd)+len;
		if(fcc0==FCC_IHDR)
		{
			xs=BGBBTJ_PNG_ReadInt32BE(ifd);
			ys=BGBBTJ_PNG_ReadInt32BE(ifd);

			bpp=vfgetc(ifd);
			clr=vfgetc(ifd);
			cm=vfgetc(ifd);
			fm=vfgetc(ifd);
			im=vfgetc(ifd);

			if(bpp!=8)
			{
				printf("only 8 bits/channel supported\n");
				return(NULL);
			}
			if((clr!=3) && (clr!=0) && (clr!=4) &&
				(clr!=2) && (clr!=6))
			{
//				printf("only RGB(A) or Y(A) images supported\n");
				printf("unsupported color type %d\n", clr);
				return(NULL);
			}
			if(cm!=0)
			{
				printf("only deflated images supported\n");
				return(NULL);
			}
			if(fm!=0)
			{
				printf("unknown filter method\n");
				return(NULL);
			}
			if(im!=0)
			{
				printf("interlacing not supported\n");
				return(NULL);
			}

			buf=malloc(xs*ys*8);
			bufe=buf;

			ssz=0;
			if(clr==2)ssz=3;
			if(clr==6)ssz=4;

			if(clr==0)ssz=1;
			if(clr==4)ssz=2;
			if(clr==3)ssz=1;

//			printf("%dx%dx%dbpp\n", xs, ys, ssz*bpp);
//			printf("clr %d cm %d fm %d im %d\n",
//				clr, cm, fm, im);
		}

		if(fcc0==FCC_IDAT)
		{
			vfread(bufe, 1, len, ifd);
			bufe+=len;
		}

		if(fcc0==FCC_PLTE)
		{
			i=(len<=768)?len:768;
			vfread(plte, 1, i, ifd);
		}
		if(fcc0==FCC_tRNS)
		{
			i=(len<=256)?len:256;
			vfread(plte, 1, i, ifd);
		}

		vfseek(ifd, end, 0);
		crc=BGBBTJ_PNG_ReadInt32BE(ifd);

//		printf("%s %d %X\n", BGBBTJ_PNG_Fourcc2String(fcc0), len, crc);
	}

	buf2=malloc(xs*ys*8);

	i=bufe-(buf+2);
	i=PDUNZ_DecodeStream(buf+2, buf2, i, xs*ys*ssz+ys);
//	i=vfInflateBuffer(buf2, buf+2, xs*ys*ssz+ys, i);
//	i=puff(buf2, &k, buf+2, &j);

	if(i<0)	//this isn't good
	{
		printf("Inflater Error %d\n", i);

		free(buf);
		free(buf2);
		return(NULL);
	}
//	i=j;

	if(i>(xs*ys*4))printf("Inflated %d expected %d\n", i, xs*ys*4);

	j=(buf[0]<<8)|buf[1];
//	printf("Zlib %04X\n", j);

	j=(buf[i+2+0]<<24)|(buf[i+2+1]<<16)|(buf[i+2+2]<<8)|buf[i+2+3];
	k=BGBBTJ_PNG_DataAdler32(buf2, xs*ys*ssz+ys, 1);

	if(j!=k)printf("Adler32: %s  %08X %08X\n", (j==k)?"Pass":"Fail", j, k);

//	PDZ2_EncodeStream(buf2, buf, xs*ys*ssz+ys, xs*ys*8);
//	PDUNZ_DecodeStream(buf, buf2, i, xs*ys*ssz+ys);
	free(buf);

	buf=malloc((xs+1)*(ys+1)*4);
	s=buf2;
	t=buf;

	for(i=0; i<ys; i++)
	{
		fm=*s++;

		for(j=0; j<xs; j++)
		{
			for(k=0; k<ssz; k++)
			{
				if(i && j)
				{
					pa=buf[(((ys-i)*xs)+j-1)*4+k];
					pb=buf[(((ys-i)*xs)+j)*4+k];
					pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
				}else if(i)
				{
					pa=0;
					pb=buf[(((ys-i)*xs)+j)*4+k];
					pc=0;
				}else if(j)
				{
					pa=0;
					pb=0;
					pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
				}else
				{
					pa=0;
					pb=0;
					pc=0;
				}

				switch(fm)
				{
				case 0:
					buf[(((ys-i-1)*xs)+j)*4+k]=s[k];
					break;
				case 1:
					buf[(((ys-i-1)*xs)+j)*4+k]=s[k]+pc;
					break;
				case 2:
					buf[(((ys-i-1)*xs)+j)*4+k]=s[k]+pb;
					break;
				case 3:
					buf[(((ys-i-1)*xs)+j)*4+k]=
						s[k]+((pc+pb)>>1);
					break;
				case 4:
					buf[(((ys-i-1)*xs)+j)*4+k]=
						s[k]+BGBBTJ_PNG_Paeth(pc, pb, pa);
					break;
				default:
					break;
				}
			}
			if(ssz==3)buf[(((ys-i-1)*xs)+j)*4+3]=255;

			s+=ssz;
		}
	}
	free(buf2);

	//correct for grayscale images...
	if(clr==0)
	{
		for(i=0; i<(xs*ys); i++)
		{
			buf[i*4+1]=buf[i*4+0];
			buf[i*4+2]=buf[i*4+0];
			buf[i*4+3]=255;
		}
	}
	if(clr==4)
	{
		for(i=0; i<(xs*ys); i++)
		{
			buf[i*4+3]=buf[i*4+1];
			buf[i*4+1]=buf[i*4+0];
			buf[i*4+2]=buf[i*4+0];
		}
	}

	//correct for paletized images
	if(clr==3)
	{
		for(i=0; i<xs*ys; i++)
		{
			j=buf[i*4+0];

			buf[i*4+0]=plte[j*3+0];
			buf[i*4+1]=plte[j*3+1];
			buf[i*4+2]=plte[j*3+2];
			buf[i*4+3]=trns[j];
		}
	}


	*w=xs;
	*h=ys;
	return(buf);
}

BGBBTJ_API byte *BGBBTJ_PNG_LoadRaw(char *name, int *w, int *h)
{
	VFILE *fd;
	byte *tmp;

	fd=vffopen(name, "rb");
	if(!fd)
	{
		printf("PCX_LoadRaw: can't open '%s'\n", name);
		return(NULL);
	}

	tmp=BGBBTJ_PNG_Load(fd, w, h);
	vfclose(fd);

	return(tmp);
}

BGBBTJ_API void BGBBTJ_PNG_Free(byte *buf)
{
	free(buf);
}

void BGBBTJ_PNG_WriteInt32LE(VFILE *fd, uint v)
{
	vfputc(v&0xFF, fd);
	vfputc((v>>8)&0xFF, fd);
	vfputc((v>>16)&0xFF, fd);
	vfputc((v>>24)&0xFF, fd);
}

void BGBBTJ_PNG_WriteInt32BE(VFILE *fd, uint v)
{
	vfputc((v>>24)&0xFF, fd);
	vfputc((v>>16)&0xFF, fd);
	vfputc((v>>8)&0xFF, fd);
	vfputc(v&0xFF, fd);
}

void BGBBTJ_PNG_WriteFourcc(VFILE *fd, uint v)
{
	vfputc(v&0xFF, fd);
	vfputc((v>>8)&0xFF, fd);
	vfputc((v>>16)&0xFF, fd);
	vfputc((v>>24)&0xFF, fd);
}

void BGBBTJ_PNG_WriteChunk(VFILE *fd, uint fcc, byte *buf, int len)
{
	byte tb[4];
	uint crc;

	BGBBTJ_PNG_WriteInt32BE(fd, len);
	BGBBTJ_PNG_WriteFourcc(fd, fcc);
	vfwrite(buf, 1, len, fd);

	tb[0]=fcc&0xFF; tb[1]=(fcc>>8)&0xFF;
	tb[2]=(fcc>>16)&0xFF; tb[3]=(fcc>>24)&0xFF;
	crc=BGBBTJ_PNG_CRC32(tb, 4, (uint)-1);
	crc=BGBBTJ_PNG_CRC32(buf, len, crc);

//	printf("%s %d %X\n", BGBBTJ_PNG_Fourcc2String(fcc), len, ~crc);

	BGBBTJ_PNG_WriteInt32BE(fd, ~crc);
}

#ifndef ABS
#define ABS(v)	(((v)<0)?(-(v)):(v))
#endif

BGBBTJ_API void BGBBTJ_PNG_Store(VFILE *fd, byte *buf, int xs, int ys)
{
	byte hbuf[64];
	byte *buf2, *buf3, *s, *t;
	int fm, sz, pa, pb, pc, pd;
	int e, be, bf, am, ssz;
	int i, j, k, l;

	am=0;
	for(i=0; i<(xs*ys); i++)
		if(buf[i*4+3]<255)am=1;
	ssz=am?4:3;

	buf2=malloc(xs*ys*ssz+ys);

	t=buf2;
	for(i=0; i<ys; i++)
	{
		be=ssz*xs*255;
		bf=0;

		for(l=0; l<5; l++)
		{
//			if(l==4)continue;

			e=0;
			for(j=0; j<xs; j++)
			{
				for(k=0; k<ssz; k++)
				{
					pd=buf[(((ys-i-1)*xs)+j)*4+k];

					if(i && j)
//					if(((i+1)<xs) && j)
					{
						pa=buf[(((ys-i)*xs)+j-1)*4+k];
						pb=buf[(((ys-i)*xs)+j)*4+k];
						pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
					}else if(i)
//					}else if((i+1)<xs)
					{
						pa=0;
						pb=buf[(((ys-i)*xs)+j)*4+k];
						pc=0;
					}else if(j)
					{
						pa=0;
						pb=0;
						pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
					}else
					{
						pa=0;
						pb=0;
						pc=0;
					}

					switch(l)
					{
					case 0:
						e+=ABS(pd);
						break;
					case 1:
						e+=ABS(pd-pc);
						break;
					case 2:
						e+=ABS(pd-pb);
						break;
					case 3:
						e+=ABS(pd-((pc+pb)>>1));
						break;
					case 4:
						e+=ABS(pd-BGBBTJ_PNG_Paeth(pc, pb, pa));
						break;
					default:
						break;
					}
				}
			}

//			if(l==4)continue;

			if(e<be)
			{
				be=e;
				bf=l;
			}
		}

//		printf("%d ", bf);

		fm=bf;
		*t++=fm;

		for(j=0; j<xs; j++)
		{
			for(k=0; k<ssz; k++)
			{
				pd=buf[(((ys-i-1)*xs)+j)*4+k];

				if(i && j)
//				if(((i+1)<xs) && j)
				{
					pa=buf[(((ys-i)*xs)+j-1)*4+k];
					pb=buf[(((ys-i)*xs)+j)*4+k];
					pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
				}else if(i)
//				}else if((i+1)<xs)
				{
					pa=0;
					pb=buf[(((ys-i)*xs)+j)*4+k];
					pc=0;
				}else if(j)
				{
					pa=0;
					pb=0;
					pc=buf[(((ys-i-1)*xs)+j-1)*4+k];
				}else
				{
					pa=0;
					pb=0;
					pc=0;
				}

				switch(fm)
				{
				case 0:
					*t++=pd;
					break;
				case 1:
					*t++=pd-pc;
					break;
				case 2:
					*t++=pd-pb;
					break;
				case 3:
					*t++=pd-((pc+pb)>>1);
					break;
				case 4:
					*t++=pd-BGBBTJ_PNG_Paeth(pc, pb, pa);
					break;
				default:
					break;
				}
			}
		}
	}
//	printf("\n");

	buf=malloc(xs*ys*8);

	//zlib header
	i=(7<<12)|(8<<8)|(3<<6);
	j=i%31;
	if(j)i|=31-j;
	buf[0]=i>>8;
	buf[1]=i&0xFF;
//	printf("Zlib %04X\n", i);

	i=PDZ2_EncodeStreamLvl(buf2, buf+2, xs*ys*ssz+ys, xs*ys*8, 1);
//	i=vfDeflateBufferLvl(buf+2, buf2, xs*ys*8, xs*ys*ssz+ys, 9);

	if(i<0)
	{
		printf("PNG: Deflate Error %d\n", i);
	}

	//checksum
	j=BGBBTJ_PNG_DataAdler32(buf2, xs*ys*ssz+ys, 1);
	buf[2+i+0]=(j>>24)&0xFF;
	buf[2+i+1]=(j>>16)&0xFF;
	buf[2+i+2]=(j>>8)&0xFF;
	buf[2+i+3]=j&0xFF;

//	printf("Adler32: Wrote %08X\n", j);

#if 1
	k=xs*ys*ssz+ys;
	buf3=malloc(xs*ys*ssz+ys);
	PDUNZ_DecodeStreamSz(buf+2, buf3, i, k, NULL, 0);
	for(j=0; j<k; j++)
		{ if(buf2[j]!=buf3[j])break; }
	if(j<k)
	{
		printf("PNG: Check Fail: Offs=%d %d->%d\n", j, buf2[j], buf3[j]);
	}
	free(buf3);
#endif

	sz=i+6;
	free(buf2);

	BGBBTJ_PNG_WriteFourcc(fd, FCC_PNG_LOW);
	BGBBTJ_PNG_WriteFourcc(fd, FCC_PNG_HIGH);

	hbuf[0]=xs>>24; hbuf[1]=xs>>16; hbuf[2]=xs>>8; hbuf[3]=xs;
	hbuf[4]=ys>>24; hbuf[5]=ys>>16; hbuf[6]=ys>>8; hbuf[7]=ys;
	hbuf[8]=8;	//8 bits/sample
	hbuf[9]=am?6:2;	//RGB(A)
	hbuf[10]=0;	//0=deflate
	hbuf[11]=0;	//no filter
	hbuf[12]=0;	//no interlace

	BGBBTJ_PNG_WriteChunk(fd, FCC_IHDR, hbuf, 13);

//	BGBBTJ_PNG_WriteChunk(fd, FCC_IDAT, buf, sz);

	s=buf; i=sz;
	while(i>65536)
	{
		BGBBTJ_PNG_WriteChunk(fd, FCC_IDAT, s, 65536);
		s+=65536;
		i-=65536;
	}
	BGBBTJ_PNG_WriteChunk(fd, FCC_IDAT, s, i);

	BGBBTJ_PNG_WriteChunk(fd, FCC_IEND, NULL, 0);
}


BGBBTJ_API int BGBBTJ_PNG_SaveRaw(char *name, byte *buf, int xs, int ys)
{
	VFILE *fd;
	int i;

	fd=vffopen(name, "wb");
	if(!fd)return(-1);

	BGBBTJ_PNG_Store(fd, buf, xs, ys);
	vfclose(fd);

	return(0);
}

BGBBTJ_API int BGBBTJ_PNG_SaveRawFlip(char *name, byte *buf, int xs, int ys)
{
	VFILE *fd;
	byte *buf1;
	int i, j, k, w, h, w2;

	fd=vffopen(name, "wb");
	if(!fd)return(-1);

	buf1=malloc(xs*ys*4); w2=4*xs;
	for(i=0; i<ys; i++) for(j=0; j<w2; j++)
		buf1[i*w2+j]=buf[(ys-i-1)*w2+j];

	BGBBTJ_PNG_Store(fd, buf1, xs, ys);
	free(buf1); vfclose(fd);
	return(0);
}
#include <bgbbtj.h>

typedef struct TargaHeader_s {
	unsigned char 	id_length, ctype, itype;
	unsigned short	cindex, clength;
	unsigned char	csize;
	unsigned short	x_origin, y_origin, width, height;
	unsigned char	bpp, attributes;
} TargaHeader;

byte *BGBBTJ_Img_LoadTGA(VFILE *fd, int *w, int *h)
{
	TargaHeader head;
	int pixlin, i, j;
	byte *dest, *src, *buf, *obuf, r, g, b, a;

	head.id_length=vfgetc(fd);
	head.ctype=vfgetc(fd);
	head.itype=vfgetc(fd);
	head.cindex=vfgetc(fd)+(vfgetc(fd)<<8);
	head.clength=vfgetc(fd)+(vfgetc(fd)<<8);
	head.csize=vfgetc(fd);
	head.x_origin=vfgetc(fd)+(vfgetc(fd)<<8);
	head.y_origin=vfgetc(fd)+(vfgetc(fd)<<8);
	head.width=vfgetc(fd)+(vfgetc(fd)<<8);
	head.height=vfgetc(fd)+(vfgetc(fd)<<8);
	head.bpp=vfgetc(fd);
	head.attributes=vfgetc(fd);

	if(((head.itype!=2) && (head.itype!=10)) ||
			((head.bpp!=32) && (head.bpp!=24)) || (head.ctype!=0))
	{
		printf("Img_LoadTGA: only RGB(24)/RGBA(32) uncompressed "
			"images supported.\n");
		printf("   bpp: %d, type: %d\n", head.bpp, head.ctype);
		return(NULL);
	}

	vfseek(fd, head.id_length, 1); /* skip comment */

	pixlin=head.width*head.height;
	obuf=malloc(pixlin*4);
	dest=obuf;

	buf=malloc(2*pixlin*(head.bpp>>3));
	vfread(buf, 1, 2*pixlin*(head.bpp>>3), fd);
	src=buf;

	if(head.itype==2)
	{
		for(i=0; i<pixlin; i++)
		{
			b=*src++;
			g=*src++;
			r=*src++;
			if(head.bpp==32)
				a=*src++;
				else a=255;
			*dest++=r;
			*dest++=g;
			*dest++=b;
			*dest++=a;
		}
	}

	if(head.itype==10)
	{
		i=0;
		while(i<pixlin)
		{
			j=*src++;
			if(j<128)
			{
				j++;
				while(j)
				{
					b=*src++;
					g=*src++;
					r=*src++;
					if(head.bpp==32)
						a=*src++;
						else a=255;
					*dest++=r;
					*dest++=g;
					*dest++=b;
					*dest++=a;

					j--;
					i++;
				}
			}else
			{
				b=*src++;
				g=*src++;
				r=*src++;
				if(head.bpp==32)
					a=*src++;
					else a=255;

				j-=127;
				while(j)
				{
					*dest++=r;
					*dest++=g;
					*dest++=b;
					*dest++=a;

					j--;
					i++;
				}
			}
		}
	}

	free(buf);

	if(head.attributes&32)
	{
		dest=malloc(pixlin*4);
		for(i=0; i<head.height; i++)
			memcpy(&dest[i*head.width*4], &obuf[(head.height-(i+1))*head.width*4], head.width*4);
		memcpy(obuf, dest, pixlin*4);
		free(dest);
	}

	*w=head.width;
	*h=head.height;
	return(obuf);
}

int BGBBTJ_Img_StoreTGA(VFILE *fd, byte *buf, int w, int h)
{
	TargaHeader head;
	int i;
	byte *s;

	head.id_length=0;
	head.ctype=0;
	head.itype=2;
	head.cindex=0;
	head.clength=0;
	head.csize=0;
	head.x_origin=0;
	head.y_origin=0;
	head.width=w;
	head.height=h;
	head.bpp=24;
	head.attributes=0;

	vfputc(head.id_length, fd);
	vfputc(head.ctype, fd);
	vfputc(head.itype, fd);

	vfputc(head.cindex, fd);
	vfputc(head.cindex>>8, fd);
	vfputc(head.clength, fd);
	vfputc(head.clength>>8, fd);

	vfputc(head.csize, fd);

	vfputc(head.x_origin, fd);
	vfputc(head.x_origin>>8, fd);
	vfputc(head.y_origin, fd);
	vfputc(head.y_origin>>8, fd);

	vfputc(head.width, fd);
	vfputc(head.width>>8, fd);
	vfputc(head.height, fd);
	vfputc(head.height>>8, fd);

	vfputc(head.bpp, fd);
	vfputc(head.attributes, fd);

//	vfwrite(buf, w*4, h, fd);

	s=buf;
	for(i=0; i<w*h; i++)
	{
		vfputc(s[2], fd);
		vfputc(s[1], fd);
		vfputc(s[0], fd);
		s+=4;
	}

	return(0);
}


BGBBTJ_API byte *BGBBTJ_TGA_LoadRaw(char *name, int *w, int *h)
{
	VFILE *fd;
	byte *tmp;

	fd=vffopen(name, "rb");
	if(!fd)
	{
		printf("PCX_LoadRaw: can't open '%s'\n", name);
		return(NULL);
	}

	tmp=BGBBTJ_Img_LoadTGA(fd, w, h);
	vfclose(fd);

	return(tmp);
}

BGBBTJ_API int BGBBTJ_TGA_SaveRaw(char *name, byte *buf, int w, int h)
{
	VFILE *fd;
	
	fd=vffopen(name, "wb");
	if(!fd)
	{
		return(-1);
	}
	return(BGBBTJ_Img_StoreTGA(fd, buf, w, h));
}
/*
Deflater

Use Huffman trees to calculate code lengths.
Use the inflater to construct the tables themselves.

Leaves will use negative ID numbers, nodes positive numbers.
May need to make 2 passes, first to an internal representation and secondly to
the deflated format.

Use 24 bits/run (8 bit len, 3..258, 16 bit distance, 1..65536).
Bytes will also be stored here.
Run mask will be stored Externally.

Maybe use a flag to indicate whether to search 32 or 64kB.

Output size is a sane maximum.

*/

#include <bgbbtj.h>

// #define PDZ2_CHUNK	(1<<22)

#define PDZ2_CHUNK	262144
// #define PDZ2_CHUNK	65536
// #define PDZ2_CHUNK	16384

extern u16 pdunz_ltab_idx[256];	//literal index table
extern u16 pdunz_dtab_idx[256];	//distance index table

extern u16 pdunz_ltab_code[288];	//literal codes
extern u16 pdunz_ltab_mask[288];	//literal code masks
extern u16 pdunz_ltab_next[288];	//literal table code chains
extern byte pdunz_ltab_len[288];	//literal code lengths

extern u16 pdunz_dtab_code[32];	//distance codes
extern u16 pdunz_dtab_mask[32];	//distance code masks
extern u16 pdunz_dtab_next[32];	//distance table code chains
extern byte pdunz_dtab_len[32];		//distance code lengths

byte *pdz2_ibuf;	//input buffer
byte *pdz2_obuf;	//output buffer
byte *pdz2_cs;		//current input pos
byte *pdz2_ce;		//end of input buffer
byte *pdz2_ct;		//current output pos
byte *pdz2_cte;		//end of output buffer

u32 pdz2_win;		//bit window
int pdz2_pos;		//bit window position

byte pdz2_wbuf[65536];		//window buffer
u16 pdz2_lbuf[65536];	//link buffer
u16 pdz2_hash[4096];		//hash table
u16 pdz2_wpos;		//window position

int pdz2_sdepth;	//search depth
int pdz2_maxdist;	//max distance

#ifdef PDZ2_FIXCHUNK
byte pdz2_tbuf[PDZ2_CHUNK];
byte pdz2_mbuf[(PDZ2_CHUNK+7)/8];
#else
byte *pdz2_tbuf=NULL;
byte *pdz2_mbuf=NULL;
int pdz2_tsz;
int pdz2_msz;
#endif

void PDZ2_WriteBit(int i)
{
	i&=1;
	pdz2_win|=i<<pdz2_pos;
	pdz2_pos++;
	if(pdz2_pos>=8)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
}

void PDZ2_Write2Bits(int i)
{
	i&=3;
	pdz2_win|=i<<pdz2_pos;
	pdz2_pos+=2;
	if(pdz2_pos>=8)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
}

void PDZ2_Write3Bits(int i)
{
	i&=7;
	pdz2_win|=i<<pdz2_pos;
	pdz2_pos+=3;
	if(pdz2_pos>=8)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
}

void PDZ2_Write4Bits(int i)
{
	i&=15;
	pdz2_win|=i<<pdz2_pos;
	pdz2_pos+=4;
	if(pdz2_pos>=8)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
}

void PDZ2_Write5Bits(int i)
{
	i&=31;
	pdz2_win|=i<<pdz2_pos;
	pdz2_pos+=5;
	if(pdz2_pos>=8)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
}

void PDZ2_WriteNBits(int i, int n)
{
	i&=((1<<n)-1);
	pdz2_win|=i<<pdz2_pos;
	pdz2_pos+=n;
	while(pdz2_pos>=8)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
}

void PDZ2_FlushBits()
{
	while(pdz2_pos>0)
	{
		*pdz2_ct++=pdz2_win&0xFF;
		pdz2_win>>=8;
		pdz2_pos-=8;
	}
	pdz2_pos=0;
	pdz2_win=0;
}

int PDZ2_BalanceTree_r(short *nodes, short *nlen, int root, int h, int ml)
{
	int h0, h1, h2, h3;
	int l0, l1, l2;

	if(root<0)
	{
//		printf("L");
		return(0);
	}

//	printf("{");

	h1=PDZ2_BalanceTree_r(nodes, nlen, nodes[root*2+0], h+1, ml);
	h2=PDZ2_BalanceTree_r(nodes, nlen, nodes[root*2+1], h+1, ml);
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	if((h+h0)<=ml)	//depth limit not exceeded
	{
//		printf("}");
		return(h0);
	}

	//ok, so part of the tree is too deep
	if((h1+1)<h2)
	{
		l0=nodes[root*2+1];
//		if(l0<0)return(h0);	//can't rebalance leaves

		l1=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[root*2+0];
		nodes[root*2+0]=l0;
		nodes[root*2+1]=l1;
	}else if((h2+1)<h1)
	{
		l0=nodes[root*2+0];
//		if(l0<0)return(h0);	//can't rebalance leaves

		l1=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[root*2+1];
		nodes[root*2+0]=l1;
		nodes[root*2+1]=l0;
	}else
	{
//		printf("bal}");
		//rotating would be ineffective or would make things worse...
		return(h0);
	}

	//recalc depth of modified sub-tree
	l1=nodes[l0*2+0];
	l2=nodes[l0*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h3=((h1>h2)?h1:h2)+1;
	nlen[l0]=h3;

	//recalc height of root node
	l1=nodes[root*2+0];
	l2=nodes[root*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

//	printf("rebal}");

	return(h0);
}

void PDZ2_CalcLengths_r(short *nodes, byte *cl, int root, int h)
{
	if(root<0)
	{
		cl[(-root)-1]=h;
		return;
	}

	PDZ2_CalcLengths_r(nodes, cl, nodes[root*2+0], h+1);
	PDZ2_CalcLengths_r(nodes, cl, nodes[root*2+1], h+1);
}

int PDZ2_BuildLengths(int *stat, int nc, byte *cl, int ml)
{
	static short nodes[1024], nlen[512];
	static short roots[512], clen[512];
	static int cnts[512];
	int nr, nn;
	int i, j, k, l;

	nr=0; nn=0;
	for(i=0; i<nc; i++)
	{
		if(!stat[i])continue;
		roots[nr]=-(i+1);
		cnts[nr]=stat[i];
		clen[nr]=0;
		nr++;
	}

	for(i=0; i<nc; i++)cl[i]=0;
	if(!nr)
	{
		printf("empty tree\n");
		return(-1);
	}


	while(nr>1)
	{
		if(cnts[0]>=cnts[1]) { j=0; k=1; }
			else { j=1; k=0; }
		for(i=2; i<nr; i++)
		{
			if(cnts[i]<=cnts[k])
			{
				j=k; k=i;
				continue;
			}
			if(cnts[i]<=cnts[j])
			{
				j=i;
				continue;
			}
		}

		nlen[nn]=((clen[j]>clen[k])?clen[j]:clen[k])+1;
		nodes[nn*2+0]=roots[j];
		nodes[nn*2+1]=roots[k];

		roots[nr]=nn;
		cnts[nr]=cnts[j]+cnts[k];
		clen[nr]=nlen[nn];

//		printf("%d %d %d\n", cnts[j], cnts[k], cnts[nr]);

		nn++; nr++;

		l=0;
		for(i=0; i<nr; i++)
		{
			if((i==j) || (i==k))continue;
			roots[l]=roots[i];
			cnts[l]=cnts[i];
			clen[l]=clen[i];
			l++;
		}
		nr=l;
	}

	l=roots[0];
	j=clen[0];
	k=j;

	i=4;
	while((i--) && (k>ml))
		k=PDZ2_BalanceTree_r(nodes, nlen, l, 0, ml);
	if(k>ml)
	{
		printf("tree balance failure\n");
		printf("tree depth %d, org %d, %d nodes\n", k, j, nn);
		return(-2);
	}

	PDZ2_CalcLengths_r(nodes, cl, l, 0);
	return(0);
}

int PDZ2_BuildLengthsAdjust(int *stat, int nc, byte *cl, int ml)
{
	int i, j;

	while(1)
	{
		j=PDZ2_BuildLengths(stat, nc, cl, ml);
		if(j<0)
			printf("PDZ2_BuildLengthsAdjust: Huff Fail %d\n");

		for(i=0; i<nc; i++)
			if(stat[i] && !cl[i])
				break;
		if(i>=nc)break;

		printf("PDZ2_BuildLengthsAdjust: Fiddle Adjust\n");
		for(i=0; i<nc; i++)
			stat[i]++;
		continue;
	}
	return(0);
}

void PDZ2_UpdateWindowByte(byte *s)
{
	int h;

	h=(s[0]^(s[1]<<4)^(s[2]<<8))&0xFFF;
//	h=(s[0]^(s[1]<3)^(s[2]<<6))&0xFFF;
	pdz2_lbuf[pdz2_wpos]=pdz2_hash[h];
	pdz2_hash[h]=pdz2_wpos;
	pdz2_wbuf[pdz2_wpos]=*s;
	pdz2_wpos++;
}

void PDZ2_UpdateWindowString(byte *s, int l)
{
	int h;

	while(l--)
	{
		h=(s[0]^(s[1]<<4)^(s[2]<<8))&0xFFF;
//		h=(s[0]^(s[1]<<3)^(s[2]<<6))&0xFFF;
		pdz2_lbuf[pdz2_wpos]=pdz2_hash[h];
		pdz2_hash[h]=pdz2_wpos;
		pdz2_wbuf[pdz2_wpos]=*s++;
		pdz2_wpos++;
	}
}

int PDZ2_LookupString(byte *cs, byte *ce, int *rl, int *rd)
{
	byte *s, *t, *se;
	int i, j, l;
	int bl, bi, md, sd;

	if(pdz2_maxdist>32768)
		{ se=cs+65536; }
	else
		{ se=cs+258; }

	if(ce<se)se=ce;
	if((ce-cs)<3)return(0);

	md=pdz2_maxdist;
	sd=pdz2_sdepth;

	i=(cs[0]^(cs[1]<<4)^(cs[2]<<8))&0xFFF;
	i=pdz2_hash[i];

#if 1
	bl=0; bi=0; l=2;
	while(l && (sd--))
	{
		j=pdz2_wpos-i;
		if(j<=0)j+=65536;
		if(j>=md)break;

		if(i<(65536-258))
		{
			s=cs; t=pdz2_wbuf+i;
			while((s<se) && (*s==*t)) { s++; t++; }
			j=s-cs;
		}else
		{
			s=cs;
			for(j=0; ((*s++)==pdz2_wbuf[(i+j)&0xFFFF]) &&
				(s<se); j++);
		}

		if(j>bl)
		{
			bl=j; bi=i;

			if(bl>=258)break;
			if(bl>64)
			{
				if(sd>256)sd=256;
				if(bl>128)if(sd>128)sd=128;
				if(bl>192)
				{
					if(sd>64)sd=64;
					if(bl>224)if(sd>16)sd=16;
					if(bl>=256)if(sd>4)sd=4;
				}
			}
		}

		j=pdz2_lbuf[i];
		if(j>=i)l--;
		i=j;
	}
#endif

//	printf("ok\n");

	if(bl>2)
	{
		i=pdz2_wpos-bi;
		if(i<0)i+=65536;

		*rl=bl;
		*rd=i;

		return(1);
	}
	return(0);
}

int PDZ2_LZCompressBuffer(byte *ibuf, byte *obuf, byte *mbuf, int sz)
{
	byte *cs, *ce, *ct, *mt;
	int l, d, l2, d2, mi, ni;
	int mp, n, pi, pj;
	int i, j;

//	if(pdz2_sdepth<2)
	if(pdz2_sdepth<1)
	{
		i=PDZ2_LZCompressBufferRLE(ibuf, obuf, mbuf, sz);
		return(i);
	}

	cs=ibuf;
	ce=ibuf+sz;
	ct=obuf; mt=mbuf;

	mp=0; n=0; pi=pdz2_wpos; pj=0;
	mi=PDZ2_LookupString(cs, ce, &l, &d);
	while(cs<ce)
	{
		j=((ce-cs)>=260)?260:(ce-cs);
		for(i=pj; i<j; i++)
			{ pdz2_wbuf[pi]=cs[i]; pi=(pi+1)&0xFFFF; pj++; }

		ni=PDZ2_LookupString(cs+1, ce, &l2, &d2);
		if(mi && ni && (l2>(l+1)))mi=0;

		if(mi)
		{
			*mt|=1<<(mp++);
			if(mp>=8) { mt++; mp-=8; }
			n++;

			if(l>=258)
			{
				*ct++=255;
				*ct++=d&0xFF;
				*ct++=(d>>8)&0xFF;
				*ct++=l&0xFF;
				*ct++=(l>>8)&0xFF;
			}else
			{
				*ct++=l-3;
				*ct++=d&0xFF;
				*ct++=(d>>8)&0xFF;
			}

			PDZ2_UpdateWindowString(cs, l);
			cs+=l;
			pj-=l;

			j=((ce-cs)>=260)?260:(ce-cs);
			for(i=pj; i<j; i++)
				{ pdz2_wbuf[pi]=cs[i];
				pi=(pi+1)&0xFFFF; pj++; }

			mi=PDZ2_LookupString(cs, ce, &l, &d);
			continue;
		}

		*mt&=~(1<<(mp++));
		if(mp>=8) { mt++; mp-=8; }
		n++;

		PDZ2_UpdateWindowByte(cs);
		*ct++=*cs++;
		pj--;

		mi=ni; l=l2; d=d2+1;
	}

	if((ct-obuf)>sz)
	{
		printf("Deflate: LZ Buffer Overflow\n");
		*(int *)-1=-1;
	}

	return(n);
}

int PDZ2_LZCompressBufferRLE(byte *ibuf, byte *obuf, byte *mbuf, int sz)
{
	byte *cs, *ce, *ct, *mt;
	int l, d, l2, d2, mi, ni, mxl;
	int mp, n, pi, pj;
	int i, j, lc;

	cs=ibuf;
	ce=ibuf+sz;
	ct=obuf; mt=mbuf;
	mxl=(pdz2_maxdist>32768)?65536:256;

	mp=0; n=0; pi=pdz2_wpos; pj=0; lc=-1;
	while(cs<ce)
	{
		j=ce-cs;
		if(j>mxl) { j=mxl; }
		for(i=0; i<j; i++)
			if(cs[i]!=lc)
				break;
		l=i; d=1;
//		l=0; d=1;
	
		if(l>=3)
		{
			*mt|=1<<(mp++);
			if(mp>=8) { mt++; mp-=8; }
			n++;

			if(l>=258)
			{
				*ct++=255;
				*ct++=d&0xFF;
				*ct++=(d>>8)&0xFF;
				*ct++=l&0xFF;
				*ct++=(l>>8)&0xFF;
			}else
			{
				*ct++=l-3;
				*ct++=d&0xFF;
				*ct++=(d>>8)&0xFF;
			}

			cs+=l;
			continue;
		}

		*mt&=~(1<<(mp++));
		if(mp>=8) { mt++; mp-=8; }
		n++;

		lc=*cs++;
		*ct++=lc;
	}

	if((ct-obuf)>sz)
	{
		printf("Deflate: LZ Buffer Overflow\n");
		*(int *)-1=-1;
	}

	return(n);
}

void PDZ2_StatLZRun(byte *cs, int *lstat, int *dstat)
{
	static int dbase[]={
		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
		257, 385, 513, 769, 1025, 1537, 2049, 3073,
		4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
	static int dextra[]={
		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
		7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14};

	static int lbase[]={
		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
		35, 43, 51, 59, 67, 83, 99, 115,
		131, 163, 195, 227, 258, 0, 0, 0};
	static int lextra[]={
		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0};

	int i, j, k;

	j=cs[0]+3;
	if(j==258)
	{
		lstat[285]++;
	}else
	{
		for(i=0; i<29; i++)
		{
			k=lbase[i]+(1<<lextra[i]);
			if((j>=lbase[i]) && (j<k))
			{
				lstat[257+i]++;
				break;
			}
		}
	}

	j=cs[1]|(cs[2]<<8);
	for(i=0; i<32; i++)
	{
		k=dbase[i]+(1<<dextra[i]);
		if((j>=dbase[i]) && (j<k))
		{
			dstat[i]++;
			break;
		}
	}
}

void PDZ2_StatLZBuffer(byte *tbuf, byte *mbuf, int n,
	int *lstat, int *dstat)
{
	byte *s;
	int i;

	for(i=0; i<288; i++)lstat[i]=0;
	for(i=0; i<32; i++)dstat[i]=0;

	s=tbuf;
	for(i=0; i<n; i++)
	{
		if(mbuf[i>>3]&(1<<(i&7)))
		{
			PDZ2_StatLZRun(s, lstat, dstat);
//			s+=3;
			if(s[0]==255)	{ s+=5; }
			else			{ s+=3; }
			continue;
		}

		lstat[*s++]++;
	}
	lstat[256]++;
}

void PDZ2_StatLengths(byte *cl, int nc, int *stat)
{
	int i, j, l;

	l=-1;
	for(i=0; i<nc;)
	{
		for(j=0; ((i+j)<nc) && (cl[i+j]==0); j++);
		if(j>138)j=138;
		if(j>10) { stat[18]++; i+=j; l=0; continue; }
		if(j>2) { stat[17]++; i+=j; l=0; continue; }

		for(j=0; ((i+j)<nc) && (cl[i+j]==l); j++);
		if(j>6)j=6;
		if(j>2) { stat[16]++; i+=j; continue; }

		l=cl[i++];
		stat[l]++;
	}
}

void PDZ2_EncodeSymbol(int v)
{
	if(!pdunz_ltab_len[v])
		printf("PDZ2_EncodeSymbol: no symbol %d\n", v);

	PDZ2_WriteNBits(pdunz_ltab_code[v],
		pdunz_ltab_len[v]);
}

void PDZ2_EncodeLengths(byte *cl, int nc)
{
	int i, j, l;

	i=0; l=-1;
	while(i<nc)
	{
		for(j=0; ((i+j)<nc) && (cl[i+j]==0); j++);
		if(j>10)
		{
			if(j>138)j=138;
			PDZ2_EncodeSymbol(18);
			PDZ2_WriteNBits(j-11, 7);
			i+=j;
			l=0;

//			printf("Z%d ", j);
			continue;
		}
		if(j>2)
		{
			PDZ2_EncodeSymbol(17);
			PDZ2_Write3Bits(j-3);
			i+=j;
			l=0;

//			printf("Z%d ", j);
			continue;
		}

		for(j=0; ((i+j)<nc) && (cl[i+j]==l); j++);
		if(j>2)
		{
			if(j>6)j=6;
			PDZ2_EncodeSymbol(16);
			PDZ2_Write2Bits(j-3);
			i+=j;

//			printf("R%d ", j);
			continue;
		}

		l=cl[i++];
		PDZ2_EncodeSymbol(l);

//		printf("L%d ", l);

		if((l<0) || (l>15))printf("problem: bad code length noted\n");
	}
//	printf("\n");
}

void PDZ2_EncodeLZRun(byte *cs)
{
	static int dbase[]={
		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
		257, 385, 513, 769, 1025, 1537, 2049, 3073,
		4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
	static int dextra[]={
		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
		7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14};

	static int lbase[]={
		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
		35, 43, 51, 59, 67, 83, 99, 115,
		131, 163, 195, 227, 258, 0, 0, 0};
	static int lextra[]={
		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0};

	int i, j, k;

	j=cs[0]+3;
	if(j==258)
	{
		PDZ2_EncodeSymbol(285);
		if(pdz2_maxdist>32768)
		{
			k=cs[3]|(cs[4]<<8);
			PDZ2_WriteNBits(k-3, 16);
		}
	}else
	{
		for(i=0; i<29; i++)
		{
			k=lbase[i]+(1<<lextra[i]);
			if((j>=lbase[i]) && (j<k))
			{
				PDZ2_EncodeSymbol(257+i);
				PDZ2_WriteNBits(j-lbase[i], lextra[i]);
				break;
			}
		}
	}

	j=cs[1]|(cs[2]<<8);
	for(i=0; i<32; i++)
	{
		k=dbase[i]+(1<<dextra[i]);
		if((j>=dbase[i]) && (j<k))
		{
			if(!pdunz_dtab_len[i])
				printf("PDZ2_EncodeLZRun: "
					"no dist sym %d, %d\n", i, j);

			PDZ2_WriteNBits(pdunz_dtab_code[i],
				pdunz_dtab_len[i]);

			PDZ2_WriteNBits(j-dbase[i], dextra[i]);
			break;
		}
	}
}

void PDZ2_EncodeLZBuffer(byte *tbuf, byte *mbuf, int n)
{
	byte *s;
	int i;

	s=tbuf;
	for(i=0; i<n; i++)
	{
		if(mbuf[i>>3]&(1<<(i&7)))
		{
			PDZ2_EncodeLZRun(s);
			if(s[0]==255)	{ s+=5; }
			else			{ s+=3; }
			continue;
		}

		PDZ2_EncodeSymbol(*s++);
	}
	PDZ2_EncodeSymbol(256);
}

int PDZ2_EncodeBlockStatic(byte *ibuf, int isz, int last)
{
	byte *tbuf, *mbuf;
	int n;

	tbuf=malloc(isz*2);
	mbuf=malloc((isz*2+7)/8);

	n=PDZ2_LZCompressBuffer(ibuf, tbuf, mbuf, isz);

	PDZ2_WriteBit(last);
	PDZ2_Write2Bits(1);

	PDUNZ_SetupStatic();

	PDZ2_EncodeLZBuffer(tbuf, mbuf, n);

	free(tbuf);
	free(mbuf);

	return(0);
}

int PDZ2_EncodeBlock(byte *ibuf, int isz, int last)
{
	static int lorder[]={
		16, 17, 18, 0, 8,7, 9,6, 10,5, 11,4, 12,3, 13,2, 14,1, 15};

//	static byte *tbuf=NULL, *mbuf=NULL;
//	static int tsz, msz;

	int lstat[288], dstat[32], hstat[24];
	byte lcl[288], dcl[32], hcl[24], hcl2[24];
	int lc, dc, hc;
	int i, j, n;

#ifndef PDZ2_FIXCHUNK
	i=isz;
	if(!pdz2_tbuf || (isz>pdz2_tsz))
	{
		if(pdz2_tbuf)free(pdz2_tbuf);
		if(pdz2_mbuf)free(pdz2_mbuf);
		pdz2_tsz=i; pdz2_msz=(i+7)/8;
		pdz2_tbuf=malloc(pdz2_tsz);
		pdz2_mbuf=malloc(pdz2_msz);
	}
#endif

	n=PDZ2_LZCompressBuffer(ibuf, pdz2_tbuf, pdz2_mbuf, isz);

	PDZ2_StatLZBuffer(pdz2_tbuf, pdz2_mbuf, n, lstat, dstat);

	if(pdz2_sdepth<2)
	{
		for(i=0; i<256; i++)
			lstat[i]++;
		for(i=0; i<8; i++)
			dstat[i]++;
	}

//	PDZ2_BuildLengths(lstat, 288, lcl, 15);
//	PDZ2_BuildLengths(dstat, 32, dcl, 15);
	PDZ2_BuildLengthsAdjust(lstat, 288, lcl, 15);
	PDZ2_BuildLengthsAdjust(dstat, 32, dcl, 15);

	for(i=0; i<32; i++)if(dcl[i])break;
	if(i==32)for(i=0; i<32; i++)dcl[i]=5;

	for(lc=257; lc<286; lc++)
	{
		for(i=lc; i<286; i++)
			if(lcl[i])break;
		if(i==286)break;
	}

	for(dc=1; dc<32; dc++)
	{
		for(i=dc; i<32; i++)
			if(dcl[i])break;
		if(i==32)break;
	}

	for(i=0; i<24; i++)hstat[i]=0;
	PDZ2_StatLengths(lcl, lc, hstat);
	PDZ2_StatLengths(dcl, dc, hstat);
//	PDZ2_BuildLengths(hstat, 24, hcl, 7);
	PDZ2_BuildLengthsAdjust(hstat, 24, hcl, 7);

	for(i=0; i<19; i++)hcl2[i]=hcl[lorder[i]];

	for(hc=4; hc<19; hc++)
	{
		for(i=hc; i<19; i++)
			if(hcl2[i])break;
		if(i==19)break;
	}

	PDZ2_WriteBit(last);
	PDZ2_Write2Bits(2);

	PDZ2_Write5Bits(lc-257);
	PDZ2_Write5Bits(dc-1);
	PDZ2_Write4Bits(hc-4);

	for(i=0; i<hc; i++)
		PDZ2_Write3Bits(hcl[lorder[i]]);

	j=PDUNZ_SetupTable(hcl, 24,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)return(j);

	PDZ2_EncodeLengths(lcl, lc);
	PDZ2_EncodeLengths(dcl, dc);

	j=PDUNZ_SetupTable(lcl, lc,
		pdunz_ltab_code, pdunz_ltab_mask, pdunz_ltab_len,
		pdunz_ltab_idx, pdunz_ltab_next);
	if(j<0)return(j);

	j=PDUNZ_SetupTable(dcl, dc,
		pdunz_dtab_code, pdunz_dtab_mask, pdunz_dtab_len,
		pdunz_dtab_idx, pdunz_dtab_next);
	if(j<0)return(j);

	PDZ2_EncodeLZBuffer(pdz2_tbuf, pdz2_mbuf, n);

//	free(tbuf);
//	free(mbuf);

	return(0);
}

int PDZ2_EncodeStream_I(byte *ibuf, byte *obuf, int isz, int osz)
{
	byte *s;
	int i, j, k;

	pdz2_ibuf=ibuf;
	pdz2_obuf=obuf;
	pdz2_pos=0;
	pdz2_win=0;

	pdz2_ct=obuf;
	pdz2_cte=obuf+osz;

	memset(pdz2_wbuf, 0, 65536);

	for(i=0; i<4096; i++)pdz2_hash[i]=0;
	pdz2_lbuf[0]=0;
	pdz2_wpos=0xFFFF;

	s=ibuf;
	i=isz;	k=0;

#ifdef PDZ2_CHUNK
	while(i>PDZ2_CHUNK)
	{
//		printf("Encode Block %d\r", k++);

#if 1
		for(j=0; j<4096; j++)pdz2_hash[j]=0;
		pdz2_lbuf[0]=0;
		pdz2_wpos=0xFFFF;
#endif

		j=PDZ2_EncodeBlock(s, PDZ2_CHUNK, 0);
//		j=PDZ2_EncodeBlockStatic(s, PDZ2_CHUNK, 0);
		if(j<0)return(j);
		i-=PDZ2_CHUNK;
		s+=PDZ2_CHUNK;
	}
//	printf("\n");
#endif

	j=PDZ2_EncodeBlock(s, i, 1);
//	j=PDZ2_EncodeBlockStatic(s, i, 1);
	if(j<0)return(j);

	PDZ2_FlushBits();
	return(pdz2_ct-obuf);
}

int PDZ2_EncodeStream(byte *ibuf, byte *obuf, int isz, int osz)
{
	int i;

	pdz2_sdepth=4096;
	pdz2_maxdist=32768;

	i=PDZ2_EncodeStream_I(ibuf, obuf, isz, osz);
	return(i);
}

int PDZ2_EncodeStream64(byte *ibuf, byte *obuf, int isz, int osz)
{
	int i;

	pdz2_sdepth=4096;
	pdz2_maxdist=65536-260;

	i=PDZ2_EncodeStream_I(ibuf, obuf, isz, osz);
	return(i);
}

int PDZ2_EncodeStreamLvl(byte *ibuf, byte *obuf, int isz, int osz, int l)
{
	static int sd[10]=
		{1, 16, 16, 64, 64, 256, 256, 1024, 4096, 16384};
	static int md[10]=
		{1, 4096, 8192, 4096, 8192, 8192, 16384, 16384, 32768, 32768};

	int i;

	pdz2_sdepth=sd[l];
	pdz2_maxdist=md[l];

	i=PDZ2_EncodeStream_I(ibuf, obuf, isz, osz);
	return(i);
}

int PDZ2_EncodeStream64Lvl(byte *ibuf, byte *obuf,
	int isz, int osz, int lvl)
{
//	static int sd[10]=
//		{1, 16, 16, 64, 64, 256, 256, 1024, 4096, 16384};
//	static int sd[10]=
//		{1, 4, 16, 32, 64, 256, 256, 1024, 4096, 16384};
	static int sd[10]=
		{0, 1, 4, 16, 64, 256, 256, 1024, 4096, 16384};
	int i;

//	pdz2_sdepth=4096;
	pdz2_sdepth=sd[lvl];
	pdz2_maxdist=65536-260;

	i=PDZ2_EncodeStream_I(ibuf, obuf, isz, osz);
	return(i);
}

int PDZ2_EncodeStreamLvlZl(byte *ibuf, byte *obuf,
	int isz, int osz, int lvl)
{
	int i, j, k, l;

	j=PDZ2_EncodeStreamLvl(ibuf, obuf+2, isz, osz-6, lvl);

	k=(7<<12)|(8<<8)|(3<<6); l=k%31;
	if(l)k|=31-l;
	obuf[0]=k>>8; obuf[1]=k&0xFF;

	k=BGBBTJ_BufPNG_DataAdler32(ibuf, isz, 1);
	obuf[2+j+0]=(k>>24)&0xFF;
	obuf[2+j+1]=(k>>16)&0xFF;
	obuf[2+j+2]=(k>>8)&0xFF;
	obuf[2+j+3]=k&0xFF;

	j+=6;
	
	return(j);
}

int PDZ2_EncodeStream64LvlZl(byte *ibuf, byte *obuf,
	int isz, int osz, int lvl)
{
	int i, j, k, l;

	j=PDZ2_EncodeStream64Lvl(ibuf, obuf+2, isz, osz-6, lvl);

	k=(8<<12)|(9<<8)|(3<<6); l=k%31;
	if(l)k|=31-l;
	obuf[0]=k>>8; obuf[1]=k&0xFF;

	k=BGBBTJ_BufPNG_DataAdler32(ibuf, isz, 1);
	obuf[2+j+0]=(k>>24)&0xFF;
	obuf[2+j+1]=(k>>16)&0xFF;
	obuf[2+j+2]=(k>>8)&0xFF;
	obuf[2+j+3]=k&0xFF;

	j+=6;
	
	return(j);
}

int PDZ2_EncodeStream64LvlZlTest(byte *ibuf, byte *obuf,
	int isz, int osz, int lvl)
{
	byte *tbuf;
	int i, j, k, l;

	i=PDZ2_EncodeStream64LvlZl(ibuf, obuf, isz, osz, lvl);

	tbuf=malloc(isz+32768);
	PDUNZ_DecodeStreamSzZl(obuf, tbuf, i, isz+32768, &j, 0);
	if(j!=isz)
	{
		printf("PDZ2_EncodeStream64LvlZlTest: Size %d -> %d\n", isz, j);
		free(tbuf);
		return(-1);
	}
	
	for(k=0; k<isz; k++)
		if(tbuf[k]!=ibuf[k])
			break;
	if(k<isz)
	{
		printf("PDZ2_EncodeStream64LvlZlTest: Error @%d/%d\n", k, isz);
		free(tbuf);
		return(-1);
	}
	
	free(tbuf);
	return(i);
}
#include <bgbbtj.h>

#if 1
// void BGBBTJ_JPG_TransDCT_Horiz(byte *iblk, int *oblk)
void BGBBTJ_JPG_TransDCT_Horiz(short *iblk, int *oblk, int dcbias)
{
	int ib[8];

//	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
//	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
//	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
//	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	ib[0]=iblk[0]-dcbias;	ib[1]=iblk[1]-dcbias;
	ib[2]=iblk[2]-dcbias;	ib[3]=iblk[3]-dcbias;
	ib[4]=iblk[4]-dcbias;	ib[5]=iblk[5]-dcbias;
	ib[6]=iblk[6]-dcbias;	ib[7]=iblk[7]-dcbias;

	oblk[0]=ib[0]*91  +ib[1]*91  +ib[2]*91  +ib[3]*91  
			+ib[4]*91  +ib[5]*91  +ib[6]*91  +ib[7]*91;
	oblk[1]=ib[0]*126 +ib[1]*106 +ib[2]*71  +ib[3]*25  
			-ib[4]*25  -ib[5]*71  -ib[6]*106 -ib[7]*126;
	oblk[2]=ib[0]*118 +ib[1]*49  -ib[2]*49  -ib[3]*118 
			-ib[4]*118 -ib[5]*49  +ib[6]*49  +ib[7]*118;
	oblk[3]=ib[0]*106 -ib[1]*25  -ib[2]*126 -ib[3]*71  
			+ib[4]*71  +ib[5]*126 +ib[6]*25  -ib[7]*106;
	oblk[4]=ib[0]*91  -ib[1]*91  -ib[2]*91  +ib[3]*91  
			+ib[4]*91  -ib[5]*91  -ib[6]*91  +ib[7]*91;
	oblk[5]=ib[0]*71  -ib[1]*126 +ib[2]*25  +ib[3]*106 
			-ib[4]*106 -ib[5]*25  +ib[6]*126 -ib[7]*71;
	oblk[6]=ib[0]*49  -ib[1]*118 +ib[2]*118 -ib[3]*49  
			-ib[4]*49  +ib[5]*118 -ib[6]*118 +ib[7]*49;
	oblk[7]=ib[0]*25  -ib[1]*71  +ib[2]*106 -ib[3]*126 
			+ib[4]*126 -ib[5]*106 +ib[6]*71  -ib[7]*25;
}

void BGBBTJ_JPG_TransDCT_Vert(int *iblk, int *oblk)
{
	oblk[ 0]=iblk[0]*91  +iblk[8]*91  
			+iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  +iblk[40]*91  
			+iblk[48]*91  +iblk[56]*91;
	oblk[ 8]=iblk[0]*126 +iblk[8]*106 
			+iblk[16]*71  +iblk[24]*25  
			-iblk[32]*25  -iblk[40]*71  
			-iblk[48]*106 -iblk[56]*126;
	oblk[16]=iblk[0]*118 +iblk[8]*49  
			-iblk[16]*49  -iblk[24]*118 
			-iblk[32]*118 -iblk[40]*49  
			+iblk[48]*49  +iblk[56]*118;
	oblk[24]=iblk[0]*106 -iblk[8]*25  
			-iblk[16]*126 -iblk[24]*71  
			+iblk[32]*71  +iblk[40]*126 
			+iblk[48]*25  -iblk[56]*106;
	oblk[32]=iblk[0]*91  -iblk[8]*91  
			-iblk[16]*91  +iblk[24]*91  
			+iblk[32]*91  -iblk[40]*91  
			-iblk[48]*91  +iblk[56]*91;
	oblk[40]=iblk[0]*71  -iblk[8]*126 
			+iblk[16]*25  +iblk[24]*106
			-iblk[32]*106 -iblk[40]*25  
			+iblk[48]*126 -iblk[56]*71;
	oblk[48]=iblk[0]*49  -iblk[8]*118
			+iblk[16]*118 -iblk[24]*49  
			-iblk[32]*49  +iblk[40]*118 
			-iblk[48]*118 +iblk[56]*49;
	oblk[56]=iblk[0]*25  -iblk[8]*71  
			+iblk[16]*106 -iblk[24]*126 
			+iblk[32]*126 -iblk[40]*106 
			+iblk[48]*71  -iblk[56]*25;
}

// void BGBBTJ_JPG_TransDCT(byte *iblk, short *oblk)
void BGBBTJ_JPG_TransDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	BGBBTJ_JPG_TransDCT_Horiz(iblk+0, s+0, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+8, s+8, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+16, s+16, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+24, s+24, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+32, s+32, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+40, s+40, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+48, s+48, dcbias);
	BGBBTJ_JPG_TransDCT_Horiz(iblk+56, s+56, dcbias);

	BGBBTJ_JPG_TransDCT_Vert(s+0, t+0);
	BGBBTJ_JPG_TransDCT_Vert(s+1, t+1);
	BGBBTJ_JPG_TransDCT_Vert(s+2, t+2);
	BGBBTJ_JPG_TransDCT_Vert(s+3, t+3);
	BGBBTJ_JPG_TransDCT_Vert(s+4, t+4);
	BGBBTJ_JPG_TransDCT_Vert(s+5, t+5);
	BGBBTJ_JPG_TransDCT_Vert(s+6, t+6);
	BGBBTJ_JPG_TransDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i]>>16;
}

#endif

#if 0
void BGBBTJ_JPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
	int t0, t1, t2, t3, t4, t5, t6, t7;
	int tt0, tt1, tt2, tt3;
	int t10, t11, t12, t13, t14, t15, t16, t17;
	int tt10, tt11, tt12, tt13;
	int z1, z2;

	t0=iblk[0]+iblk[7];	t1=iblk[1]+iblk[6];
	t2=iblk[2]+iblk[5];	t3=iblk[3]+iblk[4];
	t4=iblk[0]-iblk[7];	t5=iblk[1]-iblk[6];
	t6=iblk[2]-iblk[5];	t7=iblk[3]-iblk[4];
	t10=t0+t3;	t11=t1+t2;
	t12=t0-t3;	t13=t1-t2;

	t14=t4+t7;	t15=t5+t6;
	t16=t4+t6;	t17=t5+t7;
	
	z1=(t12+t13)*139;	z2=(t16+t17)*301;

	tt0=t4*384;			tt1=t5*787;
	tt2=t6*526;			tt3=t7*77;
	tt10=t14*-230;		tt11=t15*-656;
	tt12=t16*-100+z2;	tt13=t17*-502+z2;

	oblk[0]=(t10+t11)*256;
	oblk[4]=(t10-t11)*256;
	oblk[2]=(z1+t12* 196);
	oblk[6]=(z1+t13*-473);

	oblk[1]=tt0+tt10+tt12;
	oblk[3]=tt1+tt11+tt13;
	oblk[5]=tt2+tt11+tt12;
	oblk[7]=tt3+tt10+tt13;
}
#endif

#if 1
void BGBBTJ_JPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
//	int i0, i1, i2, i3, i4, i5, i6, i7;
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

#if 0
	i0=iblk[0];	i1=iblk[1];	i2=iblk[2];	i3=iblk[3];
	i4=iblk[4];	i5=iblk[5];	i6=iblk[6];	i7=iblk[7];
	a=i0* 91;	b=i4* 91;
	c=i2*118;	d=i2* 49;
	e=i6*118;	f=i6* 49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=i1*126+i3*106+i5* 71+i7* 25;
	n=i1*106-i3* 25-i5*126-i7* 71;
	o=i1* 71-i3*126+i5* 25+i7*106;
	p=i1* 25-i3* 71+i5*106-i7*126;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
#endif

#if 1
	a=iblk[0]* 91;	b=iblk[4]* 91;
	c=iblk[2]*118;	d=iblk[2]* 49;
	e=iblk[6]*118;	f=iblk[6]* 49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[1]*126+iblk[3]*106+iblk[5]* 71+iblk[7]* 25;
	n=iblk[1]*106-iblk[3]* 25-iblk[5]*126-iblk[7]* 71;
	o=iblk[1]* 71-iblk[3]*126+iblk[5]* 25+iblk[7]*106;
	p=iblk[1]* 25-iblk[3]* 71+iblk[5]*106-iblk[7]*126;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
#endif
}

void BGBBTJ_JPG_TransIDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]* 91;	b=iblk[32]*91;
	c=iblk[16]*118;	d=iblk[16]*49;
	e=iblk[48]*118;	f=iblk[48]*49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[ 8]*126+iblk[24]*106+iblk[40]* 71+iblk[56]* 25;
	n=iblk[ 8]*106-iblk[24]* 25-iblk[40]*126-iblk[56]* 71;
	o=iblk[ 8]* 71-iblk[24]*126+iblk[40]* 25+iblk[56]*106;
	p=iblk[ 8]* 25-iblk[24]* 71+iblk[40]*106-iblk[56]*126;
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

void BGBBTJ_JPG_TransIDCT_Vert2(int *iblk, short *oblk, int dcbias)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]* 91;	b=iblk[32]*91;
	c=iblk[16]*118;	d=iblk[16]*49;
	e=iblk[48]*118;	f=iblk[48]*49;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[ 8]*126+iblk[24]*106+iblk[40]* 71+iblk[56]* 25;
	n=iblk[ 8]*106-iblk[24]* 25-iblk[40]*126-iblk[56]* 71;
	o=iblk[ 8]* 71-iblk[24]*126+iblk[40]* 25+iblk[56]*106;
	p=iblk[ 8]* 25-iblk[24]* 71+iblk[40]*106-iblk[56]*126;
	oblk[ 0]=((i+m)>>16)+dcbias;	oblk[ 8]=((j+n)>>16)+dcbias;
	oblk[16]=((k+o)>>16)+dcbias;	oblk[24]=((l+p)>>16)+dcbias;
	oblk[32]=((l-p)>>16)+dcbias;	oblk[40]=((k-o)>>16)+dcbias;
	oblk[48]=((j-n)>>16)+dcbias;	oblk[56]=((i-m)>>16)+dcbias;
}

/** Determine whether the DCT block is a flat color (all AC coefficients are zero). */
int BGBBTJ_JPG_DetectFlatIDCT(short *iblk)
{
	int i;

	if(iblk[ 1])return(0);
	if(iblk[ 8])return(0);

//	if(iblk[ 1]|iblk[8])return(0);
	if(iblk[19]|iblk[9])return(0);
	if(iblk[ 2]|iblk[3]|iblk[10])	return(0);
	if(iblk[17]|iblk[24]|iblk[32]|iblk[25])	return(0);
	if(iblk[18]|iblk[11]|iblk[ 4]|iblk[ 5])	return(0);

	if(	iblk[12]|iblk[19]|iblk[26]|iblk[33]|
		iblk[40]|iblk[48]|iblk[41]|iblk[34])
			return(0);
	if(	iblk[27]|iblk[20]|iblk[13]|iblk[ 6]|
		iblk[ 7]|iblk[14]|iblk[21]|iblk[28])
			return(0);

	if(	iblk[35]|iblk[42]|iblk[49]|iblk[56]|
		iblk[57]|iblk[50]|iblk[43]|iblk[36]|
		iblk[29]|iblk[22]|iblk[15]|iblk[23]|
		iblk[30]|iblk[37]|iblk[44]|iblk[51])
			return(0);
	if(	iblk[58]|iblk[59]|iblk[52]|iblk[45]|
		iblk[38]|iblk[31]|iblk[39]|iblk[46]|
		iblk[53]|iblk[60]|iblk[61]|iblk[54]|
		iblk[47]|iblk[55]|iblk[62]|iblk[63])
			return(0);
	return(1);
}

// void BGBBTJ_JPG_TransIDCT(short *iblk, byte *oblk)
void BGBBTJ_JPG_TransIDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	short *ob, *obe;
	int i, j, k;

#if 1
	if(BGBBTJ_JPG_DetectFlatIDCT(iblk))
	{
		/* If DCT block is a flat color, fill directly */
		k=((iblk[0]*8281+32768)>>16)+dcbias;
//		k=((iblk[0]*8192+32768)>>16)+dcbias;
		ob=oblk; obe=ob+64;
//		for(i=0; i<8; i++)
		while(ob<obe)
		{
			ob[ 0]=k; ob[ 1]=k; ob[ 2]=k; ob[ 3]=k;
			ob[ 4]=k; ob[ 5]=k; ob[ 6]=k; ob[ 7]=k;
			ob[ 8]=k; ob[ 9]=k; ob[10]=k; ob[11]=k;
			ob[12]=k; ob[13]=k; ob[14]=k; ob[15]=k;
			ob+=16;
		}
		return;
	}
#endif

#if 0
//	i=iblk[1]+iblk[8]+iblk[16]+iblk[9];
	i=iblk[1]+iblk[8];
	if(!i)
	{
		k=iblk[1]+iblk[2]+iblk[3]+iblk[4]+
			iblk[5]+iblk[6]+iblk[7];
		for(i=1; (i<8) && !k; i++)
		{
			j=i*8;
			k+=iblk[j+0]+iblk[j+1]+iblk[j+2]+iblk[j+3]+
				iblk[j+4]+iblk[j+5]+iblk[j+6]+iblk[j+7];
		}
		if(!k)
		{
			k=((iblk[0]*8281)>>16)+dcbias;

			for(i=0; i<8; i++)
			{
				j=i*8;
				oblk[j+0]=k; oblk[j+1]=k;
				oblk[j+2]=k; oblk[j+3]=k;
				oblk[j+4]=k; oblk[j+5]=k;
				oblk[j+6]=k; oblk[j+7]=k;
			}
			return;
		}
	}
#endif

	BGBBTJ_JPG_TransIDCT_Horiz(iblk+0, s+0);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+8, s+8);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+16, s+16);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+24, s+24);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+32, s+32);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+40, s+40);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+48, s+48);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+56, s+56);

#if 1
	BGBBTJ_JPG_TransIDCT_Vert2(s+0, oblk+0, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+1, oblk+1, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+2, oblk+2, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+3, oblk+3, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+4, oblk+4, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+5, oblk+5, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+6, oblk+6, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+7, oblk+7, dcbias);
#endif

#if 0
	BGBBTJ_JPG_TransIDCT_Vert(s+0, t+0);
	BGBBTJ_JPG_TransIDCT_Vert(s+1, t+1);
	BGBBTJ_JPG_TransIDCT_Vert(s+2, t+2);
	BGBBTJ_JPG_TransIDCT_Vert(s+3, t+3);
	BGBBTJ_JPG_TransIDCT_Vert(s+4, t+4);
	BGBBTJ_JPG_TransIDCT_Vert(s+5, t+5);
	BGBBTJ_JPG_TransIDCT_Vert(s+6, t+6);
	BGBBTJ_JPG_TransIDCT_Vert(s+7, t+7);
#endif

#if 0
	for(i=0; i<8; i++)
	{
		j=i*8;
		oblk[j+0]=(t[j+0]>>16)+dcbias;
		oblk[j+1]=(t[j+1]>>16)+dcbias;
		oblk[j+2]=(t[j+2]>>16)+dcbias;
		oblk[j+3]=(t[j+3]>>16)+dcbias;
		oblk[j+4]=(t[j+4]>>16)+dcbias;
		oblk[j+5]=(t[j+5]>>16)+dcbias;
		oblk[j+6]=(t[j+6]>>16)+dcbias;
		oblk[j+7]=(t[j+7]>>16)+dcbias;
	}
#endif

#if 0
	for(i=0; i<64; i++)
	{
		j=(t[i]>>16)+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
//		oblk[i]=(j<0)?0:((j>255)?255:j);
	}
#endif
}

void BGBBTJ_JPG_TransIDCT16(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	BGBBTJ_JPG_TransIDCT_Horiz(iblk+0, s+0);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+8, s+8);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+16, s+16);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+24, s+24);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+32, s+32);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+40, s+40);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+48, s+48);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+56, s+56);

	for(i=0; i<DCTSZ2; i++)
		s[i]>>=4;

	BGBBTJ_JPG_TransIDCT_Vert(s+0, t+0);
	BGBBTJ_JPG_TransIDCT_Vert(s+1, t+1);
	BGBBTJ_JPG_TransIDCT_Vert(s+2, t+2);
	BGBBTJ_JPG_TransIDCT_Vert(s+3, t+3);
	BGBBTJ_JPG_TransIDCT_Vert(s+4, t+4);
	BGBBTJ_JPG_TransIDCT_Vert(s+5, t+5);
	BGBBTJ_JPG_TransIDCT_Vert(s+6, t+6);
	BGBBTJ_JPG_TransIDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
	{
		j=(t[i]>>12)+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
	}
}

#endif


#if 0
void BGBBTJ_JPG_TransIDCT_Horiz(short *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[0]*6;	b=iblk[4]*6;
	c=iblk[2]*7;	d=iblk[2]*3;
	e=iblk[6]*7;	f=iblk[6]*3;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[1]*8+iblk[3]*7+iblk[5]*4+iblk[7]*2;
	n=iblk[1]*7-iblk[3]*2-iblk[5]*8-iblk[7]*4;
	o=iblk[1]*4-iblk[3]*8+iblk[5]*2+iblk[7]*7;
	p=iblk[1]*2-iblk[3]*4+iblk[5]*7-iblk[7]*8;
	oblk[0]=i+m;	oblk[1]=j+n;	oblk[2]=k+o;	oblk[3]=l+p;
	oblk[4]=l-p;	oblk[5]=k-o;	oblk[6]=j-n;	oblk[7]=i-m;
}

void BGBBTJ_JPG_TransIDCT_Vert(int *iblk, int *oblk)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]*6;	b=iblk[32]*6;
	c=iblk[16]*7;	d=iblk[16]*3;
	e=iblk[48]*7;	f=iblk[48]*3;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[ 8]*8+iblk[24]*7+iblk[40]*4+iblk[56]*2;
	n=iblk[ 8]*7-iblk[24]*2-iblk[40]*8-iblk[56]*4;
	o=iblk[ 8]*4-iblk[24]*8+iblk[40]*2+iblk[56]*7;
	p=iblk[ 8]*2-iblk[24]*4+iblk[40]*7-iblk[56]*8;
	oblk[ 0]=i+m;	oblk[ 8]=j+n;	oblk[16]=k+o;	oblk[24]=l+p;
	oblk[32]=l-p;	oblk[40]=k-o;	oblk[48]=j-n;	oblk[56]=i-m;
}

void BGBBTJ_JPG_TransIDCT_Vert2(int *iblk, short *oblk, int dcbias)
{
	int a, b, c, d, e, f;
	int i, j, k, l;
	int m, n, o, p;

	a=iblk[ 0]*6;	b=iblk[32]*6;
	c=iblk[16]*7;	d=iblk[16]*3;
	e=iblk[48]*7;	f=iblk[48]*3;
	i=a+c+b+f;	j=a+d-b-e;	k=a-d-b+e;	l=a-c+b-f;
	m=iblk[ 8]*8+iblk[24]*7+iblk[40]*4+iblk[56]*2;
	n=iblk[ 8]*7-iblk[24]*2-iblk[40]*8-iblk[56]*4;
	o=iblk[ 8]*4-iblk[24]*8+iblk[40]*2+iblk[56]*7;
	p=iblk[ 8]*2-iblk[24]*4+iblk[40]*7-iblk[56]*8;
	oblk[ 0]=((i+m)>>8)+dcbias;	oblk[ 8]=((j+n)>>8)+dcbias;
	oblk[16]=((k+o)>>8)+dcbias;	oblk[24]=((l+p)>>8)+dcbias;
	oblk[32]=((l-p)>>8)+dcbias;	oblk[40]=((k-o)>>8)+dcbias;
	oblk[48]=((j-n)>>8)+dcbias;	oblk[56]=((i-m)>>8)+dcbias;
}

// void BGBBTJ_JPG_TransIDCT(short *iblk, byte *oblk)
void BGBBTJ_JPG_TransIDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j, k;

	BGBBTJ_JPG_TransIDCT_Horiz(iblk+0, s+0);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+8, s+8);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+16, s+16);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+24, s+24);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+32, s+32);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+40, s+40);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+48, s+48);
	BGBBTJ_JPG_TransIDCT_Horiz(iblk+56, s+56);

#if 0
	BGBBTJ_JPG_TransIDCT_Vert(s+0, t+0);
	BGBBTJ_JPG_TransIDCT_Vert(s+1, t+1);
	BGBBTJ_JPG_TransIDCT_Vert(s+2, t+2);
	BGBBTJ_JPG_TransIDCT_Vert(s+3, t+3);
	BGBBTJ_JPG_TransIDCT_Vert(s+4, t+4);
	BGBBTJ_JPG_TransIDCT_Vert(s+5, t+5);
	BGBBTJ_JPG_TransIDCT_Vert(s+6, t+6);
	BGBBTJ_JPG_TransIDCT_Vert(s+7, t+7);
#endif

#if 1
	BGBBTJ_JPG_TransIDCT_Vert2(s+0, oblk+0, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+1, oblk+1, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+2, oblk+2, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+3, oblk+3, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+4, oblk+4, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+5, oblk+5, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+6, oblk+6, dcbias);
	BGBBTJ_JPG_TransIDCT_Vert2(s+7, oblk+7, dcbias);
#endif
}
#endif


#define FLTOFIX14(x)	((int)((x)*8192+0.5))
#define FIX14TOI(x)	(((x)+4096)>>13)

#if 0
//RDCT: Integer Reversible DCT (Lossless)

// void BGBBTJ_JPG_TransRDCT_Horiz(byte *iblk, int *oblk)
void BGBBTJ_JPG_TransRDCT_Horiz(short *iblk, int *oblk, int dcbias)
{
	int ib[8];

	ib[0]=iblk[2]-dcbias;	ib[1]=iblk[7]-dcbias;
	ib[2]=iblk[4]-dcbias;	ib[3]=iblk[3]-dcbias;
	ib[4]=iblk[6]-dcbias;	ib[5]=iblk[0]-dcbias;
	ib[6]=iblk[1]-dcbias;	ib[7]=iblk[5]-dcbias;

	ib[7]=(-ib[7])+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));
	ib[0]=ib[0]+FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[1]=ib[1]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[2]=ib[2]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[3]=ib[3]+FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[4]=ib[4]+FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[5]=ib[5]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[6]=ib[6]+FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[7]=ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	oblk[0]=ib[3];	oblk[1]=ib[6];
	oblk[2]=ib[4];	oblk[3]=ib[2];
	oblk[4]=ib[5];	oblk[5]=ib[7];
	oblk[6]=ib[0];	oblk[7]=ib[1];
}

void BGBBTJ_JPG_TransRDCT_Vert(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[16];	ib[1]=iblk[56];
	ib[2]=iblk[32];	ib[3]=iblk[24];
	ib[4]=iblk[48];	ib[5]=iblk[ 0];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	ib[7]=(-ib[7])+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));
	ib[0]=ib[0]+FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[1]=ib[1]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[2]=ib[2]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[3]=ib[3]+FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[4]=ib[4]+FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[5]=ib[5]+FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[6]=ib[6]+FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[7]=ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	oblk[0]=ib[3];	oblk[8]=ib[6];
	oblk[16]=ib[4];	oblk[24]=ib[2];
	oblk[32]=ib[5];	oblk[40]=ib[7];
	oblk[48]=ib[0];	oblk[56]=ib[1];
}

// void BGBBTJ_JPG_TransRDCT(byte *iblk, short *oblk)
void BGBBTJ_JPG_TransRDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	BGBBTJ_JPG_TransRDCT_Horiz(iblk+0, s+0, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+8, s+8, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+16, s+16, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+24, s+24, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+32, s+32, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+40, s+40, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+48, s+48, dcbias);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+56, s+56, dcbias);

	BGBBTJ_JPG_TransRDCT_Vert(s+0, t+0);
	BGBBTJ_JPG_TransRDCT_Vert(s+1, t+1);
	BGBBTJ_JPG_TransRDCT_Vert(s+2, t+2);
	BGBBTJ_JPG_TransRDCT_Vert(s+3, t+3);
	BGBBTJ_JPG_TransRDCT_Vert(s+4, t+4);
	BGBBTJ_JPG_TransRDCT_Vert(s+5, t+5);
	BGBBTJ_JPG_TransRDCT_Vert(s+6, t+6);
	BGBBTJ_JPG_TransRDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}
#endif

#if 0
#undef FLTOFIX14
#undef FIX14TOI
#define FLTOFIX14(x)	((int)((x)*16384+0.5))
#define FIX14TOI(x)	(((x)+8192)>>14)
#endif

#if 0
void BGBBTJ_JPG_TransIRDCT_Horiz(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[6];	ib[1]=iblk[7];
	ib[2]=iblk[3];	ib[3]=iblk[0];
	ib[4]=iblk[2];	ib[5]=iblk[4];
	ib[6]=iblk[1];	ib[7]=iblk[5];

	ib[7]=ib[7]-FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	ib[6]=ib[6]-FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[5]=ib[5]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[4]=ib[4]-FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[3]=ib[3]-FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[2]=ib[2]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[1]=ib[1]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[0]=ib[0]-FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[7]=-ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));

	oblk[0]=ib[5];	oblk[1]=ib[6];
	oblk[2]=ib[0];	oblk[3]=ib[3];
	oblk[4]=ib[2];	oblk[5]=ib[7];
	oblk[6]=ib[4];	oblk[7]=ib[1];
}

void BGBBTJ_JPG_TransIRDCT_Vert(short *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[48];	ib[1]=iblk[56];
	ib[2]=iblk[24];	ib[3]=iblk[ 0];
	ib[4]=iblk[16];	ib[5]=iblk[32];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	ib[7]=ib[7]-FIX14TOI(
		ib[0]*FLTOFIX14(1.1020)+		ib[1]*FLTOFIX14(-2.0306)+
		ib[2]*FLTOFIX14(-0.3881)+		ib[3]*FLTOFIX14(0.6561)+
		ib[4]*FLTOFIX14(1.2405)+		ib[5]*FLTOFIX14(1.6577)+
		ib[6]*FLTOFIX14(-1.1914));
	ib[6]=ib[6]-FIX14TOI(
		ib[0]*FLTOFIX14(1.0024)+		ib[1]*FLTOFIX14(-0.7180)+
		ib[2]*FLTOFIX14(-0.0928)+		ib[3]*FLTOFIX14(-0.0318)+
		ib[4]*FLTOFIX14(0.4170)+		ib[5]*FLTOFIX14(1.1665)+
		ib[7]*FLTOFIX14(0.4904));
	ib[5]=ib[5]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.6573)+		ib[1]*FLTOFIX14(0.5810)+
		ib[2]*FLTOFIX14(-0.2931)+		ib[3]*FLTOFIX14(-0.5307)+
		ib[4]*FLTOFIX14(-0.8730)+		ib[6]*FLTOFIX14(-0.1594)+
		ib[7]*FLTOFIX14(-0.3560));
	ib[4]=ib[4]-FIX14TOI(
		ib[0]*FLTOFIX14(0.4591)+		ib[1]*FLTOFIX14(0.4108)+
		ib[2]*FLTOFIX14(-0.2073)+		ib[3]*FLTOFIX14(-1.0824)+
		ib[5]*FLTOFIX14(0.7071)+		ib[6]*FLTOFIX14(0.8873)+
		ib[7]*FLTOFIX14(-0.2517));
	ib[3]=ib[3]-FIX14TOI(
		ib[0]*FLTOFIX14(0.7957)+		ib[1]*FLTOFIX14(0.9664)+
		ib[2]*FLTOFIX14(0.4439)+		ib[4]*FLTOFIX14(0.6173)+
		ib[5]*FLTOFIX14(-0.1422)+		ib[6]*FLTOFIX14(1.0378)+
		ib[7]*FLTOFIX14(-0.1700));
	ib[2]=ib[2]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0364)+		ib[1]*FLTOFIX14(-1.7104)+
		ib[3]*FLTOFIX14(-1.0000)+		ib[4]*FLTOFIX14(0.3066)+
		ib[5]*FLTOFIX14(0.6671)+		ib[6]*FLTOFIX14(-0.5953)+
		ib[7]*FLTOFIX14(0.2039));
	ib[1]=ib[1]-FIX14TOI(
		ib[0]*FLTOFIX14(-0.0685)+		ib[2]*FLTOFIX14(0.2708)+
		ib[3]*FLTOFIX14(-0.2708)+		ib[4]*FLTOFIX14(-0.2235)+
		ib[5]*FLTOFIX14(0.2568)+		ib[6]*FLTOFIX14(-0.3205)+
		ib[7]*FLTOFIX14(0.3841));
	ib[0]=ib[0]-FIX14TOI(
		ib[1]*FLTOFIX14(-1.1129)+		ib[2]*FLTOFIX14(0.0570)+
		ib[3]*FLTOFIX14(-0.4712)+		ib[4]*FLTOFIX14(0.1029)+
		ib[5]*FLTOFIX14(0.0156)+		ib[6]*FLTOFIX14(-0.4486)+
		ib[7]*FLTOFIX14(-0.4619));
	ib[7]=-ib[7]+FIX14TOI(
		ib[0]*FLTOFIX14(1.1648)+		ib[1]*FLTOFIX14(-2.8234)+
		ib[2]*FLTOFIX14(0.5375)+		ib[3]*FLTOFIX14(-0.6058)+
		ib[4]*FLTOFIX14(1.2228)+		ib[5]*FLTOFIX14(-0.3805)+
		ib[6]*FLTOFIX14(0.0288));

	oblk[ 0]=ib[5];	oblk[ 8]=ib[6];
	oblk[16]=ib[0];	oblk[24]=ib[3];
	oblk[32]=ib[2];	oblk[40]=ib[7];
	oblk[48]=ib[4];	oblk[56]=ib[1];
}

#if 0
// void BGBBTJ_JPG_TransIRDCT(short *iblk, byte *oblk)
void BGBBTJ_JPG_TransIRDCT(short *iblk, short *oblk, int dcbias)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	BGBBTJ_JPG_TransIRDCT_Vert(iblk+0, s+0);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+1, s+1);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+2, s+2);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+3, s+3);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+4, s+4);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+5, s+5);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+6, s+6);
	BGBBTJ_JPG_TransIRDCT_Vert(iblk+7, s+7);

	BGBBTJ_JPG_TransIRDCT_Horiz(s+0, t+0);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+8, t+8);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+16, t+16);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+24, t+24);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+32, t+32);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+40, t+40);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+48, t+48);
	BGBBTJ_JPG_TransIRDCT_Horiz(s+56, t+56);

	for(i=0; i<64; i++)
	{
		j=(t[i])+dcbias;
//		if(j&(~255))j=(j<0)?0:((j>255)?255:j);
		oblk[i]=j;
	}
}
#endif

#endif

void BGBBTJ_JPG_TransRDCT_Ref(
	int iblk0, int iblk1, int iblk2, int iblk3,
	int iblk4, int iblk5, int iblk6, int iblk7,
	int *oblk0, int *oblk1, int *oblk2, int *oblk3,
	int *oblk4, int *oblk5, int *oblk6, int *oblk7)
{
	int ib0, ib1, ib2, ib3, ib4, ib5, ib6, ib7;

	ib0=iblk2; ib1=iblk7;
	ib2=iblk4; ib3=iblk3;
	ib4=iblk6; ib5=iblk0;
	ib6=iblk1; ib7=iblk5;

	//9542 -23129 4403 -4963 10017 -3117 236
	//-9117 467 -3860 843 128 -3675 -3784
	//-561 2218 -2218 -1831 2104 -2626 3147
	//-298 -14012 -8192 2512 5465 -4877 1670
	//6518 7917 3636 5057 -1165 8502 -1393
	//3761 3365 -1698 -8867 5793 7269 -2062
	//-5385 4760 -2401 -4347 -7152 -1306 -2916
	//8212 -5882 -760 -261 3416 9556 4017
	//9028 -16635 -3179 5375 10162 13580 -9760

#if 1
	ib7=(-ib7) + (((ib0*9542 + ib1*-23129 +
		ib2*4403 + ib3*-4963 + ib4*10017 +
		ib5*-3117 + ib6*236) + 4096) >> 13);
	ib0=ib0 + (((ib1*-9117 + ib2*467 +
		ib3*-3860 + ib4*843 + ib5*128 +
		ib6*-3675 + ib7*-3784) + 4096) >> 13);
	ib1=ib1 + (((ib0*-561 + ib2*2218 +
		ib3*-2218 + ib4*-1831 + ib5*2104 +
		ib6*-2626 + ib7*3147) + 4096) >> 13);
	ib2=ib2 + (((ib0*-298 + ib1*-14012 +
		ib3*-8192 + ib4*2512 + ib5*5465 +
		ib6*-4877 + ib7*1670) + 4096) >> 13);
	ib3=ib3 + (((ib0*6518 + ib1*7917 +
		ib2*3636 + ib4*5057 + ib5*-1165 +
		ib6*8502 + ib7*-1393) + 4096) >> 13);
	ib4=ib4 + (((ib0*3761 + ib1*3365 +
		ib2*-1698 + ib3*-8867 + ib5*5793 +
		ib6*7269 + ib7*-2062) + 4096) >> 13);
	ib5=ib5 + (((ib0*-5385 + ib1*4760 +
		ib2*-2401 + ib3*-4347 + ib4*-7152 +
		ib6*-1306 + ib7*-2916) + 4096) >> 13);
	ib6=ib6 + (((ib0*8212 + ib1*-5882 +
		ib2*-760 + ib3*-261 + ib4*3416 +
		ib5*9556 + ib7*4017) + 4096) >> 13);
	ib7=ib7 + (((ib0*9028 + ib1*-16635 +
		ib2*-3179 + ib3*5375 + ib4*10162 +
		ib5*13580 + ib6*-9760) + 4096) >> 13);
#endif

	*oblk0=ib3; *oblk1=ib6;
	*oblk2=ib4; *oblk3=ib2;
	*oblk4=ib5; *oblk5=ib7;
	*oblk6=ib0; *oblk7=ib1;
}

void BGBBTJ_JPG_TransIRDCT_Ref(
	int iblk0, int iblk1, int iblk2, int iblk3,
	int iblk4, int iblk5, int iblk6, int iblk7,
	int *oblk0, int *oblk1, int *oblk2, int *oblk3,
	int *oblk4, int *oblk5, int *oblk6, int *oblk7)
{
	int ib0, ib1, ib2, ib3, ib4, ib5, ib6, ib7;

	ib0=iblk6; ib1=iblk7;
	ib2=iblk3; ib3=iblk0;
	ib4=iblk2; ib5=iblk4;
	ib6=iblk1; ib7=iblk5;

	//9028 -16635 -3179 5375 10162 13580 -9760
	//8212 -5882 -760 -261 3416 9556 4017
	//-5385 4760 -2401 -4347 -7152 -1306 -2916
	//3761 3365 -1698 -8867 5793 7269 -2062
	//6518 7917 3636 5057 -1165 8502 -1393
	//-298 -14012 -8192 2512 5465 -4877 1670
	//-561 2218 -2218 -1831 2104 -2626 3147
	//-9117 467 -3860 843 128 -3675 -3784
	//9542 -23129 4403 -4963 10017 -3117 236

#if 1
	ib7=ib7 - (((ib0*9028 + ib1*-16635 +
		ib2*-3179 + ib3*5375 + ib4*10162 +
		ib5*13580 + ib6*-9760) + 4096) >> 13);
	ib6=ib6 - (((ib0*8212 + ib1*-5882 +
		ib2*-760 + ib3*-261 + ib4*3416 +
		ib5*9556 + ib7*4017) + 4096) >> 13);
	ib5=ib5 - (((ib0*-5385 + ib1*4760 +
		ib2*-2401 + ib3*-4347 + ib4*-7152 +
		ib6*-1306 + ib7*-2916) + 4096) >> 13);
	ib4=ib4 - (((ib0*3761 + ib1*3365 +
		ib2*-1698 + ib3*-8867 + ib5*5793 +
		ib6*7269 + ib7*-2062) + 4096) >> 13);
	ib3=ib3 - (((ib0*6518 + ib1*7917 +
		ib2*3636 + ib4*5057 + ib5*-1165 +
		ib6*8502 + ib7*-1393) + 4096) >> 13);
	ib2=ib2 - (((ib0*-298 + ib1*-14012 +
		ib3*-8192 + ib4*2512 + ib5*5465 +
		ib6*-4877 + ib7*1670) + 4096) >> 13);
	ib1=ib1 - (((ib0*-561 + ib2*2218 +
		ib3*-2218 + ib4*-1831 + ib5*2104 +
		ib6*-2626 + ib7*3147) + 4096) >> 13);
	ib0=ib0 - (((ib1*-9117 + ib2*467 +
		ib3*-3860 + ib4*843 + ib5*128 +
		ib6*-3675 + ib7*-3784) + 4096) >> 13);
	ib7=-ib7 + (((ib0*9542 + ib1*-23129 +
		ib2*4403 + ib3*-4963 + ib4*10017 +
		ib5*-3117 + ib6*236) + 4096) >> 13);
#endif

	*oblk0=ib5; *oblk1=ib6;
	*oblk2=ib0; *oblk3=ib3;
	*oblk4=ib2; *oblk5=ib7;
	*oblk6=ib4; *oblk7=ib1;
}

void BGBBTJ_JPG_TransRDCT(short *iblk, short *oblk, int dcbias)
{
	int s00, s01, s02, s03, s04, s05, s06, s07;
	int s10, s11, s12, s13, s14, s15, s16, s17;
	int s20, s21, s22, s23, s24, s25, s26, s27;
	int s30, s31, s32, s33, s34, s35, s36, s37;
	int s40, s41, s42, s43, s44, s45, s46, s47;
	int s50, s51, s52, s53, s54, s55, s56, s57;
	int s60, s61, s62, s63, s64, s65, s66, s67;
	int s70, s71, s72, s73, s74, s75, s76, s77;
	int t00, t01, t02, t03, t04, t05, t06, t07;
	int t10, t11, t12, t13, t14, t15, t16, t17;
	int t20, t21, t22, t23, t24, t25, t26, t27;
	int t30, t31, t32, t33, t34, t35, t36, t37;
	int t40, t41, t42, t43, t44, t45, t46, t47;
	int t50, t51, t52, t53, t54, t55, t56, t57;
	int t60, t61, t62, t63, t64, t65, t66, t67;
	int t70, t71, t72, t73, t74, t75, t76, t77;
	//int i;

	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[ 0] - dcbias, iblk[ 1] - dcbias,
		iblk[ 2] - dcbias, iblk[ 3] - dcbias,
		iblk[ 4] - dcbias, iblk[ 5] - dcbias,
		iblk[ 6] - dcbias, iblk[ 7] - dcbias,
		&s00, &s01, &s02, &s03,
		&s04, &s05, &s06, &s07);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[ 8] - dcbias, iblk[ 9] - dcbias,
		iblk[10] - dcbias, iblk[11] - dcbias,
		iblk[12] - dcbias, iblk[13] - dcbias,
		iblk[14] - dcbias, iblk[15] - dcbias,
		&s10, &s11, &s12, &s13,
		&s14, &s15, &s16, &s17);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[16] - dcbias, iblk[17] - dcbias,
		iblk[18] - dcbias, iblk[19] - dcbias,
		iblk[20] - dcbias, iblk[21] - dcbias,
		iblk[22] - dcbias, iblk[23] - dcbias,
		&s20, &s21, &s22, &s23,
		&s24, &s25, &s26, &s27);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[24] - dcbias, iblk[25] - dcbias,
		iblk[26] - dcbias, iblk[27] - dcbias,
		iblk[28] - dcbias, iblk[29] - dcbias,
		iblk[30] - dcbias, iblk[31] - dcbias,
		&s30, &s31, &s32, &s33, 
		&s34, &s35, &s36, &s37);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[32] - dcbias, iblk[33] - dcbias,
		iblk[34] - dcbias, iblk[35] - dcbias,
		iblk[36] - dcbias, iblk[37] - dcbias,
		iblk[38] - dcbias, iblk[39] - dcbias,
		&s40, &s41, &s42, &s43,
		&s44, &s45, &s46, &s47);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[40] - dcbias, iblk[41] - dcbias,
		iblk[42] - dcbias, iblk[43] - dcbias,
		iblk[44] - dcbias, iblk[45] - dcbias,
		iblk[46] - dcbias, iblk[47] - dcbias,
		&s50, &s51, &s52, &s53,
		&s54, &s55, &s56, &s57);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[48] - dcbias, iblk[49] - dcbias,
		iblk[50] - dcbias, iblk[51] - dcbias,
		iblk[52] - dcbias, iblk[53] - dcbias,
		iblk[54] - dcbias, iblk[55] - dcbias,
		&s60, &s61, &s62, &s63,
		&s64, &s65, &s66, &s67);
	BGBBTJ_JPG_TransRDCT_Ref(
		iblk[56] - dcbias, iblk[57] - dcbias,
		iblk[58] - dcbias, iblk[59] - dcbias,
		iblk[60] - dcbias, iblk[61] - dcbias,
		iblk[62] - dcbias, iblk[63] - dcbias,
		&s70, &s71, &s72, &s73,
		&s74, &s75, &s76, &s77);

	BGBBTJ_JPG_TransRDCT_Ref(s00, s10, s20, s30, s40, s50, s60, s70,
		&t00, &t10, &t20, &t30, &t40, &t50, &t60, &t70);
	BGBBTJ_JPG_TransRDCT_Ref(s01, s11, s21, s31, s41, s51, s61, s71,
		&t01, &t11, &t21, &t31, &t41, &t51, &t61, &t71);
	BGBBTJ_JPG_TransRDCT_Ref(s02, s12, s22, s32, s42, s52, s62, s72,
		&t02, &t12, &t22, &t32, &t42, &t52, &t62, &t72);
	BGBBTJ_JPG_TransRDCT_Ref(s03, s13, s23, s33, s43, s53, s63, s73,
		&t03, &t13, &t23, &t33, &t43, &t53, &t63, &t73);
	BGBBTJ_JPG_TransRDCT_Ref(s04, s14, s24, s34, s44, s54, s64, s74,
		&t04, &t14, &t24, &t34, &t44, &t54, &t64, &t74);
	BGBBTJ_JPG_TransRDCT_Ref(s05, s15, s25, s35, s45, s55, s65, s75,
		&t05, &t15, &t25, &t35, &t45, &t55, &t65, &t75);
	BGBBTJ_JPG_TransRDCT_Ref(s06, s16, s26, s36, s46, s56, s66, s76,
		&t06, &t16, &t26, &t36, &t46, &t56, &t66, &t76);
	BGBBTJ_JPG_TransRDCT_Ref(s07, s17, s27, s37, s47, s57, s67, s77,
		&t07, &t17, &t27, &t37, &t47, &t57, &t67, &t77);

	oblk[ 0]=t00; oblk[ 1]=t01; oblk[ 2]=t02; oblk[ 3]=t03;
	oblk[ 4]=t04; oblk[ 5]=t05; oblk[ 6]=t06; oblk[ 7]=t07;
	oblk[ 8]=t10; oblk[ 9]=t11; oblk[10]=t12; oblk[11]=t13;
	oblk[12]=t14; oblk[13]=t15; oblk[14]=t16; oblk[15]=t17;
	oblk[16]=t20; oblk[17]=t21; oblk[18]=t22; oblk[19]=t23;
	oblk[20]=t24; oblk[21]=t25; oblk[22]=t26; oblk[23]=t27;
	oblk[24]=t30; oblk[25]=t31; oblk[26]=t32; oblk[27]=t33;
	oblk[28]=t34; oblk[29]=t35; oblk[30]=t36; oblk[31]=t37;
	oblk[32]=t40; oblk[33]=t41; oblk[34]=t42; oblk[35]=t43;
	oblk[36]=t44; oblk[37]=t45; oblk[38]=t46; oblk[39]=t47;
	oblk[40]=t50; oblk[41]=t51; oblk[42]=t52; oblk[43]=t53;
	oblk[44]=t54; oblk[45]=t55; oblk[46]=t56; oblk[47]=t57;
	oblk[48]=t60; oblk[49]=t61; oblk[50]=t62; oblk[51]=t63;
	oblk[52]=t64; oblk[53]=t65; oblk[54]=t66; oblk[55]=t67;
	oblk[56]=t70; oblk[57]=t71; oblk[58]=t72; oblk[59]=t73;
	oblk[60]=t74; oblk[61]=t75; oblk[62]=t76; oblk[63]=t77;
}

void BGBBTJ_JPG_TransIRDCT(short *iblk, short *oblk, int dcbias)
{
	int s00, s01, s02, s03, s04, s05, s06, s07;
	int s10, s11, s12, s13, s14, s15, s16, s17;
	int s20, s21, s22, s23, s24, s25, s26, s27;
	int s30, s31, s32, s33, s34, s35, s36, s37;
	int s40, s41, s42, s43, s44, s45, s46, s47;
	int s50, s51, s52, s53, s54, s55, s56, s57;
	int s60, s61, s62, s63, s64, s65, s66, s67;
	int s70, s71, s72, s73, s74, s75, s76, s77;
	int t00, t01, t02, t03, t04, t05, t06, t07;
	int t10, t11, t12, t13, t14, t15, t16, t17;
	int t20, t21, t22, t23, t24, t25, t26, t27;
	int t30, t31, t32, t33, t34, t35, t36, t37;
	int t40, t41, t42, t43, t44, t45, t46, t47;
	int t50, t51, t52, t53, t54, t55, t56, t57;
	int t60, t61, t62, t63, t64, t65, t66, t67;
	int t70, t71, t72, t73, t74, t75, t76, t77;

	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 0], iblk[ 8], iblk[16], iblk[24],
		iblk[32], iblk[40], iblk[48], iblk[56],
		&s00, &s10, &s20, &s30, &s40, &s50, &s60, &s70);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 1], iblk[ 9], iblk[17], iblk[25],
		iblk[33], iblk[41], iblk[49], iblk[57],
		&s01, &s11, &s21, &s31, &s41, &s51, &s61, &s71);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 2], iblk[10], iblk[18], iblk[26],
		iblk[34], iblk[42], iblk[50], iblk[58],
		&s02, &s12, &s22, &s32, &s42, &s52, &s62, &s72);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 3], iblk[11], iblk[19], iblk[27],
		iblk[35], iblk[43], iblk[51], iblk[59],
		&s03, &s13, &s23, &s33, &s43, &s53, &s63, &s73);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 4], iblk[12], iblk[20], iblk[28],
		iblk[36], iblk[44], iblk[52], iblk[60],
		&s04, &s14, &s24, &s34, &s44, &s54, &s64, &s74);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 5], iblk[13], iblk[21], iblk[29],
		iblk[37], iblk[45], iblk[53], iblk[61],
		&s05, &s15, &s25, &s35, &s45, &s55, &s65, &s75);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 6], iblk[14], iblk[22], iblk[30],
		iblk[38], iblk[46], iblk[54], iblk[62],
		&s06, &s16, &s26, &s36, &s46, &s56, &s66, &s76);
	BGBBTJ_JPG_TransIRDCT_Ref(
		iblk[ 7], iblk[15], iblk[23], iblk[31],
		iblk[39], iblk[47], iblk[55], iblk[63],
		&s07, &s17, &s27, &s37, &s47, &s57, &s67, &s77);

	BGBBTJ_JPG_TransIRDCT_Ref(s00, s01, s02, s03, s04, s05, s06, s07,
		&t00, &t01, &t02, &t03, &t04, &t05, &t06, &t07);
	BGBBTJ_JPG_TransIRDCT_Ref(s10, s11, s12, s13, s14, s15, s16, s17,
		&t10, &t11, &t12, &t13, &t14, &t15, &t16, &t17);
	BGBBTJ_JPG_TransIRDCT_Ref(s20, s21, s22, s23, s24, s25, s26, s27,
		&t20, &t21, &t22, &t23, &t24, &t25, &t26, &t27);
	BGBBTJ_JPG_TransIRDCT_Ref(s30, s31, s32, s33, s34, s35, s36, s37,
		&t30, &t31, &t32, &t33, &t34, &t35, &t36, &t37);
	BGBBTJ_JPG_TransIRDCT_Ref(s40, s41, s42, s43, s44, s45, s46, s47,
		&t40, &t41, &t42, &t43, &t44, &t45, &t46, &t47);
	BGBBTJ_JPG_TransIRDCT_Ref(s50, s51, s52, s53, s54, s55, s56, s57,
		&t50, &t51, &t52, &t53, &t54, &t55, &t56, &t57);
	BGBBTJ_JPG_TransIRDCT_Ref(s60, s61, s62, s63, s64, s65, s66, s67,
		&t60, &t61, &t62, &t63, &t64, &t65, &t66, &t67);
	BGBBTJ_JPG_TransIRDCT_Ref(s70, s71, s72, s73, s74, s75, s76, s77,
		&t70, &t71, &t72, &t73, &t74, &t75, &t76, &t77);

	oblk[ 0]=t00 + dcbias; oblk[ 1]=t01 + dcbias;
	oblk[ 2]=t02 + dcbias; oblk[ 3]=t03 + dcbias;
	oblk[ 4]=t04 + dcbias; oblk[ 5]=t05 + dcbias;
	oblk[ 6]=t06 + dcbias; oblk[ 7]=t07 + dcbias;
	oblk[ 8]=t10 + dcbias; oblk[ 9]=t11 + dcbias;
	oblk[10]=t12 + dcbias; oblk[11]=t13 + dcbias;
	oblk[12]=t14 + dcbias; oblk[13]=t15 + dcbias;
	oblk[14]=t16 + dcbias; oblk[15]=t17 + dcbias;
	oblk[16]=t20 + dcbias; oblk[17]=t21 + dcbias;
	oblk[18]=t22 + dcbias; oblk[19]=t23 + dcbias;
	oblk[20]=t24 + dcbias; oblk[21]=t25 + dcbias;
	oblk[22]=t26 + dcbias; oblk[23]=t27 + dcbias;
	oblk[24]=t30 + dcbias; oblk[25]=t31 + dcbias;
	oblk[26]=t32 + dcbias; oblk[27]=t33 + dcbias;
	oblk[28]=t34 + dcbias; oblk[29]=t35 + dcbias;
	oblk[30]=t36 + dcbias; oblk[31]=t37 + dcbias;
	oblk[32]=t40 + dcbias; oblk[33]=t41 + dcbias;
	oblk[34]=t42 + dcbias; oblk[35]=t43 + dcbias;
	oblk[36]=t44 + dcbias; oblk[37]=t45 + dcbias;
	oblk[38]=t46 + dcbias; oblk[39]=t47 + dcbias;
	oblk[40]=t50 + dcbias; oblk[41]=t51 + dcbias;
	oblk[42]=t52 + dcbias; oblk[43]=t53 + dcbias;
	oblk[44]=t54 + dcbias; oblk[45]=t55 + dcbias;
	oblk[46]=t56 + dcbias; oblk[47]=t57 + dcbias;
	oblk[48]=t60 + dcbias; oblk[49]=t61 + dcbias;
	oblk[50]=t62 + dcbias; oblk[51]=t63 + dcbias;
	oblk[52]=t64 + dcbias; oblk[53]=t65 + dcbias;
	oblk[54]=t66 + dcbias; oblk[55]=t67 + dcbias;
	oblk[56]=t70 + dcbias; oblk[57]=t71 + dcbias;
	oblk[58]=t72 + dcbias; oblk[59]=t73 + dcbias;
	oblk[60]=t74 + dcbias; oblk[61]=t75 + dcbias;
	oblk[62]=t76 + dcbias; oblk[63]=t77 + dcbias;
}

#if 0
//HAD: Hadamard Transform (Lossless)

void BGBBTJ_JPG_TransHAD_Horiz(byte *iblk, int *oblk)
{
	int ia[8];
	int ib[8];
	int ic[8];
	int id[8];

	ib[0]=iblk[0]-128;	ib[1]=iblk[1]-128;
	ib[2]=iblk[2]-128;	ib[3]=iblk[3]-128;
	ib[4]=iblk[4]-128;	ib[5]=iblk[5]-128;
	ib[6]=iblk[6]-128;	ib[7]=iblk[7]-128;

	ia[0]=ib[0]+ib[4];
	ia[1]=ib[1]+ib[5];
	ia[2]=ib[2]+ib[6];
	ia[3]=ib[3]+ib[7];
	ia[4]=(ia[0]>>1)-ib[4];
	ia[5]=(ia[1]>>1)-ib[5];
	ia[6]=(ia[2]>>1)-ib[6];
	ia[7]=(ia[3]>>1)-ib[7];

	ic[0]=ia[0]+ia[2];
	ic[1]=ia[1]+ia[3];
	ic[2]=(ic[0]>>1)-ia[2];
	ic[3]=(ic[1]>>1)-ia[3];
	ic[4]=ia[4]+ia[6];
	ic[5]=ia[5]+ia[7];
	ic[6]=(ic[4]>>1)-ia[6];
	ic[7]=(ic[5]>>1)-ia[7];

	id[0]=ic[0]+ic[1];
	id[1]=(id[0]>>1)-ic[1];
	id[2]=ic[2]+ic[3];
	id[3]=(id[2]>>1)-ic[3];
	id[4]=ic[4]+ic[5];
	id[5]=(id[4]>>1)-ic[5];
	id[6]=ic[6]+ic[7];
	id[7]=(id[6]>>1)-ic[7];

	oblk[0]=id[0];	oblk[1]=id[4];
	oblk[2]=id[6];	oblk[3]=id[2];
	oblk[4]=id[3];	oblk[5]=id[7];
	oblk[6]=id[5];	oblk[7]=id[1];
}

void BGBBTJ_JPG_TransHAD_Vert(int *iblk, int *oblk)
{
	int ib[8];

	ib[0]=iblk[16];	ib[1]=iblk[56];
	ib[2]=iblk[32];	ib[3]=iblk[24];
	ib[4]=iblk[48];	ib[5]=iblk[ 0];
	ib[6]=iblk[ 8];	ib[7]=iblk[40];

	oblk[0]=ib[3];	oblk[8]=ib[6];
	oblk[16]=ib[4];	oblk[24]=ib[2];
	oblk[32]=ib[5];	oblk[40]=ib[7];
	oblk[48]=ib[0];	oblk[56]=ib[1];
}

void BGBBTJ_JPG_TransHAD(byte *iblk, short *oblk)
{
	int s[DCTSZ2];
	int t[DCTSZ2];
	int i, j;

	BGBBTJ_JPG_TransHAD_Horiz(iblk+0, s+0);
	BGBBTJ_JPG_TransHAD_Horiz(iblk+8, s+8);
	BGBBTJ_JPG_TransHAD_Horiz(iblk+16, s+16);
	BGBBTJ_JPG_TransHAD_Horiz(iblk+24, s+24);
	BGBBTJ_JPG_TransHAD_Horiz(iblk+32, s+32);
	BGBBTJ_JPG_TransHAD_Horiz(iblk+40, s+40);
	BGBBTJ_JPG_TransHAD_Horiz(iblk+48, s+48);
	BGBBTJ_JPG_TransRDCT_Horiz(iblk+56, s+56);

	BGBBTJ_JPG_TransRDCT_Vert(s+0, t+0);
	BGBBTJ_JPG_TransRDCT_Vert(s+1, t+1);
	BGBBTJ_JPG_TransRDCT_Vert(s+2, t+2);
	BGBBTJ_JPG_TransRDCT_Vert(s+3, t+3);
	BGBBTJ_JPG_TransRDCT_Vert(s+4, t+4);
	BGBBTJ_JPG_TransRDCT_Vert(s+5, t+5);
	BGBBTJ_JPG_TransRDCT_Vert(s+6, t+6);
	BGBBTJ_JPG_TransRDCT_Vert(s+7, t+7);

	for(i=0; i<64; i++)
		oblk[i]=t[i];
}
#endif
#include <bgbbtj.h>

extern const int pdjpg_zigzag[64];
extern const int pdjpg_zigzag2[64];

int BGBBTJ_Huff_NextByte(BGBBTJ_JPG_Context *ctx)
{
	int i, j;

//	if(pdjhuff_isend)return(0xFF);
	if(pdjhuff_isend)return(0x00);

	i=*pdjhuff_cs++;
	if(i==0xFF)
	{
		j=*pdjhuff_cs++;
		if(j)
		{
//			printf("BGBBTJ_Huff_NextByte: Bitstream Marker %02X\n", j);
			pdjhuff_isend=1;
			return(0x00);
		}
	}
	return(i);
}

int BGBBTJ_Huff_InitStream(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	pdjhuff_pos=0;
	pdjhuff_isend=0;

	pdjhuff_cs=buf;
	pdjhuff_win=BGBBTJ_Huff_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
	pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
	return(0);
}

int BGBBTJ_Huff_ReadBit(BGBBTJ_JPG_Context *ctx)
{
	int i;

	i=(pdjhuff_win>>(31-pdjhuff_pos))&1;
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

int BGBBTJ_Huff_ReadNBits(BGBBTJ_JPG_Context *ctx, int n)
{
	int i;

	if(n<=0)return(0);

	i=(pdjhuff_win>>(32-n-pdjhuff_pos))&((1<<n)-1);
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
		pdjhuff_pos-=8;
	}
	return(i);
}

void BGBBTJ_Huff_SkipNBits(BGBBTJ_JPG_Context *ctx, int n)
{
	pdjhuff_pos+=n;
	while(pdjhuff_pos>=8)
	{
		pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
		pdjhuff_pos-=8;
	}
}

int BGBBTJ_Huff_PeekWord(BGBBTJ_JPG_Context *ctx)
{
	int i;
	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
	return(i);
}

#if 1
int BGBBTJ_Huff_DecodeSymbol(BGBBTJ_JPG_Context *ctx, int tab)
{
	int i, j, k, l;

//	i=BGBBTJ_Huff_PeekWord(ctx);
//	i=(pdjhuff_win>>(16-pdjhuff_pos))&65535;
//	i=(u16)(pdjhuff_win>>(16-pdjhuff_pos));

	i=(byte)(pdjhuff_win>>(24-pdjhuff_pos));
	
	tab<<=8;
//	j=ctx->huff_idx[tab|k];
//	j=ctx->huff_idx[tab|(i>>8)];
	j=ctx->huff_idx[tab|i];

#if 1
//	l=tab|j;
//	k=ctx->huff_len[l];
	k=ctx->huff_len[tab|j];
//	if(0)
	if(k<=8)
//	if(k<8)
	{
		pdjhuff_pos+=k;
//		while(pdjhuff_pos>=8)
		if(pdjhuff_pos>=8)
		{
			pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
			pdjhuff_pos-=8;
		}

//		BGBBTJ_Huff_SkipNBits(ctx, k);
		return(j);
	}
#endif

	i=(u16)(pdjhuff_win>>(16-pdjhuff_pos));
	j=ctx->huff_idx[tab|(i>>8)];

	while(1)
	{
		l=tab|j;
		k=ctx->huff_len[l];
		if(!k)
		{
//			printf("BGBBTJ_Huff_DecodeSymbol: Trap A\n");
			break;
		}

#if 1
		if((i>>(16-k))!=ctx->huff_code[l])
//		if((k>=8) && (i>>(16-k))!=ctx->huff_code[l])
		{
			j=ctx->huff_next[l];
//			if(!j)
			if(j<0)
			{
//				printf("BGBBTJ_Huff_DecodeSymbol: Trap B\n");
				break;
			}
			continue;
		}
#endif

		pdjhuff_pos+=k;
		while(pdjhuff_pos>=8)
//		if(pdjhuff_pos>=8)
		{
			pdjhuff_win=(pdjhuff_win<<8)|BGBBTJ_Huff_NextByte(ctx);
			pdjhuff_pos-=8;
		}

//		BGBBTJ_Huff_SkipNBits(ctx, k);
		return(j);
	}

#if 0
	i=BGBBTJ_Huff_PeekWord(ctx);
	for(j=0; j<256; j++)
	{
		k=ctx->huff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=ctx->huff_code[tab|j])
			continue;
		BGBBTJ_Huff_SkipNBits(ctx, k);
		return(j);
	}
#endif

	return(-1);
}
#endif


#if 0
int BGBBTJ_Huff_DecodeSymbol(BGBBTJ_JPG_Context *ctx, int tab)
{
	int i, j, k, l;

	tab<<=8;

#if 0
	i=BGBBTJ_Huff_PeekWord(ctx);
	j=ctx->huff_idx[tab|(i>>8)];
	while(1)
	{
		l=tab|j;
		k=ctx->huff_len[l];
//		if(!k)break;

		if((i>>(16-k))!=ctx->huff_code[l])
		{
			j=ctx->huff_next[l];
			if(!j)break;
			continue;
		}
		BGBBTJ_Huff_SkipNBits(ctx, k);
		return(j);
	}
#endif

#if 1
	i=BGBBTJ_Huff_PeekWord(ctx);
	for(j=0; j<256; j++)
	{
		k=ctx->huff_len[tab|j];
		if(!k)continue;

		if((i>>(16-k))!=ctx->huff_code[tab|j])
			continue;
		BGBBTJ_Huff_SkipNBits(ctx, k);
		return(j);
	}
#endif

	return(-1);
}
#endif

int BGBBTJ_Huff_DecodeDiffDC(BGBBTJ_JPG_Context *ctx, int tab)
{
	int i, j;

	i=BGBBTJ_Huff_DecodeSymbol(ctx, tab);
	j=BGBBTJ_Huff_ReadNBits(ctx, i);

	if(!(j&(1<<(i-1))))
		j=(-1<<i)+j+1;
	return(j);
}

int BGBBTJ_Huff_DecodeBlock(BGBBTJ_JPG_Context *ctx,
	short *buf, int dctab, int actab,
	int ni, int nn)
{
	int i, j, k;

//	for(i=1; i<64; i++)buf[i]=0;
	memset(buf+1, 0, 63*sizeof(short));

	buf[0]+=BGBBTJ_Huff_DecodeDiffDC(ctx, dctab);
	for(i=1; i<64; i++)
	{
		j=BGBBTJ_Huff_DecodeSymbol(ctx, actab);
		if(j<=0)
		{
			if(j<0)
			{
				printf("bad dct block1 %02X(%d) %d/%d\n", j, j, ni, nn);
				return(-1);
			}
			break;
		}

		i+=(j>>4)&15;	//preceding 0's
		if(!(j&15))continue;
		if(i>=64)
		{
//			printf("bad dct block3 %02X(%d) len=%d %d/%d\n",
//				j, j, i, ni, nn);
			break;
		}

		j&=15;
		k=BGBBTJ_Huff_ReadNBits(ctx, j);
		if(!(k&(1<<(j-1))))
			k=(-1<<j)+k+1;

		j=pdjpg_zigzag2[i];
		buf[j]=k;
	}

#if 0
	for(j=i+1; j<64; j++)
	{
//		buf[i]=0;
		buf[pdjpg_zigzag2[j]]=0;
	}
#endif

	if(i>64)
	{
		printf("bad dct block2 %02X(%d) len=%d %d/%d\n", j, j, i, ni, nn);
		return(-1);
	}

	return(0);
}

void BGBBTJ_Huff_QuantBlock(
	BGBBTJ_JPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	int i, j;
	
//	for(i=0; i<64; i++)
//		obuf[i]=ibuf[i]/ctx->jpg_qt[qid][i];

	for(i=0; i<64; i++)
		obuf[i]=((ibuf[i]*ctx->jpg_qtfp[qid][i])+2048)>>12;
}

void BGBBTJ_Huff_DequantBlock(
	BGBBTJ_JPG_Context *ctx, short *ibuf, short *obuf, int qid)
{
	short *ib, *ob;
	byte *qt, *qt1;
	int i, j;
//	for(i=0; i<64; i++)
//		obuf[i]=ibuf[i]*ctx->jpg_qt[qid][i];

	qt=ctx->jpg_qt[qid];
	for(i=0; i<8; i++)
	{
		j=i*8; qt1=qt+j; ib=ibuf+j; ob=obuf+j;
		ob[0]=ib[0]*qt1[0];
		ob[1]=ib[1]*qt1[1];
		ob[2]=ib[2]*qt1[2];
		ob[3]=ib[3]*qt1[3];
		ob[4]=ib[4]*qt1[4];
		ob[5]=ib[5]*qt1[5];
		ob[6]=ib[6]*qt1[6];
		ob[7]=ib[7]*qt1[7];
	}
}
#include <bgbbtj.h>

extern const int pdjpg_zigzag[64];
extern const int pdjpg_zigzag2[64];

extern float pdjpg_exptab[256];
extern float pdjpg_scltab[256];

//Encoder

void BGBBTJ_Huff_WriteBit(BGBBTJ_JPG_Context *ctx, int i)
{
	pdjhuff_win|=i<<(31-pdjhuff_pos);
	pdjhuff_pos++;
	if(pdjhuff_pos>=8)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void BGBBTJ_Huff_WriteNBits(BGBBTJ_JPG_Context *ctx, int v, int n)
{
	int i, j, k;

	v&=(1<<n)-1;

	j=pdjhuff_pos+n;
	k=pdjhuff_win|(v<<(32-j));
	while(j>=8)
	{
		i=(k>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		k<<=8;
		j-=8;
	}
	pdjhuff_pos=j;
	pdjhuff_win=k;

//	pdjhuff_win|=i<<((32-n)-pdjhuff_pos);
//	pdjhuff_pos+=n;
//	while(pdjhuff_pos>=8)
//	{
//		i=(pdjhuff_win>>24)&0xFF;
//		*pdjhuff_ct++=i;
//		if(i==0xFF)*pdjhuff_ct++=0x00;
//		pdjhuff_win<<=8;
//		pdjhuff_pos-=8;
//	}
}

void BGBBTJ_Huff_FlushBits(BGBBTJ_JPG_Context *ctx)
{
	int i;
	while(pdjhuff_pos>0)
	{
		i=(pdjhuff_win>>24)&0xFF;
		*pdjhuff_ct++=i;
		if(i==0xFF)*pdjhuff_ct++=0x00;
		pdjhuff_win<<=8;
		pdjhuff_pos-=8;
	}
}

void BGBBTJ_Huff_WriteString(BGBBTJ_JPG_Context *ctx, char *str)
{
	char *s;

	BGBBTJ_Huff_FlushBits(ctx);	
	s=str;
	while(*s)
		*pdjhuff_ct++=*s++;
	*pdjhuff_ct++=0;
}

int BGBBTJ_Huff_BalanceTree_r(short *nodes, short *nlen, int root, int h, int ml)
{
	int h0, h1, h2, h3;
	int l0, l1, l2;

	if(root<0)return(0);

	h1=BGBBTJ_Huff_BalanceTree_r(nodes, nlen, nodes[root*2+0], h+1, ml);
	h2=BGBBTJ_Huff_BalanceTree_r(nodes, nlen, nodes[root*2+1], h+1, ml);
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	if((h+h0)<=ml)	//depth limit not exceeded
		return(h0);

	//ok, so part of the tree is too deep
	if((h1+1)<h2)
	{
		l0=nodes[root*2+1];
		l1=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[root*2+0];
		nodes[root*2+0]=l0;
		nodes[root*2+1]=l1;
	}else if((h2+1)<h1)
	{
		l0=nodes[root*2+0];
		l1=nodes[l0*2+0];
		nodes[l0*2+0]=nodes[l0*2+1];
		nodes[l0*2+1]=nodes[root*2+1];
		nodes[root*2+0]=l1;
		nodes[root*2+1]=l0;
	}else
	{
		//rotating would be ineffective or would make things worse...
		return(h0);
	}

	//recalc depth of modified sub-tree
	l1=nodes[l0*2+0];
	l2=nodes[l0*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h3=((h1>h2)?h1:h2)+1;
	nlen[l0]=h3;

	//recalc height of root node
	l1=nodes[root*2+0];
	l2=nodes[root*2+1];
	h1=(l1<0)?0:nlen[l1];
	h2=(l2<0)?0:nlen[l2];
	h0=((h1>h2)?h1:h2)+1;
	nlen[root]=h0;

	return(h0);
}

void BGBBTJ_Huff_CalcLengths_r(short *nodes, byte *cl, int root, int h)
{
	if(root<0)
	{
		if(root==-513)return;
		cl[(-root)-1]=h;
		return;
	}

	BGBBTJ_Huff_CalcLengths_r(nodes, cl, nodes[root*2+0], h+1);
	BGBBTJ_Huff_CalcLengths_r(nodes, cl, nodes[root*2+1], h+1);
}

int BGBBTJ_Huff_BuildLengths(int *stat, int nc, byte *cl, int ml)
{
//	static short nodes[1024], nlen[512];
//	static short roots[512], clen[512];
//	static int cnts[512];

	short nodes[1024], nlen[512];
	short roots[512], clen[512];
	int cnts[512];
	int nr, nn;
	int i, j, k, l;

	nr=0; nn=0;
	for(i=0; i<nc; i++)
	{
		if(!stat[i])continue;
		roots[nr]=-(i+1);
		cnts[nr]=stat[i];
		clen[nr]=0;
		nr++;
	}

	roots[nr]=-513;
	cnts[nr]=0;
	clen[nr]=0;
	nr++;


	for(i=0; i<nc; i++)cl[i]=0;
	if(!nr)return(-1);


	while(nr>1)
	{
		if(cnts[0]>=cnts[1]) { j=0; k=1; }
			else { j=1; k=0; }
		for(i=2; i<nr; i++)
		{
			if(cnts[i]<=cnts[k])
			{
				j=k; k=i;
				continue;
			}
			if(cnts[i]<=cnts[j])
			{
				j=i;
				continue;
			}
		}

		nlen[nn]=((clen[j]>clen[k])?clen[j]:clen[k])+1;
		nodes[nn*2+0]=roots[j];
		nodes[nn*2+1]=roots[k];

		roots[nr]=nn;
		cnts[nr]=cnts[j]+cnts[k];
		clen[nr]=nlen[nn];

//		printf("%d %d %d\n", cnts[j], cnts[k], cnts[nr]);

		nn++; nr++;

		l=0;
		for(i=0; i<nr; i++)
		{
			if((i==j) || (i==k))continue;
			roots[l]=roots[i];
			cnts[l]=cnts[i];
			clen[l]=clen[i];
			l++;
		}
		nr=l;
	}

	l=roots[0];
	j=clen[0];
	k=j;

	i=4;
	while((i--) && (k>ml))
		k=BGBBTJ_Huff_BalanceTree_r(nodes, nlen, l, 0, ml);
	if(k>ml)return(-2);	//failed to balance tree

	BGBBTJ_Huff_CalcLengths_r(nodes, cl, l, 0);
	return(0);
}

int BGBBTJ_Huff_BuildLengthsAdjust(int *stat, int nc, byte *cl, int ml)
{
	int i, j;

	while(1)
	{
		j=BGBBTJ_Huff_BuildLengths(stat, nc, cl, ml);
		if(j<0)
			printf("BGBBTJ_Huff_BuildLengthsAdjust: Huff Fail %d\n");

		for(i=0; i<nc; i++)
			if(stat[i] && !cl[i])
				break;
		if(i>=nc)break;

		printf("BGBBTJ_Huff_BuildLengthsAdjust: Fiddle Adjust\n");
		for(i=0; i<nc; i++)
			stat[i]++;
		continue;
	}
	return(0);
}

void BGBBTJ_Huff_EncodeSymbol(BGBBTJ_JPG_Context *ctx, int tab, int v)
{
	tab<<=8;
	BGBBTJ_Huff_WriteNBits(ctx, ctx->huff_code[tab|v], ctx->huff_len[tab|v]);
}

void BGBBTJ_Huff_EncodeVal(BGBBTJ_JPG_Context *ctx, int tab, int z, int v)
{
	int i, j, k;

	if(!v) { BGBBTJ_Huff_EncodeSymbol(ctx, tab, z<<4); return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		if(i>15)
		{
			printf("BGBBTJ_Huff_EncodeVal: Overflow A\n");
			i=15;
		}
		
		BGBBTJ_Huff_EncodeSymbol(ctx, tab, (z<<4)|i);
		BGBBTJ_Huff_WriteNBits(ctx, v, i);
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	if(i>15)
	{
		printf("BGBBTJ_Huff_EncodeVal: Overflow B\n");
		i=15;
	}

	BGBBTJ_Huff_EncodeSymbol(ctx, tab, (z<<4)|i);

	k=(1<<i)-(j+1);
	BGBBTJ_Huff_WriteNBits(ctx, k, i);
	return;
}

void BGBBTJ_Huff_StatVal(int *stat, int z, int v)
{
	int i, j, k;

	if(!v) { stat[z<<4]++; return; }

	if(v>0)
	{
		i=1; while(v>=(1<<i))i++;
		if(i>15)i=15;
		stat[(z<<4)|i]++;
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	if(i>15)i=15;
	stat[(z<<4)|i]++;
}

#if 1
int BGBBTJ_Huff_EncodeBlock(BGBBTJ_JPG_Context *ctx,
	short *buf, int dctab, int actab)
{
	int i, j, k;

	BGBBTJ_Huff_EncodeVal(ctx, dctab, 0, buf[0]);

	for(i=1; i<64; i++)
	{
		j=buf[pdjpg_zigzag2[i]];
		if(j)
		{
			BGBBTJ_Huff_EncodeVal(ctx, actab, 0, j);
			continue;
		}

//		if(buf[pdjpg_zigzag2[i]])
//		{
//			BGBBTJ_Huff_EncodeVal(ctx, actab, 0, buf[pdjpg_zigzag2[i]]);
//			continue;
//		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			BGBBTJ_Huff_EncodeSymbol(ctx, actab, 0);
			break;
		}

		j-=i; if(j>15)j=15;
		BGBBTJ_Huff_EncodeVal(ctx, actab, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
	return(0);
}


int BGBBTJ_Huff_StatBlock(short *buf, int *dcstat, int *acstat)
{
	int i, j, k;

	BGBBTJ_Huff_StatVal(dcstat, 0, buf[0]);
	for(i=1; i<64; i++)
	{
		if(buf[pdjpg_zigzag2[i]])
		{
			BGBBTJ_Huff_StatVal(acstat, 0, buf[pdjpg_zigzag2[i]]);
			continue;
		}
		for(j=i; j<64; j++)
			if(buf[pdjpg_zigzag2[j]])break;
		if(j>=64)
		{
			acstat[0]++;
			break;
		}

		j-=i; if(j>15)j=15;
		BGBBTJ_Huff_StatVal(acstat, j, buf[pdjpg_zigzag2[i+j]]);
		i+=j;
	}
	return(0);
}
#endif

#if defined(X86) || defined(X86_64)
#define memcpy8(dst, src)	(*(double *)(dst)=*(double *)(src))
#else
#define memcpy8(dst, src)	memcpy(dst, src, 8)
#endif

#define memcpy16(dst, src)	memcpy(dst, src, 16)

#if 0
int BGBBTJ_JPG_GetImgBlk(char *blk, int xo, int yo, byte *img, int xs, int ys)
{
	byte *cs;
	char *ct;
	int i, j, k;

	cs=img+(yo*xs+xo); ct=blk;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); ct+=8; cs+=xs;
	memcpy8(ct, cs); // ct+=8; cs+=xs;
	return(0);
}
#endif

#if 1
int BGBBTJ_JPG_GetImgBlk16(
	short *blk, int xo, int yo,
	short *img, int xs, int ys)
{
	short *cs;
	short *ct;
	int i, j, k;

	cs=img+(yo*xs+xo); ct=blk;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs); ct+=8; cs+=xs;
	memcpy16(ct, cs);
	return(0);
}
#endif

// int BGBBTJ_JPG_FilterImageDCT(byte *ibuf, short *obuf, int xs, int ys)
int BGBBTJ_JPG_FilterImageDCT(short *ibuf, short *obuf,
	int xs, int ys, int dcbias)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
//	char blk[DCTSZ2];
	short blk[DCTSZ2];
	int i, j, k, l, xn, yn;

	xn=(xs/DCTSZ);
	yn=(ys/DCTSZ);
	k=0;
	for(i=0; i<yn; i++)
		for(j=0; j<xn; j++)
	{
//		BGBBTJ_JPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		BGBBTJ_JPG_GetImgBlk16(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		BGBBTJ_JPG_TransDCT(blk, obuf+k*DCTSZ2, dcbias);
//		BGBBTJ_JPG_TransQDCT(blk, obuf+k*DCTSZ2, dcbias);
		k++;
	}
	return(0);
}

//int BGBBTJ_JPG_FilterImageRDCT(byte *ibuf, short *obuf, int xs, int ys)
int BGBBTJ_JPG_FilterImageRDCT(short *ibuf, short *obuf,
	int xs, int ys, int dcbias)
{
//	static short tblk[DCTSZ2], tblk2[DCTSZ2];
//	static char blk[DCTSZ2];
	short tblk[DCTSZ2], tblk2[DCTSZ2];
//	char blk[DCTSZ2];
	short blk[DCTSZ2];
	int i, j, k, l;

	k=0;
	for(i=0; i<(ys/DCTSZ); i++)
		for(j=0; j<(xs/DCTSZ); j++)
	{
//		BGBBTJ_JPG_GetImgBlk(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		BGBBTJ_JPG_GetImgBlk16(blk, j*DCTSZ, i*DCTSZ, ibuf, xs, ys);
		BGBBTJ_JPG_TransRDCT(blk, obuf+k*DCTSZ2, dcbias);
		k++;
	}
	return(0);
}

void BGBBTJ_JPG_EmitDQT(BGBBTJ_JPG_Context *ctx, int n)
{
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DQT;

	i=64+3;
	*pdjhuff_ct++=i>>8;
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=n;
	for(i=0; i<64; i++)
		*pdjhuff_ct++=ctx->jpg_qt[n][pdjpg_zigzag2[i]];
}

void BGBBTJ_JPG_EmitSOF(BGBBTJ_JPG_Context *ctx, int xs, int ys)
{
	byte *p;
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOF0;

	i=8+(ctx->jpg_mono?1:3)*3;
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	*pdjhuff_ct++=8; 	//P

	*pdjhuff_ct++=ys>>8;	//Y
	*pdjhuff_ct++=ys&0xFF;	//Y
	*pdjhuff_ct++=xs>>8;	//X
	*pdjhuff_ct++=xs&0xFF;	//X

	if(ctx->jpg_mono)
	{
		*pdjhuff_ct++=1;	//Nf

		*pdjhuff_ct++=1;	//Ci
		*pdjhuff_ct++=0x11;	//Hi Vi
		*pdjhuff_ct++=0;	//Tqi
	}else if(ctx->jpg_is420)
	{
		if(!ctx->jpg_yuvw)
		{
			//YUV 4:2:0
		
			*pdjhuff_ct++=3;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x22;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}else
		{
			//YUVW 4:2:0

			*pdjhuff_ct++=4;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x22;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=4;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}
	}else if(ctx->jpg_is410)
	{
		if(!ctx->jpg_yuvw)
		{
			//YUV 4:1:0
		
			*pdjhuff_ct++=3;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x44;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}else
		{
			//YUVW 4:1:0

			*pdjhuff_ct++=4;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x44;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=4;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}
	}else
	{
		if(!ctx->jpg_yuvw)
		{
			//YUV 4:4:4

			*pdjhuff_ct++=3;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}else
		{
			//YUVW 4:4:4

			*pdjhuff_ct++=4;	//Nf

			*pdjhuff_ct++=1;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=0;	//Tqi
			*pdjhuff_ct++=2;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=3;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
			*pdjhuff_ct++=4;	//Ci
			*pdjhuff_ct++=0x11;	//Hi Vi
			*pdjhuff_ct++=1;	//Tqi
		}
	}

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void BGBBTJ_JPG_EmitSOS(BGBBTJ_JPG_Context *ctx)
{
	byte *p;
	int i;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOS;

	i=6+(ctx->jpg_mono?1:3)*2;
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	if(ctx->jpg_yuvw)
	{
		*pdjhuff_ct++=4; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=4;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else if(!ctx->jpg_mono)
	{
		*pdjhuff_ct++=3; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
		*pdjhuff_ct++=2;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
		*pdjhuff_ct++=3;	//Csi
		*pdjhuff_ct++=0x11;	//Tdi Tai
	}else
	{
		*pdjhuff_ct++=1; 	//Ns

		*pdjhuff_ct++=1;	//Csi
		*pdjhuff_ct++=0x00;	//Tdi Tai
	}

	*pdjhuff_ct++=0; 	//Ss
	*pdjhuff_ct++=63; 	//Se
	*pdjhuff_ct++=0x00; 	//Ah Al

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void BGBBTJ_JPG_EmitDHT(BGBBTJ_JPG_Context *ctx, int tab)
{
	byte *p;
	int i, j, k;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_DHT;

	i=8+3*1;	//temp value
	p=pdjhuff_ct;
	*pdjhuff_ct++=i>>8;	//Lf
	*pdjhuff_ct++=i&0xFF;

	i=(tab/2)|((tab&1)<<4);
	*pdjhuff_ct++=i; 	//Tc Th

	tab<<=8;
	for(i=1; i<=16; i++)
	{
		k=0;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
				k++;
		*pdjhuff_ct++=k; 	//Li
	}

	k=0;
	for(i=1; i<=16; i++)
	{
		k<<=1;
		for(j=0; j<256; j++)
			if(ctx->huff_len[tab|j]==i)
		{
			*pdjhuff_ct++=j; 	//Vi
			ctx->huff_code[tab|j]=k++;
		}
	}

	if(k>=65536)
		printf("BGBBTJ_JPG_EmitDHT: Error %04X\n", k);

//	printf("DHT %04X\n", k);

	i=pdjhuff_ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
	
#if 0
	printf("DHT Tab=%d\n", tab>>8);

#if 0
	printf("{ ");
	
	for(i=0; i<32; i++)
	{
		for(j=0; j<8; j++)
		{
			printf("0x%04X, ", ctx->huff_code[tab|(i*8+j)]);
		}
		printf("\n");
	}
	printf("},\n");
#endif

	printf("{ ");
	
	for(i=0; i<16; i++)
	{
		for(j=0; j<16; j++)
		{
			printf("%2d, ", ctx->huff_len[tab|(i*16+j)]);
		}
		printf("\n");
	}
	printf("},\n");

#endif
}


static int pdjpg_ijg_qtab_y[64] = {
16, 11, 10, 16,  24,  40,  51,  61,
12, 12, 14, 19,  26,  58,  60,  55,
14, 13, 16, 24,  40,  57,  69,  56,
14, 17, 22, 29,  51,  87,  80,  62,
18, 22, 37, 56,  68, 109, 103,  77,
24, 35, 55, 64,  81, 104, 113,  92,
49, 64, 78, 87, 103, 121, 120, 101,
72, 92, 95, 98, 112, 100, 103,  99};

static int pdjpg_ijg_qtab_uv[64] = {
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
47, 66, 99, 99, 99, 99, 99, 99,
24, 26, 56, 99, 99, 99, 99, 99,
18, 21, 26, 66, 99, 99, 99, 99,
17, 18, 24, 47, 99, 99, 99, 99};

void BGBBTJ_JPG_MakeQuantTabFastIJG_Y(
	short *inv, int cnt, byte *tab, float qf)
{
	double s, q;
	int i, j;

	q = (qf * 100);
	s = (q < 50) ? 5000 / q : (200 - 2 * q);
	for (i = 0; i < 64; i++)
	{
		j = (int)((s * pdjpg_ijg_qtab_y[i] + 50) / 100);
		j = (j < 1) ? 1 : ((j < 256) ? j : 255);
		tab[i] = j;
	}
}

void BGBBTJ_JPG_MakeQuantTabFastIJG_UV(
	short *inv, int cnt, byte *tab, float qf)
{
	double s, q;
	int i, j;

	q = (qf * 100);
	s = (q < 50) ? 5000 / q : (200 - 2 * q);
	for (i = 0; i < 64; i++)
	{
		j = (int)((s * pdjpg_ijg_qtab_y[i] + 50) / 100);
		j = (j < 1) ? 1 : ((j < 256) ? j : 255);
		tab[i] = j;
	}
}

void BGBBTJ_JPG_MakeQuantTabInput(short *inv, int cnt, byte *tab, float q)
{
	BGBBTJ_JPG_MakeQuantTabInput_AA(inv, cnt, tab, q);
}

void BGBBTJ_JPG_MakeQuantTabInputY(short *inv, int cnt, byte *tab, float q)
{
	byte taba[64], tabb[64];
	int i;

	//BGBBTJ_JPG_MakeQuantTabInput_AA(inv, cnt, tab, q);
	//BGBBTJ_JPG_MakeQuantTabFastIJG_UV(inv, cnt, tab, q);

	BGBBTJ_JPG_MakeQuantTabInput_AA(inv, cnt, taba, q);
	BGBBTJ_JPG_MakeQuantTabFastIJG_UV(inv, cnt, tabb, q);
	for (i = 0; i < 64; i++)
		tab[i] = (taba[i] + tabb[i]) / 2;
}

void BGBBTJ_JPG_MakeQuantTabInputUV(short *inv, int cnt, byte *tab, float q)
{
	byte taba[64], tabb[64];
	int i;

	//BGBBTJ_JPG_MakeQuantTabInput_AA(inv, cnt, tab, q);
	//BGBBTJ_JPG_MakeQuantTabFastIJG_UV(inv, cnt, tab, q);

	BGBBTJ_JPG_MakeQuantTabInput_AA(inv, cnt, taba, q);
	BGBBTJ_JPG_MakeQuantTabFastIJG_UV(inv, cnt, tabb, q);
	for (i = 0; i < 64; i++)
		tab[i] = (taba[i] + tabb[i]) / 2;
}

void BGBBTJ_JPG_MakeQuantTabInput_AA(short *in, int cnt, byte *tab, float q)
{
//	static double deltas[DCTSZ2];
	double deltas[DCTSZ2];
	double f, g, te;
	int i, j, k;

	if(q>=1)
	{
		for(i=0; i<DCTSZ2; i++)
			tab[i]=1;
		return;
	}

	for(j=0; j<DCTSZ2; j++)
		deltas[j]=0;

	for(i=0; i<cnt; i++)
		for(j=0; j<DCTSZ2; j++)
	{
		f=in[i*DCTSZ2+j];
		deltas[j]+=f*f;
	}
	for(j=0; j<DCTSZ2; j++)
	{
		deltas[j]=sqrt(deltas[j]/cnt);
//		deltas[j]/=cnt;
	}

	te=0;
	for(j=0; j<DCTSZ2; j++)
		te+=deltas[j];

	for(i=0; i<DCTSZ; i++)
	{
		for(j=0; j<DCTSZ; j++)
		{
			f=deltas[i*DCTSZ+j];

			f=f/te;
			if(f<0.00001)f=0.00001;
			g=(1.0-q);
			f=10*g*g*g/f;
			k=f;
			if(k<1)k=1;
			if(k>255)k=255;

//			printf("%f/%f %d\n", deltas[i*DCTSZ+j], te, k);

//			if(f<1)f=1;
//			if(f>255)f=255;
			tab[i*DCTSZ+j]=k;
		}
	}

#if 1
	if(tab[DCTSZ2-3]>1)tab[DCTSZ2-3]*=0.75;
	if(tab[DCTSZ2-2]>1)tab[DCTSZ2-2]*=0.75;
	if(tab[DCTSZ2-1]>1)tab[DCTSZ2-1]*=0.5;
#endif
}

void BGBBTJ_JPG_MakeQuantTabInputFast(
	short *in, int cnt, byte *tab, float q)
{
	int i;
//	BGBBTJ_JPG_MakeQuantTabInput(in, cnt, tab, q);

	i=cnt/16;
	if(i<1)i=1;
	BGBBTJ_JPG_MakeQuantTabInputY(in, i, tab, q);
}

void BGBBTJ_JPG_EmitMarkerBCST(BGBBTJ_JPG_Context *ctx)
{
	byte *lfp;
	int i, j, k;

	if(ctx->jpg_rdct)
	{
		//Emit libjpeg SERM marker
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP9;

		lfp=pdjhuff_ct;
		*pdjhuff_ct++=0x00;	//length
		*pdjhuff_ct++=0x00;
		*pdjhuff_ct++='J';
		*pdjhuff_ct++='P';
		*pdjhuff_ct++='S';
		*pdjhuff_ct++='E';
		*pdjhuff_ct++='R';
		*pdjhuff_ct++='M';
		*pdjhuff_ct++=0;

		i=pdjhuff_ct-lfp;
		lfp[0]=i>>8;	//length
		lfp[1]=i&0xFF;
	}

	if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_RGB)
	{
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP14;

		lfp=pdjhuff_ct;
		*pdjhuff_ct++=0x00;	//length
		*pdjhuff_ct++=0x00;

		*pdjhuff_ct++='A';
		*pdjhuff_ct++='d';
		*pdjhuff_ct++='o';
		*pdjhuff_ct++='b';
		*pdjhuff_ct++='e';

		i=100;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		i=0;
		*pdjhuff_ct++=(i>>24)&0xFF;
		*pdjhuff_ct++=(i>>16)&0xFF;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		*pdjhuff_ct++=0;	//RGB
//		*pdjhuff_ct++=ctx->bcst_bpp;

		i=pdjhuff_ct-lfp;
		lfp[0]=i>>8;	//length
		lfp[1]=i&0xFF;
	}

	ctx->bcst_version=0x0100;
	ctx->bcst_flags=0;
	ctx->bcst_trans=ctx->jpg_clrtrans;
	ctx->bcst_bpp=8;

	if(ctx->jpg_rdct)
		ctx->bcst_flags|=BGBBTJ_JPG_BCSFL_RDCT;

	//check if not to bother with marker...
	if(!ctx->bcst_flags && !ctx->bcst_trans)
	{
//		printf("BGBBTJ_JPG_EmitMarkerBCST: No Emit\n");
		return;
	}

//	printf("BGBBTJ_JPG_EmitMarkerBCST: Emit\n");

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP12;

	lfp=pdjhuff_ct;
	*pdjhuff_ct++=0x00;	//length
	*pdjhuff_ct++=0x00;

	*pdjhuff_ct++='B';
	*pdjhuff_ct++='C';
	*pdjhuff_ct++='S';
	*pdjhuff_ct++='T';

	*pdjhuff_ct++=(ctx->bcst_version>>8)&0xFF;
	*pdjhuff_ct++=ctx->bcst_version&0xFF;

	*pdjhuff_ct++=ctx->bcst_trans;
	*pdjhuff_ct++=ctx->bcst_bpp;

	*pdjhuff_ct++=(ctx->bcst_flags>>24)&0xFF;
	*pdjhuff_ct++=(ctx->bcst_flags>>16)&0xFF;
	*pdjhuff_ct++=(ctx->bcst_flags>>8)&0xFF;
	*pdjhuff_ct++=ctx->bcst_flags&0xFF;


	i=pdjhuff_ct-lfp;
	lfp[0]=i>>8;	//length
	lfp[1]=i&0xFF;
}

void BGBBTJ_JPG_EmitMarkerInlineAlpha(BGBBTJ_JPG_Context *ctx)
{
	if(ctx->badb)
	{
		pdjhuff_ct=BTIC1_EmitLumpAPP12Z(
			pdjhuff_ct, BTIC1_FCC_BA1Z,
			ctx->badb, ctx->sz_badb);
	}
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtx_Prepare(
	BGBBTJ_JPG_Context *ctx, int xs, int ys, int qfl, int pf)
{
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l, qf;

	qf=qfl&255;

	ctx->jpg_is420=1;

	if((qf==110) || (qf==111) || (qfl&BGBBTJ_JPG_QFL_444) ||
			(qf==102) || (qf==103))
		ctx->jpg_is420=0;

	if(qfl&BGBBTJ_QFL_410)
	{
		ctx->jpg_is420=0;
		ctx->jpg_is410=1;
	}

//	ctx->jpg_is444=0;

	if(ctx->jpg_is420)
	{
//		xs2=((xs+7)/8)*8;
//		ys2=((ys+7)/8)*8;
//		xs3=(xs2+1)/2;
//		ys3=(ys2+1)/2;

		xs2=((xs+15)/16)*16;
		ys2=((ys+15)/16)*16;

		xs3=((xs+15)/16)*8;
		ys3=((ys+15)/16)*8;
		ctx->jpg_is444=0;
		ctx->jpg_is410=0;
//		printf("BGBBTJ_JPG_EncodeCtx_Prepare: 4:2:0 %dx%d\n", xs, ys);
	}else if(ctx->jpg_is410)
	{
		xs2=((xs+7)/8)*8;
		ys2=((ys+7)/8)*8;
//		xs3=(xs2+1)/2;
//		ys3=(ys2+1)/2;

		xs3=((xs+31)/32)*8;
		ys3=((ys+31)/32)*8;
		ctx->jpg_is444=0;
		ctx->jpg_is420=0;
//		printf("BGBBTJ_JPG_EncodeCtx_Prepare: 4:1:0 %dx%d\n", xs, ys);
	}else
	{
		xs2=((xs+7)/8)*8;
		ys2=((ys+7)/8)*8;
		xs3=xs2;
		ys3=ys2;
		ctx->jpg_is444=1;
		ctx->jpg_is410=0;
		ctx->jpg_is420=0;
//		printf("BGBBTJ_JPG_EncodeCtx_Prepare: 4:4:4 %dx%d\n", xs, ys);
	}
	
	ctx->xs=xs;
	ctx->ys=ys;
	ctx->xs2=xs2;
	ctx->ys2=ys2;
	ctx->xs3=xs3;
	ctx->ys3=ys3;

	ctx->jpg_mono=0;
	ctx->jpg_yuvw=0;
	ctx->jpg_tabcacheframe=0;
	ctx->xs=xs;
	ctx->ys=ys;

	if(pf==BGBBTJ_JPG_YYYA)
		ctx->jpg_mono=1;

	ctx->jpg_rdct=0;
	if((qf==110) || (qf==111) || (qfl&BGBBTJ_JPG_QFL_RDCT))
		ctx->jpg_rdct=1;

	ctx->jpg_clrtrans=0;
	if((qf==110) || (qfl&BGBBTJ_JPG_QFL_ORCT) || (qf==101) || (qf==103))
		ctx->jpg_clrtrans=BGBBTJ_JPG_CLRS_ORCT;
	if((qf==111) || (qfl&BGBBTJ_JPG_QFL_RGB) || (qf==104))
		ctx->jpg_clrtrans=BGBBTJ_JPG_CLRS_RGB;

	if(!(qfl&BGBBTJ_QFL_PFRAME) && !(qfl&BGBBTJ_QFL_SUBLAYER))
//	if(1)
	{
		//full quality
		for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
		for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;

		//dummy huffman tables
		for(i=0; i<256; i++)ctx->huff_len[0*256+i]=0;
		for(i=0; i<256; i++)ctx->huff_len[1*256+i]=0;
		for(i=0; i<256; i++)ctx->huff_len[2*256+i]=0;
		for(i=0; i<256; i++)ctx->huff_len[3*256+i]=0;

		for(i=0; i<16; i++)ctx->huff_len[0*256+i]=4;
		for(i=0; i<16; i++)ctx->huff_len[2*256+i]=4;
		for(i=0; i<255; i++)ctx->huff_len[1*256+i]=8;
		for(i=0; i<255; i++)ctx->huff_len[3*256+i]=8;

//		for(i=0; i<255; i++)ctx->huff_len[0*256+i]=8;
//		for(i=0; i<255; i++)ctx->huff_len[2*256+i]=8;
	}


//	ctx->huff_len[1*256+0]=7;

//	printf("M0\n");

	//make sure intermediate buffers are present and the correct size
	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		//W channel is rare, and so is handled specially
		if(ctx->wb)
		{
			free(ctx->wb);
			free(ctx->wdb);
		}

//		if(ctx->bab)
//		{
//			free(ctx->bab);
//			ctx->bab=NULL;
//		}
		
		if(ctx->badb)
		{
			free(ctx->badb);
			ctx->badb=NULL;
		}

//		ctx->yb=malloc(xs2*ys2);
//		ctx->ub=malloc(xs2*ys2);
//		ctx->vb=malloc(xs2*ys2);

//		ctx->yb=malloc(xs2*ys2*sizeof(short));
//		ctx->ub=malloc(xs2*ys2*sizeof(short));
//		ctx->vb=malloc(xs2*ys2*sizeof(short));

		ctx->yb=malloc((xs2+16)*(ys2+16)*sizeof(short));
		ctx->ub=malloc((xs2+8)*(ys2+8)*sizeof(short));
		ctx->vb=malloc((xs2+8)*(ys2+8)*sizeof(short));

		ctx->ydb=malloc((xs2+16)*(ys2+16)*sizeof(short));
//		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
//		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->udb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		ctx->vdb=malloc((xs2+8)*(ys2+8)*sizeof(short));

		if(ctx->jpg_yuvw)
		{
			ctx->wb=malloc((xs2+8)*(ys2+8)*sizeof(short));
			ctx->wdb=malloc((xs2+8)*(ys2+8)*sizeof(short));
		}

		ctx->lxs=xs;
		ctx->lys=ys;
	}

	if(qfl&BGBBTJ_QFL_BITALPHA)
	{
//		if(!ctx->bab)
//		{
//			i=(xs2/8)*(ys2/8)*8;
//			ctx->bab=malloc(i);
//			memset(ctx->bab, 0, i);
//		}

		if(!ctx->badb)
		{
			i=(xs2/8)*(ys2/8)*8;
			j=((xs2+8)/8)*((ys2+8)/8)*8;
			ctx->badb=malloc(j);
			ctx->sz_badb=i;
			memset(ctx->badb, 0, i);
		}
	}

//	memset(ctx->yb, 128, xs2*ys2);
//	memset(ctx->ub, 128, xs2*ys2);
//	memset(ctx->vb, 128, xs2*ys2);

	memset(ctx->yb, 128, xs2*ys2*sizeof(short));
	memset(ctx->ub, 128, xs2*ys2*sizeof(short));
	memset(ctx->vb, 128, xs2*ys2*sizeof(short));

	memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
	memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
	memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

	if(ctx->jpg_yuvw)
	{
		memset(ctx->wb, 128, xs2*ys2*sizeof(short));
		memset(ctx->wdb, 0, xs2*(ys2+8)*sizeof(short));
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtx_ColorTransform(
	BGBBTJ_JPG_Context *ctx, byte *ibuf, int xs, int ys, int pf)
{
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, ca, cy, cu, cv, cw;
	int i, j, k, l, n, qf;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

	if((xs!=xs2) || (ys!=ys2))
	{
		n=xs2*ys2;
		for(i=0; i<n; i++)
			{ ctx->yb[i]=128; }
//		memset(ctx->yb, 128, xs2*ys2);
	}
	if((xs!=xs3) || (ys!=ys3))
	{
		n=xs3*ys3;
		for(i=0; i<n; i++)
			{ ctx->ub[i]=128; ctx->vb[i]=128; }
		if(ctx->wb)
		{
			for(i=0; i<n; i++)
				{ ctx->wb[i]=128; }
		}

//		memset(ctx->ub, 128, xs3*ys3);
//		memset(ctx->vb, 128, xs3*ys3);
//		if(ctx->wb)
//			{ memset(ctx->wb, 128, xs3*ys3); }
	}

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];
		ca=ibuf[(k*xs+j)*4+2];

//		if(qf==110)
		if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR)
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;

			cy=(cy<0)?0:((cy>255)?255:cy);
			cu=(cu<0)?0:((cu>255)?255:cu);
			cv=(cv<0)?0:((cv>255)?255:cv);
		}else if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_ORCT)
		{
//			cy=(cr+2*cg+cb)/4;
			cy=cg+(cb+cr-2*cg)/4;
			cu=(cb-cg)+128;
			cv=(cr-cg)+128;
			cw=ca;
//			k=cy-(cu+cv-256)/4;
//			cy+=cg-k;
//			if(k!=cg)cy++;

//			cu=cb-cr;
//			cv=cg-cr-0.5*cu;
//			cy=cg-0.5*cv;
//			cu+=128; cv+=128;
		}else if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_RGB)
		{
			cy=cr;
			cu=cg;
			cv=cb;
			cw=ca;
		}else
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;
		}

//		cu=128; cv=128;

//		cy=(cy<0)?0:((cy>255)?255:cy);
//		cu=(cu<0)?0:((cu>255)?255:cu);
//		cv=(cv<0)?0:((cv>255)?255:cv);

		ctx->yb[i*xs2+j]=cy;
		ctx->ub[i*xs2+j]=cu;
		ctx->vb[i*xs2+j]=cv;
		if(ctx->jpg_yuvw)
			ctx->wb[i*xs2+j]=cw;

		if(ctx->badb)
		{
			k=(i>>3)*(xs2>>3)+(j>>3);
			if(ca>=128)
			{
				ctx->badb[k*8+(i&7)]|=128>>(j&7);
			}
		}
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtx_ColorTransform16(
	BGBBTJ_JPG_Context *ctx, short *ibuf, int xs, int ys, int pf)
{
	int xs2, ys2, xs3, ys3;
	int cr, cg, cb, ca, cy, cu, cv, cw;
	int i, j, k, l, qf;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		k=ys-(i+1);
		cr=ibuf[(k*xs+j)*4+0];
		cg=ibuf[(k*xs+j)*4+1];
		cb=ibuf[(k*xs+j)*4+2];
		ca=ibuf[(k*xs+j)*4+2];

//		if(qf==110)
		if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR)
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;

			//cy=(cy<0)?0:((cy>255)?255:cy);
			//cu=(cu<0)?0:((cu>255)?255:cu);
			//cv=(cv<0)?0:((cv>255)?255:cv);
		}else if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_ORCT)
		{
//			cy=(cr+2*cg+cb)/4;
			cy=cg+(cb+cr-2*cg)/4;
			cu=(cb-cg)+128;
			cv=(cr-cg)+128;
			cw=ca;
		}else if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_RGB)
		{
			cy=cr; cu=cg; cv=cb; cw=ca;
		}else
		{
			cy=0.299*cr	+0.587*cg	+0.114*cb;
			cu=-0.1687*cr	-0.3313*cg	+0.5*cb 	+128;
			cv=0.5*cr	-0.4187*cg	-0.0813*cb	+128;
			cw=ca;
		}

//		cu=128; cv=128;

//		cy=(cy<0)?0:((cy>255)?255:cy);
//		cu=(cu<0)?0:((cu>255)?255:cu);
//		cv=(cv<0)?0:((cv>255)?255:cv);

		ctx->yb[i*xs2+j]=cy;
		ctx->ub[i*xs2+j]=cu;
		ctx->vb[i*xs2+j]=cv;
		if(ctx->jpg_yuvw)
			ctx->wb[i*xs2+j]=cw;

		if(ctx->badb)
		{
			k=(i>>3)*(xs2>>3)+(j>>3);
			if(ca>=128)
			{
				ctx->badb[k*8+(i&7)]|=128>>(j&7);
			}
		}
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtx_DownSample(BGBBTJ_JPG_Context *ctx)
{
	int xs2, ys2, xs3, ys3;
	int i, j, k, l;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

//	if((xs3!=xs2) || (ys3!=ys2))
	if(ctx->jpg_is420)
	{
		for(i=0; i<ys3; i++)
			for(j=0; j<xs3; j++)
		{
			k=ctx->ub[(i*2)*xs2+j*2]+
				ctx->ub[(i*2)*xs2+j*2+1]+
				ctx->ub[(i*2+1)*xs2+j*2]+
				ctx->ub[(i*2+1)*xs2+j*2+1];
			ctx->ub[i*xs3+j]=k/4;

			k=ctx->vb[(i*2)*xs2+j*2]+
				ctx->vb[(i*2)*xs2+j*2+1]+
				ctx->vb[(i*2+1)*xs2+j*2]+
				ctx->vb[(i*2+1)*xs2+j*2+1];
			ctx->vb[i*xs3+j]=k/4;

			if(ctx->jpg_yuvw)
			{
				k=ctx->wb[(i*2)*xs2+j*2]+
					ctx->wb[(i*2)*xs2+j*2+1]+
					ctx->wb[(i*2+1)*xs2+j*2]+
					ctx->wb[(i*2+1)*xs2+j*2+1];
				ctx->wb[i*xs3+j]=k/4;
			}
		}
	}

	if(ctx->jpg_is410)
	{
		for(i=0; i<ys3; i++)
			for(j=0; j<xs3; j++)
		{
			k=	ctx->ub[(i*4+0)*xs2+j*4+0]+ctx->ub[(i*4+0)*xs2+j*4+1]+
				ctx->ub[(i*4+0)*xs2+j*4+2]+ctx->ub[(i*4+0)*xs2+j*4+3]+
				ctx->ub[(i*4+1)*xs2+j*4+0]+ctx->ub[(i*4+1)*xs2+j*4+1]+
				ctx->ub[(i*4+1)*xs2+j*4+2]+ctx->ub[(i*4+1)*xs2+j*4+3]+
				ctx->ub[(i*4+2)*xs2+j*4+0]+ctx->ub[(i*4+2)*xs2+j*4+1]+
				ctx->ub[(i*4+2)*xs2+j*4+2]+ctx->ub[(i*4+2)*xs2+j*4+3]+
				ctx->ub[(i*4+3)*xs2+j*4+0]+ctx->ub[(i*4+3)*xs2+j*4+1]+
				ctx->ub[(i*4+3)*xs2+j*4+2]+ctx->ub[(i*4+3)*xs2+j*4+3];
//			ctx->ub[i*xs3+j]=(k+8)>>4;
			ctx->ub[i*xs3+j]=k>>4;

			k=	ctx->vb[(i*4+0)*xs2+j*4+0]+ctx->vb[(i*4+0)*xs2+j*4+1]+
				ctx->vb[(i*4+0)*xs2+j*4+2]+ctx->vb[(i*4+0)*xs2+j*4+3]+
				ctx->vb[(i*4+1)*xs2+j*4+0]+ctx->vb[(i*4+1)*xs2+j*4+1]+
				ctx->vb[(i*4+1)*xs2+j*4+2]+ctx->vb[(i*4+1)*xs2+j*4+3]+
				ctx->vb[(i*4+2)*xs2+j*4+0]+ctx->vb[(i*4+2)*xs2+j*4+1]+
				ctx->vb[(i*4+2)*xs2+j*4+2]+ctx->vb[(i*4+2)*xs2+j*4+3]+
				ctx->vb[(i*4+3)*xs2+j*4+0]+ctx->vb[(i*4+3)*xs2+j*4+1]+
				ctx->vb[(i*4+3)*xs2+j*4+2]+ctx->vb[(i*4+3)*xs2+j*4+3];
//			ctx->vb[i*xs3+j]=(k+8)>>4;
			ctx->vb[i*xs3+j]=k>>4;

			if(ctx->jpg_yuvw)
			{
				k=	ctx->wb[(i*4+0)*xs2+j*4+0]+ctx->wb[(i*4+0)*xs2+j*4+1]+
					ctx->wb[(i*4+0)*xs2+j*4+2]+ctx->wb[(i*4+0)*xs2+j*4+3]+
					ctx->wb[(i*4+1)*xs2+j*4+0]+ctx->wb[(i*4+1)*xs2+j*4+1]+
					ctx->wb[(i*4+1)*xs2+j*4+2]+ctx->wb[(i*4+1)*xs2+j*4+3]+
					ctx->wb[(i*4+2)*xs2+j*4+0]+ctx->wb[(i*4+2)*xs2+j*4+1]+
					ctx->wb[(i*4+2)*xs2+j*4+2]+ctx->wb[(i*4+2)*xs2+j*4+3]+
					ctx->wb[(i*4+3)*xs2+j*4+0]+ctx->wb[(i*4+3)*xs2+j*4+1]+
					ctx->wb[(i*4+3)*xs2+j*4+2]+ctx->wb[(i*4+3)*xs2+j*4+3];
//				ctx->wb[i*xs3+j]=(k+8)>>4;
				ctx->wb[i*xs3+j]=k>>4;
			}
		}
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtx(
	BGBBTJ_JPG_Context *ctx, byte *ibuf, byte *obuf, int xs, int ys,
	int qfl, int pf)
{
	int i;
	BGBBTJ_JPG_EncodeCtx_Prepare(ctx, xs, ys, qfl, pf);
	BGBBTJ_JPG_EncodeCtx_ColorTransform(ctx, ibuf, xs, ys, pf);
	BGBBTJ_JPG_EncodeCtx_DownSample(ctx);
	i=BGBBTJ_JPG_EncodeCtx_Inner(ctx, obuf, xs, ys, qfl);
	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtxSS(
	BGBBTJ_JPG_Context *ctx, short *ibuf, byte *obuf, int xs, int ys,
	int qfl, int pf)
{
	int i;
	BGBBTJ_JPG_EncodeCtx_Prepare(ctx, xs, ys, qfl, pf);
	BGBBTJ_JPG_EncodeCtx_ColorTransform16(ctx, ibuf, xs, ys, pf);
	BGBBTJ_JPG_EncodeCtx_DownSample(ctx);
	i=BGBBTJ_JPG_EncodeCtx_Inner(ctx, obuf, xs, ys, qfl);
	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeCtx_Inner(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys, int qfl)
{
//	static byte *yb=NULL, *ub, *vb;
//	static short *ydb=NULL, *udb, *vdb;
//	static int lxs=0, lys=0;

	int dcs[256], acs[256];
	int dcsuv[256], acsuv[256];
	short *tp;
	int xs2, ys2, xs3, ys3, qf;
	int cr, cg, cb, cy, cu, cv;
	int i, j, k, l, m, n;

	qf=qfl&255;

//	qfl&=~BGBBTJ_QFL_PFRAME;
//	qfl&=~BGBBTJ_QFL_IFRAME;

	xs2=ctx->xs2;
	ys2=ctx->ys2;
	xs3=ctx->xs3;
	ys3=ctx->ys3;

//	printf("M1\n");

//	if(qf==110)
	if(ctx->jpg_rdct)
	{
//		printf("BGBBTJ_JPG_EncodeCtx: Lossless Detect\n");
	
		BGBBTJ_JPG_FilterImageRDCT(ctx->yb, ctx->ydb, xs2, ys2, 128);
		BGBBTJ_JPG_FilterImageRDCT(ctx->ub, ctx->udb, xs3, ys3, 128);
		BGBBTJ_JPG_FilterImageRDCT(ctx->vb, ctx->vdb, xs3, ys3, 128);
	}else
	{
		BGBBTJ_JPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2, 128);
		BGBBTJ_JPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3, 128);
		BGBBTJ_JPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3, 128);
	}

	if(!(qfl&BGBBTJ_QFL_PFRAME) && !(qfl&BGBBTJ_QFL_SUBLAYER))
	{
		j=(xs2/8)*(ys2/8);
		BGBBTJ_JPG_MakeQuantTabInput(ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

		j=(xs3/8)*(ys3/8);
		BGBBTJ_JPG_MakeQuantTabInput(ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
		BGBBTJ_JPG_MakeQuantTabInput(ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
		for(i=0; i<64; i++)
		{
			ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;
		}

		BGBBTJ_JPG_SetupQuantTabDivFP(ctx, 0);
		BGBBTJ_JPG_SetupQuantTabDivFP(ctx, 1);
	}

//	free(yb);
//	free(ub);
//	free(vb);


//	if(ctx->jpg_mono || !ctx->jpg_is420)
	if(ctx->jpg_mono || ctx->jpg_is444)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			BGBBTJ_Huff_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k; k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono && ctx->jpg_is420)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	if(ctx->jpg_is410)
	{
		m=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			for(k=0; k<4; k++)
				for(l=0; l<4; l++)
			{
				tp=ctx->ydb+((i*4+k)*(xs2/8)+j*4+l)*64;
				BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
				tp[0]-=m; m=tp[0]+m;
			}
		}
	}

#if 0
	if(!ctx->jpg_mono && !ctx->jpg_is420)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			BGBBTJ_Huff_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 1);
			ctx->ydb[i*64+0]-=l; l=ctx->ydb[i*64+0]+l;
		}
	}
#endif

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		BGBBTJ_Huff_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		BGBBTJ_Huff_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

	if(ctx->jpg_yuvw)
	{
		j=(xs3/8)*(ys3/8); k=0;
		for(i=0; i<j; i++)
		{
			BGBBTJ_Huff_QuantBlock(ctx, ctx->wdb+i*64, ctx->wdb+i*64, 1);
			ctx->wdb[i*64+0]-=k; k=ctx->wdb[i*64+0]+k;
		}
	}

//	printf("M2\n");

	if(!(qfl&BGBBTJ_QFL_PFRAME) && !(qfl&BGBBTJ_QFL_SUBLAYER))
	{
		if((qfl&BGBBTJ_QFL_IFRAME) || (qfl&BGBBTJ_QFL_TAGBASELAYER))
//		if(0)
		{
			for(i=0; i<16; i++)dcs[i]=1;
			for(i=16; i<256; i++)dcs[i]=0;
			for(i=0; i<256; i++)acs[i]=1;

			for(i=0; i<16; i++)dcsuv[i]=1;
			for(i=16; i<256; i++)dcsuv[i]=0;
			for(i=0; i<256; i++)acsuv[i]=1;
		}else
		{
			for(i=0; i<256; i++)dcs[i]=0;
			for(i=0; i<256; i++)acs[i]=0;
			for(i=0; i<256; i++)dcsuv[i]=0;
			for(i=0; i<256; i++)acsuv[i]=0;
		}

		j=(xs2/8)*(ys2/8);
		k=(xs3/8)*(ys3/8);
		for(i=0; i<j; i++)BGBBTJ_Huff_StatBlock(ctx->ydb+i*64, dcs, acs);
		for(i=0; i<k; i++)BGBBTJ_Huff_StatBlock(ctx->udb+i*64, dcsuv, acsuv);
		for(i=0; i<k; i++)BGBBTJ_Huff_StatBlock(ctx->vdb+i*64, dcsuv, acsuv);
	
		if(ctx->jpg_yuvw)
			{ for(i=0; i<k; i++)BGBBTJ_Huff_StatBlock(
				ctx->wdb+i*64, dcsuv, acsuv); }

//		BGBBTJ_Huff_BuildLengths(dcs, 256, ctx->huff_len+0*256, 16);
//		BGBBTJ_Huff_BuildLengths(acs, 256, ctx->huff_len+1*256, 16);
//		BGBBTJ_Huff_BuildLengths(dcsuv, 256, ctx->huff_len+2*256, 16);
//		BGBBTJ_Huff_BuildLengths(acsuv, 256, ctx->huff_len+3*256, 16);

		BGBBTJ_Huff_BuildLengthsAdjust(dcs, 256, ctx->huff_len+0*256, 16);
		BGBBTJ_Huff_BuildLengthsAdjust(acs, 256, ctx->huff_len+1*256, 16);
		BGBBTJ_Huff_BuildLengthsAdjust(dcsuv, 256, ctx->huff_len+2*256, 16);
		BGBBTJ_Huff_BuildLengthsAdjust(acsuv, 256, ctx->huff_len+3*256, 16);
	}

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(!(qfl&BGBBTJ_QFL_NOSOI))
	{
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_SOI;
	}

	BGBBTJ_JPG_EmitMarkerBCST(ctx);

	if(!(qfl&BGBBTJ_QFL_PFRAME) && !(qfl&BGBBTJ_QFL_SUBLAYER))
//	if(1)
	{
		BGBBTJ_JPG_EmitDQT(ctx, 0);
		if(!ctx->jpg_mono)BGBBTJ_JPG_EmitDQT(ctx, 1);
	}

	BGBBTJ_JPG_EmitSOF(ctx, xs, ys);

	BGBBTJ_JPG_EmitMarkerInlineAlpha(ctx);

	if(!(qfl&BGBBTJ_QFL_PFRAME) && !(qfl&BGBBTJ_QFL_SUBLAYER))
//	if(1)
	{
		BGBBTJ_JPG_EmitDHT(ctx, 0);
		BGBBTJ_JPG_EmitDHT(ctx, 1);
		if(!ctx->jpg_mono)
		{
			BGBBTJ_JPG_EmitDHT(ctx, 2);
			BGBBTJ_JPG_EmitDHT(ctx, 3);
		}
	}

	BGBBTJ_JPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)BGBBTJ_Huff_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else if(ctx->jpg_is420)
	{
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
			if(ctx->jpg_yuvw)
				{ BGBBTJ_Huff_EncodeBlock(ctx, ctx->wdb+k*64, 2, 3); }
		}
	}else if(ctx->jpg_is410)
	{
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			for(k=0; k<4; k++)
				for(l=0; l<4; l++)
			{
				BGBBTJ_Huff_EncodeBlock(ctx,
					ctx->ydb+((i*4+k)*(xs2/8)+j*4+l)*64, 0, 1);
			}

			k=i*(xs3/8)+j;
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
			if(ctx->jpg_yuvw)
				{ BGBBTJ_Huff_EncodeBlock(ctx, ctx->wdb+k*64, 2, 3); }
		}
	}else
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)
		{
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->udb+i*64, 2, 3);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->vdb+i*64, 2, 3);
			if(ctx->jpg_yuvw)
				{ BGBBTJ_Huff_EncodeBlock(ctx, ctx->wdb+i*64, 2, 3); }
		}

#if 0
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			k=i*(xs3/8)+j;
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->ydb+k*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
#endif
	}

	BGBBTJ_Huff_FlushBits(ctx);

	if(!(qfl&BGBBTJ_QFL_NOSOI))
	{
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_EOI;
	}

//	free(ydb);
//	free(udb);
//	free(vdb);

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

BGBBTJ_API BGBBTJ_JPG_Context *BGBBTJ_JPG_AllocContext()
{
	BGBBTJ_JPG_Context *ctx;

	BGBBTJ_JPG_Init();
	ctx=malloc(sizeof(BGBBTJ_JPG_Context));
	memset(ctx, 0, sizeof(BGBBTJ_JPG_Context));
	return(ctx);
}

BGBBTJ_API void BGBBTJ_JPG_FreeContext(BGBBTJ_JPG_Context *ctx)
{
	if(ctx->yb)
	{
		free(ctx->yb);
		free(ctx->ub);
		free(ctx->vb);
		free(ctx->ydb);
		free(ctx->udb);
		free(ctx->vdb);
	}

	if(ctx->jpg_imgbuf)
		free(ctx->jpg_imgbuf);

	if(ctx->imgbuf_rgba)
		free(ctx->imgbuf_rgba);
	if(ctx->imgbuf_norm)
		free(ctx->imgbuf_norm);
	if(ctx->imgbuf_spec)
		free(ctx->imgbuf_spec);
	if(ctx->imgbuf_luma)
		free(ctx->imgbuf_luma);
	if(ctx->imgbuf_lebe)
		free(ctx->imgbuf_lebe);

	free(ctx);
}

BGBBTJ_API int BGBBTJ_JPG_Encode(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	BGBBTJ_JPG_Context *ctx;
	int sz;
	
	ctx=BGBBTJ_JPG_AllocContext();
	sz=BGBBTJ_JPG_EncodeCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
	BGBBTJ_JPG_FreeContext(ctx);
	return(sz);
}

BGBBTJ_API void BGBBTJ_JPG_FlushEncodeFast(BGBBTJ_JPG_Context *ctx)
{
	if(!ctx)return;
	ctx->jpg_tabcacheframe=0;	//force rebuild
	ctx->oldAlphaClr=0;
}

BGBBTJ_API void BGBBTJ_JPG_SetContextAlphaColor(BGBBTJ_JPG_Context *ctx,
	int cr, int cg, int cb, int ca)
{
	int cy, cu, cv;
	if(!ctx)return;

	if(ca<1)
	{
		ctx->alphaClr=0;
		return;
	}

	ctx->alphaClr=cr+(cg<<8)+(cb<<16)+(ca<<24);

	cy= 19595*cr +38470*cg + 7471*cb;
	cu=-11056*cr -21712*cg +32768*cb;
	cv= 32768*cr -27440*cg - 5328*cb;
	ctx->alphaClrY=cy>>16;
	ctx->alphaClrU=(cu>>16)+128;
	ctx->alphaClrV=(cv>>16)+128;
	ctx->alphaClrA=ca;
}

#if 0
//static void pdjpg_getPixel2_RGBA(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb)
//{
//	*ra=rgb[0]; *ga=rgb[1]; *ba=rgb[2];
//	*ra=rgb[4]; *ga=rgb[5]; *ba=rgb[6];
//}
#endif

void BGBBTJ_JPG_ConvertImageYUV(BGBBTJ_JPG_Context *ctx,
	byte *ibuf, int xs, int ys, int pf,
	int xs2, int ys2, int xs3, int ys3)
{
//	void (*getPixel2)(byte *rgb,
//		int *ra, int *ga, int *ba,
//		int *rb, int *gb, int *bb);
	byte *cs, *cse;
	short *cty, *ctu, *ctv;
	byte *cs1, *cs2;
	short *cty1, *cty2;

	int cr, cg, cb, ca, cy, cu, cv;

	int cra, cga, cba, caa, cya, cua, cva;
	int crb, cgb, cbb, cab, cyb, cub, cvb;
	int crc, cgc, cbc, cac, cyc, cuc, cvc;
	int crd, cgd, cbd, cad, cyd, cud, cvd;
	int psz, psz2;

	int i, j, k, l, n;

	if((pf==BGBBTJ_JPG_RGBA) && !ctx->alphaClr)
	{
		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*4;
			cs1=ibuf+k; cse=cs1+xs*4;
			l=((ys-(2*i+2))*xs)*4;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
				cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2);
				crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6);
				crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2);
				crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6);

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=8; cs2+=8;
			}
		}
	}else
	if((pf==BGBBTJ_JPG_RGBA) || (pf==BGBBTJ_JPG_RGB) ||
		(pf==BGBBTJ_JPG_BGRA) || (pf==BGBBTJ_JPG_BGR))
	{
		switch(pf)
		{
		case BGBBTJ_JPG_RGBA: case BGBBTJ_JPG_BGRA:
			psz=4; break;
		case BGBBTJ_JPG_RGB: case BGBBTJ_JPG_BGR:
			psz=3; break;
		default: psz=4; break;
		}
		psz2=psz*2;

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			k=((ys-(2*i+1))*xs)*psz;
			cs1=ibuf+k; cse=cs1+xs*psz;
			l=((ys-(2*i+2))*xs)*psz;
			cs2=ibuf+l;

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case BGBBTJ_JPG_RGBA:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=*(cs1+3);
					crb=*(cs1+4); cgb=*(cs1+5); cbb=*(cs1+6); cab=*(cs1+7);
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=*(cs2+3);
					crd=*(cs2+4); cgd=*(cs2+5); cbd=*(cs2+6); cad=*(cs2+7);
					psz=8; break;
				case BGBBTJ_JPG_BGRA:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=*(cs1+3);
					crb=*(cs1+6); cgb=*(cs1+5); cbb=*(cs1+4); cab=*(cs1+7);
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=*(cs2+3);
					crd=*(cs2+6); cgd=*(cs2+5); cbd=*(cs2+4); cad=*(cs2+7);
					psz=8; break;
				case BGBBTJ_JPG_RGB:
					cra=*(cs1+0); cga=*(cs1+1); cba=*(cs1+2); caa=255;
					crb=*(cs1+3); cgb=*(cs1+4); cbb=*(cs1+5); cab=255;
					crc=*(cs2+0); cgc=*(cs2+1); cbc=*(cs2+2); cac=255;
					crd=*(cs2+3); cgd=*(cs2+4); cbd=*(cs2+5); cad=255;
					psz=6; break;
				case BGBBTJ_JPG_BGR:
					cra=*(cs1+2); cga=*(cs1+1); cba=*(cs1+0); caa=255;
					crb=*(cs1+5); cgb=*(cs1+4); cbb=*(cs1+3); cab=255;
					crc=*(cs2+2); cgc=*(cs2+1); cbc=*(cs2+0); cac=255;
					crd=*(cs2+5); cgd=*(cs2+4); cbd=*(cs2+3); cad=255;
					psz=6; break;
				}

				if(ctx->alphaClr)
				{
					ca=(caa+cab+cac+cad)>>2;
					if(ca<ctx->alphaClrA)
					{
						cy=ctx->alphaClrY;
						cu=ctx->alphaClrU;
						cv=ctx->alphaClrV;
						*cty1++=cy; *cty1++=cy;
						*cty2++=cy; *cty2++=cy;
						*ctu++=cu; *ctv++=cv;
						continue;
					}
				}

				cya=19595*cra + 38470*cga + 7471*cba;
				cyb=19595*crb + 38470*cgb + 7471*cbb;
				cyc=19595*crc + 38470*cgc + 7471*cbc;
				cyd=19595*crd + 38470*cgd + 7471*cbd;
				*cty1++=cya>>16;
				*cty1++=cyb>>16;
				*cty2++=cyc>>16;
				*cty2++=cyd>>16;

				cr=(cra+crb+crc+crd)>>2;
				cg=(cga+cgb+cgc+cgd)>>2;
				cb=(cba+cbb+cbc+cbd)>>2;

				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				*ctu++=(cu>>16)+128;
				*ctv++=(cv>>16)+128;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}else
	{
		switch(pf)
		{
		case BGBBTJ_JPG_YUVA: psz=4; psz2=8; break;
		case BGBBTJ_JPG_YUV: psz=3; psz2=6; break;
		case BGBBTJ_JPG_YUV422: psz=2; psz2=4; break;
		case BGBBTJ_JPG_YUV420: psz=3; psz2=3; break;
		case BGBBTJ_JPG_YA: psz=2; psz2=4; break;
		case BGBBTJ_JPG_Y: psz=1; psz2=2; break;
		case BGBBTJ_JPG_YYYA: psz=4; psz2=8; break;
		default: psz=4; psz2=8; break;
		}

		n=(ys+1)/2;
		for(i=0; i<n; i++)
		{
			if(pf==BGBBTJ_JPG_YUV420)
			{
				k=(((ys-(2*i+1))*xs2)*psz2)>>1;
				cs1=ibuf+k; cse=cs1+((xs*psz2)>>1);
				l=(((ys-(2*i+2))*xs2)*psz2)>>1;
				cs2=ibuf+l;
			}else
			{
				k=((ys-(2*i+1))*xs)*psz;
				cs1=ibuf+k; cse=cs1+xs*psz;
				l=((ys-(2*i+2))*xs)*psz;
				cs2=ibuf+l;
			}

			cty1=ctx->yb+(2*i+0)*xs2;
			cty2=ctx->yb+(2*i+1)*xs2;

			l=i*xs3;
			ctu=ctx->ub+l;
			ctv=ctx->vb+l;

			while(cs1<cse)
			{
//				getPixel2(cs1, &cra, &cga, &cba, &crb, &cgb, &cbb);
//				getPixel2(cs2, &crc, &cgc, &cbc, &crd, &cgd, &cbd);

				switch(pf)
				{
				case BGBBTJ_JPG_YUVA:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+4); cub=*(cs1+5); cvb=*(cs1+6);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+4); cud=*(cs2+5); cvd=*(cs2+6);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case BGBBTJ_JPG_YUV:
					cya=*(cs1+0); cua=*(cs1+1); cva=*(cs1+2);
					cyb=*(cs1+3); cub=*(cs1+4); cvb=*(cs1+5);
					cyc=*(cs2+0); cuc=*(cs2+1); cvc=*(cs2+2);
					cyd=*(cs2+3); cud=*(cs2+4); cvd=*(cs2+5);
					cu=(cua+cub+cuc+cud)>>2;
					cv=(cva+cvb+cvc+cvd)>>2;
					break;
				case BGBBTJ_JPG_YUV422:
					cya=*(cs1+0); cua=*(cs1+1); cyb=*(cs1+2); cva=*(cs1+3);
					cyc=*(cs2+0); cuc=*(cs2+1); cyd=*(cs2+2); cvc=*(cs2+3);
					cu=(cua+cuc)>>1; cv=(cva+cvc)>>1;
					break;
				case BGBBTJ_JPG_YUV420:
					cya=*(cs1+0); cyb=*(cs1+1); cu=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+1); cv=*(cs2+2);
					break;
				case BGBBTJ_JPG_YA:
					cya=*(cs1+0); cyb=*(cs1+2);
					cyc=*(cs2+0); cyd=*(cs2+2);
					cu=0; cv=0;
					break;
				case BGBBTJ_JPG_Y:
					cya=*(cs1+0); cyb=*(cs1+1);
					cyc=*(cs2+0); cyd=*(cs2+1);
					cu=0; cv=0;
					break;

				case BGBBTJ_JPG_YYYA:
					cya=*(cs1+1); cyb=*(cs1+5);
					cyc=*(cs2+1); cyd=*(cs2+5);
					cu=0; cv=0;
					break;
				}

				*cty1++=cya; *cty1++=cyb;
				*cty2++=cyc; *cty2++=cyd;
				*ctu++=cu; *ctv++=cv;

				cs1+=psz2; cs2+=psz2;
			}
		}
	}
}

BGBBTJ_API int BGBBTJ_JPG_EncodeFastCtx(BGBBTJ_JPG_Context *ctx,
	byte *ibuf, byte *obuf, int xs, int ys, int qf, int pf)
{
	char tb[256];
	short *tp;
//	byte *cs, *cse, *cty, *ctu, *ctv;
	int xs2, ys2, xs3, ys3;
//	int cr, cg, cb, cy, cu, cv;

//	int cra, cga, cba, cya;
//	int crb, cgb, cbb, cyb;
//	int crc, cgc, cbc, cyc;
//	int crd, cgd, cbd, cyd;
//	byte *cs1, *cs2, *cty1, *cty2;
	byte *ctt;

	int i, j, k, l, n;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	ctx->jpg_mono=0;

	if(qf&BGBBTJ_QFL_IFRAME)
	{
		ctx->jpg_tabcacheframe=0;
	}

	if(qf&BGBBTJ_QFL_PFRAME)
	{
//		ctx->jpg_tabcacheframe=16;
		ctx->jpg_tabcacheframe=8;
	}

	if(!ctx->jpg_tabcacheframe)
	{
		//full quality
		for(i=0; i<64; i++)ctx->jpg_qt[0][i]=1;
		for(i=0; i<64; i++)ctx->jpg_qt[1][i]=1;
	}

	if(!ctx->yb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->yb)
		{
			free(ctx->yb);
			free(ctx->ub);
			free(ctx->vb);
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->yb=malloc(xs2*ys2);
		ctx->ub=malloc(xs2*ys2);
		ctx->vb=malloc(xs2*ys2);

		ctx->ydb=malloc((xs2+8)*(ys2+16)*sizeof(short));
		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;

		memset(ctx->yb, 128, xs2*ys2);
		memset(ctx->ub, 128, xs2*ys2);
		memset(ctx->vb, 128, xs2*ys2);

		memset(ctx->ydb, 0, xs2*(ys2+8)*sizeof(short));
		memset(ctx->udb, 0, xs3*(ys3+8)*sizeof(short));
		memset(ctx->vdb, 0, xs3*(ys3+8)*sizeof(short));

		ctx->jpg_tabcacheframe=0;	//force rebuild
	}

	BGBBTJ_JPG_ConvertImageYUV(ctx,
		ibuf, xs, ys, pf,
		xs2, ys2, xs3, ys3);

	BGBBTJ_JPG_FilterImageDCT(ctx->yb, ctx->ydb, xs2, ys2, 128);
	BGBBTJ_JPG_FilterImageDCT(ctx->ub, ctx->udb, xs3, ys3, 128);
	BGBBTJ_JPG_FilterImageDCT(ctx->vb, ctx->vdb, xs3, ys3, 128);

	if(ctx->jpg_tabcacheframe<=0)
	{
		j=(xs2/8)*(ys2/8);
		BGBBTJ_JPG_MakeQuantTabInputFast(
			ctx->ydb, j, ctx->jpg_qt[0], qf/100.0);

		j=(xs3/8)*(ys3/8);
		BGBBTJ_JPG_MakeQuantTabInputFast(
			ctx->udb, j, ctx->jpg_qt[1], qf/100.0);
		BGBBTJ_JPG_MakeQuantTabInputFast(
			ctx->vdb, j, ctx->jpg_qt[2], qf/100.0);
		for(i=0; i<64; i++)
			ctx->jpg_qt[1][i]=(ctx->jpg_qt[1][i]+ctx->jpg_qt[2][i])/2;

		BGBBTJ_JPG_SetupQuantTabDivFP(ctx, 0);
		BGBBTJ_JPG_SetupQuantTabDivFP(ctx, 1);
	}

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8); k=0;
		for(i=0; i<j; i++)
		{
			BGBBTJ_Huff_QuantBlock(ctx, ctx->ydb+i*64, ctx->ydb+i*64, 0);
			ctx->ydb[i*64+0]-=k;
			k=ctx->ydb[i*64+0]+k;
		}
	}

	if(!ctx->jpg_mono)
	{
		l=0;
		for(i=0; i<=(ys3/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;

			tp=ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64;
			BGBBTJ_Huff_QuantBlock(ctx, tp, tp, 0);
			tp[0]-=l; l=tp[0]+l;
		}
	}

	j=(xs3/8)*(ys3/8); k=0; l=0;
	for(i=0; i<j; i++)
	{
		BGBBTJ_Huff_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		BGBBTJ_Huff_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

//	printf("M2\n");

	if(ctx->jpg_tabcacheframe<=0)
	{
		for(i=0; i<256; i++)ctx->dcs[i]=1;
		for(i=0; i<256; i++)ctx->acs[i]=1;
		for(i=0; i<256; i++)ctx->dcsuv[i]=1;
		for(i=0; i<256; i++)ctx->acsuv[i]=1;

		j=(xs2/8)*(ys2/8);
		k=(xs3/8)*(ys3/8);
		for(i=0; i<j; i++)
			BGBBTJ_Huff_StatBlock(ctx->ydb+i*64, ctx->dcs, ctx->acs);
		for(i=0; i<k; i++)
			BGBBTJ_Huff_StatBlock(ctx->udb+i*64, ctx->dcsuv, ctx->acsuv);
		for(i=0; i<k; i++)
			BGBBTJ_Huff_StatBlock(ctx->vdb+i*64, ctx->dcsuv, ctx->acsuv);

//		BGBBTJ_Huff_BuildLengths(ctx->dcs, 256, ctx->huff_len+0*256, 16);
//		BGBBTJ_Huff_BuildLengths(ctx->acs, 256, ctx->huff_len+1*256, 16);
//		BGBBTJ_Huff_BuildLengths(ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
//		BGBBTJ_Huff_BuildLengths(ctx->acsuv, 256, ctx->huff_len+3*256, 16);

		BGBBTJ_Huff_BuildLengthsAdjust(
			ctx->dcs, 256, ctx->huff_len+0*256, 16);
		BGBBTJ_Huff_BuildLengthsAdjust(
			ctx->acs, 256, ctx->huff_len+1*256, 16);
		BGBBTJ_Huff_BuildLengthsAdjust(
			ctx->dcsuv, 256, ctx->huff_len+2*256, 16);
		BGBBTJ_Huff_BuildLengthsAdjust(
			ctx->acsuv, 256, ctx->huff_len+3*256, 16);
	}

	pdjhuff_ct=obuf;
	pdjhuff_win=0;
	pdjhuff_pos=0;

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_SOI;

	if(ctx->alphaClr && (ctx->alphaClr!=ctx->oldAlphaClr))
	{
		sprintf(tb, "%d %d %d %d",
			(ctx->alphaClr&0xFF),
			((ctx->alphaClr>>8)&0xFF),
			((ctx->alphaClr>>16)&0xFF),
			((ctx->alphaClr>>24)&0xFF));
	
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP11;
		ctt=pdjhuff_ct;
		*pdjhuff_ct++=0x00;
		*pdjhuff_ct++=0x00;
		BGBBTJ_Huff_WriteString(ctx, "AlphaColor");
		BGBBTJ_Huff_WriteString(ctx, tb);
		i=(pdjhuff_ct-ctt);
		ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	}


	if(ctx->jpg_tabcacheframe<=0)
	{
		BGBBTJ_JPG_EmitDQT(ctx, 0);
		if(!ctx->jpg_mono)BGBBTJ_JPG_EmitDQT(ctx, 1);
	}

	BGBBTJ_JPG_EmitSOF(ctx, xs, ys);

//	if(ctx->jpg_tabcacheframe<=0)
	if(1)
	{
		BGBBTJ_JPG_EmitDHT(ctx, 0);
		BGBBTJ_JPG_EmitDHT(ctx, 1);
		if(!ctx->jpg_mono)
		{
			BGBBTJ_JPG_EmitDHT(ctx, 2);
			BGBBTJ_JPG_EmitDHT(ctx, 3);
		}
	}

	BGBBTJ_JPG_EmitSOS(ctx);

	pdjhuff_win=0;
	pdjhuff_pos=0;

	if(ctx->jpg_mono)
	{
		j=(xs2/8)*(ys2/8);
		for(i=0; i<j; i++)BGBBTJ_Huff_EncodeBlock(ctx, ctx->ydb+i*64, 0, 1);
	}else
	{
		for(i=0; i<=((ys3)/8); i++)
			for(j=0; j<(xs3/8); j++)
		{
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+0)*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+0)*(xs2/8)+j*2+1)*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+0)*64, 0, 1);
			BGBBTJ_Huff_EncodeBlock(ctx,
				ctx->ydb+((i*2+1)*(xs2/8)+j*2+1)*64, 0, 1);

			k=i*(xs3/8)+j;
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
			BGBBTJ_Huff_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
		}
	}

	BGBBTJ_Huff_FlushBits(ctx);

	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_EOI;

	if(ctx->jpg_tabcacheframe<=0)
	{
//		ctx->jpg_tabcacheframe=16;
		ctx->jpg_tabcacheframe=8;
	}else
	{
		ctx->jpg_tabcacheframe--;
	}

//	printf("M3\n");

	i=pdjhuff_ct-obuf;

	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeFast(
	byte *ibuf, byte *obuf, int xs, int ys, int qf)
{
	static BGBBTJ_JPG_Context *ctx=NULL;
	int sz;
	
	if(!ctx)ctx=BGBBTJ_JPG_AllocContext();
	sz=BGBBTJ_JPG_EncodeFastCtx(ctx, ibuf, obuf, xs, ys, qf, 0);
//	BGBBTJ_JPG_FreeContext(ctx);
	return(sz);
}

byte *BGBBTJ_JPG_EmitComponentLayer(BGBBTJ_JPG_Context *ctx,
	byte *ct, char *name)
{
	byte *ctt;
	int i;

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP11;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	BGBBTJ_Huff_WriteString(ctx, "CompLayer");
	BGBBTJ_Huff_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

byte *BGBBTJ_JPG_EmitMarkerJFIF(BGBBTJ_JPG_Context *ctx, byte *ct)
{
	byte *ctt;
	int i;

	if(ctx->jpg_clrtrans!=BGBBTJ_JPG_CLRS_YCBCR)
		return(ct);

	pdjhuff_ct=ct; pdjhuff_win=0; pdjhuff_pos=0;
	*pdjhuff_ct++=0xFF;
	*pdjhuff_ct++=JPG_APP0;
	ctt=pdjhuff_ct;
	*pdjhuff_ct++=0x00;
	*pdjhuff_ct++=0x00;
	BGBBTJ_Huff_WriteString(ctx, "JFIF");

	*pdjhuff_ct++=0x01;		//version high
	*pdjhuff_ct++=0x02;		//version low

	*pdjhuff_ct++=0x00;		//no units

	*pdjhuff_ct++=0x00;		//X density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//Y density
	*pdjhuff_ct++=0x01;

	*pdjhuff_ct++=0x00;		//thumbnail
	*pdjhuff_ct++=0x00;

//	BGBBTJ_Huff_WriteString(ctx, name);
	i=pdjhuff_ct-ctt;
	ctt[0]=(i>>8)&0xFF; ctt[1]=i&0xFF;
	return(pdjhuff_ct);
}

BGBBTJ_API int BGBBTJ_JPG_EscapeEncodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if(*cs==0xFF)
		{
			cs++;
			*ct++=0xFF;
			*ct++=0x00;
			continue;
		}
		
		*ct++=*cs++;
	}
	
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_JPG_EscapeEncodeSingleBuffer(byte *buf, int sz)
{
	byte *tbuf;
	int i;
	
	tbuf=malloc(sz*2);
	i=BGBBTJ_JPG_EscapeEncodeBuffer(buf, sz, tbuf, sz*2);
	if(i<0)return(i);
	memcpy(buf, tbuf, i);
	free(tbuf);
	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_EscapeDecodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_JPG_EscapeDecodeSingleBuffer(byte *buf, int sz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=buf; cse=buf+sz;
	ct=buf; cte=buf+sz;
	
	while((cs<cse) && (ct<cte))
	{
		if((cs[0]==0xFF) && (cs[1]==0x00))
			{ cs+=2; *ct++=0xFF; continue; }
		*ct++=*cs++;
	}
	if(ct>=cte)return(-1);
	return(ct-buf);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeLDatCtx(
	BGBBTJ_JPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cts;
	int i, j, sz, tsz;
	
//	if(!ctx)ctx=BGBBTJ_JPG_AllocContext();

	tbuf=malloc(1<<24);
	sz=BGBBTJ_JPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);

	sz=BGBBTJ_JPG_EscapeEncodeSingleBuffer(tbuf, sz);

	cts=tbuf; tsz=sz;
	pdjhuff_ct=obuf; pdjhuff_win=0; pdjhuff_pos=0;
	while(tsz>=65528)
	{
		i=65529;
		if(cts[i-1]==0xFF)i--;
		j=i+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(j>>8)&0xFF;
		*pdjhuff_ct++=j&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, i);
		cts+=i; pdjhuff_ct+=i;
		tsz-=i;
	}
	
	if((tsz>0) && (tsz<65528))
	{
		i=tsz+6;
		*pdjhuff_ct++=0xFF;
		*pdjhuff_ct++=JPG_APP12;
		*pdjhuff_ct++=(i>>8)&0xFF;
		*pdjhuff_ct++=i&0xFF;

		*pdjhuff_ct++='L';
		*pdjhuff_ct++='D';
		*pdjhuff_ct++='A';
		*pdjhuff_ct++='T';
		
		memcpy(pdjhuff_ct, cts, tsz);
		pdjhuff_ct+=tsz;
	}

	sz=pdjhuff_ct-obuf;
	free(tbuf);
	
	return(sz);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeBaseCtx(
	BGBBTJ_JPG_Context *ctx, byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	byte *tbuf, *cs, *cse, *ct;
	int sz;

	tbuf=malloc(1<<24);
	sz=BGBBTJ_JPG_EncodeCtx(ctx, ibuf, tbuf, xs, ys, qf, pf);
	
	cs=tbuf; cse=tbuf+sz; ct=obuf;
	if((cs[0]==0xFF) && (cs[1]==JPG_SOI))
		cs+=2;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_EOI))
			break;
		*ct++=*cs++;
	}
	
	free(tbuf);
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeComponentCtx(
	BGBBTJ_JPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	return(BGBBTJ_JPG_EncodeComponentCtxI(ctx,
		rgba, norm, spec, luma, NULL,
		obuf, xs, ys, qf));
}

BGBBTJ_API int BGBBTJ_JPG_EncodeComponentCtxI(
	BGBBTJ_JPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe,
	byte *obuf, int xs, int ys, int qf)
{
	byte *tbuf;
	byte *ct;
	int i, j, k, n, qf1;

	if(!rgba)return(-1);

	n=xs*ys;
	tbuf=malloc(xs*ys*4);

	ct=obuf;

	*ct++=0xFF;
	*ct++=JPG_SOI;

	ct=BGBBTJ_JPG_EmitMarkerJFIF(ctx, ct);

	qf1=qf|BGBBTJ_QFL_TAGBASELAYER;

	ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "RGB");
//	i=BGBBTJ_JPG_EncodeCtx(ctx, rgba, ct, xs, ys, qf, 0);
	i=BGBBTJ_JPG_EncodeBaseCtx(ctx, rgba, ct, xs, ys, qf1, 0);
	if(i<0) { free(tbuf); return(i); }
	ct+=i;
	
//	if((ct[-2]==0xFF) && (ct[-2]==JPG_EOI))
//		{ ct-=2; }
	
	qf1=qf|BGBBTJ_QFL_SUBLAYER;
	qf1&=~BGBBTJ_QFL_BITALPHA;
	
	if(norm)
	{
		for(i=0; i<n; i++)
		{
			tbuf[i*4+0]=norm[i*4+0];
			tbuf[i*4+1]=norm[i*4+2];
			tbuf[i*4+2]=norm[i*4+1];
			tbuf[i*4+3]=255;
		}

		ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "XYZ");
		i=BGBBTJ_JPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf1, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(spec)
	{
		ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "SpRGB");
		i=BGBBTJ_JPG_EncodeLDatCtx(ctx, spec, ct, xs, ys, qf1, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(norm || spec)
	{
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			tbuf[i*4+0]=norm?norm[i*4+3]:j;
			tbuf[i*4+1]=rgba[i*4+3];
			tbuf[i*4+2]=spec?spec[i*4+3]:j;
			tbuf[i*4+3]=255;
		}

		ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "DASe");
		i=BGBBTJ_JPG_EncodeLDatCtx(ctx, tbuf, ct, xs, ys, qf1, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}else
	{
		k=0;
		for(i=0; i<n; i++)
		{
			j=rgba[i*4+3];
			if(j!=255)k=1;
			tbuf[i*4+0]=j;
			tbuf[i*4+1]=j;
			tbuf[i*4+2]=j;
			tbuf[i*4+3]=255;
		}

		if(k)
		{
			ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "Alpha");
			i=BGBBTJ_JPG_EncodeLDatCtx(ctx, tbuf,
				ct, xs, ys, qf1, BGBBTJ_JPG_YYYA);
			if(i<0) { free(tbuf); return(i); }
			ct+=i;
		}
	}

	if(luma)
	{
		ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "LuRGB");
		i=BGBBTJ_JPG_EncodeLDatCtx(ctx, luma, ct, xs, ys, qf1, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	if(lebe)
	{
		ct=BGBBTJ_JPG_EmitComponentLayer(ctx, ct, "LeBe");
		i=BGBBTJ_JPG_EncodeLDatCtx(ctx, lebe, ct, xs, ys, qf1, 0);
		if(i<0) { free(tbuf); return(i); }
		ct+=i;
	}

	*ct++=0xFF;
	*ct++=JPG_EOI;

	free(tbuf);
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_JPG_EncodeComponent(
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	BGBBTJ_JPG_Context *ctx;
	int sz;
	
	ctx=BGBBTJ_JPG_AllocContext();
	sz=BGBBTJ_JPG_EncodeComponentCtx(ctx,
		rgba, norm, spec, luma,
		obuf, xs, ys, qf);
	BGBBTJ_JPG_FreeContext(ctx);
	return(sz);
}

float pdjpg_ssqr(float f)
	{ return((f>=0)?(f*f):(-f*f)); }
float pdjpg_ssqrt(float f)
	{ return((f>=0)?sqrt(f):(-sqrt(-f))); }

int BGBBTJ_JPG_CalcComponentValueExponent(float val)
{
	float f, g;
	int i, j;

	if(val>=0)
	{
		f=log(val)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=192+i;
		return(j);
	}else
	{
		f=log(-val)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=63-i;
		return(j);
	}
}

void BGBBTJ_JPG_EncodeFloatPixel(float *ipix, byte *opix, byte *oexp)
{
	float f, g;
	int i, j, k;

	if((ipix[0]>=0) && (ipix[0]<=1) &&
		(ipix[1]>=0) && (ipix[1]<=1) &&
		(ipix[2]>=0) && (ipix[2]<=1))
	{
		*oexp=192;
		opix[0]=ipix[0]*255;
		opix[1]=ipix[1]*255;
		opix[2]=ipix[2]*255;
		return;
	}
	
	f=ipix[1];
	if(fabs(ipix[0])>fabs(f))f=ipix[0];
	if(fabs(ipix[2])>fabs(f))f=ipix[2];
	
	if(f>=0)
	{
		f=log(f)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=192+i;
		g=pdjpg_scltab[j];

		*oexp=j;
		f=255/g;
		k=ipix[0]*f; k=(k<0)?0:((k<=255)?k:255); opix[0]=k;
		k=ipix[1]*f; k=(k<0)?0:((k<=255)?k:255); opix[1]=k;
		k=ipix[2]*f; k=(k<0)?0:((k<=255)?k:255); opix[2]=k;
		return;
	}else
	{
		f=log(-f)/log(2);
		i=pdjpg_ssqrt(f*240)+0.5;
		if(i>63)i=63;
		if(i<(-63))i=-63;
		j=63-i;
		g=pdjpg_scltab[j];

		*oexp=j;
		f=255/g;
		k=ipix[0]*f; k=(k<0)?0:((k<=255)?k:255); opix[0]=k;
		k=ipix[1]*f; k=(k<0)?0:((k<=255)?k:255); opix[1]=k;
		k=ipix[2]*f; k=(k<0)?0:((k<=255)?k:255); opix[2]=k;
		return;
	}
}

BGBBTJ_API int BGBBTJ_JPG_EncodeFloatComponentCtx(BGBBTJ_JPG_Context *ctx,
	float *rgba, float *norm, float *spec, float *luma,
	byte *obuf, int xs, int ys, int qf)
{
	byte *trgba, *tnorm, *tspec, *tluma, *tlebe;
	int i, j, n;
	float f, g;

	n=xs*ys;
	if(!ctx->imgbuf_rgba)
		ctx->imgbuf_rgba=malloc(4*n);
	if(!ctx->imgbuf_norm)
		ctx->imgbuf_norm=malloc(4*n);
	if(!ctx->imgbuf_spec)
		ctx->imgbuf_spec=malloc(4*n);
	if(!ctx->imgbuf_luma)
		ctx->imgbuf_luma=malloc(4*n);

	if(!ctx->imgbuf_lebe)
	{
		ctx->imgbuf_lebe=malloc(4*n);
		memset(ctx->imgbuf_lebe, 192, 4*n);
	}
	
	trgba=ctx->imgbuf_rgba;
	tnorm=ctx->imgbuf_norm;
	tspec=ctx->imgbuf_spec;
	tluma=ctx->imgbuf_luma;
	tlebe=ctx->imgbuf_lebe;
	
	if(rgba)
	{
		for(i=0; i<n; i++)
		{
			BGBBTJ_JPG_EncodeFloatPixel(rgba, trgba+i*4, tlebe+i*4+0);
		}
	}

	if(norm)
	{
		for(i=0; i<n; i++)
		{
//			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			j=BGBBTJ_JPG_CalcComponentValueExponent(norm[i*4+3]);
			f=255/pdjpg_scltab[j];
			tnorm[i*4+0]=norm[i*4+0]*255;
			tnorm[i*4+1]=norm[i*4+1]*255;
			tnorm[i*4+2]=norm[i*4+2]*255;
			tnorm[i*4+3]=norm[i*4+3]*f;
			tlebe[i*4+3]=j;
		}
	}

	if(spec)
	{
		for(i=0; i<n; i++)
		{
			tspec[i*4+0]=spec[i*4+0]*255;
			tspec[i*4+1]=spec[i*4+1]*255;
			tspec[i*4+2]=spec[i*4+2]*255;
			tspec[i*4+3]=spec[i*4+3]*255;
		}
	}

	if(luma)
	{
		for(i=0; i<n; i++)
		{
			BGBBTJ_JPG_EncodeFloatPixel(luma, tluma+i*4, tlebe+i*4+1);
		}
	}

	i=BGBBTJ_JPG_EncodeComponentCtxI(ctx,
		trgba, tnorm, tspec, tluma, tlebe,
		obuf, xs, ys, qf);
	return(i);
}
#include <bgbbtj.h>

extern const int pdjpg_zigzag[64];
extern const int pdjpg_zigzag2[64];

extern float pdjpg_exptab[256];
extern float pdjpg_scltab[256];

//Decoder

int BGBBTJ_JPG_MarkerSOS(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	short dbuf[4*64];
	byte ch[4], cv[4], qid[4];
	byte step[4];
	int xi[4], yi[4], wi[4], hi[4];
	byte cdt[4], cat[4];
	int ccnt[4];

	byte *s;
	int i, j, k, l, i1, j1, k1, l1;
	int w, h, n, ns, rt;

	l=(buf[0]<<8)|buf[1];
//	printf("ns %d\n", buf[2]);

#if 1
	if((ctx->xs!=ctx->lxs) || (ctx->ys!=ctx->lys))
	{
		for(i=0; i<4; i++)
		{
			if(ctx->jpg_scbuf[i])free(ctx->jpg_scbuf[i]);
			if(ctx->jpg_sibuf[i])free(ctx->jpg_sibuf[i]);
			ctx->jpg_scbuf[i]=NULL;
			ctx->jpg_sibuf[i]=NULL;
		}
	}
#endif

	ns=buf[2]; rt=0;
	s=buf+3;
	for(i=0; i<buf[2]; i++)
	{
//		printf("%d %d %d\n", s[0], s[1]>>4, s[1]&15);

		cdt[i]=s[1]>>4;
		cat[i]=s[1]&15;

		for(j=0; j<ctx->jpg_nc; j++)
			if(ctx->jpg_cid[j]==s[0])
		{
			ch[i]=ctx->jpg_ch[j];
			cv[i]=ctx->jpg_cv[j];
			qid[i]=ctx->jpg_qid[j];
			xi[i]=ctx->jpg_cxi[j];
			yi[i]=ctx->jpg_cyi[j];

			step[i]=ch[i]*cv[i];
			break;
		}

		w=(xi[i]+7)/8;
		h=(yi[i]+7)/8;
//		w=(xi[i]+15)/8;
//		h=(yi[i]+15)/8;
		wi[i]=w;
		hi[i]=h;

		n=(w+1)*(h+2);
		ctx->jpg_scid[i]=s[0];
		ctx->jpg_scn[i]=j;
		if(!ctx->jpg_scbuf[i])
			ctx->jpg_scbuf[i]=malloc(n*64*sizeof(short));
		if(!ctx->jpg_sibuf[i])
			ctx->jpg_sibuf[i]=malloc(n*64*sizeof(short));

//		memset(ctx->jpg_sibuf[i], 0, n*64);

		ccnt[i]=0;

		s+=2;
	}
	s+=3;

	i=(ctx->xs+ctx->jpg_chm*8-1)/(ctx->jpg_chm*8);
	j=(ctx->ys+ctx->jpg_chn*8-1)/(ctx->jpg_chn*8);
	n=i*j;

#if 1
	for(i=0; i<ctx->jpg_nc; i++)
	{
		j=ctx->jpg_scn[i];
//		ctx->jpg_schsc[i]=ctx->jpg_ch[j]/(ctx->jpg_chm*1.0);
//		ctx->jpg_scvsc[i]=ctx->jpg_cv[j]/(ctx->jpg_chn*1.0);

		ctx->jpg_schsci[i]=(65536*ctx->jpg_ch[j])/ctx->jpg_chm;
		ctx->jpg_scvsci[i]=(65536*ctx->jpg_cv[j])/ctx->jpg_chn;

		ctx->jpg_schs[i]=(ctx->jpg_cxi[j]+7)/8;
		ctx->jpg_scvs[i]=(ctx->jpg_cyi[j]+7)/8;
		
	}

	if(ctx->jpg_nc==3)
	{
		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=32768)i=0;
		if(ctx->jpg_scvsci[1]!=32768)i=0;
		if(ctx->jpg_schsci[2]!=32768)i=0;
		if(ctx->jpg_scvsci[2]!=32768)i=0;
		ctx->jpg_is420=i;

		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=65536)i=0;
		if(ctx->jpg_scvsci[1]!=65536)i=0;
		if(ctx->jpg_schsci[2]!=65536)i=0;
		if(ctx->jpg_scvsci[2]!=65536)i=0;
		ctx->jpg_is444=i;
	}else
	{
		ctx->jpg_is420=0;
		ctx->jpg_is444=0;
	}
#endif

	BGBBTJ_Huff_InitStream(ctx, s);

	for(i=0; i<(4*64); i++)dbuf[i]=0;

	if(ctx->jpg_nc==1)
	{
		rt=0;
		for(i=0; i<n; i++)
		{
			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf,
				cdt[0]*2+0, cat[0]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf,
				ctx->jpg_scbuf[0]+i*64, qid[0]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[0]+i*64,
				ctx->jpg_sibuf[0]+i*64, 128);
		}
	}else
	if(ctx->jpg_is420 && !ctx->jpg_rdct)
//	if(0)
	{
		rt=0;
		for(i=0; i<n; i++)
		{
#if 1
			j=wi[0]>>1;
			i1=(i/j)<<1;
			j1=(i%j)<<1;

			k=((i1+0)*wi[0])+(j1+0);
			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf,
				cdt[0]*2+0, cat[0]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf,
				ctx->jpg_scbuf[0]+k*64, qid[0]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[0]+k*64,
				ctx->jpg_sibuf[0]+k*64, 128);

			k=((i1+0)*wi[0])+(j1+1);
			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf,
				cdt[0]*2+0, cat[0]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf,
				ctx->jpg_scbuf[0]+k*64, qid[0]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[0]+k*64,
				ctx->jpg_sibuf[0]+k*64, 128);

			k=((i1+1)*wi[0])+(j1+0);
			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf,
				cdt[0]*2+0, cat[0]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf,
				ctx->jpg_scbuf[0]+k*64, qid[0]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[0]+k*64,
				ctx->jpg_sibuf[0]+k*64, 128);

			k=((i1+1)*wi[0])+(j1+1);
			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf,
				cdt[0]*2+0, cat[0]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf,
				ctx->jpg_scbuf[0]+k*64, qid[0]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[0]+k*64,
				ctx->jpg_sibuf[0]+k*64, 128);
#endif

#if 1
			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf+1*64,
				cdt[1]*2+0, cat[1]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf+1*64,
				ctx->jpg_scbuf[1]+i*64, qid[1]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[1]+i*64,
				ctx->jpg_sibuf[1]+i*64, 128);

			rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf+2*64,
				cdt[2]*2+0, cat[2]*2+1, i, n);
			if(rt<0)break;
			BGBBTJ_Huff_DequantBlock(ctx, dbuf+2*64,
				ctx->jpg_scbuf[2]+i*64, qid[2]);
			BGBBTJ_JPG_TransIDCT(
				ctx->jpg_scbuf[2]+i*64,
				ctx->jpg_sibuf[2]+i*64, 128);
#endif
		}
	}else
	{
		rt=0;
		for(i=0; i<n; i++)
		{
			for(j=0; j<ns; j++)
			{
				for(k=0; k<cv[j]; k++)
				{
					for(l=0; l<ch[j]; l++)
					{
						if(rt<0)break;

						i1=(i/(wi[j]/ch[j]))*ch[j];
						j1=(i%(wi[j]/ch[j]))*ch[j];
						k1=((i1+k)*wi[j])+(j1+l);

						rt=BGBBTJ_Huff_DecodeBlock(ctx, dbuf+j*64,
							cdt[j]*2+0, cat[j]*2+1, i, n);
						if(rt<0)break;
						BGBBTJ_Huff_DequantBlock(ctx, dbuf+j*64,
							ctx->jpg_scbuf[j]+k1*64, qid[j]);
						
						if(ctx->jpg_rdct)
						{
							BGBBTJ_JPG_TransIRDCT(ctx->jpg_scbuf[j]+k1*64,
								ctx->jpg_sibuf[j]+k1*64, 128);
						}else
						{
							BGBBTJ_JPG_TransIDCT(ctx->jpg_scbuf[j]+k1*64,
								ctx->jpg_sibuf[j]+k1*64, 128);

//							BGBBTJ_JPG_TransIQDCT(ctx->jpg_scbuf[j]+k1*64,
//								ctx->jpg_sibuf[j]+k1*64, 128);
						}
					}
					if(rt<0)break;
				}
				if(rt<0)break;
			}
			if(rt<0)break;
		}
	}

	if(rt<0)
	{
		printf("BGBBTJ_JPG_MarkerSOS: Bad Image\n");
		return(-1);
	}

	i=ctx->huff_cs-buf;
	return(i);

//	return(0);
}

int BGBBTJ_JPG_MarkerSOF0(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, m, n;

	l=(buf[0]<<8)|buf[1];
//	printf("p %d\n", buf[2]);

	i=(buf[3]<<8)|buf[4];
	j=(buf[5]<<8)|buf[6];

	ctx->xs=j;
	ctx->ys=i;
//	printf("size %dx%d\n", j, i);

	if((ctx->xs!=ctx->lxs) || (ctx->ys!=ctx->lys))
	{
		if(ctx->badb)
		{
			free(ctx->badb);
			ctx->badb=NULL;
		}
	}

	m=0; n=0;

	k=buf[7];
	s=buf+8;
	for(i=0; i<k; i++)
	{
		ctx->jpg_cid[i]=s[0];
		ctx->jpg_ch[i]=s[1]>>4;
		ctx->jpg_cv[i]=s[1]&15;
		ctx->jpg_qid[i]=s[2];

		if(ctx->jpg_ch[i]>m)m=ctx->jpg_ch[i];
		if(ctx->jpg_cv[i]>n)n=ctx->jpg_cv[i];

//		printf("CID %d: %d %d %d\n", ctx->jpg_cid[i],
//			ctx->jpg_ch[i], ctx->jpg_cv[i], ctx->jpg_qid[i]);
		s+=3;
	}

	ctx->jpg_chm=m;
	ctx->jpg_chn=n;

	for(i=0; i<k; i++)
	{
		ctx->jpg_cxi[i]=(ctx->jpg_ch[i]*ctx->xs)/m;
		ctx->jpg_cyi[i]=(ctx->jpg_cv[i]*ctx->ys)/n;
	}

	ctx->jpg_nc=k;

	return(0);
}

int BGBBTJ_JPG_MarkerDQT(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	byte *s, *se;
	int i, j, l;

	l=(buf[0]<<8)|buf[1];

	s=buf+2;
	se=buf+l;

	while(s<se)
	{
		i=(s[0]>>4)&15;
		if(i)
		{
//			printf("bad bits %d\n", i);
			return(-1);
		}
		i=s[0]&15;
//		printf("dest %d\n", i);

		for(j=0; j<64; j++)
			ctx->jpg_qt[i][pdjpg_zigzag2[j]]=s[j+1];
		s+=65;
	}
	
	return(s-buf);
//	return(0);
}

int BGBBTJ_JPG_MarkerDHT(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	byte *cnt, *s;
	int i, j, k, l, tn;

	l=(buf[0]<<8)|buf[1];

	j=(buf[2]>>4)&15;
	i=buf[2]&15;
//	printf("dest %d, type %d\n", i, j);

	tn=i*2+j;

	for(i=0; i<256; i++)
	{
		ctx->huff_len[tn*256+i]=0;
		ctx->huff_next[tn*256+i]=-1;
		ctx->huff_idx[tn*256+i]=-1;
	}

	cnt=buf+3;
	s=cnt+16;
	k=0; l=0;
	for(i=0; i<16; i++)
	{
		k<<=1;
		for(j=0; j<cnt[i]; j++)
		{
			ctx->huff_code[tn*256+(*s)]=k++;
			ctx->huff_len[tn*256+(*s)]=i+1;
			ctx->huff_mask[tn*256+(*s)]=(1<<(i+1))-1;
			l=i+1;
			s++;
		}
	}
//	printf("%04X %d\n", k, l);

	//build lookup indices / chains

	for(i=0; i<256; i++)
	{
//		ctx->huff_next[tn*256+i]=0;
//		ctx->huff_idx[tn*256+i]=0;
		ctx->huff_next[tn*256+i]=-1;
		ctx->huff_idx[tn*256+i]=-1;
	}

	for(i=0; i<256; i++)
	{
		l=ctx->huff_len[tn*256+i];
		if(!l)continue;
		j=ctx->huff_code[tn*256+i];
		
		if(l<=8)
		{
			j=j<<(8-l);
			k=1<<(8-l);
			while((k--) && (j<256))
			{
				ctx->huff_idx[tn*256+j]=i;
				j++;
			}
		}else
		{
			j=j>>(l-8);
			ctx->huff_next[tn*256+i]=
				ctx->huff_idx[tn*256+j];
			ctx->huff_idx[tn*256+j]=i;
		}
	}

	return(s-buf);
//	return(0);
}

int BGBBTJ_JPG_MarkerAPP0(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	return(0);
}

int BGBBTJ_JPG_MarkerAPP9(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	int i;
	buf+=2;

	if(!memcmp(buf, "JPSERM", 6))
	{
		ctx->jpg_rdct=1;
		return(1);
	}
	
	return(0);
}

int BGBBTJ_JPG_MarkerAPP11(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	int cr, cg, cb, ca;

	buf+=2;

	if(!strcmp((char *)buf, "AlphaColor"))
	{
		buf+=strlen((char *)buf)+1;
		sscanf(buf, "%d %d %d %d", &cr, &cg, &cb, &ca);
		BGBBTJ_JPG_SetContextAlphaColor(ctx, cr, cg, cb, ca);
		return(1);
	}
	
	return(0);
}

int BGBBTJ_JPG_MarkerAPP12(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	byte *tbuf;
	int i, sz, sz1;
	
	sz=(buf[0]<<8)|buf[1];
	buf+=2;

	i=(buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
//	printf("BGBBTJ_JPG_MarkerAPP12: %08X\n", i);

	if(!memcmp(buf, "BCST", 4))
	{
		ctx->bcst_version=(buf[4]<<8)|buf[5];
		ctx->bcst_trans=buf[6];
		ctx->bcst_bpp=buf[7];
		ctx->bcst_flags=
			(buf[8]<<24)|(buf[9]<<16)|
			(buf[10]<<8)|buf[11];

		if(sz>14)
		{
			ctx->bcst_alpha=buf[12];
			ctx->bcst_blend=buf[13];
			ctx->bcst_orgx=((buf[14]<<8)|buf[15]);
			ctx->bcst_orgy=((buf[16]<<8)|buf[17]);

			ctx->bcst_minx = ((buf[18] << 8) | buf[19]);
			ctx->bcst_miny = ((buf[20] << 8) | buf[21]);
			ctx->bcst_maxx = ((buf[22] << 8) | buf[23]);
			ctx->bcst_maxy = ((buf[24] << 8) | buf[25]);
		}
		else
		{
			ctx->bcst_alpha=255;
			ctx->bcst_blend=0;
			ctx->bcst_orgx=0;
			ctx->bcst_orgy=0;

			ctx->bcst_minx = 0;
			ctx->bcst_miny = 0;
			ctx->bcst_maxx = 0;
			ctx->bcst_maxy = 0;
		}

		ctx->jpg_clrtrans=ctx->bcst_trans;
		
		if(ctx->bcst_flags&BGBBTJ_JPG_BCSFL_RDCT)
			ctx->jpg_rdct=1;
			
//		printf("BGBBTJ_JPG_MarkerAPP12: BCST %04X %02X %02X %08X\n",
//			ctx->bcst_version, ctx->bcst_trans,
//			ctx->bcst_bpp, ctx->bcst_flags);
		return(1);
	}

	if(!memcmp(buf, "BA1Z", 4))
	{
		if(ctx->badb)
		{
			PDUNZ_DecodeStreamSz(buf+6, ctx->badb, sz-8,
				ctx->sz_badb, &sz1, BGBBTJ_ZFL_ESCAPE_FF);
		}else
		{
			tbuf=malloc(1<<20);
			PDUNZ_DecodeStreamSz(buf+6, tbuf, sz-8, 1<<20, &sz1,
				BGBBTJ_ZFL_ESCAPE_FF);
			ctx->badb=malloc(sz1);
			ctx->sz_badb=sz1;
			memcpy(ctx->badb, tbuf, sz1);
			free(tbuf);
		}
	}

	return(0);
}

int BGBBTJ_JPG_MarkerAPP14(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	buf+=2;

#if 0
	if(!memcmp((char *)buf, "Adobe", 5))
	{
		ctx->jpg_app14_dctversion=(buf[5]<<8)|buf[6];
		ctx->jpg_app14_flags0=(buf[7]<<8)|buf[8];
		ctx->jpg_app14_flags1=(buf[9]<<8)|buf[10];
		ctx->jpg_app14_trans=buf[11];
		
		switch(ctx->jpg_app14_trans)
		{
		case 0: ctx->jpg_clrtrans=BGBBTJ_JPG_CLRS_RGB; break;
		case 1: ctx->jpg_clrtrans=BGBBTJ_JPG_CLRS_YCBCR; break;
		case 2: ctx->jpg_clrtrans=BGBBTJ_JPG_CLRS_YCCK; break;
		}
		
		return(1);
	}
#endif

	return(0);
}

int BGBBTJ_JPG_MarkerAPPN(BGBBTJ_JPG_Context *ctx, byte *buf)
{
	return(0);
}

#if 0
int BGBBTJ_JPG_GetComponentPixel(BGBBTJ_JPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	id=ctx->jpg_scn[cn];

	i=x*ctx->jpg_schsc[cn];
	j=y*ctx->jpg_scvsc[cn];
//	i=(ctx->jpg_ch[id]*x)/ctx->jpg_chm;
//	j=(ctx->jpg_cv[id]*y)/ctx->jpg_chn;
	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
	h=ctx->jpg_scvs[cn];
//	w=(ctx->jpg_cxi[id]+7)/8;
//	h=(ctx->jpg_cyi[id]+7)/8;
//	w=(ctx->jpg_cxi[id]+15)/8;
//	h=(ctx->jpg_cyi[id]+15)/8;
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}
#endif

#if 1
int BGBBTJ_JPG_GetComponentPixel(BGBBTJ_JPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

//	i=x*ctx->jpg_schsc[cn];
//	j=y*ctx->jpg_scvsc[cn];

	i=(x*ctx->jpg_schsci[cn])>>16;
	j=(y*ctx->jpg_scvsci[cn])>>16;

	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}
#endif

#if 1
int BGBBTJ_JPG_GetComponentPixelS1(BGBBTJ_JPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	i=x>>3;
	j=y>>3;
	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(j*w)+i;

	k=x&7;
	l=y&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

int BGBBTJ_JPG_GetComponentPixelS2(BGBBTJ_JPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	i=x>>1;
	j=y>>1;

	k=i>>3;
	l=j>>3;
	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	return(v);
}

int BGBBTJ_JPG_GetComponentPixelS122(BGBBTJ_JPG_Context *ctx, int x, int y,
	int *ry, int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	x1=x>>1; y1=y>>1;

	w0=ctx->jpg_schs[0];
	w1=ctx->jpg_schs[1];

	i=x>>3; j=y>>3;
	k=x1>>3; l=y1>>3;
	n0=(j*w0)+i;
	n1=(l*w1)+k;

	i=x&7; j=y&7;
	k=x1&7; l=y1&7;
	t0=(n0<<6)+((j<<3)+i);
	t1=(n1<<6)+((l<<3)+k);

	*ry=ctx->jpg_sibuf[0][t0];
	*ru=ctx->jpg_sibuf[1][t1];
	*rv=ctx->jpg_sibuf[2][t1];

	return(0);
}

int BGBBTJ_JPG_GetComponentPixelS111(BGBBTJ_JPG_Context *ctx, int x, int y,
	int *ry, int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	w0=ctx->jpg_schs[0];
	i=x>>3; j=y>>3;
	n0=(j*w0)+i;

	i=x&7; j=y&7;
	t0=(n0<<6)+((j<<3)+i);

	*ry=ctx->jpg_sibuf[0][t0];
	*ru=ctx->jpg_sibuf[1][t0];
	*rv=ctx->jpg_sibuf[2][t0];

	return(0);
}

int BGBBTJ_JPG_GetComponentPixelS420(BGBBTJ_JPG_Context *ctx, int x, int y,
	int *ry0, int *ry1, int *ry2, int *ry3,
	int *ru, int *rv)
{
	int i, j, k, l;
	int t0, t1, w0, w1, n0, n1, x1, y1;

	x1=x>>1; y1=y>>1;

	w0=ctx->jpg_schs[0];
	w1=ctx->jpg_schs[1];

	i=x>>3; j=y>>3;
	k=x1>>3; l=y1>>3;
	n0=(j*w0)+i;
	n1=(l*w1)+k;

	i=x&7; j=y&7;
	k=x1&7; l=y1&7;
	t0=(n0<<6)+((j<<3)+i);
	t1=(n1<<6)+((l<<3)+k);

	*ry0=ctx->jpg_sibuf[0][t0];
	*ry1=ctx->jpg_sibuf[0][t0+1];
	*ry2=ctx->jpg_sibuf[0][t0+8];
	*ry3=ctx->jpg_sibuf[0][t0+9];

	*ru=ctx->jpg_sibuf[1][t1];
	*rv=ctx->jpg_sibuf[2][t1];

	return(0);
}

#endif

#if 1
int BGBBTJ_JPG_GetComponentPixelAlpha(
	BGBBTJ_JPG_Context *ctx, int cn, int x, int y)
{
	int i, j, k, l;
	int id, w, h, n, v;

	if(!ctx->badb)
		return(255);

	i=(x*ctx->jpg_schsci[cn])>>16;
	j=(y*ctx->jpg_scvsci[cn])>>16;

	k=i>>3;
	l=j>>3;

	w=ctx->jpg_schs[cn];
//	h=ctx->jpg_scvs[cn];
	n=(l*w)+k;

	k=i&7;
	l=j&7;

//	v=ctx->jpg_sibuf[cn][n*64+(l*8+k)];
	v=((ctx->badb[n*8+l]>>(7-k))&1)?255:0;
	return(v);
}
#endif

int BGBBTJ_JPG_DecodeColorTransformYCbCr420(BGBBTJ_JPG_Context *ctx, byte *obuf)
{
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

#if 1
		for(i=0; i<ctx->ys; i+=2)
			for(j=0; j<ctx->xs; j+=2)
		{
//			BGBBTJ_JPG_GetComponentPixelS122(ctx, j, i, &y0, &u, &v);
//			y1=BGBBTJ_JPG_GetComponentPixelS1(ctx, 0, j+1, i+0);
//			y2=BGBBTJ_JPG_GetComponentPixelS1(ctx, 0, j+0, i+1);
//			y3=BGBBTJ_JPG_GetComponentPixelS1(ctx, 0, j+1, i+1);

			BGBBTJ_JPG_GetComponentPixelS420(ctx, j, i,
				&y0, &y1, &y2, &y3, &u, &v);

			if(ctx->alphaClr)
			{
				a=255;

				k=y0-ctx->alphaClrY; l=k*k;
				k=y1-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				k=y2-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				k=y3-ctx->alphaClrY; k=k*k; if(k<l)l=k;
				
//				k=y0-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				
				a=ctx->alphaClrA;
				a=(l<=(a*a))?0:255;
			}else { a=255; }

			u1=u-128; v1=v-128;
			l0=91881*v1;
			l1=-22554*u1-46802*v1;
			l2=116130*u1;

			y0<<=16; y1<<=16; y2<<=16; y3<<=16;
			r0=y0+l0; g0=y0+l1; b0=y0+l2;
			r1=y1+l0; g1=y1+l1; b1=y1+l2;
			r2=y2+l0; g2=y2+l1; b2=y2+l2;
			r3=y3+l0; g3=y3+l1; b3=y3+l2;

//			r0=65536*y0+l0; g0=65536*y0+l1; b0=65536*y0+l2;
//			r1=65536*y1+l0; g1=65536*y1+l1; b1=65536*y1+l2;
//			r2=65536*y2+l0; g2=65536*y2+l1; b2=65536*y2+l2;
//			r3=65536*y3+l0; g3=65536*y3+l1; b3=65536*y3+l2;

			r0>>=16; g0>>=16; b0>>=16;
			r1>>=16; g1>>=16; b1>>=16;
			r2>>=16; g2>>=16; b2>>=16;
			r3>>=16; g3>>=16; b3>>=16;

#if 0
			if((r0|r1|r2|r3)&(~255))
			{
				r0=(r0<0)?0:((r0>255)?255:r0);
				r1=(r1<0)?0:((r1>255)?255:r1);
				r2=(r2<0)?0:((r2>255)?255:r2);
				r3=(r3<0)?0:((r3>255)?255:r3);
			}

			if((g0|g1|g2|g3)&(~255))
			{
				g0=(g0<0)?0:((g0>255)?255:g0);
				g1=(g1<0)?0:((g1>255)?255:g1);
				g2=(g2<0)?0:((g2>255)?255:g2);
				g3=(g3<0)?0:((g3>255)?255:g3);
			}

			if((b0|b1|b2|b3)&(~255))
			{
				b0=(b0<0)?0:((b0>255)?255:b0);
				b1=(b1<0)?0:((b1>255)?255:b1);
				b2=(b2<0)?0:((b2>255)?255:b2);
				b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 1
			if((r0|r1|r2|r3)&(~255))
			{
				if(r0&(~255))r0=(r0<0)?0:((r0>255)?255:r0);
				if(r1&(~255))r1=(r1<0)?0:((r1>255)?255:r1);
				if(r2&(~255))r2=(r2<0)?0:((r2>255)?255:r2);
				if(r3&(~255))r3=(r3<0)?0:((r3>255)?255:r3);
			}

			if((g0|g1|g2|g3)&(~255))
			{
				if(g0&(~255))g0=(g0<0)?0:((g0>255)?255:g0);
				if(g1&(~255))g1=(g1<0)?0:((g1>255)?255:g1);
				if(g2&(~255))g2=(g2<0)?0:((g2>255)?255:g2);
				if(g3&(~255))g3=(g3<0)?0:((g3>255)?255:g3);
			}

			if((b0|b1|b2|b3)&(~255))
			{
				if(b0&(~255))b0=(b0<0)?0:((b0>255)?255:b0);
				if(b1&(~255))b1=(b1<0)?0:((b1>255)?255:b1);
				if(b2&(~255))b2=(b2<0)?0:((b2>255)?255:b2);
				if(b3&(~255))b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 0
			k=r0|r1|r2|r3 | g0|g1|g2|g3 | b0|b1|b2|b3;
			if(k&(~255))
			{
				if(r0&(~255))r0=(r0<0)?0:((r0>255)?255:r0);
				if(g0&(~255))g0=(g0<0)?0:((g0>255)?255:g0);
				if(b0&(~255))b0=(b0<0)?0:((b0>255)?255:b0);
				if(r1&(~255))r1=(r1<0)?0:((r1>255)?255:r1);
				if(g1&(~255))g1=(g1<0)?0:((g1>255)?255:g1);
				if(b1&(~255))b1=(b1<0)?0:((b1>255)?255:b1);
				if(r2&(~255))r2=(r2<0)?0:((r2>255)?255:r2);
				if(g2&(~255))g2=(g2<0)?0:((g2>255)?255:g2);
				if(b2&(~255))b2=(b2<0)?0:((b2>255)?255:b2);
				if(r3&(~255))r3=(r3<0)?0:((r3>255)?255:r3);
				if(g3&(~255))g3=(g3<0)?0:((g3>255)?255:g3);
				if(b3&(~255))b3=(b3<0)?0:((b3>255)?255:b3);
			}
#endif

#if 0
			r0=(!(r0&(~255)))?r0:((r0<0)?0:((r0>255)?255:r0));
			g0=(!(g0&(~255)))?g0:((g0<0)?0:((g0>255)?255:g0));
			b0=(!(b0&(~255)))?b0:((b0<0)?0:((b0>255)?255:b0));
			r1=(!(r1&(~255)))?r1:((r1<0)?0:((r1>255)?255:r1));
			g1=(!(g1&(~255)))?g1:((g1<0)?0:((g1>255)?255:g1));
			b1=(!(b1&(~255)))?b1:((b1<0)?0:((b1>255)?255:b1));
			r2=(!(r2&(~255)))?r2:((r2<0)?0:((r2>255)?255:r2));
			g2=(!(g2&(~255)))?g2:((g2<0)?0:((g2>255)?255:g2));
			b2=(!(b2&(~255)))?b2:((b2<0)?0:((b2>255)?255:b2));
			r3=(!(r3&(~255)))?r3:((r3<0)?0:((r3>255)?255:r3));
			g3=(!(g3&(~255)))?g3:((g3<0)?0:((g3>255)?255:g3));
			b3=(!(b3&(~255)))?b3:((b3<0)?0:((b3>255)?255:b3));
#endif

#if 0
			r0=(r0<0)?0:((r0>255)?255:r0);
			g0=(g0<0)?0:((g0>255)?255:g0);
			b0=(b0<0)?0:((b0>255)?255:b0);
			r1=(r1<0)?0:((r1>255)?255:r1);
			g1=(g1<0)?0:((g1>255)?255:g1);
			b1=(b1<0)?0:((b1>255)?255:b1);
			r2=(r2<0)?0:((r2>255)?255:r2);
			g2=(g2<0)?0:((g2>255)?255:g2);
			b2=(b2<0)?0:((b2>255)?255:b2);
			r3=(r3<0)?0:((r3>255)?255:r3);
			g3=(g3<0)?0:((g3>255)?255:g3);
			b3=(b3<0)?0:((b3>255)?255:b3);
#endif

			k=ctx->ys-1-i;
			l0=((k*ctx->xs)+j+0)*4;
//			l1=((k*ctx->xs)+j+1)*4;
			k=ctx->ys-2-i;
			l2=((k*ctx->xs)+j+0)*4;
//			l3=((k*ctx->xs)+j+1)*4;

//			ct=obuf+l0; *ct++=r0; *ct++=g0; *ct++=b0; *ct++=a;
//			ct=obuf+l1; *ct++=r1; *ct++=g1; *ct++=b1; *ct++=a;
//			ct=obuf+l2; *ct++=r2; *ct++=g2; *ct++=b2; *ct++=a;
//			ct=obuf+l3; *ct++=r3; *ct++=g3; *ct++=b3; *ct++=a;

			obuf[l0+0]=r0; obuf[l0+1]=g0; obuf[l0+2]=b0; obuf[l0+3]=a;
			obuf[l0+4]=r1; obuf[l0+5]=g1; obuf[l0+6]=b1; obuf[l0+7]=a;
			obuf[l2+0]=r2; obuf[l2+1]=g2; obuf[l2+2]=b2; obuf[l2+3]=a;
			obuf[l2+4]=r3; obuf[l2+5]=g3; obuf[l2+6]=b3; obuf[l2+7]=a;

//			obuf[l0+0]=r0; obuf[l0+1]=g0; obuf[l0+2]=b0; obuf[l0+3]=a;
//			obuf[l1+0]=r1; obuf[l1+1]=g1; obuf[l1+2]=b1; obuf[l1+3]=a;
//			obuf[l2+0]=r2; obuf[l2+1]=g2; obuf[l2+2]=b2; obuf[l2+3]=a;
//			obuf[l3+0]=r3; obuf[l3+1]=g3; obuf[l3+2]=b3; obuf[l3+3]=a;
		}
#endif

#if 0
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			BGBBTJ_JPG_GetComponentPixelS122(ctx, j, i, &y, &u, &v);

			if(ctx->alphaClr)
			{
				k=y-ctx->alphaClrY; l=k*k;
				k=u-ctx->alphaClrU; l+=k*k;
				k=v-ctx->alphaClrV; l+=k*k;
				
				a=ctx->alphaClrA;
				a=(l<=(a*a))?0:255;
			}else { a=255; }

			u1=u-128; v1=v-128;
			r=65536*y          +91881*v1;
			g=65536*y- 22554*u1-46802*v1;
			b=65536*y+116130*u1;
			r>>=16; g>>=16; b>>=16;

			r=(r<0)?0:((r>255)?255:r);
			g=(g<0)?0:((g>255)?255:g);
			b=(b<0)?0:((b>255)?255:b);

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
#endif
	return(0);
}

/** Simulate basic decoding, but doesn't actually decode image.
  * Can be used to retrieve resolution or initialize Huffman tables
  * at a lower cost than a full decode. */
BGBBTJ_API int BGBBTJ_JPG_DummyDecodeCtx(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *obuf, *ct;
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l;

//	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
//		return(-1);

	ctx->jpg_is420=0;
	ctx->jpg_rdct=0;
	ctx->jpg_clrtrans=0;

	ctx->bcst_version=0;
	ctx->bcst_flags=0;
	ctx->bcst_trans=0;
	ctx->bcst_bpp=0;

	for(i=0; i<4; i++)
	{
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}

	for(i=0; i<sz; i++)
	{
//		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		if(buf[i]==0xFF)
		{
			if(buf[i+1]==0x00)
				{ i++; continue; }
			if(buf[i+1]==0xFF)
				{ i++; continue; }

			j=buf[i+1]-0xC0;
			if(j<0)j=63;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)BGBBTJ_JPG_MarkerDQT(ctx, buf+i+2);
			if(buf[i+1]==JPG_DHT)BGBBTJ_JPG_MarkerDHT(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOF0)BGBBTJ_JPG_MarkerSOF0(ctx, buf+i+2);
			if(buf[i+1]==JPG_SOS)
			{
//				j=BGBBTJ_JPG_MarkerSOS(ctx, buf+i+2);
//				if(j>0) { i+=j; }
				continue;
			}

			if((buf[i+1]>=JPG_APP0) && (buf[i+1]<=JPG_APP15))
			{
				if(buf[i+1]==JPG_APP0)BGBBTJ_JPG_MarkerAPP0(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP9)BGBBTJ_JPG_MarkerAPP9(ctx, buf+i+2);
				
				if(buf[i+1]==JPG_APP11)BGBBTJ_JPG_MarkerAPP11(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP12)BGBBTJ_JPG_MarkerAPP12(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP14)BGBBTJ_JPG_MarkerAPP14(ctx, buf+i+2);

				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j;
				continue;
			}

			if(buf[i+1]==JPG_EOI)break;
		}
	}

	*xs=ctx->xs;
	*ys=ctx->ys;

	return(0);
}

int BGBBTJ_JPG_DecodeColorTransform_YCbCr420_DXT1(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys, int stride)
{
	short *yblk, *ublk, *vblk;
	byte *oblk;
	int xs1, ys1, xs2, ys2, xs3, ys3, xs4, ys4;
	int i, j, k, i1;

	xs1=xs>>1; ys1=ys>>1;
	xs2=xs>>2; ys2=ys>>2;
	xs3=xs>>3; ys3=ys>>3;
	xs4=xs>>4; ys4=ys>>4;

	for(i=0; i<ys4; i++)
		for(j=0; j<xs4; j++)
	{
		k=i*xs4+j;
		ublk=ctx->jpg_sibuf[1]+k*64;
		vblk=ctx->jpg_sibuf[2]+k*64;

#if 1
		i1=ys4-i-1;

		k=((i*2+0)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;

		k=((i1*4+3)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+0, vblk+0);
		k=((i1*4+3)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+2, vblk+2);
		k=((i1*4+2)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+16, vblk+16);
		k=((i1*4+2)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+18, vblk+18);

		k=((i*2+0)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i1*4+3)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+4, vblk+4);
		k=((i1*4+3)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+6, vblk+6);
		k=((i1*4+2)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+20, vblk+20);
		k=((i1*4+2)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+22, vblk+22);

		k=((i*2+1)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i1*4+1)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+32, vblk+32);
		k=((i1*4+1)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+34, vblk+34);
		k=((i1*4+0)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+48, vblk+48);
		k=((i1*4+0)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+50, vblk+50);

		k=((i*2+1)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i1*4+1)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+36, vblk+36);
		k=((i1*4+1)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+38, vblk+38);
		k=((i1*4+0)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+52, vblk+52);
		k=((i1*4+0)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+54, vblk+54);
#endif

#if 0
		k=((i*2+0)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;

		k=((i*4+0)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+0, vblk+0);
		k=((i*4+0)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+2, vblk+2);
		k=((i*4+1)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+16, vblk+16);
		k=((i*4+1)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+18, vblk+18);

		k=((i*2+0)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i*4+0)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+4, vblk+4);
		k=((i*4+0)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+6, vblk+6);
		k=((i*4+1)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+20, vblk+20);
		k=((i*4+1)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+22, vblk+22);

		k=((i*2+1)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i*4+2)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+32, vblk+32);
		k=((i*4+2)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+34, vblk+34);
		k=((i*4+3)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+48, vblk+48);
		k=((i*4+3)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+50, vblk+50);

		k=((i*2+1)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i*4+2)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+0, ublk+36, vblk+36);
		k=((i*4+2)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+4, ublk+38, vblk+38);
		k=((i*4+3)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+32, ublk+52, vblk+52);
		k=((i*4+3)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(oblk, yblk+36, ublk+54, vblk+54);
#endif

	}
	return(0);
}

int BGBBTJ_JPG_DecodeColorTransform_YCbCr420_DXT1A(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys, int stride)
{
	short *yblk, *ublk, *vblk;
	byte *oblk, *ablk;
	int xs1, ys1, xs2, ys2, xs3, ys3, xs4, ys4;
	int i, j, k, i1, a;

	xs1=xs>>1; ys1=ys>>1;
	xs2=xs>>2; ys2=ys>>2;
	xs3=xs>>3; ys3=ys>>3;
	xs4=xs>>4; ys4=ys>>4;

	for(i=0; i<ys4; i++)
		for(j=0; j<xs4; j++)
	{
		k=i*xs4+j;
		ublk=ctx->jpg_sibuf[1]+k*64;
		vblk=ctx->jpg_sibuf[2]+k*64;

		i1=ys4-i-1;

		k=((i*2+0)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;
		ablk=ctx->badb+k*8;

		a=(	(ablk[0]&0xF0)<<8)|((ablk[1]&0xF0)<<4)|
			(ablk[2]&0xF0)|((ablk[3]&0xF0)>>8);
		k=((i1*4+3)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+0, ublk+0, vblk+0, a);

		a=(	(ablk[0]&0x0F)<<12)|((ablk[1]&0x0F)<<8)|
			((ablk[2]&0x0F)<<4)|(ablk[3]&0x0F);
		k=((i1*4+3)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+4, ublk+2, vblk+2, a);

		a=(	(ablk[4]&0xF0)<<8)|((ablk[5]&0xF0)<<4)|
			(ablk[6]&0xF0)|((ablk[7]&0xF0)>>8);
		k=((i1*4+2)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+32, ublk+16, vblk+16, a);

		a=(	(ablk[4]&0x0F)<<12)|((ablk[5]&0x0F)<<8)|
			((ablk[6]&0x0F)<<4)|(ablk[7]&0x0F);
		k=((i1*4+2)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+36, ublk+18, vblk+18, a);


		k=((i*2+0)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
		ablk=ctx->badb+k*8;
	
		a=(	(ablk[0]&0xF0)<<8)|((ablk[1]&0xF0)<<4)|
			(ablk[2]&0xF0)|((ablk[3]&0xF0)>>8);
		k=((i1*4+3)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+0, ublk+4, vblk+4, a);

		a=(	(ablk[0]&0x0F)<<12)|((ablk[1]&0x0F)<<8)|
			((ablk[2]&0x0F)<<4)|(ablk[3]&0x0F);
		k=((i1*4+3)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+4, ublk+6, vblk+6, a);

		a=(	(ablk[4]&0xF0)<<8)|((ablk[5]&0xF0)<<4)|
			(ablk[6]&0xF0)|((ablk[7]&0xF0)>>8);
		k=((i1*4+2)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+32, ublk+20, vblk+20, a);

		a=(	(ablk[4]&0x0F)<<12)|((ablk[5]&0x0F)<<8)|
			((ablk[6]&0x0F)<<4)|(ablk[7]&0x0F);
		k=((i1*4+2)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+36, ublk+22, vblk+22, a);


		k=((i*2+1)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;
		ablk=ctx->badb+k*8;
	
		a=(	(ablk[0]&0xF0)<<8)|((ablk[1]&0xF0)<<4)|
			(ablk[2]&0xF0)|((ablk[3]&0xF0)>>8);
		k=((i1*4+1)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+0, ublk+32, vblk+32, a);

		a=(	(ablk[0]&0x0F)<<12)|((ablk[1]&0x0F)<<8)|
			((ablk[2]&0x0F)<<4)|(ablk[3]&0x0F);
		k=((i1*4+1)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+4, ublk+34, vblk+34, a);

		a=(	(ablk[4]&0xF0)<<8)|((ablk[5]&0xF0)<<4)|
			(ablk[6]&0xF0)|((ablk[7]&0xF0)>>8);
		k=((i1*4+0)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+32, ublk+48, vblk+48, a);

		a=(	(ablk[4]&0x0F)<<12)|((ablk[5]&0x0F)<<8)|
			((ablk[6]&0x0F)<<4)|(ablk[7]&0x0F);
		k=((i1*4+0)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+36, ublk+50, vblk+50, a);


		k=((i*2+1)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
		ablk=ctx->badb+k*8;
	
		a=(	(ablk[0]&0xF0)<<8)|((ablk[1]&0xF0)<<4)|
			(ablk[2]&0xF0)|((ablk[3]&0xF0)>>8);
		k=((i1*4+1)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+0, ublk+36, vblk+36, a);

		a=(	(ablk[0]&0x0F)<<12)|((ablk[1]&0x0F)<<8)|
			((ablk[2]&0x0F)<<4)|(ablk[3]&0x0F);
		k=((i1*4+1)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+4, ublk+38, vblk+38, a);

		a=(	(ablk[4]&0xF0)<<8)|((ablk[5]&0xF0)<<4)|
			(ablk[6]&0xF0)|((ablk[7]&0xF0)>>8);
		k=((i1*4+0)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+32, ublk+52, vblk+52, a);

		a=(	(ablk[4]&0x0F)<<12)|((ablk[5]&0x0F)<<8)|
			((ablk[6]&0x0F)<<4)|(ablk[7]&0x0F);
		k=((i1*4+0)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(
			oblk, yblk+36, ublk+54, vblk+54, a);
	}
	return(0);
}

#if 1
int BGBBTJ_JPG_DecodeColorTransform_YBC4(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys, int stride)
{
	short *yblk;
	byte *oblk, *ablk;
	int xs1, ys1, xs2, ys2, xs3, ys3, xs4, ys4;
	int i, j, k, i1, a;

	xs1=xs>>1; ys1=ys>>1;
	xs2=xs>>2; ys2=ys>>2;
	xs3=xs>>3; ys3=ys>>3;
	xs4=xs>>4; ys4=ys>>4;

	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		k=i*xs3+j;
		i1=ys3-i-1;

		yblk=ctx->jpg_sibuf[0]+k*64;
		k=((i1*2+1)*xs2)+(j*2+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockBC4Y8x8(oblk, yblk+0);
		k=((i1*2+1)*xs2)+(j*2+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockBC4Y8x8(oblk, yblk+4);
		k=((i1*2+0)*xs2)+(j*2+0); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockBC4Y8x8(oblk, yblk+32);
		k=((i1*2+0)*xs2)+(j*2+1); oblk=obuf+k*stride;
		BGBBTJ_BCn_EncodeBlockBC4Y8x8(oblk, yblk+36);
	}
	return(0);
}
#endif

#if 1
int BGBBTJ_JPG_DecodeColorTransform_YCbCr420_BC7(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys,
	int stride, int vfl)
{
	short *yblk, *ublk, *vblk;
	byte *oblk;
	int xs1, ys1, xs2, ys2, xs3, ys3, xs4, ys4;
	int i, j, k, i1;

	xs1=xs>>1; ys1=ys>>1;
	xs2=xs>>2; ys2=ys>>2;
	xs3=xs>>3; ys3=ys>>3;
	xs4=xs>>4; ys4=ys>>4;

	for(i=0; i<ys4; i++)
		for(j=0; j<xs4; j++)
	{
		k=i*xs4+j;
		ublk=ctx->jpg_sibuf[1]+k*64;
		vblk=ctx->jpg_sibuf[2]+k*64;

		i1=ys4-i-1;

		k=((i*2+0)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;

		k=((i1*4+3)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+0, ublk+0, vblk+0, vfl);
		k=((i1*4+3)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+4, ublk+2, vblk+2, vfl);
		k=((i1*4+2)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+32, ublk+16, vblk+16, vfl);
		k=((i1*4+2)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+36, ublk+18, vblk+18, vfl);

		k=((i*2+0)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i1*4+3)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+0, ublk+4, vblk+4, vfl);
		k=((i1*4+3)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+4, ublk+6, vblk+6, vfl);
		k=((i1*4+2)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+32, ublk+20, vblk+20, vfl);
		k=((i1*4+2)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+36, ublk+22, vblk+22, vfl);

		k=((i*2+1)*xs3)+(j*2+0);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i1*4+1)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+0, ublk+32, vblk+32, vfl);
		k=((i1*4+1)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+4, ublk+34, vblk+34, vfl);
		k=((i1*4+0)*xs2)+(j*4+0); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+32, ublk+48, vblk+48, vfl);
		k=((i1*4+0)*xs2)+(j*4+1); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+36, ublk+50, vblk+50, vfl);

		k=((i*2+1)*xs3)+(j*2+1);
		yblk=ctx->jpg_sibuf[0]+k*64;
	
		k=((i1*4+1)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+0, ublk+36, vblk+36, vfl);
		k=((i1*4+1)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+4, ublk+38, vblk+38, vfl);
		k=((i1*4+0)*xs2)+(j*4+2); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+32, ublk+52, vblk+52, vfl);
		k=((i1*4+0)*xs2)+(j*4+3); oblk=obuf+k*stride;
		BGBBTJ_BC7_EncodeBlock_YUV420(oblk, yblk+36, ublk+54, vblk+54, vfl);
	}
	return(0);
}
#endif

void BGBBTJ_JPG_DecodeColorTransform_YFast(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys)
{
	short *yblk;
	byte *oblk;
	int xs1, ys1, xs2, ys2, xs3, ys3, xs4, ys4;
	int y, l0, l1;
	int i, j, k;

	xs3=xs>>3; ys3=ys>>3;
	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		k=(i*xs3)+j;
		yblk=ctx->jpg_sibuf[0]+k*64;
		
		oblk=obuf+((((ys3-i-1)*8)*xs)+(j*8))*4;
		for(k=0; k<8; k++)
		{
			l0=(7-k)*8; l1=k*xs*4;
			y=yblk[l0+0]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+ 0]=y; oblk[l1+ 1]=y; oblk[l1+ 2]=y;
			y=yblk[l0+1]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+ 4]=y; oblk[l1+ 5]=y; oblk[l1+ 6]=y;
			y=yblk[l0+2]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+ 8]=y; oblk[l1+ 9]=y; oblk[l1+10]=y;
			y=yblk[l0+3]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+12]=y; oblk[l1+13]=y; oblk[l1+14]=y;
			y=yblk[l0+4]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+16]=y; oblk[l1+17]=y; oblk[l1+18]=y;
			y=yblk[l0+5]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+20]=y; oblk[l1+21]=y; oblk[l1+22]=y;
			y=yblk[l0+6]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+24]=y; oblk[l1+25]=y; oblk[l1+26]=y;
			y=yblk[l0+7]; y=(y<0)?0:((y>255)?255:y);
			oblk[l1+28]=y; oblk[l1+29]=y; oblk[l1+30]=y;
		}
	}
}

BGBBTJ_API void BGBBTJ_JPG_DecodeCtxI_ColorTransform(
	BGBBTJ_JPG_Context *ctx, byte *obuf, int xs, int ys, int clrs)
{
	int y, u, v, r, g, b, a, u1, v1;
//	int y0, y1, y2, y3;
//	int r0, g0, b0, a0;
//	int r1, g1, b1, a1;
//	int r2, g2, b2, a2;
//	int r3, g3, b3, a3;
//	int l0, l1, l2, l3;
	int i, j, k, l;

	if((clrs==BGBBTJ_JPG_BC1) || (clrs==BGBBTJ_JPG_BC1F))
	{
		if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&15) &&
			(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR))
		{
			BGBBTJ_JPG_DecodeColorTransform_YCbCr420_DXT1(
				ctx, obuf, xs, ys, 8);
			return;
		}
		return;
	}

	if(clrs==BGBBTJ_JPG_BC1A)
	{
		if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&15) &&
			(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR))
		{
			if(ctx->badb)
			{
				BGBBTJ_JPG_DecodeColorTransform_YCbCr420_DXT1A(
					ctx, obuf, xs, ys, 8);
			}else
			{
				BGBBTJ_JPG_DecodeColorTransform_YCbCr420_DXT1(
					ctx, obuf, xs, ys, 8);
			}
			return;
		}
		return;
	}

	if((clrs==BGBBTJ_JPG_BC3) || (clrs==BGBBTJ_JPG_BC3F) ||
		(clrs==BGBBTJ_JPG_BC3_VF))
	{
		if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&15) &&
			(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR))
		{
			BGBBTJ_JPG_DecodeColorTransform_YCbCr420_DXT1(
				ctx, obuf+8, xs, ys, 16);
			return;
		}
		return;
	}

	if((clrs==BGBBTJ_JPG_BC7) ||
		(clrs==BGBBTJ_JPG_BC7_VF2))
	{
		if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&15) &&
			(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR))
		{
			BGBBTJ_JPG_DecodeColorTransform_YCbCr420_BC7(
				ctx, obuf, xs, ys, 16, 1);
			return;
		}
		return;
	}

	if(clrs==BGBBTJ_JPG_BC7_VF)
	{
		if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&15) &&
			(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR))
		{
			BGBBTJ_JPG_DecodeColorTransform_YCbCr420_BC7(
				ctx, obuf, xs, ys, 16, 0);
			return;
		}
		return;
	}

	if(clrs==BGBBTJ_JPG_BC4)
	{
		if(ctx->jpg_nc==1)
		{
			BGBBTJ_JPG_DecodeColorTransform_YBC4(ctx, obuf, xs, ys, 8);
			return;
		}
		return;
	}

	if(clrs==BGBBTJ_JPG_BC4A)
	{
		if(ctx->jpg_nc==1)
		{
			BGBBTJ_JPG_DecodeColorTransform_YBC4(ctx, obuf, xs, ys, 16);
			return;
		}
		return;
	}

	if(clrs==BGBBTJ_JPG_YYYA)
	{
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			y=BGBBTJ_JPG_GetComponentPixel(ctx, 0, j, i);
//			if(y<0)y=0;
//			if(y>255)y=255;
			y=(y<0)?0:((y>255)?255:y);
			r=y; g=y; b=y; a=255;

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
		return;
	}

	if(ctx->jpg_is420 && !((ctx->xs|ctx->ys)&1) &&
		(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR))
	{
		BGBBTJ_JPG_DecodeColorTransformYCbCr420(ctx, obuf);
		return;
	}
	
	if(ctx->jpg_nc==1)
	{
#if 0
		if(!((ctx->xs|ctx->ys)&7))
		{
			BGBBTJ_JPG_DecodeColorTransform_YFast(
				ctx, obuf, ctx->xs, ctx->ys);
			return;
		}
#endif

		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			y=BGBBTJ_JPG_GetComponentPixel(ctx, 0, j, i);
			y=(y<0)?0:((y>255)?255:y);
			r=y; g=y; b=y; a=255;

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
		return;
	}
	
	if(1)
	{
		for(i=0; i<ctx->ys; i++)
			for(j=0; j<ctx->xs; j++)
		{
			if(ctx->jpg_nc==3)
			{
				if(ctx->jpg_is420)
				{
//					y=BGBBTJ_JPG_GetComponentPixelS1(ctx, 0, j, i);
//					u=BGBBTJ_JPG_GetComponentPixelS2(ctx, 1, j, i);
//					v=BGBBTJ_JPG_GetComponentPixelS2(ctx, 2, j, i);
					BGBBTJ_JPG_GetComponentPixelS122(ctx, j, i, &y, &u, &v);
//					a=255;
					a=BGBBTJ_JPG_GetComponentPixelAlpha(ctx, 0, j, i);
				}else if(ctx->jpg_is444)
				{
					BGBBTJ_JPG_GetComponentPixelS111(ctx, j, i, &y, &u, &v);
//					a=255;
					a=BGBBTJ_JPG_GetComponentPixelAlpha(ctx, 0, j, i);
				}else
				{
					y=BGBBTJ_JPG_GetComponentPixel(ctx, 0, j, i);
					u=BGBBTJ_JPG_GetComponentPixel(ctx, 1, j, i);
					v=BGBBTJ_JPG_GetComponentPixel(ctx, 2, j, i);
//					a=255;
					a=BGBBTJ_JPG_GetComponentPixelAlpha(ctx, 0, j, i);
				}

				if(ctx->alphaClr)
				{
					k=y-ctx->alphaClrY; l=k*k;
					k=u-ctx->alphaClrU; l+=k*k;
					k=v-ctx->alphaClrV; l+=k*k;
				
					a=ctx->alphaClrA;
					a=(l<=(a*a))?0:255;
				
//					if(l<(16*16))
//					{
//						a=255*((16*sqrt(l))/ctx->alphaClrA);
//						a=(a<0)?0:(a>255)?255:a;
//					}
				}

//				r=y+1.40200*(v-128);
//				g=y-0.34414*(u-128)-0.71414*(v-128);
//				b=y+1.77200*(u-128);

				if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_YCBCR)
				{
					u1=u-128; v1=v-128;
					r=65536*y          +91881*v1;
					g=65536*y- 22554*u1-46802*v1;
					b=65536*y+116130*u1;
					r>>=16; g>>=16; b>>=16;
				}else if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_ORCT)
				{
					u1=u-128; v1=v-128;
					g=y-(u1+v1)/4;
					r=v1+g;
					b=u1+g;
				}else if(ctx->jpg_clrtrans==BGBBTJ_JPG_CLRS_RGB)
				{
					r=y;
					g=u;
					b=v;
				}

				r=(r<0)?0:((r>255)?255:r);
				g=(g<0)?0:((g>255)?255:g);
				b=(b<0)?0:((b>255)?255:b);

//				r=(r<0)?0:((r>16777215)?255:(r>>16));
//				g=(g<0)?0:((g>16777215)?255:(g>>16));
//				b=(b<0)?0:((b>16777215)?255:(b>>16));
			}else if(ctx->jpg_nc==1)
			{
				y=BGBBTJ_JPG_GetComponentPixel(ctx, 0, j, i);
				y=(y<0)?0:((y>255)?255:y);
				r=y; g=y; b=y; a=255;
			}

			k=ctx->ys-1-i;
			l=((k*ctx->xs)+j)*4;

			obuf[l+0]=r;
			obuf[l+1]=g;
			obuf[l+2]=b;
			obuf[l+3]=a;
		}
	}
}

BGBBTJ_API byte *BGBBTJ_JPG_DecodeCtx(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	return(BGBBTJ_JPG_DecodeCtxI(ctx, buf, sz, BGBBTJ_JPG_RGBA, xs, ys));
}

BGBBTJ_API byte *BGBBTJ_JPG_DecodeCtxClrs(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs, int *xs, int *ys)
{
	return(BGBBTJ_JPG_DecodeCtxI(ctx, buf, sz, clrs, xs, ys));
}

byte *BGBBTJ_JPG_DecodeCtxI(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs, int *xs, int *ys)
{
	byte *obuf, *ct;
	int y, u, v, r, g, b, a, u1, v1;
	int y0, y1, y2, y3;
	int r0, g0, b0, a0;
	int r1, g1, b1, a1;
	int r2, g2, b2, a2;
	int r3, g3, b3, a3;
	int l0, l1, l2, l3;
	int i, j, k, l, lvm, lvo;

//	if((buf[0]!=0xFF) || (buf[1]!=JPG_SOI))
//		return(NULL);

	ctx->jpg_is420=0;
	ctx->jpg_rdct=0;
	ctx->jpg_clrtrans=0;

	ctx->bcst_version=0;
	ctx->bcst_flags=0;
	ctx->bcst_trans=0;
	ctx->bcst_bpp=0;

#if 0
	for(i=0; i<4; i++)
	{
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}
#endif

	lvm=0;
	for(i=0; i<sz; i++)
	{
//		if((buf[i]==0xFF) && (buf[i+1]!=0x00) && (buf[i+1]!=0xFF))
		if(buf[i]==0xFF)
		{
			if(buf[i+1]==0x00)
				{ i++; continue; }
			if(buf[i+1]==0xFF)
				{ i++; continue; }

			j=buf[i+1]-0xC0;
			if(j<0)j=63;

			lvm=buf[i+1]; lvo=i;

//			printf("@ %d %s(%02X)\n", i,
//				pdjpg_marker[j], buf[i+1]);

			if(buf[i+1]==JPG_DQT)
			{
				BGBBTJ_JPG_MarkerDQT(ctx, buf+i+2);
				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j+1;
				continue;
			}

			if(buf[i+1]==JPG_DHT)
			{
				BGBBTJ_JPG_MarkerDHT(ctx, buf+i+2);
				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j+1;
				continue;
			}

			if(buf[i+1]==JPG_SOF0)
			{
				BGBBTJ_JPG_MarkerSOF0(ctx, buf+i+2);
				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j+1;
				continue;
			}
			if(buf[i+1]==JPG_SOS)
			{
				j=BGBBTJ_JPG_MarkerSOS(ctx, buf+i+2);
				if(j>0) { i+=j; }
				continue;

				//skip over marker
//				j=(buf[i+2]<<8)|buf[i+3];
//				i+=j+1;
//				continue;
			}

			if((buf[i+1]>=JPG_APP0) && (buf[i+1]<=JPG_APP15))
			{
				if(buf[i+1]==JPG_APP0)BGBBTJ_JPG_MarkerAPP0(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP11)BGBBTJ_JPG_MarkerAPP11(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP12)BGBBTJ_JPG_MarkerAPP12(ctx, buf+i+2);
				if(buf[i+1]==JPG_APP14)BGBBTJ_JPG_MarkerAPP14(ctx, buf+i+2);

				//skip over marker
				j=(buf[i+2]<<8)|buf[i+3];
				i+=j+1;
				continue;
			}

			if(buf[i+1]==JPG_SOI)
			{
				i++;
				continue;
			}

			if(buf[i+1]==JPG_EOI)
			{
				i++;
				break;
			}
		}
		
//		printf("BGBBTJ_JPG_DecodeCtxI: Misalign After %02X @%06X\n",
//			lvm, lvo);
	}

	obuf=ctx->jpg_imgbuf;
	if(!obuf || (ctx->xs!=ctx->lxs) || (ctx->ys!=ctx->lys))
	{
		if(ctx->jpg_imgbuf)
			free(ctx->jpg_imgbuf);
		
		obuf=malloc((ctx->xs+1)*(ctx->ys+1)*4);
		memset(obuf, 0xFF, ctx->xs*ctx->ys*4);
		
		ctx->jpg_imgbuf=obuf;
		ctx->lxs=ctx->xs;
		ctx->lys=ctx->ys;
	}

#if 0
	for(i=0; i<ctx->jpg_nc; i++)
	{
		j=ctx->jpg_scn[i];
//		ctx->jpg_schsc[i]=ctx->jpg_ch[j]/(ctx->jpg_chm*1.0);
//		ctx->jpg_scvsc[i]=ctx->jpg_cv[j]/(ctx->jpg_chn*1.0);

		ctx->jpg_schsci[i]=(65536*ctx->jpg_ch[j])/ctx->jpg_chm;
		ctx->jpg_scvsci[i]=(65536*ctx->jpg_cv[j])/ctx->jpg_chn;

		ctx->jpg_schs[i]=(ctx->jpg_cxi[j]+7)/8;
		ctx->jpg_scvs[i]=(ctx->jpg_cyi[j]+7)/8;
		
	}

	if(ctx->jpg_nc==3)
	{
		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=32768)i=0;
		if(ctx->jpg_scvsci[1]!=32768)i=0;
		if(ctx->jpg_schsci[2]!=32768)i=0;
		if(ctx->jpg_scvsci[2]!=32768)i=0;
		ctx->jpg_is420=i;

		i=1;
		if(ctx->jpg_schsci[0]!=65536)i=0;
		if(ctx->jpg_scvsci[0]!=65536)i=0;
		if(ctx->jpg_schsci[1]!=65536)i=0;
		if(ctx->jpg_scvsci[1]!=65536)i=0;
		if(ctx->jpg_schsci[2]!=65536)i=0;
		if(ctx->jpg_scvsci[2]!=65536)i=0;
		ctx->jpg_is444=i;
	}else
	{
		ctx->jpg_is420=0;
		ctx->jpg_is444=0;
	}
#endif

	BGBBTJ_JPG_DecodeCtxI_ColorTransform(ctx, obuf, ctx->xs, ctx->ys, clrs);

#if 0
	for(i=0; i<4; i++)
	{
		if(ctx->jpg_scbuf[i])free(ctx->jpg_scbuf[i]);
		if(ctx->jpg_sibuf[i])free(ctx->jpg_sibuf[i]);
		ctx->jpg_scbuf[i]=NULL;
		ctx->jpg_sibuf[i]=NULL;
	}
#endif

	*xs=ctx->xs;
	*ys=ctx->ys;
	return(obuf);
}

BGBBTJ_API void BGBBTJ_JPG_Free(byte *buf)
{
	if(!buf)return;
	free(buf);
}


/*
BGB Extensions:
APP11: BGBTech Tag
	FF,APP11,xx,xx,<ASCIZ TagName>, ...
	Tag-specific data until next marker.
	
	"AlphaColor":
		AlphaColor
		RGBA as string ("red green blue alpha").
		
		Specifies a "Alpha Color" extension, where any color sufficiently
		close to the given color (determined by 'alpha'), will be assumed
		to be a transparent pixel. These values are given in decimal.

	APP11 markers may indicate component layer:
		FF,APP11,xx,xx,"CompLayer\0", <layername:ASCIZ>
			"RGB": Base RGB
			"XYZ": Normal XYZ
			"SpRGB": Specular RGB
			"DASe": Depth, Alpha, Specular-Exponent
			"LuRGB": Luma RGB
			"Alpha": Mono alpha layer

	Component Layouts:
		3 component: (no marker, RGB)
		4 component: RGB+Alpha
		7 component: RGB+Alpha+LuRGB
		8 component: RGB+XYZ+DASe
		12 component: RGB+XYZ+SpRGB+DASe
		16 component: RGB+XYZ+SpRGB+DASe+LuRGB

	The APP11 tag for a layer will be followed by the layer
	(as a JPEG image), which may be placed within LDAT tags.
	
	Images lacking DHT and DQT will reuse those from the base image.

APP12: BGBTech Tag 2
	FF,APP12,xx,xx,tt,tt,tt,tt
		tt=FOURCC Tag.

	'LDAT': Layer Data.
	Gives an image/layer spread across a span of 'LDAT' tags.
	The encoded image will be split linearly across the tags.

APP11,"TagLayer":
	Allows giving a layer name to a collection of component layers.
	All images within a tag-layer will need to be the same resolution.
	Different taglayers may have different resolutions.
	
FF B0: DVFH, Define Video Frame Header
	FF B0 xx xx
	TfTd HmMt Lid ... 

	Tf = 4-bit frame-type (0=I-Frame, 1=P-Frame, 2-15=Reserved)
	Td = 4-bit delta type (0=None, 1=Subtract I-Frame YCbCr, 2-15=Reserved)
	Hm = Huffman table for motion vectors.
	Mt = Motion Vector Type (0=Default, 1=15=Reserved)
	Lid = 8-bit layer ID.

The layer ID will specify the layer used for motion compensation.
A P-Frame will refer to the last I-Frame with the same layer-ID, which will need to have both the same resolution and image-layout.

FF B1: SOMV, Start Of Motion Vectors

	Motion Vectors:
	Huffman coded values: ZcBc
	Zc = zero count
	Bc = bit-count 
*/

#include <bgbbtj.h>

//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>

#include <math.h>


const char *pdjpg_marker[]={
"SOF0", "SOF1", "SOF2", "SOF3", "DHT", "SOF5", "SOF6", "SOF7",
"JPG", "SOF9", "SOF10", "SOF11", "DAC", "SOF13", "SOF14", "SOF15",
"RST0", "RST1", "RST2", "RST3", "RST4", "RST5", "RST6", "RST7",
"SOI", "EOI", "SOS", "DQT", "DNL", "DRI", "DHP", "EXP",
"APP0", "APP1", "APP2", "APP3", "APP4", "APP5", "APP6", "APP7", 
"APP8", "APP9", "APP10", "APP11", "APP12", "APP13", "APP14", "APP15", 
"JPG0", "JPG1", "JPG2", "JPG3", "JPG4", "JPG5", "JPG6", "JPG7", 
"JPG8", "JPG9", "JPG10", "JPG11", "JPG12", "JPG13", "COM", ""
};

const int pdjpg_zigzag[64]={
 0,  1,  5,  6, 14, 15, 27, 28,
 2,  4,  7, 13, 16, 26, 29, 42,
 3,  8, 12, 17, 25, 30, 41, 43,
 9, 11, 18, 24, 31, 40, 44, 53,
10, 19, 23, 32, 39, 45, 52, 54,
20, 22, 33, 38, 46, 51, 55, 60,
21, 34, 37, 47, 50, 56, 59, 61,
35, 36, 48, 49, 57, 58, 62, 63
};

const int pdjpg_zigzag2[64]={
 0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63
};

float pdjpg_exptab[256];
float pdjpg_scltab[256];


BGBBTJ_API BGBBTJ_JPG_Context *BGBBTJ_JPG_AllocContext();
BGBBTJ_API void BGBBTJ_JPG_FreeContext(BGBBTJ_JPG_Context *ctx);
BGBBTJ_API void BGBBTJ_JPG_SetContextAlphaColor(BGBBTJ_JPG_Context *ctx,
	int cr, int cg, int cb, int ca);

//Common

void BGBBTJ_JPG_Init()
{
	static int init=0;
	int i, j;
	float f, g;

	if(init)return;
	init=1;

	for(i=0; i<64; i++)
	{
		f=(i*i)/240.0;
		g=pow(2, f);
//		printf("%d %f %f %f\n", i, f, g, 1/g);
			
		pdjpg_exptab[192+i]=f;
		pdjpg_exptab[192-i]=-f;
		pdjpg_exptab[63+i]=-f;
		pdjpg_exptab[63-i]=f;
			
		pdjpg_scltab[192+i]=g;
		pdjpg_scltab[192-i]=1.0/g;
		pdjpg_scltab[63+i]=-1.0/g;
		pdjpg_scltab[63-i]=-g;
	}

	for(i=0; i<18; i++)
	{
		j=sqrt(i*240)+0.5;
//		printf("%d %d %d %d %d %d\n", i, j,
//			192+j, 192-j, 63-j, 63+j);

		if(j>63)continue;

		g=pow(2, i);

		pdjpg_exptab[192+j]=i;
		pdjpg_exptab[192-j]=-i;
		pdjpg_exptab[63+j]=-i;
		pdjpg_exptab[63-j]=i;

		pdjpg_scltab[192+j]=g;
		pdjpg_scltab[192-j]=1.0/g;
		pdjpg_scltab[63+j]=-1.0/g;
		pdjpg_scltab[63-j]=-g;
	}
		
//	exptab[128]=0;

#if 0
	for(i=0; i<(256/2); i++)
	{
		for(j=0; j<2; j++)
		{
			sprintf(tb, "% 3d: %.4f,%.8f", i*2+j,
				exptab[i*2+j], scltab[i*2+j]);
			printf("%-32s ", tb);
		}
		printf("\n");
	}
#endif
}

void BGBBTJ_JPG_SetupQuantTabDivFP(BGBBTJ_JPG_Context *ctx, int qid)
{
	int i;
	
	for(i=0; i<64; i++)
		ctx->jpg_qtfp[qid][i]=4096.0/ctx->jpg_qt[qid][i];
}

#if 1
BGBBTJ_API byte *BGBBTJ_JPG_Load(VFILE *fd, int *xs, int *ys)
{
	byte *buf, *obuf;
	int fsz;

	vfseek(fd, 0, 2);
	fsz=vftell(fd);
	vfseek(fd, 0, 0);

	buf=malloc(fsz+256);
	vfread(buf, 1, fsz, fd);

	obuf=BGBBTJ_JPG_Decode(buf, fsz, xs, ys);
	free(buf);

	return(obuf);
}

BGBBTJ_API int BGBBTJ_JPG_Store(VFILE *fd, byte *ibuf, int xs, int ys, int qf)
{
	static byte *buf=NULL;
	int fsz;

	if(!buf)buf=malloc(1<<22);

	fsz=BGBBTJ_JPG_Encode(ibuf, buf, xs, ys, qf);
	if(fsz<0)return(fsz);

	vfwrite(buf, 1, fsz, fd);
//	free(buf);

	return(0);
}
#endif
/*
Filter for DXTn / BCn texture compression.

Pixel Block:
	A B C D
	E F G H
	I J K L
	M N O P

Color: 5:6:5
	Red: Bits 11-15
	Green: Bits 5-10
	Blue: Bits 0-4
	
DXT1 / BC1
color_0: Color
color_1: Color
pixels: bytes[4] (2 bpp)
	DCBA
	HGFE
	LKJI
	PONM
	
DXT5 / BC3
alpha_0: byte
alpha_1: byte
alphas: byte[6] (3bpp)
color_0: Color
color_1: Color
pixels: bytes[4]

DXT5 Alpha / BC4: 
	alpha_0: byte
	alpha_1: byte
	alphas: byte[6] (3bpp)

if(alpha_0<=alpha_1)
{
	0=alpha_0, 1=alpha_1;
	2-5=interpolated alphas;
	6=0, 7=255.
}else
{
	0=alpha_0, 1=alpha_1;
	2-7=interpolated alphas;
}

UVAY
	A holds Y.
	RG holds UV.
	B holds Alpha / Scale
		0-127: Alpha=2.0*B, Scale=1.0.
		128-255: Alpha=1.0, Scale=1.0-(2.0*B-1.0).

Assertion: For alpha-blending, reduced color precision is acceptable, 

*/

#include <bgbbtj.h>

char *bgbbtj_gl_extensions=NULL;
char **bgbbtj_gl_extensions_xsa=NULL;
int *bgbbtj_gl_extensions_xsac;
int bgbbtj_gl_extensions_xsah[1024];
int bgbbtj_gl_extensions_nxsa;

BGBBTJ_API int BGBBTJ_SetGlExtensions(char *str)
{
	char tb[256];
	char **xsa;
	int *xsac;
	char *s, *t;
	int nxsa, mxsa;
	int i, j, k;

	bgbbtj_gl_extensions=str;
	
	mxsa=1024; nxsa=0;
	xsa=malloc(mxsa*sizeof(char *));
	
	s=str;
	while(*s)
	{
		if(*s<=' ')
		{
			while(*s && (*s<=' '))s++;
			continue;
		}
		
		t=tb;
		while(*s && (*s>' '))*t++=*s++;
		*t++=0;
		
		if((nxsa+1)>=mxsa)
		{
			mxsa=mxsa+(mxsa>>1);
			xsa=realloc(xsa, mxsa*sizeof(char *));
		}
		
		xsa[nxsa++]=strdup(tb);
	}

	xsa=realloc(xsa, nxsa*sizeof(char *));
	xsac=malloc(nxsa*sizeof(int));
	
	bgbbtj_gl_extensions_xsa=xsa;
	bgbbtj_gl_extensions_xsac=xsac;
	bgbbtj_gl_extensions_nxsa=nxsa;

	for(i=0; i<1024; i++)
		bgbbtj_gl_extensions_xsah[i]=-1;
		
	for(i=0; i<nxsa; i++)
	{
		s=xsa[i]; k=0;
		while(*s)
			{ k=(k*251)+(*s++); }
		k=((k*251)>>8)&1023;
		
		xsac[i]=bgbbtj_gl_extensions_xsah[k];
		bgbbtj_gl_extensions_xsah[k]=i;
	}
	
	return(0);
}

BGBBTJ_API int BGBBTJ_CheckGlExtension(char *str)
{
	char *s, *t;
	int i, j, k;

	if(!bgbbtj_gl_extensions)
		return(0);

	s=str; k=0;
	while(*s)
		{ k=(k*251)+(*s++); }
	k=((k*251)>>8)&1023;
	
	i=bgbbtj_gl_extensions_xsah[k];
	while(i>0)
	{
		if(!strcmp(bgbbtj_gl_extensions_xsa[i], str))
			return(1);
		i=bgbbtj_gl_extensions_xsac[i];
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_BCn_RoundColorNearest5Bits(int v)
{
	int p0, p1, d0, d1, p;
	
	p0=(v>>3); p0=(p0<<3)|(p0>>2);
	p1=(v>>3)+1; p1=(p1<<3)|(p1>>2);
	d0=p0-v; d0=d0*d0;
	d1=p1-v; d1=d1*d1;
	p=(d0<d1)?p0:p1;
	p=(p<0)?0:((p>255)?255:p);
	return(p);
}

BGBBTJ_API int BGBBTJ_BCn_RoundColorNearest6Bits(int v)
{
	int p0, p1, d0, d1, p;
	
	p0=(v>>2); p0=(p0<<2)|(p0>>4);
	p1=(v>>2)+1; p1=(p1<<2)|(p1>>4);
	d0=p0-v; d0=d0*d0;
	d1=p1-v; d1=d1*d1;
	p=(d0<d1)?p0:p1;
	p=(p<0)?0:((p>255)?255:p);
	return(p);
}

BGBBTJ_API int BGBBTJ_BCn_TranscodeBlockBC1ToBC3(
	byte *sblk, byte *dblk)
{
	u32 v;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int i, j, k;
	
#if defined(X86) || defined(X86_64)
	i=((u16 *)sblk)[0];
	j=((u16 *)sblk)[1];
#else
	i=sblk[0]|(sblk[1]<<8);
	j=sblk[2]|(sblk[3]<<8);
#endif

	if(j<i)
	{
		//Opaque Block
#if defined(X86) || defined(X86_64)
		((u64 *)dblk)[0]=0x000000000000FFFFULL;
		((u64 *)dblk)[1]=*(u64 *)sblk;
#else
		dblk[0]=255;	dblk[1]=255;	dblk[2]=0;	dblk[3]=0;
		dblk[4]=0;		dblk[5]=0;		dblk[6]=0;	dblk[7]=0;
		memcpy(dblk+8, sblk, 8);
//		memcpy(dblk+i*16+8, sblk+i*8, 8);
#endif
	}else
	{
#if defined(X86) || defined(X86_64)
		v=((u32 *)sblk)[1];
		if(v==0xFFFFFFFF)
		{
			((u64 *)dblk)[0]=0x0000000000000000ULL;
			((u64 *)dblk)[1]=*(u64 *)sblk;
			return(0);
		}
#else
		v=sblk[4]|(sblk[5]<<8)|(sblk[6]<<16)|(sblk[7]<<24);
		if(v==0xFFFFFFFF)
		{
			memset(dblk, 0, 8);
			memcpy(dblk+8, sblk, 8);
		}
#endif

		//Block with Alpha
		dblk[0]=0;	dblk[1]=255;

		p0=((sblk[4]&0x03)!=0x03);
		p1=((sblk[4]&0x0C)!=0x0C);
		p2=((sblk[4]&0x30)!=0x30);
		p3=((sblk[4]&0xC0)!=0xC0);
		p4=((sblk[5]&0x03)!=0x03);
		p5=((sblk[5]&0x0C)!=0x0C);
		p6=((sblk[5]&0x30)!=0x30);
		p7=((sblk[5]&0xC0)!=0xC0);

		k=p0|(p1<<3)|(p2<<6)|(p3<<9)|
			(p4<<12)||(p5<<15)|(p6<<18)|(p7<<21);
		dblk[2]=k;		dblk[3]=k>>8;		dblk[4]=k>>16;

//		dblk[2]=p0|(p1<<3)|(p2<<6);
//		dblk[3]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
//		dblk[4]=(p5>>1)|(p6<<2)|(p7<<5);

		p0=((sblk[6]&0x03)!=0x03);
		p1=((sblk[6]&0x0C)!=0x0C);
		p2=((sblk[6]&0x30)!=0x30);
		p3=((sblk[6]&0xC0)!=0xC0);
		p4=((sblk[7]&0x03)!=0x03);
		p5=((sblk[7]&0x0C)!=0x0C);
		p6=((sblk[7]&0x30)!=0x30);
		p7=((sblk[7]&0xC0)!=0xC0);

		k=p0|(p1<<3)|(p2<<6)|(p3<<9)|
			(p4<<12)||(p5<<15)|(p6<<18)|(p7<<21);
		dblk[5]=k;		dblk[6]=k>>8;		dblk[7]=k>>16;

//		dblk[5]=p0|(p1<<3)|(p2<<6);
//		dblk[6]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
//		dblk[7]=(p5>>1)|(p6<<2)|(p7<<5);

		((u64 *)dblk)[1]=*(u64 *)sblk;
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_BCn_TranscodeBC1ToBC3(
	byte *sblk, byte *dblk, int xs, int ys)
{
	byte *db, *sb;
	int i, n;
	
	n=((xs+3)/4)*((ys+3)/4);
	for(i=0; i<n; i++)
	{
		db=dblk+i*16;
		sb=sblk+i*8;

		BGBBTJ_BCn_TranscodeBlockBC1ToBC3(sb, db);

#if 0
#if defined(X86) || defined(X86_64)
//#if 0
		((u64 *)db)[0]=0x000000000000FFFFULL;
		((u64 *)db)[1]=*(u64 *)sb;
#else
		db[0]=255;	db[1]=255;		db[2]=0;	db[3]=0;
		db[4]=0;	db[5]=0;		db[6]=0;	db[7]=0;
		memcpy(db+8, sb, 8);
//		memcpy(dblk+i*16+8, sblk+i*8, 8);
#endif
#endif
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_BCn_TranscodeBC1ToBC3B(
	byte *sblk, byte *dblk, int xs, int ys)
{
	byte *db, *sb;
	int i, n;
	
	n=((xs+3)/4)*((ys+3)/4);
	for(i=0; i<n; i++)
	{
		db=dblk+i*16;
		sb=sblk+i*16+8;

		BGBBTJ_BCn_TranscodeBlockBC1ToBC3(sb, db);
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_BCn_TranscodeBC1ToBC3B_Opaque(
	byte *sblk, byte *dblk, int xs, int ys)
{
	byte *db, *sb;
	int i, n;
	
	n=((xs+3)/4)*((ys+3)/4);
	for(i=0; i<n; i++)
	{
		db=dblk+i*16;
		sb=sblk+i*16+8;

#if defined(X86) || defined(X86_64)
//#if 0
		((u64 *)db)[0]=0x000000000000FFFFULL;
		((u64 *)db)[1]=*(u64 *)sb;
#else
		db[0]=255;	db[1]=255;		db[2]=0;	db[3]=0;
		db[4]=0;	db[5]=0;		db[6]=0;	db[7]=0;
		memcpy(db+8, sb, 8);
//		memcpy(dblk+i*16+8, sblk+i*8, 8);
#endif

//		BGBBTJ_BCn_TranscodeBlockBC1ToBC3(sb, db);
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_BCn_CheckEncodeImageAlpha(
	byte *rgba, int xs, int ys, int stride)
{
	int i, j;
	
	if(!rgba)return(0);
	
	for(i=0; i<ys; i++)
		for(j=0; j<xs; j++)
	{
		if(rgba[(i*xs+j)*stride+3]!=255)
			return(1);
	}
	return(0);
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXTn(byte *block,
	byte *rgba, int xs, int ys, int stride, int fmt)
{
	switch(fmt)
	{
	case BGBBTJ_JPG_BC1:
		BGBBTJ_BCn_EncodeImageDXT1(block, rgba, xs, ys, stride);
//		BGBBTJ_BCn_EncodeImageDXT1F(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC3:
		BGBBTJ_BCn_EncodeImageDXT5(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC1F:
		BGBBTJ_BCn_EncodeImageDXT1F(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC3F:
		BGBBTJ_BCn_EncodeImageDXT5F(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC1A:
		BGBBTJ_BCn_EncodeImageDXT1A(block, rgba, xs, ys, stride);
//		BGBBTJ_BCn_EncodeImageDXT1F(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC3_UVAY:
		BGBBTJ_BCn_EncodeImageDXT5_UVAY(block, rgba, xs, ys, stride);
		break;

	case BGBBTJ_JPG_BC6:
		BGBBTJ_BC6HS_EncodeImageUByte(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC7:
//		BGBBTJ_BC7_EncodeImageBC7(block, rgba, xs, ys, stride);
		BGBBTJ_BC7_EncodeImageBestBC7(block, rgba, xs, ys, stride);
		break;
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageAutoDXTn(byte *block,
	byte *rgba, int xs, int ys, int stride, int *rfmt)
{
	if(stride==3)
	{
		BGBBTJ_BCn_EncodeImageDXT1(block, rgba, xs, ys, stride);
//		BGBBTJ_BCn_EncodeImageDXT1F(block, rgba, xs, ys, stride);
		*rfmt=BGBBTJ_JPG_BC1;
		return;
	}

#if 1
	if(BGBBTJ_CheckGlExtension("GL_ARB_texture_compression_bptc"))
	{
//		BGBBTJ_BC7_EncodeImageBC7(block, rgba, xs, ys, stride);
		BGBBTJ_BC7_EncodeImageBestBC7(block, rgba, xs, ys, stride);
		*rfmt=BGBBTJ_JPG_BC7;
		return;
	}
#endif

	if(!BGBBTJ_BCn_CheckEncodeImageAlpha(rgba, xs, ys, stride))
	{
#if 0
		BGBBTJ_BC6HS_EncodeImageUByte(block, rgba, xs, ys, stride);
		*rfmt=BGBBTJ_JPG_BC6;
		return;
#endif

#if 0
		BGBBTJ_BCn_EncodeImageDXT5_UVAY(block, rgba, xs, ys, stride);
		*rfmt=BGBBTJ_JPG_BC3_UVAY;
		return;
#endif

#if 0
		BGBBTJ_BCn_EncodeImageDXT5(block, rgba, xs, ys, stride);
		*rfmt=BGBBTJ_JPG_BC3;
		return;
#endif

		BGBBTJ_BCn_EncodeImageDXT1(block, rgba, xs, ys, stride);
//		BGBBTJ_BCn_EncodeImageDXT1F(block, rgba, xs, ys, stride);
		*rfmt=BGBBTJ_JPG_BC1;
		return;
	}

#if 0
	BGBBTJ_BCn_EncodeImageDXT5_UVAY(block, rgba, xs, ys, stride);
	*rfmt=BGBBTJ_JPG_BC3_UVAY;
	return;
#endif

	BGBBTJ_BCn_EncodeImageDXT5(block, rgba, xs, ys, stride);
	*rfmt=BGBBTJ_JPG_BC3;

//	BGBBTJ_BCn_EncodeImageDXT5_UVAY(block, rgba, xs, ys, stride);
//	*rfmt=BGBBTJ_JPG_BC3_UVAY;
}

BGBBTJ_API void BGBBTJ_BCn_DecodeImageDXTn(byte *block,
	byte *rgba, int xs, int ys, int stride, int fmt)
{
	switch(fmt)
	{
	case BGBBTJ_JPG_BC1:
		BGBBTJ_BCn_DecodeImageDXT1(block, rgba, xs, ys, stride);
//		BGBBTJ_BCn_EncodeImageDXT1F(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC3:
		BGBBTJ_BCn_DecodeImageDXT5(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC1F:
		BGBBTJ_BCn_DecodeImageDXT1(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC1A:
		BGBBTJ_BCn_DecodeImageDXT1(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC3F:
		BGBBTJ_BCn_DecodeImageDXT5(block, rgba, xs, ys, stride);
		break;
	case BGBBTJ_JPG_BC3_UVAY:
		BGBBTJ_BCn_DecodeImageDXT5_UVAY(block, rgba, xs, ys, stride);
		break;

	case BGBBTJ_JPG_BC7:
		BGBBTJ_BC7_DecodeImageBC7(block, rgba, xs, ys, stride);
		break;
	}
}

void BGBBTJ_BCn_DecodeBlockDXT1(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
	byte clr[4*4];
	int i, j, k, l;
	
	i=block[0]|(block[1]<<8);
	j=block[2]|(block[3]<<8);

#if 1
	if(i==j)
	{
		k=(block[4]^block[5])|(block[5]^block[6])|(block[6]^block[7]);
		if(!k)
		{
			clr[0]=block[1]&0xF8;
			clr[1]=((block[1]<<5)|(block[0]>>3))&0xFC;
			clr[2]=(block[0]<<3)&0xF8;
			clr[3]=(block[4]==0xFF)?0:255;
			clr[0]|=(clr[0]>>5);
			clr[1]|=(clr[1]>>6);
			clr[2]|=(clr[2]>>5);
			
			for(i=0; i<4; i++)
				for(j=0; j<4; j++)
			{
				k=i*ystride+j*xstride;
				rgba[k+0]=clr[0];
				rgba[k+1]=clr[1];
				rgba[k+2]=clr[2];
				rgba[k+3]=clr[3];
			}
			return;
		}
	}
#endif

	if(i<=j)
	{
		clr[ 0]=block[1]&0xF8;
		clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
		clr[ 2]=(block[0]<<3)&0xF8;
		clr[ 3]=255;
		clr[ 4]=block[3]&0xF8;
		clr[ 5]=((block[3]<<5)|(block[2]>>3))&0xFC;
		clr[ 6]=(block[2]<<3)&0xF8;	
		clr[ 7]=255;

		clr[ 0]|=(clr[ 0]>>5);
		clr[ 1]|=(clr[ 1]>>6);
		clr[ 2]|=(clr[ 2]>>5);
		clr[ 4]|=(clr[ 4]>>5);
		clr[ 5]|=(clr[ 5]>>6);
		clr[ 6]|=(clr[ 6]>>5);

		clr[ 8]=(clr[0]+clr[4])>>1;
		clr[ 9]=(clr[1]+clr[5])>>1;
		clr[10]=(clr[2]+clr[6])>>1;
		clr[11]=255;
//		clr[12]=0;
//		clr[13]=0;
//		clr[14]=0;
		clr[12]=(clr[0]+clr[4])>>1;
		clr[13]=(clr[1]+clr[5])>>1;
		clr[14]=(clr[2]+clr[6])>>1;
		clr[15]=0;
	}else
	{
		clr[ 0]=block[1]&0xF8;
		clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
		clr[ 2]=(block[0]<<3)&0xF8;
		clr[ 3]=255;
		clr[ 4]=block[3]&0xF8;
		clr[ 5]=((block[3]<<5)|(block[2]>>3))&0xFC;
		clr[ 6]=(block[2]<<3)&0xF8;	
		clr[ 7]=255;

		clr[ 0]|=(clr[ 0]>>5);
		clr[ 1]|=(clr[ 1]>>6);
		clr[ 2]|=(clr[ 2]>>5);
		clr[ 4]|=(clr[ 4]>>5);
		clr[ 5]|=(clr[ 5]>>6);
		clr[ 6]|=(clr[ 6]>>5);

		clr[ 8]=(clr[0]*11+clr[4]*5)>>4;
		clr[ 9]=(clr[1]*11+clr[5]*5)>>4;
		clr[10]=(clr[2]*11+clr[6]*5)>>4;
		clr[11]=255;
		clr[12]=(clr[0]*5+clr[4]*11)>>4;
		clr[13]=(clr[1]*5+clr[5]*11)>>4;
		clr[14]=(clr[2]*5+clr[6]*11)>>4;
		clr[15]=255;
	}
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=i*ystride+j*xstride;
		l=((block[4+i]>>(2*j))&3)*4;
		rgba[k+0]=clr[l+0];
		rgba[k+1]=clr[l+1];
		rgba[k+2]=clr[l+2];
		rgba[k+3]=clr[l+3];
	}
}

void BGBBTJ_BCn_DecodeBlockDXT1_BGR(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
	byte clr[4*4];
	int i, j, k, l;
	
	i=block[0]|(block[1]<<8);
	j=block[2]|(block[3]<<8);

#if 1
	if(i==j)
	{
		k=(block[4]^block[5])|(block[5]^block[6])|(block[6]^block[7]);
		if(!k)
		{
			clr[ 0]=block[1]&0xF8;
			clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
			clr[ 2]=(block[0]<<3)&0xF8;
			clr[ 3]=(block[4]==0xFF)?0:255;
			clr[ 0]|=(clr[ 0]>>5);
			clr[ 1]|=(clr[ 1]>>6);
			clr[ 2]|=(clr[ 2]>>5);
		
			for(i=0; i<4; i++)
				for(j=0; j<4; j++)
			{
				k=i*ystride+j*xstride;
				rgba[k+0]=clr[2];
				rgba[k+1]=clr[1];
				rgba[k+2]=clr[0];
				rgba[k+3]=clr[3];
			}
			return;
		}
	}
#endif

	if(i<=j)
	{
		clr[ 0]=block[1]&0xF8;
		clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
		clr[ 2]=(block[0]<<3)&0xF8;
		clr[ 3]=255;
		clr[ 4]=block[3]&0xF8;
		clr[ 5]=((block[3]<<5)|(block[2]>>3))&0xFC;
		clr[ 6]=(block[2]<<3)&0xF8;	
		clr[ 7]=255;

		clr[ 0]|=(clr[ 0]>>5);
		clr[ 1]|=(clr[ 1]>>6);
		clr[ 2]|=(clr[ 2]>>5);
		clr[ 4]|=(clr[ 4]>>5);
		clr[ 5]|=(clr[ 5]>>6);
		clr[ 6]|=(clr[ 6]>>5);

//		clr[ 8]=(clr[0]+clr[4])>>1;
//		clr[ 9]=(clr[1]+clr[5])>>1;
//		clr[10]=(clr[2]+clr[6])>>1;
		clr[11]=255;
//		clr[12]=0;
//		clr[13]=0;
//		clr[14]=0;
		clr[12]=(clr[0]+clr[4])>>1;
		clr[13]=(clr[1]+clr[5])>>1;
		clr[14]=(clr[2]+clr[6])>>1;
		clr[15]=0;
	}else
	{
		clr[ 0]=block[1]&0xF8;
		clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
		clr[ 2]=(block[0]<<3)&0xF8;
		clr[ 3]=255;
		clr[ 4]=block[3]&0xF8;
		clr[ 5]=((block[3]<<5)|(block[2]>>3))&0xFC;
		clr[ 6]=(block[2]<<3)&0xF8;	
		clr[ 7]=255;

		clr[ 0]|=(clr[ 0]>>5);
		clr[ 1]|=(clr[ 1]>>6);
		clr[ 2]|=(clr[ 2]>>5);
		clr[ 4]|=(clr[ 4]>>5);
		clr[ 5]|=(clr[ 5]>>6);
		clr[ 6]|=(clr[ 6]>>5);

		clr[ 8]=(clr[0]*11+clr[4]*5)>>4;
		clr[ 9]=(clr[1]*11+clr[5]*5)>>4;
		clr[10]=(clr[2]*11+clr[6]*5)>>4;
		clr[11]=255;
		clr[12]=(clr[0]*5+clr[4]*11)>>4;
		clr[13]=(clr[1]*5+clr[5]*11)>>4;
		clr[14]=(clr[2]*5+clr[6]*11)>>4;
		clr[15]=255;
	}
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=i*ystride+j*xstride;
		l=((block[4+i]>>(2*j))&3)*4;
		rgba[k+0]=clr[l+2];
		rgba[k+1]=clr[l+1];
		rgba[k+2]=clr[l+0];
		rgba[k+3]=clr[l+3];
	}
}

void BGBBTJ_BCn_DecodeBlockDXT5(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
	byte clr[4*4];
	int i, j, k, l;

#if 1
	i=(block[0]^block[2])|(block[1]^block[3]);
	if(!i)
	{
		clr[ 0]=block[1]&0xF8;
		clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
		clr[ 2]=(block[0]<<3)&0xF8;
		clr[ 3]=(block[4]==0xFF)?0:255;
		clr[ 0]|=(clr[ 0]>>5);
		clr[ 1]|=(clr[ 1]>>6);
		clr[ 2]|=(clr[ 2]>>5);
		
		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=i*ystride+j*xstride;
			rgba[k+0]=clr[0];
			rgba[k+1]=clr[1];
			rgba[k+2]=clr[2];
			rgba[k+3]=clr[3];
		}
		return;
	}
#endif

	clr[ 0]=block[1]&0xF8;
	clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
	clr[ 2]=(block[0]<<3)&0xF8;
	clr[ 4]=block[3]&0xF8;
	clr[ 5]=((block[3]<<5)|(block[2]>>3))&0xFC;
	clr[ 6]=(block[2]<<3)&0xF8;	

	clr[ 0]|=(clr[ 0]>>5);
	clr[ 1]|=(clr[ 1]>>6);
	clr[ 2]|=(clr[ 2]>>5);
	clr[ 4]|=(clr[ 4]>>5);
	clr[ 5]|=(clr[ 5]>>6);
	clr[ 6]|=(clr[ 6]>>5);

	clr[ 8]=(clr[0]*11+clr[4]*5)>>4;
	clr[ 9]=(clr[1]*11+clr[5]*5)>>4;
	clr[10]=(clr[2]*11+clr[6]*5)>>4;
	clr[12]=(clr[0]*5+clr[4]*11)>>4;
	clr[13]=(clr[1]*5+clr[5]*11)>>4;
	clr[14]=(clr[2]*5+clr[6]*11)>>4;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=i*ystride+j*xstride;
		l=((block[4+i]>>(2*j))&3)*4;
		rgba[k+0]=clr[l+0];
		rgba[k+1]=clr[l+1];
		rgba[k+2]=clr[l+2];
	}
}

void BGBBTJ_BCn_DecodeBlockDXT5_BGRA(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
	byte clr[4*4];
	int i, j, k, l;

#if 1
	i=(block[0]^block[2])|(block[1]^block[3]);
	if(!i)
	{
		clr[ 0]=block[1]&0xF8;
		clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
		clr[ 2]=(block[0]<<3)&0xF8;
		clr[ 3]=(block[4]==0xFF)?0:255;
		clr[ 0]|=(clr[ 0]>>5);
		clr[ 1]|=(clr[ 1]>>6);
		clr[ 2]|=(clr[ 2]>>5);
		
		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=i*ystride+j*xstride;
			rgba[k+0]=clr[2];
			rgba[k+1]=clr[1];
			rgba[k+2]=clr[0];
			rgba[k+3]=clr[3];
		}
		return;
	}
#endif

	clr[ 0]=block[1]&0xF8;
	clr[ 1]=((block[1]<<5)|(block[0]>>3))&0xFC;
	clr[ 2]=(block[0]<<3)&0xF8;
	clr[ 4]=block[3]&0xF8;
	clr[ 5]=((block[3]<<5)|(block[2]>>3))&0xFC;
	clr[ 6]=(block[2]<<3)&0xF8;	

	clr[ 0]|=(clr[ 0]>>5);
	clr[ 1]|=(clr[ 1]>>6);
	clr[ 2]|=(clr[ 2]>>5);
	clr[ 4]|=(clr[ 4]>>5);
	clr[ 5]|=(clr[ 5]>>6);
	clr[ 6]|=(clr[ 6]>>5);

	clr[ 8]=(clr[0]*11+clr[4]*5)>>4;
	clr[ 9]=(clr[1]*11+clr[5]*5)>>4;
	clr[10]=(clr[2]*11+clr[6]*5)>>4;
	clr[12]=(clr[0]*5+clr[4]*11)>>4;
	clr[13]=(clr[1]*5+clr[5]*11)>>4;
	clr[14]=(clr[2]*5+clr[6]*11)>>4;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=i*ystride+j*xstride;
		l=((block[4+i]>>(2*j))&3)*4;
		rgba[k+0]=clr[l+2];
		rgba[k+1]=clr[l+1];
		rgba[k+2]=clr[l+0];
	}
}

void BGBBTJ_BCn_DecodeBlockBC4(byte *block,
	byte *rgba, int xstride, int ystride)
{
	byte val[8];
	int i, j, k, l;

	if(block[0]==block[1])
	{
//			k=(i*4+j)*3;
//			l=((block[2+(k>>3)]|(block[3+(k>>3)]<<8))>>(k&7))&7;
		l=block[0];

#if 1
		for(i=0; i<4; i++)
		{
			k=i*ystride;
			rgba[k+0*xstride]=l;
			rgba[k+1*xstride]=l;
			rgba[k+2*xstride]=l;
			rgba[k+3*xstride]=l;
		}
#endif

#if 0
		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=i*ystride+j*xstride;
			rgba[k]=l;
		}
#endif
		return;
	}
	
	if(block[0]>block[1])
	{
		val[0]=block[0];
		val[1]=block[1];
		val[2]=(val[0]*219+val[1]* 37)>>8;
		val[3]=(val[0]*183+val[1]* 73)>>8;
		val[4]=(val[0]*146+val[1]*110)>>8;
		val[5]=(val[0]*110+val[1]*146)>>8;
		val[6]=(val[0]* 73+val[1]*183)>>8;
		val[7]=(val[0]* 37+val[1]*219)>>8;
//		val[2]=(val[0]*213+val[1]*43)>>8;
//		val[3]=(val[0]*171+val[1]*85)>>8;
//		val[4]=(val[0]*85+val[1]*171)>>8;
//		val[5]=(val[0]*43+val[1]*213)>>8;
//		val[6]=0;
//		val[7]=255;
	}else
	{
		val[0]=block[0];
		val[1]=block[1];
		val[2]=(val[0]*205+val[1]* 51)>>8;
		val[3]=(val[0]*154+val[1]*102)>>8;
		val[4]=(val[0]*102+val[1]*154)>>8;
		val[5]=(val[0]* 51+val[1]*205)>>8;
//		val[2]=(val[0]*213+val[1]*43)>>8;
//		val[3]=(val[0]*171+val[1]*85)>>8;
//		val[4]=(val[0]*85+val[1]*171)>>8;
//		val[5]=(val[0]*43+val[1]*213)>>8;
		val[6]=0;
		val[7]=255;
	}

	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*4+j)*3;
		l=((block[2+(k>>3)]|(block[3+(k>>3)]<<8))>>(k&7))&7;
		k=i*ystride+j*xstride;
		rgba[k]=val[l];
	}
}

BGBBTJ_API void BGBBTJ_BCn_DecodeImageDXT1(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_DecodeBlockDXT1(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 4);
	}
}

BGBBTJ_API void BGBBTJ_BCn_DecodeImageDXT1_BGR(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_DecodeBlockDXT1_BGR(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 4);
	}
}

BGBBTJ_API void BGBBTJ_BCn_DecodeImageDXT5(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_DecodeBlockBC4(
			block+(i*xs1+j)*16,
			rgba+(i*4*xs+j*4)*stride+3,
			stride, xs*stride);
		BGBBTJ_BCn_DecodeBlockDXT5(
			block+(i*xs1+j)*16+8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 4);
	}
}

BGBBTJ_API void BGBBTJ_BCn_DecodeImageDXT5_BGRA(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_DecodeBlockBC4(
			block+(i*xs1+j)*16,
			rgba+(i*4*xs+j*4)*stride+3,
			stride, xs*stride);
		BGBBTJ_BCn_DecodeBlockDXT5_BGRA(
			block+(i*xs1+j)*16+8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 4);
	}
}

BGBBTJ_API void BGBBTJ_BCn_DecodeImageDXT5_UVAY(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	byte *pix;
	int cy, cu, cv, ca, csc;
	int dr, dg, db, da;
	int i, j, n;

	BGBBTJ_BCn_DecodeImageDXT5(block, rgba, xs, ys, stride);
	
	n=xs*ys;
	for(i=0; i<n; i++)
	{
		pix=rgba+i*stride;

		cy=pix[3];
		cu=pix[0];
		cv=pix[1];
		ca=pix[2];

		if(ca>=128)
		{
			da=255;
//			csc=256-(ca-128)*2;
			csc=256-(ca-192)*4;
		}else
		{
			csc=256;
			da=ca*2;
		}

		cu=(((cu-128)*csc+128)>>8)+128;
		cv=(((cv-128)*csc+128)>>8)+128;

//		cu=128; cv=128;

#if 0
		dg=cy-(cu+cv-256)/2;
//		dg=cy-(cu+cv-256)/2.0;
		db=dg+2*(cu-128);
		dr=dg+2*(cv-128);
#endif

#if 0
		dg=cy+(cv-128);
		dr=dg-(cv-128)*2-(cu-128);
		db=dg-(cv-128)*2+(cu-128);
#endif

#if 1
		dg=cy+((cv-128)>>1);
		dr=dg-(cv-128)-((cu-128)>>1);
		db=dg-(cv-128)+((cu-128)>>1);
#endif

		if(dr<0)dr=0;
		if(dg<0)dg=0;
		if(db<0)db=0;
		if(dr>255)dr=255;
		if(dg>255)dg=255;
		if(db>255)db=255;
		
		pix[0]=dr;		pix[1]=dg;
		pix[2]=db;		pix[3]=da;
	}
}

BGBBTJ_API void BGBBTJ_BCn_FlipImageDXT1(byte *iblk,
	byte *oblk, int xs, int ys, int stride)
{
	byte *cs, *ct;
	int xs1, ys1;
	int i, j, k, n;

	xs1=(xs+3)/4;
	ys1=(ys+3)/4;
	n=xs1*ys1;

	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		cs=iblk+((ys1-i-1)*xs1+j)*stride;
		ct=oblk+(i*xs1+j)*stride;
		ct[0]=cs[0];	ct[1]=cs[1];
		ct[2]=cs[2];	ct[3]=cs[3];
		ct[4]=cs[7];	ct[5]=cs[6];
		ct[6]=cs[5];	ct[7]=cs[4];
	}
}

BGBBTJ_API void BGBBTJ_BCn_FlipImageDXT5(byte *iblk,
	byte *oblk, int xs, int ys)
{
	byte *cs, *ct;
	int xs1, ys1;
	int i, j, k, l, n;

	xs1=(xs+3)/4;
	ys1=(ys+3)/4;
	n=xs1*ys1;

	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		cs=iblk+((ys1-i-1)*xs1+j)*16;
		ct=oblk+(i*xs1+j)*16;
		
		k=cs[2]|(cs[3]<<8)|(cs[4]<<16);
		l=cs[5]|(cs[6]<<8)|(cs[7]<<16);
		k=(k>>12)|((k&4095)<<12);
		l=(l>>12)|((l&4095)<<12);
		
		ct[ 0]=cs[ 0];			ct[ 1]=cs[ 1];
		ct[ 2]=l&255;			ct[ 3]=(l>>8)&255;
		ct[ 4]=(l>>16)&255;		ct[ 5]=k&255;
		ct[ 6]=(k>>8)&255;		ct[ 7]=(k>>16)&255;
		ct[ 8]=cs[ 8];			ct[ 9]=cs[ 9];
		ct[10]=cs[10];			ct[11]=cs[11];
		ct[12]=cs[15];			ct[13]=cs[14];
		ct[14]=cs[13];			ct[15]=cs[12];
	}
}

BGBBTJ_API void BGBBTJ_BCn_FlipImageDXT5_Mip(
	byte *iblk, byte *oblk, int xs, int ys)
{
	byte *ct, *ct1;
	byte *cs, *cs1;
	int xs1, ys1;
	int xs2, ys2;
	int xs3, ys3;
	
	xs1=xs; ys1=ys;

	xs2=xs1; ys2=ys1; cs=iblk; ct=oblk;
	while((xs2>0) || (ys2>0))
	{
		if(!xs2)xs2++;
		if(!ys2)ys2++;
		xs3=(xs2+3)/4;
		ys3=(ys2+3)/4;
//		n+=xs3*ys3;
		cs1=cs+(xs3*ys3)*16;
		ct1=ct+(xs3*ys3)*16;
//		BGBBTJ_Tex_HalfSampleDest(ct0, ct, xs2, ys2);
		BGBBTJ_BCn_FlipImageDXT5(cs, ct, xs2, ys2);
		xs2>>=1; ys2>>=1;
		cs=cs1; ct=ct1;
	}
}
#include <bgbbtj.h>

extern float pdjpg_exptab[256];
extern float pdjpg_scltab[256];

BGBBTJ_API byte *BGBBTJ_JPG_DecodeScanForComponentLayer(
	byte *buf, int sz, char *name)
{
	byte *cs, *cs2, *cse;
	int i;
	
	cs=buf; cse=buf+sz;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_APP11))
		{
			i=(cs[2]<<8)|cs[3];
			cs2=cs+i+2;

			cs+=4;
			if(!strcmp((char *)cs, "CompLayer"))
			{
				cs+=strlen((char *)cs)+1;
				if(!strcmp((char *)cs, name))
				{
//					printf("Found %s\n", name);
					cs+=strlen((char *)cs)+1;
					return(cs2);
				}

				cs+=strlen((char *)cs)+1;
				continue;
			}

			if(!strcmp((char *)cs, "TagLayer"))
				break;

			cs+=i-2;
			continue;
		}
		if((cs[0]==0xFF) && (cs[1]>=JPG_APP0) && (cs[1]<=JPG_APP15))
		{
			i=(cs[2]<<8)|cs[3];
			cs+=i+2;
			continue;
		}

		cs++;
	}
	
	return(NULL);
}

BGBBTJ_API byte *BGBBTJ_JPG_DecodeScanForTagLayer(
	byte *buf, int sz, char *name)
{
	byte *cs, *cs2, *cse;
	int i;
	
	cs=buf; cse=buf+sz;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_APP11))
		{
			i=(cs[2]<<8)|cs[3];
			cs2=cs+i+2;

			cs+=4;
			if(!strcmp((char *)cs, "TagLayer"))
			{
				cs+=strlen((char *)cs)+1;
				if(!strcmp((char *)cs, name))
				{
//					printf("Found %s\n", name);
					cs+=strlen((char *)cs)+1;
					return(cs2);
				}

				cs+=strlen((char *)cs)+1;
				continue;
			}
			cs+=i-2;
			continue;
		}
		if((cs[0]==0xFF) && (cs[1]>=JPG_APP0) && (cs[1]<=JPG_APP15))
		{
			i=(cs[2]<<8)|cs[3];
			cs+=i+2;
			continue;
		}

		cs++;
	}
	
	return(NULL);
}

BGBBTJ_API byte *BGBBTJ_JPG_DecodeScanNextTagLayer(
	byte *buf, int sz, char **rname)
{
	byte *cs, *cs2, *cse;
	int i;
	
	cs=buf; cse=buf+sz;
	while(cs<cse)
	{
		if((cs[0]==0xFF) && (cs[1]==JPG_APP11))
		{
			i=(cs[2]<<8)|cs[3];
			cs2=cs+i+2;

			cs+=4;
			if(!strcmp((char *)cs, "TagLayer"))
			{
				*rname=dystrdup((char *)cs);
				return(cs2);
			}
			cs+=i-2;
			continue;
		}
		if((cs[0]==0xFF) && (cs[1]>=JPG_APP0) && (cs[1]<=JPG_APP15))
		{
			i=(cs[2]<<8)|cs[3];
			cs+=i+2;
			continue;
		}

		cs++;
	}
	
	return(NULL);
}

BGBBTJ_API byte *BGBBTJ_JPG_Decode(byte *buf, int sz, int *xs, int *ys)
{
	BGBBTJ_JPG_Context *ctx;
	byte *obuf;
	byte *otbuf;
	byte *csl;
	int i, n, sz1;
	
	ctx=BGBBTJ_JPG_AllocContext();
	obuf=BGBBTJ_JPG_DecodeCtx(ctx, buf, sz, xs, ys);
	ctx->jpg_imgbuf=NULL;
	
	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
	if(csl)
	{
		sz1=sz-(csl-buf);
//		otbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		otbuf=BGBBTJ_JPG_DecodeLDatCtxClrs(ctx, csl, sz1,
			BGBBTJ_JPG_YYYA, xs, ys);
		
		n=ctx->xs*ctx->ys;
		for(i=0; i<n; i++)
		{
			obuf[i*4+3]=otbuf[i*4+1];
		}
	}

	BGBBTJ_JPG_FreeContext(ctx);
	return(obuf);
}

BGBBTJ_API int BGBBTJ_JPG_DecodeBufferClrs(
	byte *ibuf, int isz, byte *obuf, int clrs, int *xs, int *ys)
{
	BGBBTJ_JPG_Context *ctx;
	int i;

	ctx=BGBBTJ_JPG_AllocContext();
	i=BGBBTJ_JPG_DecodeBufferClrsCtx(ctx, ibuf, isz, obuf, clrs, xs, ys);
	BGBBTJ_JPG_FreeContext(ctx);
	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_DecodeBufferClrsCtx(
	BGBBTJ_JPG_Context *ctx,
	byte *ibuf, int isz, byte *obuf, int clrs, int *xs, int *ys)
{
	byte tbb[16];
//	BGBBTJ_JPG_Context *ctx;
	byte *ocbuf;
	byte *otbuf;
	byte *csl;
	int i, n, sz1, xs1, ys1;

	if(clrs==BGBBTJ_JPG_DXT1)
	{
//		ctx=BGBBTJ_JPG_AllocContext();
		ocbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, ibuf, isz, clrs, xs, ys);
		xs1=(*xs+3)/4;
		ys1=(*ys+3)/4;
		memcpy(obuf, ocbuf, xs1*ys1*8);
		if(ocbuf)free(ocbuf);
//		BGBBTJ_JPG_FreeContext(ctx);
		return(isz);
	}

	if((clrs==BGBBTJ_JPG_BC7) || (clrs==BGBBTJ_JPG_BC7_VF) ||
		(clrs==BGBBTJ_JPG_BC7_VF2))
	{
		ocbuf=NULL;
		otbuf=NULL;

//		ctx=BGBBTJ_JPG_AllocContext();
		ocbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, ibuf, isz, clrs, xs, ys);
		ctx->jpg_imgbuf=NULL;

		xs1=(*xs+3)/4;
		ys1=(*ys+3)/4;

		if((clrs==BGBBTJ_JPG_BC7_VF) ||
			(clrs==BGBBTJ_JPG_BC7_VF2))
		{
//			BGBBTJ_BC7_FlipImageBC7(ocbuf, obuf, xs1*4, ys1*4);
			BGBBTJ_BC7_FlipImageBlocksBC7(ocbuf, obuf, xs1*4, ys1*4);
		}else
		{
			memcpy(obuf, ocbuf, xs1*ys1*16);
		}

		if(ocbuf)free(ocbuf);
		if(otbuf)free(otbuf);

//		BGBBTJ_JPG_FreeContext(ctx);
		return(isz);
	}

	if((clrs==BGBBTJ_JPG_BC3) ||
		(clrs==BGBBTJ_JPG_BC3F) ||
		(clrs==BGBBTJ_JPG_BC3_VF))
	{
		ocbuf=NULL;
		otbuf=NULL;

//		ctx=BGBBTJ_JPG_AllocContext();
		ocbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, ibuf, isz, clrs, xs, ys);
		ctx->jpg_imgbuf=NULL;

		xs1=(*xs+3)/4;
		ys1=(*ys+3)/4;

		memcpy(obuf, ocbuf, xs1*ys1*16);
		
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(ibuf, isz, "Alpha");
		if(csl)
//		if(0)
		{
			sz1=isz-(csl-ibuf);
//			otbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			otbuf=BGBBTJ_JPG_DecodeLDatCtxClrs(ctx, csl, sz1,
				BGBBTJ_JPG_BC4, xs, ys);
		
//			n=ctx->xs*ctx->ys;
			n=xs1*ys1;
			for(i=0; i<n; i++)
			{
				bgbbtj_bt1c_memcpy8(obuf+i*16, otbuf+i*8);
//				obuf[i*4+3]=otbuf[i*4+1];
			}
		}else
		{
			tbb[0]=255;		tbb[1]=255;
			tbb[2]=0;		tbb[3]=0;
			tbb[4]=0;		tbb[5]=0;
			tbb[6]=0;		tbb[7]=0;

			n=xs1*ys1;
			for(i=0; i<n; i++)
			{
				bgbbtj_bt1c_memcpy8(obuf+i*16, tbb);
//				obuf[i*4+3]=otbuf[i*4+1];
			}
		}

		if(clrs==BGBBTJ_JPG_BC3_VF)
		{
			n=xs1*ys1;
			memcpy(ocbuf, obuf, n*16);
			BGBBTJ_BCn_FlipImageDXT5(ocbuf, obuf, *xs, *ys);
		}

		if(ocbuf)free(ocbuf);
		if(otbuf)free(otbuf);

//		BGBBTJ_JPG_FreeContext(ctx);
		return(isz);
	}
	
//	ctx=BGBBTJ_JPG_AllocContext();
	ocbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, ibuf, isz, clrs, xs, ys);
	ctx->jpg_imgbuf=NULL;
		
	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(ibuf, isz, "Alpha");
	if(csl)
	{
		sz1=isz-(csl-ibuf);
//		otbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		otbuf=BGBBTJ_JPG_DecodeLDatCtxClrs(ctx, csl, sz1,
			BGBBTJ_JPG_YYYA, xs, ys);
		
		n=ctx->xs*ctx->ys;
		for(i=0; i<n; i++)
		{
			obuf[i*4+3]=otbuf[i*4+1];
		}
	}

//	BGBBTJ_JPG_FreeContext(ctx);
	return(isz);
}

BGBBTJ_API int BGBBTJ_JPG_DecodeComponentType(byte *buf, int sz)
{
	byte *csl;
	int sz1;

//	sz1=(sz>1024)?1024:sz;
//	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz1, "RGB");
//	if(!csl)return(0);

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(16);
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)return(12);
		return(8);
	}else
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)return(7);

		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)return(4);

		return(3);
	}
}

BGBBTJ_API byte *BGBBTJ_JPG_DecodeLDatCtx(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	return(BGBBTJ_JPG_DecodeLDatCtxClrs(ctx, buf, sz,
		BGBBTJ_JPG_RGBA, xs, ys));
}

BGBBTJ_API byte *BGBBTJ_JPG_DecodeLDatCtxClrs(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs, int *xs, int *ys)
{
	byte *tbuf, *tbuf2, *cs, *ct;
	int i;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_APP12) ||
		(buf[4]!='L') || (buf[5]!='D') ||
		(buf[6]!='A') || (buf[7]!='T'))
	{
		tbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, buf, sz, clrs, xs, ys);
		return(tbuf);
	}
	
	tbuf=malloc(1<<20);
	cs=buf; ct=tbuf;

	while((cs[0]==0xFF) && (cs[1]==JPG_APP12) &&
		(cs[4]=='L') && (cs[5]=='D') &&
		(cs[6]=='A') && (cs[7]=='T'))
	{
		i=(cs[2]<<8)|cs[3];
		memcpy(ct, cs+8, i-6);
		cs+=i+2; ct+=(i-6);
	}

	i=ct-tbuf;
	i=BGBBTJ_JPG_EscapeDecodeSingleBuffer(tbuf, i);

	tbuf2=BGBBTJ_JPG_DecodeCtxClrs(ctx, tbuf, i, clrs, xs, ys);
	free(tbuf);
	return(tbuf2);
}

BGBBTJ_API int BGBBTJ_JPG_DummyDecodeLDatCtx(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int *xs, int *ys)
{
	byte *tbuf, *tbuf2, *cs, *ct;
	int i, j;

	if((buf[0]!=0xFF) || (buf[1]!=JPG_APP12) ||
		(buf[4]!='L') || (buf[5]!='D') ||
		(buf[6]!='A') || (buf[7]!='T'))
	{
		i=BGBBTJ_JPG_DummyDecodeCtx(ctx, buf, sz, xs, ys);
		return(i);
	}
	
	tbuf=malloc(1<<20);
	cs=buf; ct=tbuf;

	while((cs[0]==0xFF) && (cs[1]==JPG_APP12) &&
		(cs[4]=='L') && (cs[5]=='D') &&
		(cs[6]=='A') && (cs[7]=='T'))
	{
		i=(cs[2]<<8)|cs[3];
		memcpy(ct, cs+8, i-6);
		cs+=i+2; ct+=(i-6);
	}

	i=ct-tbuf;
	i=BGBBTJ_JPG_EscapeDecodeSingleBuffer(tbuf, i);

	j=BGBBTJ_JPG_DummyDecodeCtx(ctx, tbuf, i, xs, ys);
	free(tbuf);
	return(j);
}

BGBBTJ_API int BGBBTJ_JPG_DecodeComponentCtx(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	return(BGBBTJ_JPG_DecodeComponentCtxI(ctx, buf, sz,
		BGBBTJ_JPG_RGBA,
		rgba, norm, spec, luma, NULL,
		xs, ys));
}

BGBBTJ_API int BGBBTJ_JPG_DecodeComponentCtxClrs(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	return(BGBBTJ_JPG_DecodeComponentCtxI(ctx, buf, sz, clrs,
		rgba, norm, spec, luma, NULL,
		xs, ys));
}

BGBBTJ_API int BGBBTJ_JPG_DecodeFloatComponentCtx(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz,
	float *rgba, float *norm, float *spec, float *luma,
	int *xs, int *ys)
{
	byte *trgba, *tnorm, *tspec, *tluma, *tlebe;
	int i, n;
	float f, g;

	i=BGBBTJ_JPG_DummyDecodeCtx(ctx, buf, sz, xs, ys);
	if(i<0)return(-1);

	n=ctx->xs*ctx->ys;
	if(!ctx->imgbuf_rgba)
		ctx->imgbuf_rgba=malloc(4*n);
	if(!ctx->imgbuf_norm)
		ctx->imgbuf_norm=malloc(4*n);
	if(!ctx->imgbuf_spec)
		ctx->imgbuf_spec=malloc(4*n);
	if(!ctx->imgbuf_luma)
		ctx->imgbuf_luma=malloc(4*n);

	if(!ctx->imgbuf_lebe)
	{
		ctx->imgbuf_lebe=malloc(4*n);
		memset(ctx->imgbuf_lebe, 192, 4*n);
	}

	i=BGBBTJ_JPG_DecodeComponentCtxI(ctx, buf, sz,
		BGBBTJ_JPG_RGBA,
		ctx->imgbuf_rgba, ctx->imgbuf_norm,
		ctx->imgbuf_spec, ctx->imgbuf_luma,
		ctx->imgbuf_lebe,
		xs, ys);
	if(i<0)
	{
		return(-1);
	}
	
	trgba=ctx->imgbuf_rgba;
	tnorm=ctx->imgbuf_norm;
	tspec=ctx->imgbuf_spec;
	tluma=ctx->imgbuf_luma;
	tlebe=ctx->imgbuf_lebe;
	
	if(rgba)
	{
		for(i=0; i<n; i++)
		{
			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			rgba[i*4+0]=trgba[i*4+0]*f;
			rgba[i*4+1]=trgba[i*4+1]*f;
			rgba[i*4+2]=trgba[i*4+2]*f;
			rgba[i*4+3]=trgba[i*4+3]*(1.0/256);
		}
	}

	if(norm)
	{
		for(i=0; i<n; i++)
		{
//			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			f=1.0/256;
			g=(1.0/256)*pdjpg_scltab[tlebe[i*4+2]];
			norm[i*4+0]=tnorm[i*4+0]*f;
			norm[i*4+1]=tnorm[i*4+1]*f;
			norm[i*4+2]=tnorm[i*4+2]*f;
			norm[i*4+3]=tnorm[i*4+3]*g;
		}
	}

	if(spec)
	{
		for(i=0; i<n; i++)
		{
//			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+0]];
			f=1.0/256;
			spec[i*4+0]=tspec[i*4+0]*f;
			spec[i*4+1]=tspec[i*4+1]*f;
			spec[i*4+2]=tspec[i*4+2]*f;
			spec[i*4+3]=tspec[i*4+3]*f;
		}
	}

	if(luma)
	{
		for(i=0; i<n; i++)
		{
			f=(1.0/256)*pdjpg_scltab[tlebe[i*4+1]];
			luma[i*4+0]=tluma[i*4+0]*f;
			luma[i*4+1]=tluma[i*4+1]*f;
			luma[i*4+2]=tluma[i*4+2]*f;
			luma[i*4+3]=tluma[i*4+3]*(1.0/256);
		}
	}
	return(0);
}

BGBBTJ_API int BGBBTJ_JPG_ExtractComponentCtx(BGBBTJ_JPG_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe)
{
	int n;
	
	n=ctx->xs*ctx->ys;
	if(rgba && ctx->imgbuf_rgba)
		memcpy(rgba, ctx->imgbuf_rgba, n*4);
	if(norm && ctx->imgbuf_norm)
		memcpy(norm, ctx->imgbuf_norm, n*4);
	if(spec && ctx->imgbuf_spec)
		memcpy(spec, ctx->imgbuf_spec, n*4);
	if(luma && ctx->imgbuf_luma)
		memcpy(luma, ctx->imgbuf_luma, n*4);
	if(lebe && ctx->imgbuf_lebe)
		memcpy(lebe, ctx->imgbuf_lebe, n*4);
	return(0);
}

int BGBBTJ_JPG_DecodeComponentCtxI_DXT5(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe,
	int *xs, int *ys)
{
	byte *tbuf;
	byte *csl;
	int i, n, sz1, fbsz, fbn;

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "RGB");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=BGBBTJ_JPG_DecodeLDatCtxClrs(ctx, csl, sz1, clrs, xs, ys);
		if(!tbuf) return(-1);
	}
	else
	{
		tbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, buf, sz, clrs, xs, ys);
		if(!tbuf) return(-1);
	}
	
//	fbn=((*xs)/4)*((*ys)/4);
	fbn=(ctx->xs/4)*(ctx->ys/4);
	fbsz=fbn*16;
	memcpy(rgba, tbuf, fbsz);

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		BGBBTJ_BCn_EncodeIdxImageAlphaDXT5(rgba, tbuf, *xs, *ys, 4, 1);
	}else
	{
		BGBBTJ_BCn_FillImageAlphaDXT5(rgba, 255, *xs, *ys);
	}

	return(0);
}

int BGBBTJ_JPG_DecodeComponentCtxI_BC7(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe,
	int *xs, int *ys)
{
	byte *tbuf;
	byte *csl;
	int i, n, sz1, fbsz, fbn;

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "RGB");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=BGBBTJ_JPG_DecodeLDatCtxClrs(ctx, csl, sz1, clrs, xs, ys);
		if(!tbuf) return(-1);
	}
	else
	{
		tbuf=BGBBTJ_JPG_DecodeCtxClrs(ctx, buf, sz, clrs, xs, ys);
		if(!tbuf) return(-1);
	}
	
//	fbn=((*xs)/4)*((*ys)/4);
	fbn=(ctx->xs/4)*(ctx->ys/4);
	fbsz=fbn*16;
	memcpy(rgba, tbuf, fbsz);

#if 0
	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		BGBBTJ_BCn_EncodeIdxImageAlphaDXT5(rgba, tbuf, *xs, *ys, 4, 1);
	}else
	{
		BGBBTJ_BCn_FillImageAlphaDXT5(rgba, 255, *xs, *ys);
	}
#endif

	return(0);
}

int BGBBTJ_JPG_DecodeComponentCtxI(BGBBTJ_JPG_Context *ctx,
	byte *buf, int sz, int clrs,
	byte *rgba, byte *norm, byte *spec, byte *luma, byte *lebe,
	int *xs, int *ys)
{
	byte *tbuf;
	byte *csl;
	int i, n, sz1;

	if((clrs==BGBBTJ_JPG_BC3) || (clrs==BGBBTJ_JPG_BC3F))
	{
		i=BGBBTJ_JPG_DecodeComponentCtxI_DXT5(ctx, buf, sz, clrs,
			rgba, norm, spec, luma, lebe, xs, ys);
		return(i);
	}

	if((clrs==BGBBTJ_JPG_BC7) || (clrs==BGBBTJ_JPG_BC7_VF))
	{
		i=BGBBTJ_JPG_DecodeComponentCtxI_BC7(ctx, buf, sz, clrs,
			rgba, norm, spec, luma, lebe, xs, ys);
		return(i);
	}

//	tbuf=BGBBTJ_JPG_DecodeCtx(ctx, buf, sz, xs, ys);
//	if(!tbuf)return(-1);

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "RGB");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		if(!tbuf) return(-1);
	}
	else
	{
		tbuf=BGBBTJ_JPG_DecodeCtx(ctx, buf, sz, xs, ys);
		if(!tbuf) return(-1);
	}

	n=ctx->xs*ctx->ys;

	for(i=0; i<n; i++)
	{
		rgba[i*4+0]=tbuf[i*4+0];
		rgba[i*4+1]=tbuf[i*4+1];
		rgba[i*4+2]=tbuf[i*4+2];
		rgba[i*4+3]=255;
//		rgba[i*4+3]=tbuf[i*4+3];
	}

	if(norm)
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "XYZ");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				norm[i*4+0]=tbuf[i*4+0];
				norm[i*4+1]=tbuf[i*4+2];
				norm[i*4+2]=tbuf[i*4+1];
//				norm[i*4+3]=tbuf[i*4+3];
			}
		}
	}

	if(spec)
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "SpRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				spec[i*4+0]=tbuf[i*4+0];
				spec[i*4+1]=tbuf[i*4+1];
				spec[i*4+2]=tbuf[i*4+2];
//				spec[i*4+3]=tbuf[i*4+3];
			}
		}
	}

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "DASe");
	if(csl)
	{
		sz1=sz-(csl-buf);
		tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
		for(i=0; i<n; i++)
		{
			rgba[i*4+3]=tbuf[i*4+1];
			if(norm) { norm[i*4+3]=tbuf[i*4+0]; }
			if(spec) { spec[i*4+3]=tbuf[i*4+2]; }
		}
	}else
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "Alpha");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
				{ rgba[i*4+3]=tbuf[i*4+1]; }
		}
		
		if(norm)
		{
			csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "Depth");
			if(csl)
			{
				sz1=sz-(csl-buf);
				tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
				for(i=0; i<n; i++)
					{ norm[i*4+3]=tbuf[i*4+1]; }
			}
		}
	}
	
	if(luma)
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "LuRGB");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				luma[i*4+0]=tbuf[i*4+0];
				luma[i*4+1]=tbuf[i*4+1];
				luma[i*4+2]=tbuf[i*4+2];
				luma[i*4+3]=255;
			}
		}
	}

	if(lebe)
	{
		csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "LeBe");
		if(csl)
		{
			sz1=sz-(csl-buf);
			tbuf=BGBBTJ_JPG_DecodeLDatCtx(ctx, csl, sz1, xs, ys);
			for(i=0; i<n; i++)
			{
				lebe[i*4+0]=tbuf[i*4+0];
				lebe[i*4+1]=tbuf[i*4+1];
				lebe[i*4+2]=tbuf[i*4+2];
			}
		}
	}

	return(0);
}

BGBBTJ_API int BGBBTJ_JPG_DecodeComponent(byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	BGBBTJ_JPG_Context *ctx;
	int i;
	
	ctx=BGBBTJ_JPG_AllocContext();
	i=BGBBTJ_JPG_DecodeComponentCtx(ctx, buf, sz,
		rgba, norm, spec, luma, xs, ys);
//	ctx->jpg_imgbuf=NULL;
	BGBBTJ_JPG_FreeContext(ctx);
	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_DecodeComponentClrs(
	byte *buf, int sz, int clrs,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys)
{
	BGBBTJ_JPG_Context *ctx;
	int i;
	
	ctx=BGBBTJ_JPG_AllocContext();
	i=BGBBTJ_JPG_DecodeComponentCtxI(ctx, buf, sz, clrs,
		rgba, norm, spec, luma, NULL, xs, ys);
//	ctx->jpg_imgbuf=NULL;
	BGBBTJ_JPG_FreeContext(ctx);
	return(i);
}

BGBBTJ_API int BGBBTJ_JPG_DummyDecodeLayerInfo(byte *buf, int sz,
	BGBBTJ_JPG_LayerInfo *linf)
{
	BGBBTJ_JPG_Context *ctx;
	byte *csl;
	int xs, ys, sz1;
	int i;
	
	ctx=BGBBTJ_JPG_AllocContext();
//	i=BGBBTJ_JPG_DecodeComponentCtx(ctx, buf, sz,
//		rgba, norm, spec, luma, xs, ys);
//	ctx->jpg_imgbuf=NULL;

	csl=BGBBTJ_JPG_DecodeScanForComponentLayer(buf, sz, "RGB");
	if(csl)
	{
		sz1=sz-(csl-buf);
		i=BGBBTJ_JPG_DummyDecodeLDatCtx(ctx, csl, sz1, &xs, &ys);
		if(i<0) return(i);
	}
	else
	{
		i=BGBBTJ_JPG_DummyDecodeCtx(ctx, buf, sz, &xs, &ys);
		if(i<0) return(i);
	}
	
	if((xs<=0) || (ys<=0))
		return(-1);

	linf->flags=ctx->bcst_flags;
	linf->alpha=ctx->bcst_alpha;
	linf->blend=ctx->bcst_blend;
	linf->orgx=ctx->bcst_orgx;
	linf->orgy=ctx->bcst_orgy;
	linf->xs=xs;
	linf->ys=ys;

	linf->minx=ctx->bcst_minx;
	linf->miny=ctx->bcst_miny;
	linf->maxx=ctx->bcst_maxx;
	linf->maxy=ctx->bcst_maxy;

	BGBBTJ_JPG_FreeContext(ctx);
	return(i);
}
/*
DXTn packed images.

Each block tag will be encoded in the form (byte):
0 <block:QWORD>		Literal Block.
1-127				Single byte block index.
128-191	X			Two byte block index (16384 blocks).
192-223	XX			Three byte block index (2097152 blocks).
224-238 I			LZ/RLE Run (2-16 blocks, Index)
239		LI			LZ/RLE Run (Length, Index)
240		XXX			24-Bit Index
241		XXXX		32-Bit Index
242-246				Literal Blocks (2-6 Blocks)
247		L			Literal Blocks (L Blocks)
248-250	J			Raster Relative 1-3, X (Sign Folded X)
251		IJ			Raster Relative 4+, YX (Sign Folded X)
252-255				Escape (2-byte commands)

The block index will indicate how many blocks backwards to look for a matching block (1 will repeat the prior block).

Length/Index values will use the same organization as above, only limited to encoding numeric values.

0-127				0-127.
128-191	X			128-16383.
192-223	XX			16384-2097151.
240		XXX			24-Bit Index (0-16777215)
241		XXXX		32-Bit Index (0-4294967295)
248-250	J			Raster Relative 1-3, X (Sign Folded X)
251		IJ			Raster Relative 4+, YX (Sign Folded X)

Sign Folding will fold the sign according to the pattern:
0, -1, 1, -2, 2, ...

Note that DXT5 images will be split into 2 block-planes, with the first encoding the alpha component, followed by the plane encoding the RGB components.

If used with BTAC, this will be split into 4 or 16 planes.

Raster Relative References will encode an offset relative to a scanline (as opposed to a linear distance).
*/

#include <bgbbtj.h>

byte *BGBBTJ_PackBCn_EmitValue(byte *ct, int val)
{
	if(val<128)
	{
		*ct++=val;
		return(ct);
	}
	if(val<16384)
	{
		*ct++=128+(val>>8);
		*ct++=val;
		return(ct);
	}
	if(val<2097152)
	{
		*ct++=192+(val>>16);
		*ct++=val>>8;
		*ct++=val;
		return(ct);
	}
	if(val<1677216)
	{
		*ct++=240;
		*ct++=val>>16;
		*ct++=val>>8;
		*ct++=val;
		return(ct);
	}
	*ct++=241;
	*ct++=val>>24;	*ct++=val>>16;
	*ct++=val>>8;	*ct++=val;
	return(ct);
}

byte *BGBBTJ_PackBCn_EmitRun(byte *ct, int idx, int len)
{
	if(idx==0)
	{
		if(len<2)
		{
			*ct++=0;
			return(ct);
		}
		if(len<7)
		{
			*ct++=242+(len-2);
			return(ct);
		}

		*ct++=247;
		ct=BGBBTJ_PackBCn_EmitValue(ct, len);
		return(ct);
	}

	if(len<2)
	{
		ct=BGBBTJ_PackBCn_EmitValue(ct, idx);
		return(ct);
	}

	if(len<=16)
	{
		*ct++=224+(len-2);
		ct=BGBBTJ_PackBCn_EmitValue(ct, idx);
		return(ct);
	}

	*ct++=239;
	ct=BGBBTJ_PackBCn_EmitValue(ct, len);
	ct=BGBBTJ_PackBCn_EmitValue(ct, idx);
	return(ct);
}

byte *BGBBTJ_PackBCn_EmitValueSign(
	byte *ct, int val)
{
	return(BGBBTJ_PackBCn_EmitValue(ct, (val>=0)?(val<<1):(((-val)<<1)-1)));
}

byte *BGBBTJ_PackBCn_EmitValueScan(
	byte *ct, int val, int scan)
{
	int by, bx;

	if((val>=128) && (scan>1))
	{
		by=(val+(scan>>1))/scan;
		bx=val-by*scan;
		
		if((by>=1) && (by<=3) && (bx>=-64) && (bx<64))
		{
			*ct++=248+(by-1);
			ct=BGBBTJ_PackBCn_EmitValueSign(ct, bx);
			return(ct);
		}

#if 1
		if((val>=16384) && (by>=4) && (by<128) && (bx>=-64) && (bx<64))
		{
			*ct++=251;
			ct=BGBBTJ_PackBCn_EmitValue(ct, by);
			ct=BGBBTJ_PackBCn_EmitValueSign(ct, bx);
			return(ct);
		}
#endif
	}

	return(BGBBTJ_PackBCn_EmitValue(ct, val));
}

byte *BGBBTJ_PackBCn_EmitRunScan(
	byte *ct, int idx, int len, int scan)
{
	if(idx==0)
	{
		if(len<2)
		{
			*ct++=0;
			return(ct);
		}
		if(len<7)
		{
			*ct++=242+(len-2);
			return(ct);
		}

		*ct++=247;
		ct=BGBBTJ_PackBCn_EmitValue(ct, len);
		return(ct);
	}

	if(len<2)
	{
		ct=BGBBTJ_PackBCn_EmitValueScan(ct, idx, scan);
		return(ct);
	}

	if(len<=16)
	{
		*ct++=224+(len-2);
		ct=BGBBTJ_PackBCn_EmitValueScan(ct, idx, scan);
		return(ct);
	}

	*ct++=239;
	ct=BGBBTJ_PackBCn_EmitValue(ct, len);
	ct=BGBBTJ_PackBCn_EmitValueScan(ct, idx, scan);
	return(ct);
}

byte *BGBBTJ_PackBCn_EmitBlockValue(byte *ct, u64 block)
{
	*ct++=block;		*ct++=block>>8;
	*ct++=block>>16;	*ct++=block>>24;
	*ct++=block>>32;	*ct++=block>>40;
	*ct++=block>>48;	*ct++=block>>56;
	return(ct);
}

u64 BGBBTJ_PackBCn_GetBlockValue(byte *cs)
{
	u32 t1, t2;
	u64 tmp;
#if defined(X86) || defined(X86_64)
	return(*(u64 *)cs);
#else
	t1=cs[0] | (cs[1]<<8) | (cs[2]<<16) | (cs[3]<<24);
	t2=cs[4] | (cs[5]<<8) | (cs[6]<<16) | (cs[7]<<24);
	tmp=t1+(((u64)t2)<<32);
#endif
	return(tmp);
}

int BGBBTJ_PackBCn_LookupBlockSpan(
	byte *css, byte *cs, byte *cse, int stride,
	int *blkchn, int *blkhash,
	int *ridx, int *rlen, int max)
{
	u64 li, lj, lk;
	int bi, bl, ci, cl, shr;
	byte *csi, *csj, *csk;
	int i;

	switch(stride)
	{
	case 4: shr=2; break;
	case 8: shr=3; break;
	case 16: shr=4; break;
	case 32: shr=5; break;
	case 64: shr=6; break;
	}

	li=BGBBTJ_PackBCn_GetBlockValue(cs);
	
//	lj=li*2147483647*127*127;
	lj=li*187284906682965LL;
//	ci=(lj>>48)&4095;
	ci=(lj>>48)&65535;
	i=blkhash[ci];

	if(i<=0) { 	*ridx=0; *rlen=0; return(0); }

	csi=css+i*stride;
	
//	csi=cs-stride;
	bi=0; bl=0;

//	while((csi>=css) && (csi<cs))
	while(csi>=css)
	{
		lj=BGBBTJ_PackBCn_GetBlockValue(csi);
		if(li!=lj)
			{ csi-=stride; continue; }
		csj=csi+stride;
		csk=cs+stride;
		while(csk<cse)
		{
			lj=BGBBTJ_PackBCn_GetBlockValue(csj);
			lk=BGBBTJ_PackBCn_GetBlockValue(csk);
			if(lj!=lk)break;
			csj+=stride; csk+=stride;
		}
		
//		ci=(cs-csi)/stride;
//		cl=(csk-cs)/stride;
		ci=(cs-csi)>>shr;
		cl=(csk-cs)>>shr;
		if(cl>bl) { bi=ci; bl=cl; }
		if(bl>=max)break;
//		csi-=stride;

//		if((ci>1024) && (bl>=256))
//			break;
//		if((ci>4096) && (bl>=64))
//			break;

//		if((ci*bl)>65536)
//			break;

//		i=blkchn[(cs-css)/stride];
		i=blkchn[(cs-css)>>shr];
		if(i<=0)break;
		csi-=i*stride;
	}
	
	*ridx=bi;
	*rlen=bl;
	return(0);
}

int BGBBTJ_PackBCn_UpdateBlockSpan(
	byte *css, byte *cs, byte *cse, int stride,
	int *blkchn, int *blkhash, int len)
{
	u64 li, lj;
	byte *cs1;
	int ci, cj;
	int i, j, k;

	for(i=0; i<len; i++)
	{
		cs1=cs+i*stride;
		li=BGBBTJ_PackBCn_GetBlockValue(cs1);
		lj=li*187284906682965LL;
//		ci=(lj>>48)&4095;
		ci=(lj>>48)&65535;
		
		cj=(cs1-css)/stride;
		k=cj-blkhash[ci];
		blkchn[cj]=k;
		blkhash[ci]=cj;
	}
	return(0);
}

byte *BGBBTJ_PackBCn_EncodeBlockArray(byte *obuf, byte *blks,
	int count, int stride)
{
	byte *cs, *cse, *ct, *cs1;
	int *blkchn, *blkhash;
	u64 li;
	int i, bi, bl, bi1, bl1;
	
	blkchn=malloc(count*sizeof(int));
	blkhash=malloc(65536*sizeof(int));
	memset(blkchn, 0, count*sizeof(int));
	memset(blkhash, 0, 65536*sizeof(int));
	
	ct=obuf;
	cs=blks; cse=blks+count*stride;
	while(cs<cse)
	{
		BGBBTJ_PackBCn_LookupBlockSpan(blks, cs, cse, stride,
			blkchn, blkhash,
			&bi, &bl, 65536);

#if 1
		if(bi==0)
		{
			bl=1; cs1=cs+stride;
//			while((cs1<cse) && (bl<6))
//			while(cs1<cse)
			while((cs1<cse) && (bl<256))
			{
				BGBBTJ_PackBCn_LookupBlockSpan(
					blks, cs1, cse, stride,
					blkchn, blkhash,
					&bi1, &bl1, 1);
				if(bi1>0)break;
				bl++;
				cs1=cs+bl*stride;
			}
		}
#endif

		BGBBTJ_PackBCn_UpdateBlockSpan(blks, cs, cse, stride,
			blkchn, blkhash, bl);

		if(bi<1)
		{
			if(bl<2)
			{
				*ct++=0;
				li=BGBBTJ_PackBCn_GetBlockValue(cs);
				ct=BGBBTJ_PackBCn_EmitBlockValue(ct, li);
				cs+=stride;
				continue;
			}
			ct=BGBBTJ_PackBCn_EmitRun(ct, 0, bl);
			for(i=0; i<bl; i++)
			{
				li=BGBBTJ_PackBCn_GetBlockValue(cs);
				ct=BGBBTJ_PackBCn_EmitBlockValue(ct, li);
				cs+=stride;
			}
			continue;
		}
		ct=BGBBTJ_PackBCn_EmitRun(ct, bi, bl);
		cs+=bl*stride;
	}
	
	free(blkchn);
	free(blkhash);
	
	return(ct);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodeBlocksDXT1(
	byte *obuf, byte *blks, int count)
{
	byte *ct;
	ct=BGBBTJ_PackBCn_EncodeBlockArray(obuf, blks, count, 8);
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodeBlocksDXT5(
	byte *obuf, byte *blks, int count)
{
	byte *ct;
	ct=BGBBTJ_PackBCn_EncodeBlockArray(obuf, blks, count, 16);
	ct=BGBBTJ_PackBCn_EncodeBlockArray(ct, blks+8, count, 16);
	return(ct-obuf);
}

byte *BGBBTJ_PackBCn_EncodePatchBlockArray(byte *obuf, byte *blks,
	byte *iblks, int count, int stride)
{
	byte *cs, *cse, *ct, *cs1;
	int *blkchn, *blkhash;
	u64 li;
	int i, bi, bl, bi1, bl1;
	
	blkchn=malloc(2*count*sizeof(int));
	blkhash=malloc(65536*sizeof(int));
	memset(blkchn, 0, 2*count*sizeof(int));
	memset(blkhash, 0, 65536*sizeof(int));

	cs=iblks; cse=iblks+count*stride;
	BGBBTJ_PackBCn_UpdateBlockSpan(iblks, cs, cse, stride,
		blkchn, blkhash, count);

	ct=obuf;
	cs=blks; cse=blks+count*stride;
	while(cs<cse)
	{
		BGBBTJ_PackBCn_LookupBlockSpan(blks, cs, cse, stride,
			blkchn, blkhash,
			&bi, &bl, 65536);

#if 1
		if(bi==0)
		{
			bl=1; cs1=cs+stride;
//			while((cs1<cse) && (bl<6))
//			while(cs1<cse)
			while((cs1<cse) && (bl<256))
			{
				BGBBTJ_PackBCn_LookupBlockSpan(
					blks, cs1, cse, stride,
					blkchn, blkhash,
					&bi1, &bl1, 1);
				if(bi1>0)break;
				bl++;
				cs1=cs+bl*stride;
			}
		}
#endif

		BGBBTJ_PackBCn_UpdateBlockSpan(blks, cs, cse, stride,
			blkchn, blkhash, bl);

		if(bi<1)
		{
			if(bl<2)
			{
				*ct++=0;
				li=BGBBTJ_PackBCn_GetBlockValue(cs);
				ct=BGBBTJ_PackBCn_EmitBlockValue(ct, li);
				cs+=stride;
				continue;
			}
			ct=BGBBTJ_PackBCn_EmitRun(ct, 0, bl);
			for(i=0; i<bl; i++)
			{
				li=BGBBTJ_PackBCn_GetBlockValue(cs);
				ct=BGBBTJ_PackBCn_EmitBlockValue(ct, li);
				cs+=stride;
			}
			continue;
		}
		ct=BGBBTJ_PackBCn_EmitRun(ct, bi, bl);
		cs+=bl*stride;
	}
	
	free(blkchn);
	free(blkhash);
	
	return(ct);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodePatchBlocksDXT1(
	byte *obuf, byte *blks, int count)
{
	byte *ct;
	ct=BGBBTJ_PackBCn_EncodePatchBlockArray(
		obuf, blks+count*8, blks, count, 8);
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodePatchBlocksDXT5(
	byte *obuf, byte *blks, int count)
{
	byte *ct;
	ct=BGBBTJ_PackBCn_EncodePatchBlockArray(
		obuf, blks+count*16, blks, count, 16);
	ct=BGBBTJ_PackBCn_EncodePatchBlockArray(
		ct, blks+count*16+8, blks+8, count, 16);
	return(ct-obuf);
}

byte *BGBBTJ_PackBCn_DecodeValue(byte *cs, int *rval)
{
	int op, i;
	
	op=*cs++;
	if(op<128)
		{ *rval=op; return(cs); }
	if(op<192)
	{
		*rval=((op-128)<<8)|(*cs++);
		return(cs);
	}
	if(op<224)
	{
		i=((op-192)<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*rval=i;
		return(cs);
	}

	if(op==240)
	{
		i=*cs++;
		i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*rval=i;
		return(cs);
	}
	if(op==241)
	{
		i=*cs++;			i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);	i=(i<<8)|(*cs++);
		*rval=i;
		return(cs);
	}

	return(cs);
}

byte *BGBBTJ_PackBCn_DecodeRun(byte *cs, int *ridx, int *rlen)
{
	int op, i;
	
	op=*cs++;
	if(!op)
		{ *ridx=0; *rlen=0; return(cs); }
	if(op<128)
		{ *ridx=op; *rlen=1; return(cs); }
	if(op<192)
	{
		*ridx=((op-128)<<8)|(*cs++);
		*rlen=1;
		return(cs);
	}
	if(op<224)
	{
		i=((op-192)<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}
	if(op<239)
	{
		cs=BGBBTJ_PackBCn_DecodeValue(cs, ridx);
		*rlen=(op-224)+2;
		return(cs);
	}
	if(op==239)
	{
		cs=BGBBTJ_PackBCn_DecodeValue(cs, rlen);
		cs=BGBBTJ_PackBCn_DecodeValue(cs, ridx);
		return(cs);
	}
	if(op==240)
	{
		i=*cs++;
		i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}
	if(op==241)
	{
		i=*cs++;			i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);	i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}

	if(op<247)
	{
		*ridx=0;
		*rlen=(op-242)+2;
		return(cs);
	}
	if(op==247)
	{
		*ridx=0;
		cs=BGBBTJ_PackBCn_DecodeValue(cs, rlen);
		return(cs);
	}

	*ridx=0; *rlen=0;
	return(cs);
}

byte *BGBBTJ_PackBCn_DecodeValueSign(byte *cs, int *rval)
{
	int i;
	cs=BGBBTJ_PackBCn_DecodeValue(cs, &i);
	*rval=(i&1)?(-((i+1)>>1)):(i>>1);
	return(cs);
}

byte *BGBBTJ_PackBCn_DecodeValueScan(byte *cs, int *rval, int scan)
{
	int op, i, j;
	
	op=*cs;

	if((op>=248) && (op<=250))
	{
		cs++;
		cs=BGBBTJ_PackBCn_DecodeValueSign(cs, &i);
		*rval=((op-248)+1)*scan+i;
		return(cs);
	}

	if(op==251)
	{
		cs++;
		cs=BGBBTJ_PackBCn_DecodeValue(cs, &i);
		cs=BGBBTJ_PackBCn_DecodeValueSign(cs, &j);
		*rval=i*scan+j;
		return(cs);
	}
	
	return(BGBBTJ_PackBCn_DecodeValue(cs, rval));
}

byte *BGBBTJ_PackBCn_DecodeRunScan(
	byte *cs, int *ridx, int *rlen, int scan)
{
	int op, i, j;
	
	op=*cs++;
	if(!op)
		{ *ridx=0; *rlen=0; return(cs); }
	if(op<128)
		{ *ridx=op; *rlen=1; return(cs); }
	if(op<192)
	{
		*ridx=((op-128)<<8)|(*cs++);
		*rlen=1;
		return(cs);
	}
	if(op<224)
	{
		i=((op-192)<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}
	if(op<239)
	{
		cs=BGBBTJ_PackBCn_DecodeValueScan(cs, ridx, scan);
		*rlen=(op-224)+2;
		return(cs);
	}
	if(op==239)
	{
		cs=BGBBTJ_PackBCn_DecodeValue(cs, rlen);
		cs=BGBBTJ_PackBCn_DecodeValueScan(cs, ridx, scan);
		return(cs);
	}
	if(op==240)
	{
		i=*cs++;
		i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}
	if(op==241)
	{
		i=*cs++;			i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);	i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}

	if(op<247)
	{
		*ridx=0;
		*rlen=(op-242)+2;
		return(cs);
	}
	if(op==247)
	{
		*ridx=0;
		cs=BGBBTJ_PackBCn_DecodeValue(cs, rlen);
		return(cs);
	}

	if((op>=248) && (op<=250))
	{
		cs=BGBBTJ_PackBCn_DecodeValueSign(cs, &i);
		*ridx=((op-248)+1)*scan+i;
		*rlen=1;
		return(cs);
	}

	if(op==251)
	{
		cs=BGBBTJ_PackBCn_DecodeValue(cs, &i);
		cs=BGBBTJ_PackBCn_DecodeValueSign(cs, &j);
		*ridx=i*scan+j;
		*rlen=1;
		return(cs);
	}

	*ridx=0; *rlen=0;
	return(cs);
}

byte *BGBBTJ_PackBCn_DecodeBlockArray(byte *ibuf, byte *blks,
	int count, int stride)
{
	byte *cs, *ct, *cte, *cs1, *ct1, *cs1e;
	byte *cs0, *cs0a, *cs0b, *cs0c, *cs0d;
	int bi, bl;
	int i, j;

	cs0d=NULL; cs0c=NULL; cs0b=NULL; cs0a=NULL; cs0=NULL;
	cs=ibuf; ct=blks; cte=ct+count*stride;
	while(ct<cte)
	{
		cs0d=cs0c; cs0c=cs0b; cs0b=cs0a; cs0a=cs0; cs0=cs;
		cs=BGBBTJ_PackBCn_DecodeRun(cs, &bi, &bl);
		if(bi==0)
		{
			if(bl>1)
			{
#if defined(X86) || defined(X86_64)
				cs1e=cs+bl*8;
				while(cs<cs1e)
				{
					*(u64 *)ct=*(u64 *)(cs);
					cs+=8; ct+=stride;
				}
#else
				for(i=0; i<bl; i++)
					{ memcpy(ct+i*stride, cs+i*8, 8); }
				cs+=bl*8;
				ct+=bl*stride;
#endif
				continue;
			}
#if defined(X86) || defined(X86_64)
			*(u64 *)ct=*(u64 *)cs;
#else
			memcpy(ct, cs, 8);
#endif
			ct+=stride; cs+=8;
			continue;
		}

#if defined(X86) || defined(X86_64)
		cs1=ct-bi*stride;
		cs1e=cs1+bl*stride;
		while(cs1<cs1e)
		{
			*(u64 *)ct=*(u64 *)(cs1);
			cs1+=stride; ct+=stride;
		}
#else
		for(i=0; i<bl; i++)
			{ memcpy(ct+i*stride, ct+(i-bi)*stride, 8); }
		ct+=bl*stride;
#endif
	}
	return(cs);
}

BGBBTJ_API int BGBBTJ_PackBCn_DecodeBlocksDXT1(
	byte *ibuf, byte *blks, int count)
{
	byte *cs;
	cs=BGBBTJ_PackBCn_DecodeBlockArray(ibuf, blks, count, 8);
	return(cs-ibuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_DecodeBlocksDXT5(
	byte *ibuf, byte *blks, int count)
{
	byte *cs;
	cs=BGBBTJ_PackBCn_DecodeBlockArray(ibuf, blks, count, 16);
	cs=BGBBTJ_PackBCn_DecodeBlockArray(cs, blks+8, count, 16);
	return(cs-ibuf);
}

/*
BlockPack with literal DXTn blocks stored out-of-band.

The main buffer will then contain commands, with the 'lbuf' holding any literal blocks.
*/

byte *BGBBTJ_PackBCn_EncodeBlockArray2(
	byte *obuf, byte **rlbuf, byte *blks, byte *iblks,
	int count, int stride, int scan)
{
	byte *cs, *css, *cse, *ct, *ctl, *cs1;
	int *blkchn, *blkhash;
	u64 li;
	int i, bi, bl, bi1, bl1;
	
	blkchn=malloc(2*count*sizeof(int));
	blkhash=malloc(65536*sizeof(int));
	memset(blkchn, 0, 2*count*sizeof(int));
	memset(blkhash, 0, 65536*sizeof(int));

	if(iblks)
	{
		css=iblks; cs=iblks; cse=iblks+count*stride;
		BGBBTJ_PackBCn_UpdateBlockSpan(css, cs, cse, stride,
			blkchn, blkhash, count);

		ct=obuf; ctl=*rlbuf;
		cs=blks; cse=blks+count*stride;
	}else
	{
		ct=obuf; ctl=*rlbuf;
		cs=blks; css=blks; cse=blks+count*stride;
	}

//	ct=obuf; ctl=*rlbuf;
//	cs=blks; cse=blks+count*stride;
	while(cs<cse)
	{
		BGBBTJ_PackBCn_LookupBlockSpan(css, cs, cse, stride,
			blkchn, blkhash,
			&bi, &bl, 65536);

#if 1
		if(bi==0)
		{
			bl=1; cs1=cs+stride;
//			while((cs1<cse) && (bl<6))
//			while(cs1<cse)
			while((cs1<cse) && (bl<256))
			{
				BGBBTJ_PackBCn_LookupBlockSpan(
					css, cs1, cse, stride,
					blkchn, blkhash,
					&bi1, &bl1, 1);
				if(bi1>0)break;
				bl++;
				cs1=cs+bl*stride;
			}
		}
#endif

		BGBBTJ_PackBCn_UpdateBlockSpan(css, cs, cse, stride,
			blkchn, blkhash, bl);

		if(bi<1)
		{
			if(bl<2)
			{
				*ct++=0;
				li=BGBBTJ_PackBCn_GetBlockValue(cs);
				ctl=BGBBTJ_PackBCn_EmitBlockValue(ctl, li);
				cs+=stride;
				continue;
			}
			ct=BGBBTJ_PackBCn_EmitRunScan(ct, 0, bl, scan);
			for(i=0; i<bl; i++)
			{
				li=BGBBTJ_PackBCn_GetBlockValue(cs);
				ctl=BGBBTJ_PackBCn_EmitBlockValue(ctl, li);
				cs+=stride;
			}
			continue;
		}
		ct=BGBBTJ_PackBCn_EmitRunScan(ct, bi, bl, scan);
		cs+=bl*stride;
	}
	
	free(blkchn);
	free(blkhash);
	
	*rlbuf=ctl;
	return(ct);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodeBlocks2DXT1(
	byte *obuf, byte *lbuf, byte *blks, int count, int scan, int *rlsz)
{
	byte *ct, *ctl;
	
	ct=obuf; ctl=lbuf;
	ct=BGBBTJ_PackBCn_EncodeBlockArray2(
		ct, &ctl, blks, NULL, count, 8, scan);
	*rlsz=ctl-lbuf;
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodeBlocks2DXT5(
	byte *obuf, byte *lbuf, byte *blks, int count, int scan, int *rlsz)
{
	byte *ct, *ctl;
	ct=obuf; ctl=lbuf;
	ct=BGBBTJ_PackBCn_EncodeBlockArray2(
		ct, &ctl, blks, NULL, count, 16, scan);
	ct=BGBBTJ_PackBCn_EncodeBlockArray2(
		ct, &ctl, blks+8, NULL, count, 16, scan);
	*rlsz=ctl-lbuf;
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodePatchBlocks2DXT1(
	byte *obuf, byte *lbuf, byte *blks, int count, int scan, int *rlsz)
{
	byte *ct, *ctl;
	
	ct=obuf; ctl=lbuf;
	ct=BGBBTJ_PackBCn_EncodeBlockArray2(
		ct, &ctl, blks+count*8, blks, count, 8, scan);
	*rlsz=ctl-lbuf;
	return(ct-obuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_EncodePatchBlocks2DXT5(
	byte *obuf, byte *lbuf, byte *blks, int count, int scan, int *rlsz)
{
	byte *ct, *ctl;
	ct=obuf; ctl=lbuf;
	ct=BGBBTJ_PackBCn_EncodeBlockArray2(
		ct, &ctl, blks+count*16, blks, count, 16, scan);
	ct=BGBBTJ_PackBCn_EncodeBlockArray2(
		ct, &ctl, blks+count*16+8, blks+8, count, 16, scan);
	*rlsz=ctl-lbuf;
	return(ct-obuf);
}


byte *BGBBTJ_PackBCn_DecodeBlockArray2(byte *ibuf,
	byte **rlbuf, byte *blks,
	int count, int stride, int scan)
{
	byte *cs, *csl, *ct, *cte, *cs1, *ct1, *cs1e;
	byte *cs0, *cs0a, *cs0b, *cs0c, *cs0d;
	int bi, bl;
	int i, j;

	cs0d=NULL; cs0c=NULL; cs0b=NULL; cs0a=NULL; cs0=NULL;
	cs=ibuf; csl=*rlbuf; ct=blks; cte=ct+count*stride;
	while(ct<cte)
	{
		cs0d=cs0c; cs0c=cs0b; cs0b=cs0a; cs0a=cs0; cs0=cs;
		cs=BGBBTJ_PackBCn_DecodeRunScan(cs, &bi, &bl, scan);
		
		if((ct+(bl*stride))>cte)
			break;
		
		if(bi==0)
		{
			if(bl>1)
			{
#if defined(X86) || defined(X86_64)
				cs1e=csl+bl*8;
				while(csl<cs1e)
				{
					*(u64 *)ct=*(u64 *)(csl);
					csl+=8; ct+=stride;
				}
#else
				for(i=0; i<bl; i++)
					{ memcpy(ct+i*stride, csl+i*8, 8); }
				csl+=bl*8;
				ct+=bl*stride;
#endif
				continue;
			}
#if defined(X86) || defined(X86_64)
			*(u64 *)ct=*(u64 *)csl;
#else
			memcpy(ct, csl, 8);
#endif
			ct+=stride; csl+=8;
			continue;
		}

#if defined(X86) || defined(X86_64)
		cs1=ct-bi*stride;
		cs1e=cs1+bl*stride;
		while(cs1<cs1e)
		{
			*(u64 *)ct=*(u64 *)(cs1);
			cs1+=stride; ct+=stride;
		}
#else
		for(i=0; i<bl; i++)
			{ memcpy(ct+i*stride, ct+(i-bi)*stride, 8); }
		ct+=bl*stride;
#endif
	}
	
	*rlbuf=csl;
	return(cs);
}

BGBBTJ_API int BGBBTJ_PackBCn_DecodeBlocks2DXT1(
	byte *ibuf, byte *lbuf, byte *blks, int count, int scan)
{
	byte *cs, *csl;
	
	csl=lbuf;
	cs=BGBBTJ_PackBCn_DecodeBlockArray2(ibuf, &csl, blks, count, 8, scan);
	return(cs-ibuf);
}

BGBBTJ_API int BGBBTJ_PackBCn_DecodeBlocks2DXT5(
	byte *ibuf, byte *lbuf, byte *blks, int count, int scan)
{
	byte *cs, *csl;

	cs=ibuf; csl=lbuf;
	cs=BGBBTJ_PackBCn_DecodeBlockArray2(cs, &csl, blks, count, 16, scan);
	cs=BGBBTJ_PackBCn_DecodeBlockArray2(cs, &csl, blks+8, count, 16, scan);
	return(cs-ibuf);
}


byte *BGBBTJ_PackBCn_StatDecodeRun(byte *cs,
	int *ridx, int *rlen, int *stats, int scan)
{
	int op, i, j;
	
	op=*cs++;
	stats[op]++;
	
	if(!op)
		{ *ridx=0; *rlen=0; return(cs); }
	if(op<128)
		{ *ridx=op; *rlen=1; return(cs); }
	if(op<192)
	{
		stats[512+(*cs)]++;
		*ridx=((op-128)<<8)|(*cs++);
		*rlen=1;
		return(cs);
	}
	if(op<224)
	{
		stats[512+cs[0]]++;
		stats[512+cs[1]]++;

		i=((op-192)<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}
	if(op<239)
	{
		stats[256+(*cs)]++;
		cs=BGBBTJ_PackBCn_DecodeValueScan(cs, ridx, scan);
		*rlen=(op-224)+2;
		return(cs);
	}
	if(op==239)
	{
		stats[256+(*cs)]++;
		cs=BGBBTJ_PackBCn_DecodeValue(cs, rlen);
		stats[256+(*cs)]++;
		cs=BGBBTJ_PackBCn_DecodeValueScan(cs, ridx, scan);
		return(cs);
	}
	if(op==240)
	{
		i=*cs++;
		i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}
	if(op==241)
	{
		i=*cs++;			i=(i<<8)|(*cs++);
		i=(i<<8)|(*cs++);	i=(i<<8)|(*cs++);
		*ridx=i;
		*rlen=1;
		return(cs);
	}

	if(op<247)
	{
		*ridx=0;
		*rlen=(op-242)+2;
		return(cs);
	}
	if(op==247)
	{
		stats[256+(*cs)]++;
		*ridx=0;
		cs=BGBBTJ_PackBCn_DecodeValue(cs, rlen);
		return(cs);
	}

	if((op>=248) && (op<=250))
	{
		stats[256+(*cs)]++;
		cs=BGBBTJ_PackBCn_DecodeValueSign(cs, &i);
		*ridx=((op-248)+1)*scan+i;
		*rlen=1;
		return(cs);
	}

	if(op==251)
	{
		stats[256+(*cs)]++;
		cs=BGBBTJ_PackBCn_DecodeValue(cs, &i);
		cs=BGBBTJ_PackBCn_DecodeValueSign(cs, &j);
		*ridx=i*scan+j;
		*rlen=1;
		return(cs);
	}

	*ridx=0; *rlen=0;
	return(cs);
}

byte *BGBBTJ_PackBCn_StatBlockArray2(
	byte *ibuf, int *stats, int count, int scan)
{
	byte *cs, *cs1, *ct1, *cs1e;
	byte *cs0, *cs0a, *cs0b, *cs0c, *cs0d;
	int bi, bl;
	int i, j, n;

	cs0d=NULL; cs0c=NULL; cs0b=NULL; cs0a=NULL; cs0=NULL;
	cs=ibuf; n=0;
	while(n<count)
	{
		cs0d=cs0c; cs0c=cs0b; cs0b=cs0a; cs0a=cs0; cs0=cs;
//		stats[*cs]++;
		cs=BGBBTJ_PackBCn_StatDecodeRun(cs, &bi, &bl, stats, scan);
		if(bi==0)
		{
			if(bl>1)
			{
				n+=bl;
				continue;
			}
			n++;
			continue;
		}

		n+=bl;
	}
	return(cs);
}
#include <bgbbtj.h>

typedef struct BGBBTJ_BTIC1_Malloc_s BGBBTJ_BTIC1_Malloc;
struct BGBBTJ_BTIC1_Malloc_s {
BGBBTJ_BTIC1_Malloc *prev, *next;
char *fn;
int ln;
int sz;
};

BGBBTJ_BTIC1_Malloc *btic_malloc_list=NULL;

char *btic_strdup(char *str)
{
	return(dyllStrdup(str));
}

void *btic_malloc_lln(int sz, char *fn, int ln)
{
	BGBBTJ_BTIC1_Malloc *tmp;
	
	tmp=malloc(sz+sizeof(BGBBTJ_BTIC1_Malloc));
	tmp->fn=fn;
	tmp->ln=ln;
	tmp->sz=sz;
	
	if(btic_malloc_list)
	{
		tmp->prev=NULL;
		btic_malloc_list->prev=tmp;
		tmp->next=btic_malloc_list;
		btic_malloc_list=tmp;
	}else
	{
		tmp->prev=NULL;
		tmp->next=btic_malloc_list;
		btic_malloc_list=tmp;
	}
	
	return(tmp+1);
}

void btic_free(void *ptr)
{
	BGBBTJ_BTIC1_Malloc *tmp;
	
	tmp=((BGBBTJ_BTIC1_Malloc *)ptr)-1;
	
	if(tmp->prev)
	{
		tmp->prev->next=tmp->next;
		if(tmp->next)
			{ tmp->next->prev=tmp->prev; }
	}else
	{
		if(tmp->next)
			{ tmp->next->prev=NULL; }
		btic_malloc_list=tmp->next;
	}
	
	free(tmp);
}

BGBBTJ_API int BTIC1_EscapeEncodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if(*cs==0xFF)
		{
			if((cs[1]>=0) && (cs[1]<=30))
				{ *ct++=*cs++; *ct++=(*cs++)+1; continue; }

			if((cs[1]>=0xE0) && (cs[1]<=0xFF))
				{ *ct++=*cs++; *ct++=(*cs++)^0xC0; continue; }
			if((cs[1]>=0x20) && (cs[1]<=0x5F))
				{ *ct++=*cs++; *ct++=(*cs++)+0x20; continue; }

#if 0
			if(cs[1]==15)
			{
				*ct++=*cs++; cs++;
				*ct++=0x10; *ct++=0x00;
				continue;
			}

			if(cs[1]==16)
			{
				if((cs[2]>=0) && (cs[2]<=14))
					{ *ct++=*cs++; *ct++=*cs++; *ct++=(*cs++)+1; continue; }
				if(cs[1]==16)
				{
					*ct++=*cs++; *ct++=*cs++; cs++;
					*ct++=0x10; *ct++=0x00;
					continue;
				}
			}
#endif

			cs++;
			*ct++=0xFF;
			*ct++=0x00;
			continue;
		}
		
		*ct++=*cs++;
	}
	
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

BGBBTJ_API int BTIC1_EscapeEncodeSingleBuffer(byte *buf, int sz)
{
	byte *tbuf;
	int i;
	
	tbuf=btic_malloc(sz*2);
	i=BTIC1_EscapeEncodeBuffer(buf, sz, tbuf, sz*2);
	if(i<0)return(i);
	memcpy(buf, tbuf, i);
	btic_free(tbuf);
	return(i);
}

BGBBTJ_API int BTIC1_EscapeEncodeBufferSimple(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
	while((cs<cse) && (ct<cte))
	{
		if(*cs==0xFF)
		{
			cs++;
			*ct++=0xFF;
			*ct++=0x00;
			continue;
		}
		
		*ct++=*cs++;
	}
	
	if(ct>=cte)return(-1);
	return(ct-obuf);
}

byte *BTIC1_EmitInt16LE(byte *ct, uint v)
{
	*ct++=v&0xFF;
	*ct++=(v>>8)&0xFF;
	return(ct);
}

byte *BTIC1_EmitInt16BE(byte *ct, uint v)
{
	*ct++=(v>>8)&0xFF;
	*ct++=v&0xFF;
	return(ct);
}

byte *BTIC1_EmitInt32LE(byte *ct, uint v)
{
	*ct++=v&0xFF;
	*ct++=(v>>8)&0xFF;
	*ct++=(v>>16)&0xFF;
	*ct++=(v>>24)&0xFF;
	return(ct);
}

byte *BTIC1_EmitInt32BE(byte *ct, uint v)
{
	*ct++=(v>>24)&0xFF;
	*ct++=(v>>16)&0xFF;
	*ct++=(v>>8)&0xFF;
	*ct++=v&0xFF;
	return(ct);
}

byte *BTIC1_EmitFourcc(byte *ct, uint v)
{
	*ct++=v&0xFF;
	*ct++=(v>>8)&0xFF;
	*ct++=(v>>16)&0xFF;
	*ct++=(v>>24)&0xFF;
	return(ct);
}

byte *BTIC1_EmitString(byte *ct, char *str)
{
	int l;
	l=strlen(str);
	memcpy(ct, str, l+1);
	return(ct+l+1);
}

byte *BTIC1_EmitMarkerLen(byte *ct, byte tag, int len)
{
	*ct++=0xFF;
	*ct++=tag;

	if((len+2)<65536)
	{
		ct=BTIC1_EmitInt16BE(ct, len+2);
	}else
	{
		ct=BTIC1_EmitInt16BE(ct, 0);
		ct=BTIC1_EmitInt32BE(ct, len+6);
	}
	return(ct);
}

byte *BTIC1_EmitLumpFMT12(byte *ct, uint fcc, byte *buf, int len)
{
	byte *tbuf;
	byte tb[4];
	int len1;

	if(!buf)
	{
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_FMT12, len+4);
		ct=BTIC1_EmitFourcc(ct, fcc);
		memset(ct, 0, len);
		ct+=len;
	}else
	{
		tbuf=btic_malloc(2*len);
		len1=BTIC1_EscapeEncodeBuffer(buf, len, tbuf, 2*len);
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_FMT12, len1+4);
		ct=BTIC1_EmitFourcc(ct, fcc);
		memcpy(ct, tbuf, len1);
		ct+=len1;
		btic_free(tbuf);
	}

	return(ct);
}

byte *BTIC1_EmitLumpAPP12(byte *ct, uint fcc, byte *buf, int len)
{
	byte *tbuf;
	byte tb[4];
	int len1;

	if(!buf)
	{
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_APP12, len+4);
		ct=BTIC1_EmitFourcc(ct, fcc);
		memset(ct, 0, len);
		ct+=len;
	}else
	{
		tbuf=btic_malloc(2*len);
		len1=BTIC1_EscapeEncodeBuffer(buf, len, tbuf, 2*len);
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_APP12, len1+4);
		ct=BTIC1_EmitFourcc(ct, fcc);
		memcpy(ct, tbuf, len1);
		ct+=len1;
		btic_free(tbuf);
	}

	return(ct);
}

byte *BTIC1_EmitLumpFMT13(byte *ct, char *tag, byte *buf, int len)
{
	byte *tbuf;
	byte tb[4];
	int len1, lent;

	if(!buf)
	{
		lent=strlen(tag)+1;
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_FMT13, len+lent);
		ct=BTIC1_EmitString(ct, tag);
		memset(ct, 0, len);
		ct+=len;
	}else
	{
		tbuf=btic_malloc(2*len);
		len1=BTIC1_EscapeEncodeBuffer(buf, len, tbuf, 2*len);
		lent=strlen(tag)+1;
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_FMT13, len1+lent);
		ct=BTIC1_EmitString(ct, tag);
		memcpy(ct, tbuf, len1);
		ct+=len1;
		btic_free(tbuf);
	}
	
	return(ct);
}

byte *BTIC1_EmitLumpAPP13(byte *ct, char *tag, byte *buf, int len)
{
	byte *tbuf;
	byte tb[4];
	int len1, lent;

	if(!buf)
	{
		lent=strlen(tag)+1;
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_APP13, len+lent);
		ct=BTIC1_EmitString(ct, tag);
		memset(ct, 0, len);
		ct+=len;
	}else
	{
		tbuf=btic_malloc(2*len);
		len1=BTIC1_EscapeEncodeBuffer(buf, len, tbuf, 2*len);
		lent=strlen(tag)+1;
		ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_APP13, len1+lent);
		ct=BTIC1_EmitString(ct, tag);
		memcpy(ct, tbuf, len1);
		ct+=len1;
		btic_free(tbuf);
	}
	
	return(ct);
}

#if 1
byte *BTIC1_EmitLumpFMT12Z(byte *ct, uint fcc, byte *buf, int len)
{
	return(BTIC1_EmitLumpMarkFccZ(ct,
		BGBBTJ_BTIC1_MARK_FMT12, fcc, buf, len));
}

byte *BTIC1_EmitLumpAPP12Z(byte *ct, uint fcc, byte *buf, int len)
{
	return(BTIC1_EmitLumpMarkFccZ(ct,
		BGBBTJ_BTIC1_MARK_APP12, fcc, buf, len));
}

byte *BTIC1_EmitLumpMarkFccZ(byte *ct,
	int mark, uint fcc, byte *buf, int len)
{
	byte *tbuf, *tbuf1;
	byte tb[4];
	int len1, len2;

	if(!buf || !len)
	{
		ct=BTIC1_EmitMarkerLen(ct, mark, len+4);
		ct=BTIC1_EmitFourcc(ct, fcc);
		memset(ct, 0, len);
		ct+=len;
	}else
	{
		tbuf=btic_malloc(2*len);
		tbuf1=btic_malloc(2*len);
		len2=PDZ2_EncodeStream64LvlZl(buf, tbuf1, len, 2*len, 9);
		len1=BTIC1_EscapeEncodeBufferSimple(tbuf1, len2, tbuf, 2*len);
		ct=BTIC1_EmitMarkerLen(ct, mark, len1+4);
		ct=BTIC1_EmitFourcc(ct, fcc);
		memcpy(ct, tbuf, len1);
		ct+=len1;
		btic_free(tbuf); btic_free(tbuf1);
	}

	return(ct);
}

byte *BTIC1_EmitLumpFMT13Z(byte *ct, char *tag, byte *buf, int len)
{
	return(BTIC1_EmitLumpMarkStrZ(ct,
		BGBBTJ_BTIC1_MARK_FMT13, tag, buf, len));
}

byte *BTIC1_EmitLumpAPP13Z(byte *ct, char *tag, byte *buf, int len)
{
	return(BTIC1_EmitLumpMarkStrZ(ct,
		BGBBTJ_BTIC1_MARK_APP13, tag, buf, len));
}

byte *BTIC1_EmitLumpMarkStrZ(byte *ct,
	int mark, char *tag, byte *buf, int len)
{
	byte *tbuf, *tbuf1;
	byte tb[4];
	int len1, len2, lent;

	if(!buf || !len)
	{
		lent=strlen(tag)+1;
		ct=BTIC1_EmitMarkerLen(ct, mark, len+lent);
		ct=BTIC1_EmitString(ct, tag);
		memset(ct, 0, len);
		ct+=len;
	}else
	{
		tbuf=btic_malloc(2*len);
		tbuf1=btic_malloc(2*len);
		len2=PDZ2_EncodeStream64LvlZl(buf, tbuf1, len, 2*len, 9);
		len1=BTIC1_EscapeEncodeBufferSimple(tbuf1, len2, tbuf, 2*len);
		lent=strlen(tag)+1;
		ct=BTIC1_EmitMarkerLen(ct, mark, len1+lent);
		ct=BTIC1_EmitString(ct, tag);
		memcpy(ct, tbuf, len1);
		ct+=len1;
		btic_free(tbuf); btic_free(tbuf1);
	}
	
	return(ct);
}
#endif

byte *BTIC1_EmitLumpFMT11(byte *ct, char *tag, char **args)
{
	byte *buf, *ct1;
	byte tb[4];
	int len;
	int i;

	buf=btic_malloc(65536);
	ct1=buf;
	ct1=BTIC1_EmitString(ct1, tag);
	if(args)
	{
		for(i=0; args[i]; i++)
			{ ct1=BTIC1_EmitString(ct1, args[i]); }
	}
	*ct1++=0x00;
	len=ct1-buf;

	ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_FMT11, len);
	memcpy(ct, buf, len);
	ct+=len;
	
	btic_free(buf);
	
	return(ct);
}

byte *BTIC1_EmitLumpAPP11(byte *ct, char *tag, char **args)
{
	byte *buf, *ct1;
	byte tb[4];
	int len;
	int i;

	buf=btic_malloc(65536);
	ct1=buf;
	ct1=BTIC1_EmitString(ct1, tag);
	if(args)
	{
		for(i=0; args[i]; i++)
			{ ct1=BTIC1_EmitString(ct1, args[i]); }
	}
	*ct1++=0x00;
	len=ct1-buf;

	ct=BTIC1_EmitMarkerLen(ct, BGBBTJ_BTIC1_MARK_APP11, len);
	memcpy(ct, buf, len);
	ct+=len;
	
	btic_free(buf);
	
	return(ct);
}

btj_word_ube BTIC1_WrapWordUBE(u16 val)
{
	btj_word_ube tmp;
	tmp.v[0]=(val>>8)&0xFF;
	tmp.v[1]=val&0xFF;
	return(tmp);
}

btj_word_sbe BTIC1_WrapWordSBE(s16 val)
{
	btj_word_sbe tmp;
	tmp.v[0]=(val>>8)&0xFF;
	tmp.v[1]=val&0xFF;
	return(tmp);
}

btj_dword_ube BTIC1_WrapDWordUBE(u32 val)
{
	btj_dword_ube tmp;
	tmp.v[0]=(val>>24)&0xFF;
	tmp.v[1]=(val>>16)&0xFF;
	tmp.v[2]=(val>>8)&0xFF;
	tmp.v[3]=val&0xFF;
	return(tmp);
}

btj_dword_sbe BTIC1_WrapDWordSBE(s32 val)
{
	btj_dword_sbe tmp;
	tmp.v[0]=(val>>24)&0xFF;
	tmp.v[1]=(val>>16)&0xFF;
	tmp.v[2]=(val>>8)&0xFF;
	tmp.v[3]=val&0xFF;
	return(tmp);
}

byte *BTIC1_EmitLayerHeader(
	BGBBTJ_BTIC1_Context *ctx, byte *ct, BGBBTJ_BTIC1_LayerHeader *lhdr)
{
	struct BGBBTJ_BTIC1_TagLayerHeader_Ds lh;
	
	memset(&lh, 0, sizeof(struct BGBBTJ_BTIC1_TagLayerHeader_Ds));
	if(lhdr->name)
		strcpy(lh.name, lhdr->name);
	lh.layerid=BTIC1_WrapDWordSBE(lhdr->layerid);
	lh.xorg=BTIC1_WrapDWordSBE(lhdr->xorg);
	lh.yorg=BTIC1_WrapDWordSBE(lhdr->yorg);
	lh.xsize=BTIC1_WrapDWordSBE(lhdr->xsize);
	lh.ysize=BTIC1_WrapDWordSBE(lhdr->ysize);
	lh.xcenter=BTIC1_WrapDWordSBE(lhdr->xcenter);
	lh.ycenter=BTIC1_WrapDWordSBE(lhdr->ycenter);
	lh.flags=BTIC1_WrapDWordUBE(lhdr->flags);
	
	ct=BTIC1_EmitLumpFMT13(ct, "TagLayer", (byte *)(&lh),
		sizeof(struct BGBBTJ_BTIC1_TagLayerHeader_Ds));

//	ct=BTIC1_EmitLumpFMT12(ct, FCC_LHDR, (byte *)(&lh),
//		sizeof(struct BGBBTJ_BTIC1_TagLayerHeader_Ds));
	return(ct);
}

byte *BTIC1_EmitComponentLayerID(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	struct BGBBTJ_BTIC1_CompLayerID_Ds lh;
	
	memset(&lh, 0, sizeof(struct BGBBTJ_BTIC1_CompLayerID_Ds));
	lh.layerid=BTIC1_WrapDWordSBE(thdr->layerid);
	lh.flags=BTIC1_WrapDWordUBE(thdr->flags);
	
	ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_CLID, (byte *)(&lh),
		sizeof(struct BGBBTJ_BTIC1_CompLayerID_Ds));
	return(ct);
}

byte *BTIC1_EmitComponentLayerHeader(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	struct BGBBTJ_BTIC1_CompLayerHeader_Ds lh;
	
	memset(&lh, 0, sizeof(struct BGBBTJ_BTIC1_CompLayerHeader_Ds));
	strcpy(lh.name, thdr->name);
	lh.layerid=BTIC1_WrapDWordSBE(thdr->layerid);
	lh.flags=BTIC1_WrapDWordUBE(thdr->flags);
	
	ct=BTIC1_EmitLumpFMT13(ct, "CompLayer", (byte *)(&lh),
		sizeof(struct BGBBTJ_BTIC1_CompLayerHeader_Ds));
	return(ct);
}

byte *BTIC1_EmitImageHeader(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	struct BGBBTJ_BTIC1_ImageHeader_Ds lh;
	
	memset(&lh, 0, sizeof(struct BGBBTJ_BTIC1_ImageHeader_Ds));
	lh.width=BTIC1_WrapDWordSBE(thdr->width);
	lh.height=BTIC1_WrapDWordSBE(thdr->height);
	lh.imgtype=BTIC1_WrapWordUBE(thdr->imgtype);
	lh.mip_start=thdr->mip_start;
	lh.mip_end=thdr->mip_end;
	lh.filtmode=thdr->filtmode;
	lh.clrtype=thdr->clrtype;
	lh.pixtype=thdr->pixtype;
	
	ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_THDR, (byte *)(&lh),
		sizeof(struct BGBBTJ_BTIC1_ImageHeader_Ds));
	return(ct);
}

byte *BTIC1_EmitImageData(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	if(!thdr->fpdata)
		return(ct);

	if(thdr->sz_fpdata>=256)
	{
		ct=BTIC1_EmitLumpFMT12Z(ct, BTIC1_FCC_TDAZ,
			thdr->fpdata, thdr->sz_fpdata);
	}else
	{
		ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_TDAT,
			thdr->fpdata, thdr->sz_fpdata);
	}

	return(ct);
}

byte *BTIC1_EmitImageLiteralData(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	if(!thdr->fpldata)
		return(ct);
	if(thdr->sz_fpldata<=0)
		return(ct);

	if(thdr->sz_fpldata>=256)
	{
//		ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_TLDA,
//			thdr->fpldata, thdr->sz_fpldata);
		ct=BTIC1_EmitLumpFMT12Z(ct, BTIC1_FCC_TLDZ,
			thdr->fpldata, thdr->sz_fpldata);
	}else
	{
		ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_TLDA,
			thdr->fpldata, thdr->sz_fpldata);
	}

	return(ct);
}

byte *BTIC1_EmitImage(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	ct=BTIC1_EmitImageHeader(ctx, ct, thdr);
	ct=BTIC1_EmitImageLiteralData(ctx, ct, thdr);
	ct=BTIC1_EmitImageData(ctx, ct, thdr);
	ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_TEND, NULL, 0);
	return(ct);
}

void BTIC1_FilterPackImage(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	byte *tbuf, *tlbuf;
	int sz, szl, n;

	switch(thdr->imgtype)
	{
	case BGBBTJ_JPG_BC1:
	case BGBBTJ_JPG_BC1F:
	case BGBBTJ_JPG_BC1A:
		switch(thdr->filtmode)
		{
		case BGBBTJ_BTIC1_FILT_NONE:
			BTIC1_CheckBufferImageFPData(ctx, thdr, thdr->sz_data);
//			thdr->fpdata=btic_malloc(thdr->sz_data);
			memcpy(thdr->fpdata, thdr->data, thdr->sz_data);
//			thdr->sz_fpdata=thdr->sz_data;
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK:
			n=thdr->sz_data/8;
			if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }

			tbuf=btic_malloc(2*thdr->sz_data);
			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				sz=BGBBTJ_PackBCn_EncodePatchBlocksDXT1(
					tbuf, thdr->data, n);
			}else
			{
				sz=BGBBTJ_PackBCn_EncodeBlocksDXT1(
					tbuf, thdr->data, n);
			}
			BTIC1_CheckBufferImageFPData(ctx, thdr, sz);
//			thdr->fpdata=btic_malloc(sz);
			memcpy(thdr->fpdata, tbuf, sz);
//			thdr->sz_fpdata=sz;
			btic_free(tbuf);
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK2:
			tbuf=btic_malloc(2*thdr->sz_data);
			tlbuf=btic_malloc(2*thdr->sz_data);

			n=thdr->sz_data/8;
			if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }

			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				sz=BGBBTJ_PackBCn_EncodePatchBlocks2DXT1(
					tbuf, tlbuf, thdr->data,
					n, ((thdr->width+3)/4), &szl);
			}else
			{
				sz=BGBBTJ_PackBCn_EncodeBlocks2DXT1(
					tbuf, tlbuf, thdr->data,
					n, ((thdr->width+3)/4), &szl);
			}
			BTIC1_CheckBufferImageFPData(ctx, thdr, sz);
			BTIC1_CheckBufferImageFPLData(ctx, thdr, szl);
			memcpy(thdr->fpdata, tbuf, sz);
			memcpy(thdr->fpldata, tlbuf, szl);
			btic_free(tbuf);
			btic_free(tlbuf);
			break;
		default:
			break;
		}
		break;
	case BGBBTJ_JPG_BC3:
	case BGBBTJ_JPG_BC3F:
	case BGBBTJ_JPG_BC3_UVAY:
		switch(thdr->filtmode)
		{
		case BGBBTJ_BTIC1_FILT_NONE:
			BTIC1_CheckBufferImageFPData(ctx, thdr, thdr->sz_data);
//			thdr->fpdata=btic_malloc(thdr->sz_data);
			memcpy(thdr->fpdata, thdr->data, thdr->sz_data);
//			thdr->sz_fpdata=thdr->sz_data;
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK:
			tbuf=btic_malloc(2*thdr->sz_data);

			n=thdr->sz_data/16;
			if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }

			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				sz=BGBBTJ_PackBCn_EncodePatchBlocksDXT5(
					tbuf, thdr->data, n);
			}else
			{
				sz=BGBBTJ_PackBCn_EncodeBlocksDXT5(
					tbuf, thdr->data, n);
			}
			BTIC1_CheckBufferImageFPData(ctx, thdr, sz);
//			thdr->fpdata=btic_malloc(sz);
			memcpy(thdr->fpdata, tbuf, sz);
//			thdr->sz_fpdata=sz;
			btic_free(tbuf);
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK2:
			tbuf=btic_malloc(2*thdr->sz_data);
			tlbuf=btic_malloc(2*thdr->sz_data);

			n=thdr->sz_data/16;
			if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }

			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				sz=BGBBTJ_PackBCn_EncodePatchBlocks2DXT5(
					tbuf, tlbuf, thdr->data,
					n, ((thdr->width+3)/4), &szl);
			}else
			{
				sz=BGBBTJ_PackBCn_EncodeBlocks2DXT5(
					tbuf, tlbuf, thdr->data,
					n, ((thdr->width+3)/4), &szl);
			}
			BTIC1_CheckBufferImageFPData(ctx, thdr, sz);
			BTIC1_CheckBufferImageFPLData(ctx, thdr, szl);
			memcpy(thdr->fpdata, tbuf, sz);
			memcpy(thdr->fpldata, tlbuf, szl);
			btic_free(tbuf);
			btic_free(tlbuf);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
}

void BTIC1_CheckBufferImageFPData(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr,
	int sz)
{
	byte *tbuf;

	if(!thdr->fpdata || (sz!=thdr->sz_fpdata))
	{
		if(thdr->fpdata)
			btic_free(thdr->fpdata);
		tbuf=btic_malloc(sz);
		thdr->fpdata=tbuf;
		thdr->sz_fpdata=sz;
	}
}

void BTIC1_CheckBufferImageFPLData(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr,
	int sz)
{
	byte *tbuf;

	if(!thdr->fpldata || (sz!=thdr->sz_fpldata))
	{
		if(thdr->fpldata)
			btic_free(thdr->fpldata);
		tbuf=btic_malloc(sz);
		thdr->fpldata=tbuf;
		thdr->sz_fpldata=sz;
	}
}

void BTIC1_CheckBufferImageData(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr,
	int sz)
{
	byte *tbuf;

	if(!thdr->data || (sz!=thdr->sz_data))
	{
		if(thdr->data)
			btic_free(thdr->data);
		tbuf=btic_malloc(sz);
		thdr->data=tbuf;
		thdr->sz_data=sz;
	}

	if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
		(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
	{
		thdr->ofs_pframe=sz/2;
	}
}

void BTIC1_CheckBufferImageRGBA(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr,
	int sz)
{
	byte *tbuf;

	if(!thdr->rgba || (sz!=thdr->sz_rgba))
	{
		if(thdr->rgba)
			btic_free(thdr->rgba);
		tbuf=btic_malloc(sz);
		thdr->rgba=tbuf;
		thdr->sz_rgba=sz;
	}
}

void BTIC1_ColorConvertImage(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	byte *tbuf;
	int sz;

	if(!thdr->rgba)
		return;

	switch(thdr->imgtype)
	{
	case BGBBTJ_JPG_BC1:
	case BGBBTJ_JPG_BC1F:
	case BGBBTJ_JPG_BC1A:
		sz=((thdr->width+3)/4)*((thdr->height+3)/4)*8;
		if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
			(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
				{ thdr->ofs_pframe=sz; sz=2*sz; }
		BTIC1_CheckBufferImageData(ctx, thdr, sz);
		if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
		{
			BGBBTJ_BCn_EncodeImageDXTn(
				thdr->data+thdr->ofs_pframe, thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}else
		{
			BGBBTJ_BCn_EncodeImageDXTn(thdr->data, thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}
		break;
	case BGBBTJ_JPG_BC3:
	case BGBBTJ_JPG_BC3F:
	case BGBBTJ_JPG_BC3_UVAY:
		sz=((thdr->width+3)/4)*((thdr->height+3)/4)*16;
		if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
			(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
				{ thdr->ofs_pframe=sz; sz=2*sz; }
		BTIC1_CheckBufferImageData(ctx, thdr, sz);
		if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
		{
			BGBBTJ_BCn_EncodeImageDXTn(
				thdr->data+thdr->ofs_pframe, thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}else
		{
			BGBBTJ_BCn_EncodeImageDXTn(thdr->data, thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}
		break;
	default:
		break;
	}
}

byte *BTIC1_EncodeImageBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	BTIC1_ColorConvertImage(ctx, thdr);
	BTIC1_FilterPackImage(ctx, thdr);
	ct=BTIC1_EmitImage(ctx, ct, thdr);
	return(ct);
}

byte *BTIC1_EncodeCompLayerBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	int i;

	if(!thdr->layerid)
	{
		i=ctx->n_image++;
		thdr->layerid=i+1;
		ctx->image[i]=thdr;
	}

	ct=BTIC1_EmitComponentLayerHeader(ctx, ct, thdr);
	ct=BTIC1_EncodeImageBuffer(ctx, ct, thdr);
	return(ct);
}

byte *BTIC1_EncodeTagLayerBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_LayerHeader *lhdr)
{
	int i;

	ct=BTIC1_EmitLayerHeader(ctx, ct, lhdr);
//	ct=BTIC1_EncodeImageBuffer(ctx, ct, thdr);

	for(i=0; i<lhdr->n_image; i++)
	{
		ct=BTIC1_EncodeCompLayerBuffer(ctx, ct, lhdr->image[i]);
	}

	ct=BTIC1_EmitLumpFMT12(ct, BTIC1_FCC_LEND, NULL, 0);

	return(ct);
}

byte *BTIC1_EncodePatchCompLayerBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ct,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	int i;

	if(!thdr->layerid)
	{
		i=ctx->n_image++;
		thdr->layerid=i+1;
		ctx->image[i]=thdr;
	}

	ct=BTIC1_EmitComponentLayerID(ctx, ct, thdr);
	ct=BTIC1_EncodeImageBuffer(ctx, ct, thdr);
	return(ct);
}

int BTIC1_EncodeContext(
	BGBBTJ_BTIC1_Context *ctx, byte *obuf, int maxsz)
{
	byte *tbuf, *tbuf1, *ct;
	int i, j, k, l;
	
	tbuf=btic_malloc(1<<24);
	ct=tbuf;
	
	if(ctx->qflags&BGBBTJ_QFL_PFRAME)
	{
		for(i=0; i<ctx->n_image; i++)
		{
			ct=BTIC1_EncodePatchCompLayerBuffer(ctx, ct, ctx->image[i]);
		}
	}else
	{
		for(i=0; i<ctx->n_layer; i++)
		{
			ctx->layer[i]->layerid=i+1;
			ct=BTIC1_EncodeTagLayerBuffer(ctx, ct, ctx->layer[i]);
		}
	}

	if(0)
	{
		i=ct-tbuf;

		tbuf1=btic_malloc(1<<24);
		j=BGBBTJ_BitArith_EncodeData(tbuf, i, tbuf1, 1<<24);

		ct=BTIC1_EmitLumpFMT13(obuf, "BTIC1A", tbuf1, j);
		btic_free(tbuf); btic_free(tbuf1);
		return(ct-obuf);
	}

	if(0)
	{
		i=ct-tbuf;

		tbuf1=btic_malloc(1<<24);
//		j=BGBBTJ_BitArith_EncodeData(tbuf, i, tbuf1, 1<<24);
//		j=PDZ2_EncodeStreamLvl(tbuf, tbuf1+2, i, 1<<24, 0);
//		j=PDZ2_EncodeStreamLvl(tbuf, tbuf1+2, i, 1<<24, 9);
//		j=PDZ2_EncodeStream64Lvl(tbuf, tbuf1+2, i, 1<<24, 9);
		j=PDZ2_EncodeStream64LvlZl(tbuf, tbuf1, i, 1<<24, 9);

#if 0
		k=(7<<12)|(8<<8)|(3<<6); l=k%31;
		if(l)k|=31-l;
		tbuf1[0]=k>>8; tbuf1[1]=k&0xFF;

		k=BGBBTJ_BufPNG_DataAdler32(tbuf, i, 1);
		tbuf1[2+j+0]=(k>>24)&0xFF;
		tbuf1[2+j+1]=(k>>16)&0xFF;
		tbuf1[2+j+2]=(k>>8)&0xFF;
		tbuf1[2+j+3]=k&0xFF;

		j+=6;
#endif

		ct=BTIC1_EmitLumpFMT13(obuf, "BTIC1Z", tbuf1, j);
		btic_free(tbuf); btic_free(tbuf1);
		return(ct-obuf);
	}

	if(0)
	{
		i=ct-tbuf;

		tbuf1=btic_malloc(1<<24);
//		j=BGBBTJ_BitArith_EncodeData(tbuf, i, tbuf1, 1<<24);
//		j=PDZ2_EncodeStreamLvl(tbuf, tbuf1+2, i, 1<<24, 0);
//		j=PDZ2_EncodeStreamLvl(tbuf, tbuf1, i, 1<<24, 9);
		j=PDZ2_EncodeStream64Lvl(tbuf, tbuf1, i, 1<<24, 9);
		memcpy(tbuf, tbuf1, j); i=j;
		j=BGBBTJ_BitArith_EncodeData(tbuf, i, tbuf1, 1<<24);

		ct=BTIC1_EmitLumpFMT13(obuf, "BTIC1AZ", tbuf1, j);
		btic_free(tbuf); btic_free(tbuf1);
		return(ct-obuf);
	}

	i=ct-tbuf;
	ct=BTIC1_EmitLumpFMT13(obuf, "BTIC1", tbuf, i);
	btic_free(tbuf);

	return(ct-obuf);
}

BGBBTJ_BTIC1_LayerHeader *BTIC1_AllocLayer(
	BGBBTJ_BTIC1_Context *ctx, char *name)
{
	BGBBTJ_BTIC1_LayerHeader *tmp;

	tmp=btic_malloc(sizeof(BGBBTJ_BTIC1_LayerHeader));
	memset(tmp, 0, sizeof(BGBBTJ_BTIC1_LayerHeader));
	if(name)tmp->name=dyllStrdup(name);
	tmp->ctx=ctx;
	
	return(tmp);
}

BGBBTJ_BTIC1_ImageHeader *BTIC1_AllocImage(
	BGBBTJ_BTIC1_Context *ctx, char *name)
{
	BGBBTJ_BTIC1_ImageHeader *tmp;

	tmp=btic_malloc(sizeof(BGBBTJ_BTIC1_ImageHeader));
	memset(tmp, 0, sizeof(BGBBTJ_BTIC1_ImageHeader));
	if(name)tmp->name=dyllStrdup(name);
	tmp->ctx=ctx;
	
	return(tmp);
}

BGBBTJ_BTIC1_LayerHeader *BTIC1_LookupContextLayer(
	BGBBTJ_BTIC1_Context *ctx, char *name)
{
	int i;

	if(!name)
		{ return(ctx->layer[0]); }
	for(i=1; i<ctx->n_layer; i++)
	{
		if(!strcmp(ctx->layer[i]->name, name))
			return(ctx->layer[i]);
	}
	return(NULL);
}

BGBBTJ_BTIC1_LayerHeader *BTIC1_GetContextLayer(
	BGBBTJ_BTIC1_Context *ctx, char *name)
{
	BGBBTJ_BTIC1_LayerHeader *tmp;
	int i;

	if(!name)
	{
		if(ctx->layer[0])
			return(ctx->layer[0]);
		tmp=BTIC1_AllocLayer(ctx, NULL);
		ctx->layer[0]=tmp;
		if(ctx->n_layer<1)
			ctx->n_layer=1;
		return(tmp);
	}

	tmp=BTIC1_LookupContextLayer(ctx, name);
	if(tmp)return(tmp);

	if(ctx->n_layer<1)
	{
		if(!ctx->layer[0])
		{
			tmp=BTIC1_AllocLayer(ctx, NULL);
			ctx->layer[0]=tmp;
		}
		ctx->n_layer=1;
	}

	i=ctx->n_layer++;

	tmp=BTIC1_AllocLayer(ctx, name);
	ctx->layer[i]=tmp;
	return(tmp);
}

BGBBTJ_BTIC1_ImageHeader *BTIC1_LookupLayerImage(
	BGBBTJ_BTIC1_Context *ctx, BGBBTJ_BTIC1_LayerHeader *layer,
	char *name)
{
	int i;
	
	for(i=0; i<layer->n_image; i++)
	{
		if(!strcmp(layer->image[i]->name, name))
			return(layer->image[i]);
	}
	
	return(NULL);
}

BGBBTJ_BTIC1_ImageHeader *BTIC1_GetLayerImage(
	BGBBTJ_BTIC1_Context *ctx, BGBBTJ_BTIC1_LayerHeader *layer,
	char *name)
{
	BGBBTJ_BTIC1_ImageHeader *tmp;
	int i;

	tmp=BTIC1_LookupLayerImage(ctx, layer, name);
	if(tmp)return(tmp);
	
	i=layer->n_image++;
	tmp=BTIC1_AllocImage(ctx, name);
	tmp->layer=layer;
	layer->image[i]=tmp;
	return(tmp);
}

void BTIC1_SetupImageBuffer(
	BGBBTJ_BTIC1_Context *ctx, BGBBTJ_BTIC1_ImageHeader *img,
	byte *rgba, int xs, int ys, int qf, int ity, int pf)
{
	byte *rsbuf, *ct;
	int sz, xs1, ys1;
	int i, nl, fl;

	rsbuf=btic_malloc(xs*ys*4);
//	memcpy(rsbuf, rgba, xs*ys*4);
	if(qf&BGBBTJ_QFL_PFRAME)
	{
		BGBBTJ_FiltLBR_FilterImage(NULL, img->rgba, xs, ys, qf);
		BGBBTJ_FiltLBR_FilterPatchImage(rsbuf, rgba, xs, ys, qf);
	}else
	{
		BGBBTJ_FiltLBR_FilterImage(rsbuf, rgba, xs, ys, qf);
	}

	fl=0;
	if(qf&BGBBTJ_QFL_IFRAME)fl|=BGBBTJ_BTIC1_LFL_IFRAME;
	if(qf&BGBBTJ_QFL_PFRAME)fl|=BGBBTJ_BTIC1_LFL_PFRAME;

	xs1=xs; ys1=ys; sz=0;
	for(nl=0; (xs1>1) || (ys1>1); nl++)
	{
		sz+=xs1*ys1*4;
		xs1=(xs1+1)>>1;
		ys1=(ys1+1)>>1;
	}
	
	nl=0;
	
	img->width=xs;
	img->height=ys;
	img->flags=fl;
	img->imgtype=ity;
//	img->filtmode=BGBBTJ_BTIC1_FILT_BLOCKPACK;
	img->filtmode=BGBBTJ_BTIC1_FILT_BLOCKPACK2;
	img->mip_start=0;
	img->mip_end=nl;
	
//	sz=xs*ys*4;
	BTIC1_CheckBufferImageRGBA(ctx, img, sz);
//	memcpy(img->rgba, rgba, sz);

	xs1=xs; ys1=ys; ct=img->rgba;
	for(i=0; (xs1>1) || (ys1>1); i++)
	{
		memcpy(ct, rsbuf, xs1*ys1*4);
		ct+=xs1*ys1*4;
		BGBBTJ_Tex_HalfSample(rsbuf, xs1, ys1);
		xs1=(xs1+1)>>1;
		ys1=(ys1+1)>>1;
	}
	
	btic_free(rsbuf);
}

BGBBTJ_API int BTIC1_SetupComponentCtx(
	BGBBTJ_BTIC1_Context *ctx, char *lname,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int xs, int ys, int qf, int ity, int pf)
{
	BGBBTJ_BTIC1_LayerHeader *lhdr;
	BGBBTJ_BTIC1_ImageHeader *ihdr;
	int i;

	lhdr=BTIC1_GetContextLayer(ctx, lname);
	lhdr->xsize=xs;
	lhdr->ysize=ys;
	
	if(rgba)
	{
		ihdr=BTIC1_GetLayerImage(ctx, lhdr, "RGBA");
		BTIC1_SetupImageBuffer(ctx, ihdr, rgba, xs, ys, qf, ity, pf);
	}

	if(norm)
	{
		ihdr=BTIC1_GetLayerImage(ctx, lhdr, "XYZD");
		BTIC1_SetupImageBuffer(ctx, ihdr, norm, xs, ys, qf, ity, pf);
	}

	if(spec)
	{
		ihdr=BTIC1_GetLayerImage(ctx, lhdr, "SpRGBS");
		BTIC1_SetupImageBuffer(ctx, ihdr, spec, xs, ys, qf, ity, pf);
	}

	if(luma)
	{
		ihdr=BTIC1_GetLayerImage(ctx, lhdr, "LuRGBS");
		BTIC1_SetupImageBuffer(ctx, ihdr, luma, xs, ys, qf, ity, pf);
	}
	
	return(0);
}

BGBBTJ_API int BTIC1_EncodeComponentCtx(
	BGBBTJ_BTIC1_Context *ctx,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	int i, pf;

	i=BGBBTJ_BCn_CheckEncodeImageAlpha(rgba, xs, ys, 4);
	if(norm)i|=BGBBTJ_BCn_CheckEncodeImageAlpha(norm, xs, ys, 4);
	if(spec)i|=BGBBTJ_BCn_CheckEncodeImageAlpha(norm, xs, ys, 4);
	if(luma)i|=BGBBTJ_BCn_CheckEncodeImageAlpha(norm, xs, ys, 4);

	if(qf&BGBBTJ_QFL_PFRAME)
	{
		pf=ctx->imgtype;
		ctx->qflags=qf;
	}else
	{
		pf=BGBBTJ_JPG_BC1A;
		if(i)pf=BGBBTJ_JPG_BC3;
		ctx->imgtype=pf;
		ctx->qflags=qf;
	}

	BTIC1_SetupComponentCtx(ctx, NULL,
		rgba, norm, spec, luma,
		xs, ys, qf, pf, BGBBTJ_JPG_RGBA);

#if 0
	if(i)
	{
		BTIC1_SetupComponentCtx(ctx, NULL,
			rgba, norm, spec, luma,
			xs, ys, qf, BGBBTJ_JPG_BC3, BGBBTJ_JPG_RGBA);
	}else
	{
		BTIC1_SetupComponentCtx(ctx, NULL,
			rgba, norm, spec, luma,
			xs, ys, qf, BGBBTJ_JPG_BC1A, BGBBTJ_JPG_RGBA);
	}
#endif

	i=BTIC1_EncodeContext(ctx, obuf, xs*ys*4);
	return(i);
}

BGBBTJ_API BGBBTJ_BTIC1_Context *BTIC1_AllocContext(void)
{
	BGBBTJ_BTIC1_Context *tmp;
	tmp=btic_malloc(sizeof(BGBBTJ_BTIC1_Context));
	memset(tmp, 0, sizeof(BGBBTJ_BTIC1_Context));	
	return(tmp);
}

BGBBTJ_API void BTIC1_FreeContext(BGBBTJ_BTIC1_Context *ctx)
{
	BGBBTJ_BTIC1_Malloc *cur, *nxt;
	int i;
	
	for(i=0; i<ctx->n_image; i++)
	{
		if(!ctx->image[i])
			continue;
	
		if(ctx->image[i]->data)
			{ btic_free(ctx->image[i]->data); }
		if(ctx->image[i]->fpdata)
			{ btic_free(ctx->image[i]->fpdata); }
		if(ctx->image[i]->fpldata)
			{ btic_free(ctx->image[i]->fpldata); }
		if(ctx->image[i]->rgba)
			{ btic_free(ctx->image[i]->rgba); }
		btic_free(ctx->image[i]);
	}

	for(i=0; i<ctx->n_layer; i++)
	{
		btic_free(ctx->layer[i]);
	}

	btic_free(ctx);
	
#if 1
	cur=btic_malloc_list;
	while(cur)
	{
		nxt=cur->next;
		printf("Leak: %s %d\n", cur->fn, cur->ln);
		free(cur);
		cur=nxt;
	}
	btic_malloc_list=NULL;
#endif
}

BGBBTJ_API int BTIC1_EncodeComponent(
	byte *rgba, byte *norm, byte *spec, byte *luma,
	byte *obuf, int xs, int ys, int qf)
{
	int i;

	BGBBTJ_BTIC1_Context *ctx;
	
	ctx=BTIC1_AllocContext();
	i=BTIC1_EncodeComponentCtx(ctx,
		rgba, norm, spec, luma,
		obuf, xs, ys, qf);
	BTIC1_FreeContext(ctx);
	return(i);
}
#include <bgbbtj.h>

u16 BTIC1_UnwrapWordUBE(btj_word_ube val)
{
	int v;
	v=(val.v[0]<<8)|val.v[1];
	return((u16)v);
}

s16 BTIC1_UnwrapWordSBE(btj_word_sbe val)
{
	int v;
	v=(val.v[0]<<8)|val.v[1];
	return((s16)v);
}

u32 BTIC1_UnwrapDWordUBE(btj_dword_ube val)
{
	u32 v;
	v=(val.v[0]<<24)|(val.v[1]<<16)|(val.v[2]<<8)|val.v[3];
	return(v);
}

s32 BTIC1_UnwrapDWordSBE(btj_dword_sbe val)
{
	s32 v;
	v=(val.v[0]<<24)|(val.v[1]<<16)|(val.v[2]<<8)|val.v[3];
	return(v);
}

BGBBTJ_API int BTIC1_EscapeDecodeBuffer(byte *ibuf, int isz,
	byte *obuf, int osz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=ibuf; cse=ibuf+isz;
	ct=obuf; cte=obuf+osz;
	
//	while((cs<cse) && (ct<cte))
	while(cs<cse)
	{
		if(cs[0]==0xFF)
		{
			if(cs[1]==0x00)
				{ cs+=2; *ct++=0xFF; continue; }
			if((cs[1]>=0x01) && (cs[1]<=0x0F))
				{ *ct++=*cs++; *ct++=(*cs++)-1; continue; }
			if((cs[1]>=0x20) && (cs[1]<=0x3F))
				{ *ct++=*cs++; *ct++=(*cs++)^0xC0; continue; }
			if((cs[1]>=0x40) && (cs[1]<=0x7F))
				{ *ct++=*cs++; *ct++=(*cs++)-0x20; continue; }
			break;
		}
		*ct++=*cs++;
	}
	if((ct>=cte) && (cs<cse))
		return(-1);
	return(ct-obuf);
}

BGBBTJ_API int BTIC1_EscapeDecodeSingleBuffer(byte *buf, int sz)
{
	byte *cs, *ct, *cse, *cte;
	
	cs=buf; cse=buf+sz;
	ct=buf; cte=buf+sz;
	
//	while((cs<cse) && (ct<cte))
	while(cs<cse)
	{
		if(cs[0]==0xFF)
		{
			if(cs[1]==0x00)
				{ cs+=2; *ct++=0xFF; continue; }
			if((cs[1]>=0x01) && (cs[1]<=0x1F))
				{ *ct++=*cs++; *ct++=(*cs++)-1; continue; }
			if((cs[1]>=0x20) && (cs[1]<=0x3F))
				{ *ct++=*cs++; *ct++=(*cs++)^0xC0; continue; }
			if((cs[1]>=0x40) && (cs[1]<=0x7F))
				{ *ct++=*cs++; *ct++=(*cs++)-0x20; continue; }
			break;
		}
		*ct++=*cs++;
	}
	if((ct>=cte) && (cs<cse))
		return(-1);
	return(ct-buf);
}

int BTIC1_CalcUnpackImageSize(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	int xs, ys;
	int sz, n;
	int i;

	switch(thdr->imgtype)
	{
	case BGBBTJ_JPG_BC1:
	case BGBBTJ_JPG_BC1F:
	case BGBBTJ_JPG_BC1A:
		xs=thdr->width; ys=thdr->height; n=0;
		for(i=thdr->mip_start; i<=thdr->mip_end; i++)
		{
			n+=((xs+3)>>2)*((ys+3)>>2);
			xs>>=1; ys>>=1;
		}
		if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
			(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
		{
			i=(thdr->width+3)/4;
			n=((n+(i-1))/i)*i;
			sz=2*n*8;
		}else
		{
			sz=n*8;
		}
		break;
	case BGBBTJ_JPG_BC3:
	case BGBBTJ_JPG_BC3F:
	case BGBBTJ_JPG_BC3_UVAY:
		xs=thdr->width; ys=thdr->height; n=0;
		for(i=thdr->mip_start; i<=thdr->mip_end; i++)
		{
			n+=((xs+3)>>2)*((ys+3)>>2);
			xs>>=1; ys>>=1;
		}
		if((thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
			(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
		{
			i=(thdr->width+3)/4;
			n=((n+(i-1))/i)*i;
			sz=2*n*16;
		}else
		{
			sz=n*16;
		}
//		sz=n*16;
		break;
	default:
		sz=-1;
		break;
	}
	
	return(sz);
}

void BTIC1_FilterUnpackImage(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr)
{
	byte *tbuf;
	int sz, n;

	switch(thdr->imgtype)
	{
	case BGBBTJ_JPG_BC1:
	case BGBBTJ_JPG_BC1F:
	case BGBBTJ_JPG_BC1A:
		switch(thdr->filtmode)
		{
		case BGBBTJ_BTIC1_FILT_NONE:
			sz=BTIC1_CalcUnpackImageSize(ctx, thdr);
			BTIC1_CheckBufferImageData(ctx, thdr, sz);
			memcpy(thdr->data, thdr->fpdata, thdr->sz_data);
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK:
			sz=BTIC1_CalcUnpackImageSize(ctx, thdr);
			n=sz/8;
			if(	(thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }
			BTIC1_CheckBufferImageData(ctx, thdr, sz);
			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
				{ BGBBTJ_PackBCn_DecodeBlocksDXT1(
					thdr->fpdata, thdr->data+thdr->ofs_pframe, n); }
			else
				{ BGBBTJ_PackBCn_DecodeBlocksDXT1(
					thdr->fpdata, thdr->data, n); }
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK2:
			sz=BTIC1_CalcUnpackImageSize(ctx, thdr);
			n=sz/8;
			if(	(thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }
			BTIC1_CheckBufferImageData(ctx, thdr, sz);
			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				BGBBTJ_PackBCn_DecodeBlocks2DXT1(
					thdr->fpdata, thdr->fpldata,
					thdr->data+thdr->ofs_pframe,
					n, ((thdr->width+3)/4));
			}else
			{
				BGBBTJ_PackBCn_DecodeBlocks2DXT1(
					thdr->fpdata, thdr->fpldata, thdr->data,
					n, ((thdr->width+3)/4));
			}
			break;
		default:
			break;
		}
		break;
	case BGBBTJ_JPG_BC3:
	case BGBBTJ_JPG_BC3F:
	case BGBBTJ_JPG_BC3_UVAY:
		switch(thdr->filtmode)
		{
		case BGBBTJ_BTIC1_FILT_NONE:
			sz=BTIC1_CalcUnpackImageSize(ctx, thdr);
			BTIC1_CheckBufferImageData(ctx, thdr, sz);
			memcpy(thdr->data, thdr->fpdata, thdr->sz_data);
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK:
			sz=BTIC1_CalcUnpackImageSize(ctx, thdr);
			n=sz/16;
			if(	(thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }
			BTIC1_CheckBufferImageData(ctx, thdr, sz);
			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				BGBBTJ_PackBCn_DecodeBlocksDXT5(
					thdr->fpdata, thdr->data+thdr->ofs_pframe, n);
			}else
			{
				BGBBTJ_PackBCn_DecodeBlocksDXT5(
					thdr->fpdata, thdr->data, n);
			}
			break;
		case BGBBTJ_BTIC1_FILT_BLOCKPACK2:
			sz=BTIC1_CalcUnpackImageSize(ctx, thdr);
			n=sz/16;
			if(	(thdr->flags&BGBBTJ_BTIC1_LFL_IFRAME) ||
				(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME))
					{ n=n/2; }
			BTIC1_CheckBufferImageData(ctx, thdr, sz);
			if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				BGBBTJ_PackBCn_DecodeBlocks2DXT5(
					thdr->fpdata, thdr->fpldata,
					thdr->data+thdr->ofs_pframe,
					n, ((thdr->width+3)/4));
			}else
			{
				BGBBTJ_PackBCn_DecodeBlocks2DXT5(
					thdr->fpdata, thdr->fpldata, thdr->data,
					n, ((thdr->width+3)/4));
			}
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
}

void BTIC1_DecodeImageHeader(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	byte lhbuf[256];
	struct BGBBTJ_BTIC1_ImageHeader_Ds lh;
	BGBBTJ_BTIC1_ImageHeader *thdr;
	int i;

	memset(lhbuf, 0, 256);
	BTIC1_EscapeDecodeBuffer(cs, len, lhbuf, 256);
	memcpy(&lh, lhbuf, sizeof(struct BGBBTJ_BTIC1_ImageHeader_Ds));

	thdr=ctx->cur_img;
	thdr->width=BTIC1_UnwrapDWordSBE(lh.width);
	thdr->height=BTIC1_UnwrapDWordSBE(lh.height);
	thdr->imgtype=BTIC1_UnwrapWordUBE(lh.imgtype);
	thdr->mip_start=lh.mip_start;
	thdr->mip_end=lh.mip_end;
	thdr->filtmode=lh.filtmode;
	thdr->clrtype=lh.clrtype;
	thdr->pixtype=lh.pixtype;
}

void BTIC1_DecodeImageData(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	BGBBTJ_BTIC1_ImageHeader *thdr;
	byte *tbuf;
	int sz;
	
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(cs, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	thdr=ctx->cur_img;
	BTIC1_CheckBufferImageFPData(ctx, thdr, sz);
	memcpy(thdr->fpdata, tbuf, sz);
	btic_free(tbuf);
	
	BTIC1_FilterUnpackImage(ctx, thdr);
}

void BTIC1_DecodeImageLiteralData(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	BGBBTJ_BTIC1_ImageHeader *thdr;
	byte *tbuf;
	int sz;
	
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(cs, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	thdr=ctx->cur_img;
	BTIC1_CheckBufferImageFPLData(ctx, thdr, sz);
	memcpy(thdr->fpldata, tbuf, sz);
	btic_free(tbuf);
	
//	BTIC1_FilterUnpackImage(ctx, thdr);
}

void BTIC1_DecodeImageDataZ(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	BGBBTJ_BTIC1_ImageHeader *thdr;
	byte *tbuf, *tbuf1;
	int sz, sz1;

#if 0
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(cs, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	tbuf1=btic_malloc(1<<20);
//	sz1=PDUNZ_DecodeStream(tbuf+2, tbuf1, sz, 1<<20);
	PDUNZ_DecodeStreamSz(tbuf+2, tbuf1, sz, 1<<20, &sz1, 0);
#endif

#if 1
	tbuf1=btic_malloc(1<<20);
//	sz1=PDUNZ_DecodeStream(tbuf+2, tbuf1, sz, 1<<20);
	PDUNZ_DecodeStreamSz(cs+2, tbuf1, len, 1<<20, &sz1,
		BGBBTJ_ZFL_ESCAPE_FF);
#endif

	thdr=ctx->cur_img;
	BTIC1_CheckBufferImageFPData(ctx, thdr, sz1);
	memcpy(thdr->fpdata, tbuf1, sz1);
	
	BTIC1_FilterUnpackImage(ctx, thdr);

//	btic_free(tbuf);
	btic_free(tbuf1);
}

void BTIC1_DecodeImageLiteralDataZ(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	BGBBTJ_BTIC1_ImageHeader *thdr;
	byte *tbuf, *tbuf1;
	int sz, sz1;
	
#if 0
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(cs, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	tbuf1=btic_malloc(1<<20);
//	sz1=PDUNZ_DecodeStream(tbuf+2, tbuf1, sz, 1<<20);
	PDUNZ_DecodeStreamSz(tbuf+2, tbuf1, sz, 1<<20, &sz1, 0);
#endif

#if 1
	tbuf1=btic_malloc(1<<20);
//	sz1=PDUNZ_DecodeStream(tbuf+2, tbuf1, sz, 1<<20);
	PDUNZ_DecodeStreamSz(cs+2, tbuf1, len, 1<<20, &sz1,
		BGBBTJ_ZFL_ESCAPE_FF);
#endif

	thdr=ctx->cur_img;
	BTIC1_CheckBufferImageFPLData(ctx, thdr, sz1);
	memcpy(thdr->fpldata, tbuf1, sz1);

//	btic_free(tbuf);
	btic_free(tbuf1);
	
//	BTIC1_FilterUnpackImage(ctx, thdr);
}

byte *BTIC1_SyncMarker(byte *cs, byte *cse)
{
	while(cs<cse)
	{
		if((*cs==0xFF) && cs[1]>0x10)
			break;
		cs++;
	}
	return(cs);
}

byte *BTIC1_DecodeMarkerGeneric(byte *cs, byte *cse, int *rlen)
{
	int l;
	l=(cs[2]<<8)|cs[3];
	switch(l)
	{
	case 0:
		l=(cs[4]<<24)|(cs[5]<<16)|(cs[6]<<8)|cs[7];
		cs+=8; l-=10; break;
	case 1:
		l=(cs[8]<<24)|(cs[9]<<16)|(cs[10]<<8)|cs[11];
		cs+=12; l-=14; break;
	default:
		cs+=4; l-=6; break;
	}
	
	*rlen=l;
	return(cs);
}

byte *BTIC1_DecodeMarkerFMT12(byte *cs, byte *cse, int *rlen, u32 *rfcc)
{
	u32 fcc;
	int l;
	l=(cs[2]<<8)|cs[3];
	switch(l)
	{
	case 0:
		l=(cs[4]<<24)|(cs[5]<<16)|(cs[6]<<8)|cs[7];
		cs+=8; l-=10; break;
	case 1:
		l=(cs[8]<<24)|(cs[9]<<16)|(cs[10]<<8)|cs[11];
		cs+=12; l-=14; break;
	default:
		cs+=4; l-=6; break;
	}
	
	*rlen=l;
	*rfcc=FOURCC(cs[0], cs[1], cs[2], cs[3]);
	return(cs+4);
}

byte *BTIC1_DecodeMarkerAPP12(byte *cs, byte *cse, int *rlen, u32 *rfcc)
	{ return(BTIC1_DecodeMarkerFMT12(cs, cse, rlen, rfcc)); }

byte *BTIC1_DecodeMarkerFMT13(byte *cs, byte *cse, int *rlen, char **rtag)
{
	char *s;
	int l, tl;
	l=(cs[2]<<8)|cs[3];
	switch(l)
	{
	case 0:
		l=(cs[4]<<24)|(cs[5]<<16)|(cs[6]<<8)|cs[7];
		cs+=8; l-=6; break;
	case 1:
		l=(cs[8]<<24)|(cs[9]<<16)|(cs[10]<<8)|cs[11];
		cs+=12; l-=10; break;
	default:
		cs+=4; l-=2; break;
	}
	
	s=(char *)cs;
	tl=strlen(s)+1;
	
	*rlen=l-tl;
	*rtag=s;
	cs+=tl;
	return(cs);
}

byte *BTIC1_DecodeMarkerAPP13(byte *cs, byte *cse, int *rlen, char **rtag)
	{ return(BTIC1_DecodeMarkerFMT13(cs, cse, rlen, rtag)); }

byte *BTIC1_DecodeImage(BGBBTJ_BTIC1_Context *ctx, byte *cs, byte *cse)
{
	byte *cs1;
	int len;
	u32 fcc;
	int i;
	
	while(cs<cse)
	{
		if(*cs!=0xFF)
		{
			printf("BTIC1_DecodeImage: Resync\n");
			for(i=0; i<8; i++)
				printf("%02X ", cs[i]);
			printf("\n");
			cs=BTIC1_SyncMarker(cs, cse);
			continue;
		}
		
		if(cs[1]==BGBBTJ_BTIC1_MARK_FMT12)
		{
			cs1=BTIC1_DecodeMarkerFMT12(cs, cse, &len, &fcc);
			if(fcc==BTIC1_FCC_THDR)
			{
				BTIC1_DecodeImageHeader(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}
			if(fcc==BTIC1_FCC_TDAT)
			{
				BTIC1_DecodeImageData(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}

			if(fcc==BTIC1_FCC_TLDA)
			{
				BTIC1_DecodeImageLiteralData(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}

			if(fcc==BTIC1_FCC_TDAZ)
			{
				BTIC1_DecodeImageDataZ(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}

			if(fcc==BTIC1_FCC_TLDZ)
			{
				BTIC1_DecodeImageLiteralDataZ(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}

			if(fcc==BTIC1_FCC_TEND)
				{ cs=cs1+len; break; }

			printf("BTIC1_DecodeImage: BAD Marker FMT12 %04s\n", &fcc);
			break;
		}

		if((cs[1]>=BGBBTJ_BTIC1_MARK_FMT0) &&
			(cs[1]<=BGBBTJ_BTIC1_MARK_FMT13))
		{
			printf("BTIC1_DecodeImage: BAD Marker FMT%d %s\n",
				cs[1]-BGBBTJ_BTIC1_MARK_FMT0);
			break;
		}

		if((cs[1]>=BGBBTJ_BTIC1_MARK_APP0) &&
			(cs[1]<=BGBBTJ_BTIC1_MARK_APP15))
		{
			cs1=BTIC1_DecodeMarkerGeneric(cs, cse, &len);
			cs=cs1+len;
			continue;
		}

		printf("BTIC1_DecodeImage: BAD Marker %02X\n %04s\n", cs[1]);
		break;
	}
	return(cs);
}

void BTIC1_DecodeCompLayerHeader(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	byte lhbuf[256];
	struct BGBBTJ_BTIC1_CompLayerHeader_Ds lh;
	BGBBTJ_BTIC1_ImageHeader *thdr;
	int id;
	int i;

	memset(lhbuf, 0, 256);
	BTIC1_EscapeDecodeBuffer(cs, len, lhbuf, 256);
	memcpy(&lh, lhbuf, sizeof(struct BGBBTJ_BTIC1_CompLayerHeader_Ds));

	id=BTIC1_UnwrapDWordSBE(lh.layerid);
	thdr=ctx->image[id-1];
	
	if(!thdr)
	{
		i=sizeof(BGBBTJ_BTIC1_ImageHeader);
		thdr=btic_malloc(i);
		memset(thdr, 0, i);
		thdr->layerid=id;
//		thdr->name=strdup(lh.name);
//		thdr->name[8]=0;

		strncpy(lhbuf, lh.name, 8);
		thdr->name=btic_strdup(lhbuf);

		ctx->image[id-1]=thdr;
		if(id>=ctx->n_image)
			ctx->n_image=id;

		i=ctx->cur_layer->n_image++;
		ctx->cur_layer->image[i]=thdr;
	}

	ctx->cur_img=thdr;

	thdr->flags=BTIC1_UnwrapDWordUBE(lh.flags);

//	thdr=ctx->cur_img;
//	thdr->width=BTIC1_UnwrapDWordSBE(lh.width);
//	thdr->height=BTIC1_UnwrapDWordSBE(lh.height);
//	thdr->imgtype=BTIC1_UnwrapWordUBE(lh.imgtype);
//	thdr->mip_start=lh.mip_start;
//	thdr->mip_end=lh.mip_end;
//	thdr->filtmode=lh.filtmode;
//	thdr->clrtype=lh.clrtype;
//	thdr->pixtype=lh.pixtype;
}

void BTIC1_DecodeCompLayerID(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	byte lhbuf[256];
	struct BGBBTJ_BTIC1_CompLayerID_Ds lh;
	BGBBTJ_BTIC1_ImageHeader *thdr;
	int id;
	int i;

	memset(lhbuf, 0, 256);
	BTIC1_EscapeDecodeBuffer(cs, len, lhbuf, 256);
	memcpy(&lh, lhbuf, sizeof(struct BGBBTJ_BTIC1_CompLayerID_Ds));

	id=BTIC1_UnwrapDWordSBE(lh.layerid);
	thdr=ctx->image[id-1];
	
	if(!thdr)
	{
		i=sizeof(BGBBTJ_BTIC1_ImageHeader);
		thdr=btic_malloc(i);
		memset(thdr, 0, i);
		thdr->layerid=id;

		ctx->image[id-1]=thdr;
		if(id>=ctx->n_image)
			ctx->n_image=id;

//		i=ctx->cur_layer->n_image++;
//		ctx->cur_layer->image[i]=thdr;
	}

	ctx->cur_img=thdr;

	thdr->flags=BTIC1_UnwrapDWordUBE(lh.flags);
}

void BTIC1_DecodeDumpBytes(BGBBTJ_BTIC1_Context *ctx, byte *cs, byte *cse)
{
	int i, j;

	printf("%08X ", cs-ctx->frm_css);

	for(i=0; i<16; i++)
		printf("%02X ", cs[i]);
	for(i=0; i<16; i++)
	{
		j=cs[i];
		if((j<' ') || (j>'~'))
			j='~';
		printf("%c", j);
	}
	printf("\n");
}

byte *BTIC1_DecodeLayer(BGBBTJ_BTIC1_Context *ctx, byte *cs, byte *cse)
{
	byte *cs1;
	char *tag;
	int len;
	u32 fcc;
	int i;
	
	while(cs<cse)
	{
		if(*cs!=0xFF)
		{
			printf("BTIC1_DecodeLayer: Resync\n");
			BTIC1_DecodeDumpBytes(ctx, cs, cse);
			cs=BTIC1_SyncMarker(cs, cse);
			continue;
		}
		
		if(cs[1]==BGBBTJ_BTIC1_MARK_FMT12)
		{
			cs1=BTIC1_DecodeMarkerFMT12(cs, cse, &len, &fcc);

#if 0
			if(fcc==BTIC1_FCC_THDR)
			{
				BTIC1_DecodeImageHeader(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}
			if(fcc==BTIC1_FCC_TDAT)
			{
				BTIC1_DecodeImageData(ctx, cs1, len);
				cs=cs1+len;
				continue;
			}
#endif

			if(fcc==BTIC1_FCC_LEND)
				{ cs=cs1+len; break; }

			printf("BTIC1_DecodeLayer: BAD Marker FMT12 %04s\n", &fcc);
			break;
		}

		if(cs[1]==BGBBTJ_BTIC1_MARK_FMT13)
		{
			cs1=BTIC1_DecodeMarkerFMT13(cs, cse, &len, &tag);
			if(!strcmp(tag, "CompLayer"))
			{
				BTIC1_DecodeCompLayerHeader(ctx, cs1, len);
				cs=cs1+len;
				cs=BTIC1_DecodeImage(ctx, cs, cse);
				continue;
			}
			printf("BTIC1_DecodeLayer: BAD Marker FMT13 %s\n", tag);
			break;
		}

		if((cs[1]>=BGBBTJ_BTIC1_MARK_FMT0) &&
			(cs[1]<=BGBBTJ_BTIC1_MARK_FMT13))
		{
			printf("BTIC1_DecodeLayer: BAD Marker FMT%d %s\n",
				cs[1]-BGBBTJ_BTIC1_MARK_FMT0);
			break;
		}
		
		if((cs[1]>=BGBBTJ_BTIC1_MARK_APP0) &&
			(cs[1]<=BGBBTJ_BTIC1_MARK_APP15))
		{
			cs1=BTIC1_DecodeMarkerGeneric(cs, cse, &len);
			cs=cs1+len;
			continue;
		}

		printf("BTIC1_DecodeLayer: BAD Marker %02X\n %04s\n", cs[1]);
		break;
	}
	return(cs);
}

void BTIC1_DecodeTagLayerHeader(
	BGBBTJ_BTIC1_Context *ctx, byte *cs, int len)
{
	byte lhbuf[256];
	struct BGBBTJ_BTIC1_TagLayerHeader_Ds lh;
	BGBBTJ_BTIC1_LayerHeader *lhdr;
	int id;
	int i;

	memset(lhbuf, 0, 256);
	BTIC1_EscapeDecodeBuffer(cs, len, lhbuf, 256);
	memcpy(&lh, lhbuf, sizeof(struct BGBBTJ_BTIC1_TagLayerHeader_Ds));

	id=BTIC1_UnwrapDWordSBE(lh.layerid);
	lhdr=ctx->layer[id-1];
	
	if(!lhdr)
	{
		i=sizeof(BGBBTJ_BTIC1_LayerHeader);
		lhdr=btic_malloc(i);
		memset(lhdr, 0, i);
		lhdr->layerid=id;
		strncpy(lhbuf, lh.name, 32);
		lhdr->name=btic_strdup(lhbuf);
		ctx->layer[id-1]=lhdr;
		if(id>ctx->n_layer)
			ctx->n_layer=id;
	}

	lhdr->xorg=BTIC1_UnwrapDWordSBE(lh.xorg);
	lhdr->yorg=BTIC1_UnwrapDWordSBE(lh.yorg);
	lhdr->xsize=BTIC1_UnwrapDWordSBE(lh.xsize);
	lhdr->ysize=BTIC1_UnwrapDWordSBE(lh.ysize);
	lhdr->xcenter=BTIC1_UnwrapDWordSBE(lh.xcenter);
	lhdr->ycenter=BTIC1_UnwrapDWordSBE(lh.ycenter);
	lhdr->flags=BTIC1_UnwrapDWordUBE(lh.flags);

	ctx->cur_layer=lhdr;
}

byte *BTIC1_DecodeImageContents(BGBBTJ_BTIC1_Context *ctx,
	byte *cs, byte *cse)
{
	byte *cs1;
	char *tag;
	int len;
	u32 fcc;
	
	while(cs<cse)
	{
		if(*cs!=0xFF)
		{
			printf("BTIC1_DecodeImageContents: Resync\n");
			cs=BTIC1_SyncMarker(cs, cse);
			continue;
		}
		
		if(cs[1]==BGBBTJ_BTIC1_MARK_FMT12)
		{
			cs1=BTIC1_DecodeMarkerFMT12(cs, cse, &len, &fcc);

//			if(fcc==BTIC1_FCC_LEND)
//				{ cs=cs1+len; break; }

			if(fcc==BTIC1_FCC_CLID)
			{
				BTIC1_DecodeCompLayerID(ctx, cs1, len);
				cs=cs1+len;
				cs=BTIC1_DecodeImage(ctx, cs, cse);
				continue;
			}

			printf("BTIC1_DecodeImagePlainBuffer: "
				"BAD Marker FMT12 %04s\n", &fcc);
			break;
		}

		if(cs[1]==BGBBTJ_BTIC1_MARK_FMT13)
		{
			cs1=BTIC1_DecodeMarkerFMT13(cs, cse, &len, &tag);

#if 0
			if(!strcmp(tag, "CompLayer"))
			{
				BTIC1_DecodeCompLayerHeader(ctx, cs1, len);
				cs=cs1+len;
				cs=BTIC1_DecodeImage(ctx, cs, cse);
				continue;
			}
#endif

			if(!strcmp(tag, "TagLayer"))
			{
				BTIC1_DecodeTagLayerHeader(ctx, cs1, len);
				cs=cs1+len;
				cs=BTIC1_DecodeLayer(ctx, cs, cse);
				continue;
			}
			printf("BTIC1_DecodeImagePlainBuffer: "
				"BAD Marker FMT13 %s\n", tag);
			break;
		}

		if((cs[1]>=BGBBTJ_BTIC1_MARK_FMT0) &&
			(cs[1]<=BGBBTJ_BTIC1_MARK_FMT13))
		{
			printf("BTIC1_DecodeImagePlainBuffer: "
				"BAD Marker FMT%d %s\n",
				cs[1]-BGBBTJ_BTIC1_MARK_FMT0);
			break;
		}
		
		if((cs[1]>=BGBBTJ_BTIC1_MARK_APP0) &&
			(cs[1]<=BGBBTJ_BTIC1_MARK_APP15))
		{
			cs1=BTIC1_DecodeMarkerGeneric(cs, cse, &len);
			cs=cs1+len;
			continue;
		}

		printf("BTIC1_DecodeLayer: BAD Marker %02X\n %04s\n", cs[1]);
		break;
	}
	
	return(cs);
}

void BTIC1_DecodeImagePlainBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ibuf, int len)
{
	byte *tbuf;
	byte *cs, *cse;
	int sz;
	
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(ibuf, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	cs=tbuf; cse=tbuf+sz;
	ctx->frm_css=cs;
	ctx->frm_cse=cse;
	
	cs=BTIC1_DecodeImageContents(ctx, cs, cse);

	btic_free(tbuf);
}

void BTIC1_DecodeImageArithBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ibuf, int len)
{
	byte *tbuf, *tbuf1;
	byte *cs, *cse;
	int sz, sz1;
	
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(ibuf, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	tbuf1=btic_malloc(1<<24);
	sz1=BGBBTJ_BitArith_DecodeData(tbuf, sz, tbuf1, 1<<24);
	
//	cs=tbuf; cse=tbuf+sz;
	cs=tbuf1; cse=tbuf1+sz1;
	ctx->frm_css=cs;
	ctx->frm_cse=cse;
	
	cs=BTIC1_DecodeImageContents(ctx, cs, cse);
	
	btic_free(tbuf);
	btic_free(tbuf1);
}

void BTIC1_DecodeImageDeflateBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ibuf, int len)
{
	byte *tbuf, *tbuf1;
	byte *cs, *cse;
	int sz, sz1;
	
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(ibuf, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	tbuf1=btic_malloc(1<<24);
//	sz1=BGBBTJ_BitArith_DecodeData(tbuf, sz, tbuf1, 1<<24);
	sz1=PDUNZ_DecodeStream(tbuf+2, tbuf1, sz, 1<<24);

//	cs=tbuf; cse=tbuf+sz;
	cs=tbuf1; cse=tbuf1+sz1;
	ctx->frm_css=cs;
	ctx->frm_cse=cse;
	
	cs=BTIC1_DecodeImageContents(ctx, cs, cse);
	
	btic_free(tbuf);
	btic_free(tbuf1);
}

void BTIC1_DecodeImageArithDeflateBuffer(
	BGBBTJ_BTIC1_Context *ctx, byte *ibuf, int len)
{
	byte *tbuf, *tbuf1;
	byte *cs, *cse;
	int sz, sz1;
	
	tbuf=btic_malloc(len);
	sz=BTIC1_EscapeDecodeBuffer(ibuf, len, tbuf, len);
	if(sz<0) { btic_free(tbuf); return; }
	
	tbuf1=btic_malloc(1<<24);
	sz1=BGBBTJ_BitArith_DecodeData(tbuf, sz, tbuf1, 1<<24);

	btic_free(tbuf);
	tbuf=tbuf1;
	tbuf1=btic_malloc(1<<24);
	sz=sz1;

//	sz1=PDUNZ_DecodeStream(tbuf, tbuf1, sz, 1<<24);
	PDUNZ_DecodeStreamSz(tbuf, tbuf1, sz, 1<<24, &sz1, 0);

//	cs=tbuf; cse=tbuf+sz;
	cs=tbuf1; cse=tbuf1+sz1;
	ctx->frm_css=cs;
	ctx->frm_cse=cse;
	
	cs=BTIC1_DecodeImageContents(ctx, cs, cse);
	
	btic_free(tbuf);
	btic_free(tbuf1);
}

int BTIC1_DecodeContext(
	BGBBTJ_BTIC1_Context *ctx, byte *ibuf, int sz)
{
	byte *cs1;
	char *tag;
	int len;

	if((ibuf[0]!=0xFF) || (ibuf[1]!=BGBBTJ_BTIC1_MARK_FMT13))
		return(-1);
	cs1=BTIC1_DecodeMarkerFMT13(ibuf, ibuf+sz, &len, &tag);
	
	if(!strcmp(tag, "BTIC1"))
	{
		BTIC1_DecodeImagePlainBuffer(ctx, cs1, len);
		cs1+=len;
		return(cs1-ibuf);
	}

	if(!strcmp(tag, "BTIC1A"))
	{
		BTIC1_DecodeImageArithBuffer(ctx, cs1, len);
		cs1+=len;
		return(cs1-ibuf);
	}

	if(!strcmp(tag, "BTIC1Z"))
	{
		BTIC1_DecodeImageDeflateBuffer(ctx, cs1, len);
		cs1+=len;
		return(cs1-ibuf);
	}

	if(!strcmp(tag, "BTIC1AZ"))
	{
		BTIC1_DecodeImageArithDeflateBuffer(ctx, cs1, len);
		cs1+=len;
		return(cs1-ibuf);
	}
	
	return(-1);
}

void BTIC1_InverseColorConvertImage(
	BGBBTJ_BTIC1_Context *ctx,
	BGBBTJ_BTIC1_ImageHeader *thdr, int pf)
{
	byte *tbuf;
	int sz, sz1;

//	if(!thdr->rgba)
//		return;

	switch(thdr->imgtype)
	{
	case BGBBTJ_JPG_BC1:
	case BGBBTJ_JPG_BC1F:
	case BGBBTJ_JPG_BC1A:
		sz=((thdr->width+3)/4)*((thdr->height+3)/4)*8;
		sz1=thdr->width*thdr->height*4;
//		BTIC1_CheckBufferImageData(ctx, thdr, sz);
		BTIC1_CheckBufferImageRGBA(ctx, thdr, sz1);
		if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
		{
			BGBBTJ_BCn_DecodeImageDXTn(
				thdr->data+thdr->ofs_pframe,
				thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}else
		{
			BGBBTJ_BCn_DecodeImageDXTn(thdr->data, thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}
		break;
	case BGBBTJ_JPG_BC3:
	case BGBBTJ_JPG_BC3F:
	case BGBBTJ_JPG_BC3_UVAY:
		sz=((thdr->width+3)/4)*((thdr->height+3)/4)*16;
		sz1=thdr->width*thdr->height*4;
//		BTIC1_CheckBufferImageData(ctx, thdr, sz);
		BTIC1_CheckBufferImageRGBA(ctx, thdr, sz1);
		if(thdr->flags&BGBBTJ_BTIC1_LFL_PFRAME)
		{
			BGBBTJ_BCn_DecodeImageDXTn(
				thdr->data+thdr->ofs_pframe,
				thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}else
		{
			BGBBTJ_BCn_DecodeImageDXTn(
				thdr->data, thdr->rgba,
				thdr->width, thdr->height,
				4, thdr->imgtype);
		}
		break;
	default:
		break;
	}
}

bool BTIC1_CheckFormatEquiv(int fmt1, int fmt2)
{
	if(fmt1==fmt2)return(true);
	
	if((fmt1==BGBBTJ_JPG_BC1) || (fmt1==BGBBTJ_JPG_BC1F) ||
		(fmt1==BGBBTJ_JPG_BC1A))
	{
		if((fmt2==BGBBTJ_JPG_BC1) || (fmt2==BGBBTJ_JPG_BC1F) ||
			(fmt2==BGBBTJ_JPG_BC1A))
		{
			return(true);
		}
	}

	if((fmt1==BGBBTJ_JPG_BC3) || (fmt1==BGBBTJ_JPG_BC3F))
	{
		if((fmt2==BGBBTJ_JPG_BC3) || (fmt2==BGBBTJ_JPG_BC3F))
		{
			return(true);
		}
	}
	
	return(0);
}

void BTIC1_GetImageBuffer(
	BGBBTJ_BTIC1_Context *ctx, BGBBTJ_BTIC1_ImageHeader *img,
	byte *rgba, int xs, int ys, int pf)
{
	int sz;

	if((img->width!=xs) || (img->height!=ys))
	{
		return;
	}
	
	//if possible, copy image directly
	if(BTIC1_CheckFormatEquiv(pf, img->imgtype))
	{
		switch(img->imgtype)
		{
		case BGBBTJ_JPG_BC1:
		case BGBBTJ_JPG_BC1F:
		case BGBBTJ_JPG_BC1A:
			sz=((img->width+3)/4)*((img->height+3)/4)*8;
			if(img->flags&BGBBTJ_BTIC1_LFL_PFRAME)
				{ memcpy(rgba, img->data+img->ofs_pframe, sz); }
			else
				{ memcpy(rgba, img->data, sz); }
			break;
		case BGBBTJ_JPG_BC3:
		case BGBBTJ_JPG_BC3F:
		case BGBBTJ_JPG_BC3_UVAY:
			sz=((img->width+3)/4)*((img->height+3)/4)*16;
			if(img->flags&BGBBTJ_BTIC1_LFL_PFRAME)
				{ memcpy(rgba, img->data+img->ofs_pframe, sz); }
			else
				{ memcpy(rgba, img->data, sz); }
			break;
		default:
			break;
		}
		
		return;
	}

	if((pf==BGBBTJ_JPG_BC3) || (pf==BGBBTJ_JPG_BC3F))
	{
		if(	(img->imgtype==BGBBTJ_JPG_BC1) ||
			(img->imgtype==BGBBTJ_JPG_BC1F) ||
			(img->imgtype==BGBBTJ_JPG_BC1A))
		{
			if(img->flags&BGBBTJ_BTIC1_LFL_PFRAME)
			{
				BGBBTJ_BCn_TranscodeBC1ToBC3(
					img->data+img->ofs_pframe, rgba, xs, ys);
			}else
			{
				BGBBTJ_BCn_TranscodeBC1ToBC3(
					img->data, rgba, xs, ys);
			}
			return;
		}
	}

	//otherwise, convert to RGBA then into the target format
	
	BTIC1_InverseColorConvertImage(ctx, img, pf);

	switch(pf)
	{
	case BGBBTJ_JPG_BC1:
	case BGBBTJ_JPG_BC1F:
	case BGBBTJ_JPG_BC1A:
		BGBBTJ_BCn_EncodeImageDXTn(rgba, img->rgba,
			img->width, img->height, 4, pf);
		break;
	case BGBBTJ_JPG_BC3:
	case BGBBTJ_JPG_BC3F:
	case BGBBTJ_JPG_BC3_UVAY:
		BGBBTJ_BCn_EncodeImageDXTn(rgba, img->rgba,
			img->width, img->height, 4, pf);
		break;
	default:
		memcpy(rgba, img->rgba, xs*ys*4);
		break;
	}
	
//	memcpy(rgba, img->rgba, xs*ys*4);
}

BGBBTJ_API int BTIC1_GetLayerComponentCtx(
	BGBBTJ_BTIC1_Context *ctx, char *lname,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *rxs, int *rys, int pf)
{
	BGBBTJ_BTIC1_LayerHeader *lhdr;
	BGBBTJ_BTIC1_ImageHeader *ihdr;
	int i;

	lhdr=BTIC1_LookupContextLayer(ctx, lname);
	if(!lhdr)return(-1);
	
	*rxs=lhdr->xsize;
	*rys=lhdr->ysize;
	
	if(rgba)
	{
		ihdr=BTIC1_LookupLayerImage(ctx, lhdr, "RGBA");
		BTIC1_GetImageBuffer(ctx, ihdr, rgba, *rxs, *rys, pf);
	}

	if(norm)
	{
		ihdr=BTIC1_LookupLayerImage(ctx, lhdr, "XYZD");
		BTIC1_GetImageBuffer(ctx, ihdr, norm, *rxs, *rys, pf);
	}

	if(spec)
	{
		ihdr=BTIC1_LookupLayerImage(ctx, lhdr, "SpRGBS");
		BTIC1_GetImageBuffer(ctx, ihdr, spec, *rxs, *rys, pf);
	}

	if(luma)
	{
		ihdr=BTIC1_LookupLayerImage(ctx, lhdr, "LuRGBS");
		BTIC1_GetImageBuffer(ctx, ihdr, luma, *rxs, *rys, pf);
	}

	return(0);
}

BGBBTJ_API int BTIC1_DecodeComponentCtx(BGBBTJ_BTIC1_Context *ctx,
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *xs, int *ys, int pf)
{
	int i;

	i=BTIC1_DecodeContext(ctx, buf, sz);
	BTIC1_GetLayerComponentCtx(ctx, NULL,
		rgba, norm, spec, luma,
		xs, ys, pf);
	return(i);
}

BGBBTJ_API int BTIC1_DecodeComponent(
	byte *buf, int sz,
	byte *rgba, byte *norm, byte *spec, byte *luma,
	int *rxs, int *rys, int pf)
{
	int i;

	BGBBTJ_BTIC1_Context *ctx;
	
	ctx=BTIC1_AllocContext();
	i=BTIC1_DecodeComponentCtx(ctx,
		buf, sz,
		rgba, norm, spec, luma,
		rxs, rys, pf);
	BTIC1_FreeContext(ctx);
	return(i);
}
/*
Lossy Block Reduction Filter.

Goal: Reduce the number of distinct pixel blocks such that subsequent compression of DXT output will compress better.

This is done as an image pre-filter rather than as part of the block-encoding process mostly to generalize over some of the subsequent encoding steps.

Note: May write over the edges or past the end of the image if it is not evenly divisible by the block size.

This estimates the block similarily mostly via MSE (Mean Square Error).
Tests show that this will introduce blocky artifacts with gradients.
 */

#include <bgbbtj.h>

// #define BLKSZ	8
// #define BLKSZ	2
#define BLKSZ	4
#define BLKSZ2	(BLKSZ*BLKSZ)

int *filtlbr_block_vals;
int *filtlbr_block_yval;
byte *filtlbr_block_cvals;
short *filtlbr_block_cyval;
short *filtlbr_block_ychain;
int *filtlbr_block_cnt;
int *filtlbr_block_ucnt;
int filtlbr_n_blocks;

int filtlbr_chains[1024];

int filtlbr_xs;
int filtlbr_ys;

void BGBBTJ_FiltLBR_GetIndexBlock(int idx, byte *buf)
{
//	int i, n;

	memcpy(buf, filtlbr_block_cvals+(idx*(BLKSZ2*4)), BLKSZ2*4);
}

int BGBBTJ_FiltLBR_GetIndexBlockY(int idx)
{
	return(filtlbr_block_cyval[idx]);
}

void BGBBTJ_FiltLBR_AddIndexBlock(int idx, byte *buf)
{
	int i, j, n;

	i=BGBBTJ_FiltLBR_CalcBlockY(buf);
	filtlbr_block_yval[idx]+=i;

	for(i=0; i<(BLKSZ2*4); i++)
	{
		filtlbr_block_vals[idx*(BLKSZ2*4)+i]+=buf[i];
	}
	filtlbr_block_cnt[idx]++;

	n=filtlbr_block_cnt[idx];
	j=filtlbr_block_yval[idx]/n;
	filtlbr_block_cyval[idx]=j;

	for(i=0; i<(BLKSZ2*4); i++)
	{
		j=filtlbr_block_vals[idx*(BLKSZ2*4)+i]/n;
		if(j<0)j=0;
		if(j>255)j=255;
		filtlbr_block_cvals[idx*(BLKSZ2*4)+i]=j;
	}

#if 0
	j=BGBBTJ_FiltLBR_CalcBlockY(filtlbr_block_cvals+(idx*(BLKSZ2*4)));
	filtlbr_block_cyval[idx]=j;
#endif
}

int BGBBTJ_FiltLBR_CalcBlockY(byte *buf)
{
	int i, j, k;
	
	k=0;
	for(i=0; i<BLKSZ2; i++)
	{
//		j=buf[i*4+0]+2*buf[i*4+1]+buf[i*4+2]+(buf[i*4+3]>>1);
		j=(buf[i*4+0]+2*buf[i*4+1]+buf[i*4+2])>>2;
//		j=(19595*buf[i*4+0] + 38470*buf[i*4+1] + 7471*buf[i*4+2])>>16;
		k+=j;
	}
	return(k/BLKSZ2);
}

#if 0
int BGBBTJ_FiltLBR_CompareBlock(byte *blka, byte *blkb)
{
	int ya, ua, va, aa;
	int yb, ub, vb, ab;
	int yc, yd;
	int cr, cg, cb, ca;
	int cra, cga, cba, caa;
	int crb, cgb, cbb, cab;
	int dr, dg, db, da;
	int dy, du, dv;
	int i, j, k, n;

#if 0
	n=0;
	for(i=0; i<BLKSZ2; i++)
	{
		cra=blka[i*4+0]; cga=blka[i*4+1];
		cba=blka[i*4+2]; caa=blka[i*4+3];

		crb=blkb[i*4+0]; cgb=blkb[i*4+1];
		cbb=blkb[i*4+2]; cab=blkb[i*4+3];

		dr=cra-crb;	dr=dr*dr;
		dg=cga-cgb; dg=dg*dg;
		db=cba-cbb; db=db*db;
		da=caa-cab; da=da*da;

		dy=(dr+2*dg+db)>>2;

		j=dr+dg+db+dy+(da>>2);
		n+=j;

//		n+=j*j;
	}
	return(n/(BLKSZ2*2));
#endif

#if 1
	n=0;
	for(i=0; i<BLKSZ2; i++)
	{
		cr=blka[i*4+0]; cg=blka[i*4+1];
		cb=blka[i*4+2]; ca=blka[i*4+3];
		ya=(cr+2*cg+cb)>>2;
//		ua=((cb-cg)>>1)+128;
//		va=((cr-cg)>>1)+128;
		ua=(cb-cg)+128;
		va=(cr-cg)+128;
		aa=((ca-128)>>1)+128;

		cr=blkb[i*4+0]; cg=blkb[i*4+1];
		cb=blkb[i*4+2]; ca=blkb[i*4+3];
		yb=(cr+2*cg+cb)>>2;
//		ub=((cb-cg)>>1)+128;
//		vb=((cr-cg)>>1)+128;
		ub=(cb-cg)+128;
		vb=(cr-cg)+128;
		ab=((ca-128)>>1)+128;

		dy=ya-yb;
		du=ua-ub;
		dv=va-vb;
		da=aa-ab;

		j=(dy*dy)+(du*du)+(dv*dv)+(da*da);
		n+=j;

//		n+=j*j;
	}
	return(n/(BLKSZ2*2));
#endif

#if 0
	n=0;
	for(i=0; i<BLKSZ; i++)
		for(j=0; j<BLKSZ; j++)
	{
		k=i*4+j;
		cr=blka[k*4+0]; cg=blka[k*4+1];
		cb=blka[k*4+2]; ca=blka[k*4+3];
		ya=(cr+2*cg+cb)>>2;
//		ua=((cb-cg)>>1)+128;
//		va=((cr-cg)>>1)+128;
		ua=(cb-cg)+128;
		va=(cr-cg)+128;
		aa=((ca-128)>>1)+128;

		cr=blkb[k*4+0]; cg=blkb[k*4+1];
		cb=blkb[k*4+2]; ca=blkb[k*4+3];
		yb=(cr+2*cg+cb)>>2;
//		ub=((cb-cg)>>1)+128;
//		vb=((cr-cg)>>1)+128;
		ub=(cb-cg)+128;
		vb=(cr-cg)+128;
		ab=((ca-128)>>1)+128;

		dy=ya-yb;
		du=ua-ub;
		dv=va-vb;
		da=aa-ab;

//		k=(dy*dy)+(da*da);
		k=(dy*dy)+(du*du)+(dv*dv)+(da*da);
		n+=k;

#if 1
		if((j+1)<BLKSZ)
		{
			k=i*4+j+1;
			cr=blka[k*4+0]; cg=blka[k*4+1]; cb=blka[k*4+2];
			yc=(cr+2*cg+cb)>>2;
			
			cr=blkb[k*4+0]; cg=blkb[k*4+1]; cb=blkb[k*4+2];
			yd=(cr+2*cg+cb)>>2;
			
			du=yc-ya;
			dv=yd-yb;
			dy=dv-du;
			n+=(dy*dy)>>2;
		}

		if((i+1)<BLKSZ)
		{
			k=(i+1)*4+j;
			cr=blka[k*4+0]; cg=blka[k*4+1]; cb=blka[k*4+2];
			yc=(cr+2*cg+cb)>>2;
			
			cr=blkb[k*4+0]; cg=blkb[k*4+1]; cb=blkb[k*4+2];
			yd=(cr+2*cg+cb)>>2;
			
			du=yc-ya;
			dv=yd-yb;
			dy=dv-du;
			n+=(dy*dy)>>2;
		}
#endif

//		n+=j*j;
	}
	return(n/(BLKSZ2*2));
#endif

#if 0
	n=0;
	for(i=0; i<(BLKSZ2*4); i++)
	{
		j=blka[i]-blkb[i];
		n+=j*j;
	}
	return(n/(BLKSZ2*4));
#endif
}
#endif


#if 1
int BGBBTJ_FiltLBR_CompareBlock(byte *blka, byte *blkb)
{
	int ya, ua, va, aa;
	int yb, ub, vb, ab;
	int yc, yd;
	int cr, cg, cb, ca;
	int cra, cga, cba, caa;
	int crb, cgb, cbb, cab;
	int dr, dg, db, da;
	int dy, du, dv;
	int er, eg, eb, ea;
	int i, j, k, n;

#if 1
	n=0; er=0; eg=0; eb=0; ea=0;
	for(i=0; i<BLKSZ2; i++)
	{
		cra=blka[i*4+0]; cga=blka[i*4+1];
		cba=blka[i*4+2]; caa=blka[i*4+3];

		crb=blkb[i*4+0]; cgb=blkb[i*4+1];
		cbb=blkb[i*4+2]; cab=blkb[i*4+3];

		dr=cra-crb;	dr=dr*dr;
		dg=cga-cgb; dg=dg*dg;
		db=cba-cbb; db=db*db;
		da=caa-cab; da=da*da;

		j=(caa>cab)?caa:cab;

		er+=(dr*j)>>8;
		eg+=(dg*j)>>8;
		eb+=(db*j)>>8;
		ea+=(da*j)>>8;

//		er+=dr;
//		eg+=dg;
//		eb+=db;
//		ea+=da;

//		dy=(dr+2*dg+db)>>2;
//		j=dr+dg+db+dy+(da>>2);
//		n+=j;

//		n+=j*j;
	}
	
//	n=(19595*er + 38470*eg + 7471*eb + ea*4096 + 32768)>>16;
//	n=(19595*er + 38470*eg + 7471*eb + ea*4096)>>16;
	n=(19595LL*er + 38470LL*eg + 7471LL*eb + ea*4096LL)>>16;
//	if(n<0)n=(1<<31)-1;
	
	return(n/BLKSZ2);
#endif
}
#endif


int BGBBTJ_FiltLBR_GetImageBlock(
	byte *img, int xstride, int ystride,
	byte *block)
{
	int i, j;
	
	for(i=0; i<BLKSZ; i++)
		for(j=0; j<BLKSZ; j++)
	{
		block[(i*BLKSZ+j)*4+0]=img[(i*ystride)+(j*xstride)+0];
		block[(i*BLKSZ+j)*4+1]=img[(i*ystride)+(j*xstride)+1];
		block[(i*BLKSZ+j)*4+2]=img[(i*ystride)+(j*xstride)+2];
		block[(i*BLKSZ+j)*4+3]=img[(i*ystride)+(j*xstride)+3];
	}
	return(0);
}

int BGBBTJ_FiltLBR_SetImageBlock(
	byte *img, int xstride, int ystride,
	byte *block)
{
	int i, j;
	
	for(i=0; i<BLKSZ; i++)
		for(j=0; j<BLKSZ; j++)
	{
		img[(i*ystride)+(j*xstride)+0]=block[(i*BLKSZ+j)*4+0];
		img[(i*ystride)+(j*xstride)+1]=block[(i*BLKSZ+j)*4+1];
		img[(i*ystride)+(j*xstride)+2]=block[(i*BLKSZ+j)*4+2];
		img[(i*ystride)+(j*xstride)+3]=block[(i*BLKSZ+j)*4+3];
	}
	return(0);
}

int BGBBTJ_FiltLBR_YChainIdx(int yv, int mmse)
{
//	return(yv/(mmse+1));
//	return((yv+mmse)/(2*mmse+1));
	return((yv+(mmse>>1))/(mmse+1));
}

int BGBBTJ_FiltLBR_LookupMatchIndexBlockSkip(byte *blk,
	int immse, int mmse, int skip)
{
	byte tblk[BLKSZ2*4];
	int bi, be;
	int i, j, yv;
	
	yv=BGBBTJ_FiltLBR_CalcBlockY(blk);

#if 0
	bi=-1; be=mmse;
	for(i=0; i<filtlbr_n_blocks; i++)
	{
		j=BGBBTJ_FiltLBR_GetIndexBlockY(i);
		j=j-yv; j=j*j;
		if(j>be)continue;
	
		BGBBTJ_FiltLBR_GetIndexBlock(i, tblk);
		j=BGBBTJ_FiltLBR_CompareBlock(tblk, blk);
		if(j<be) { bi=i; be=j; }
	}
#endif

#if 1
	bi=-1; be=mmse; i=filtlbr_chains[BGBBTJ_FiltLBR_YChainIdx(yv, immse)];
//	for(i=0; i<filtlbr_n_blocks; i++)
	while(i>=0)
	{
#if 1
		j=BGBBTJ_FiltLBR_GetIndexBlockY(i);
		j=j-yv; j=j*j;
		if(j>be)
		{
			i=filtlbr_block_ychain[i];
			continue;
		}
#endif

		if(skip>=0)
		{
			if(i==skip)
				{ i=filtlbr_block_ychain[i]; continue; }
//			if(filtlbr_block_ucnt[i]<16)
//			if(filtlbr_block_ucnt[i]<8)
			if(filtlbr_block_ucnt[i]<4)
				{ i=filtlbr_block_ychain[i]; continue; }
		}
	
		BGBBTJ_FiltLBR_GetIndexBlock(i, tblk);
		j=BGBBTJ_FiltLBR_CompareBlock(tblk, blk);
		if(j<be) { bi=i; be=j; }
		i=filtlbr_block_ychain[i];
	}
#endif
	
	return(bi);
}

int BGBBTJ_FiltLBR_LookupMatchIndexBlock(byte *blk, int mmse)
{
	return(BGBBTJ_FiltLBR_LookupMatchIndexBlockSkip(
		blk, mmse, mmse, -1));
}

int BGBBTJ_FiltLBR_GetMatchIndexBlock(byte *blk, int mmse)
{
	int i, j, k;
	
	i=BGBBTJ_FiltLBR_LookupMatchIndexBlock(blk, mmse);
	if(i>=0)return(i);
	i=filtlbr_n_blocks++;
	BGBBTJ_FiltLBR_AddIndexBlock(i, blk);

#if 1
	j=BGBBTJ_FiltLBR_YChainIdx(
		BGBBTJ_FiltLBR_GetIndexBlockY(i), mmse);
	filtlbr_block_ychain[i]=filtlbr_chains[j];
	filtlbr_chains[j]=i;
#endif
	
	return(i);
}

BGBBTJ_API void BGBBTJ_FiltLBR_CheckSetupImage(
	int xs, int ys, int qf)
{
	int xs2, ys2;

	xs2=(xs+BLKSZ-1)/BLKSZ;
	ys2=(ys+BLKSZ-1)/BLKSZ;

	if((xs!=filtlbr_xs) || (ys!=filtlbr_ys) || !filtlbr_block_vals)
	{
		if(filtlbr_block_vals)
		{
			free(filtlbr_block_vals);
			free(filtlbr_block_yval);
			free(filtlbr_block_cnt);

			free(filtlbr_block_cvals);
			free(filtlbr_block_cyval);
			free(filtlbr_block_ychain);
		}
	
		filtlbr_block_vals=malloc(2*xs2*ys2*(BLKSZ2*4)*sizeof(int));
		filtlbr_block_yval=malloc(2*xs2*ys2*sizeof(int));
		filtlbr_block_cnt=malloc(2*xs2*ys2*sizeof(int));
		filtlbr_block_ucnt=malloc(2*xs2*ys2*sizeof(int));

		filtlbr_block_cvals=malloc(2*xs2*ys2*(BLKSZ2*4));
		filtlbr_block_cyval=malloc(2*xs2*ys2*sizeof(short));
		filtlbr_block_ychain=malloc(2*xs2*ys2*sizeof(short));

		filtlbr_n_blocks=0;
		filtlbr_xs=xs;
		filtlbr_ys=ys;
	}
}

BGBBTJ_API void BGBBTJ_FiltLBR_SetupImage(
	int xs, int ys, int qf)
{
	int xs2, ys2;
	int i;

	BGBBTJ_FiltLBR_CheckSetupImage(xs, ys, qf);

	xs2=(xs+BLKSZ-1)/BLKSZ;
	ys2=(ys+BLKSZ-1)/BLKSZ;

	filtlbr_n_blocks=0;

	memset(filtlbr_block_vals, 0, 2*xs2*ys2*(BLKSZ2*4)*sizeof(int));
	memset(filtlbr_block_yval, 0, 2*xs2*ys2*sizeof(int));
	memset(filtlbr_block_cnt, 0, 2*xs2*ys2*sizeof(int));
	memset(filtlbr_block_ucnt, 0, 2*xs2*ys2*sizeof(int));

//	memset(filtlbr_chains, 0, 256*sizeof(int));
	for(i=0; i<1024; i++)
		filtlbr_chains[i]=-1;
}

/**
 * Filter image, where irgba and orgba give the input and output images.
 * xs and ys give the size, and qf gives the quality (low 8 bits, 0-100).
 */
BGBBTJ_API void BGBBTJ_FiltLBR_FilterImageB(
	byte *orgba, byte *irgba, int xs, int ys, int qf)
{
	byte tblk[BLKSZ2*4];
	int *bidx, *uidx;
	int x, y, xs2, ys2, xstr, ystr;
	int idx, idx1, mmse;
	int i, j, k;
	
	if((qf&255)>=100)
	{
		if(!orgba)return;
		memcpy(orgba, irgba, xs*ys*4);
		return;
	}

	printf("BGBBTJ_FiltLBR_FilterImage: Begin\n");

	BGBBTJ_FiltLBR_SetupImage(xs, ys, qf);

	xs2=(xs+BLKSZ-1)/BLKSZ;
	ys2=(ys+BLKSZ-1)/BLKSZ;

	bidx=malloc(xs2*ys2*sizeof(int));
//	uidx=malloc(xs2*ys2*sizeof(int));
	uidx=filtlbr_block_ucnt;

	memset(uidx, 0, xs2*ys2*sizeof(int));

	xstr=4; ystr=xs*4;
//	mmse=95-(qf&255);
//	mmse=90-(qf&255);
//	mmse=100-(qf&255);
//	mmse=256-(qf&255);

//	mmse=1.0+10.0*(pow(100.0/(qf&255), 2)-1.0);
	mmse=1.0+10.0*((100.0/(qf&255))-1.0);
//	mmse=1.0+20.0*((100.0/(qf&255))-1.0);

	if(mmse<0)mmse=0;
	mmse=mmse*mmse;

	for(y=0; y<ys2; y++)
	{
		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
			y, ys2, filtlbr_n_blocks, y*xs2);
		for(x=0; x<xs2; x++)
		{
			BGBBTJ_FiltLBR_GetImageBlock(irgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
				xstr, ystr, tblk);
			idx=BGBBTJ_FiltLBR_GetMatchIndexBlock(tblk, mmse);
//			BGBBTJ_FiltLBR_AddIndexBlock(idx, tblk);
			bidx[y*xs2+x]=idx;
			uidx[idx]++;
		}

		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
			y, ys2, filtlbr_n_blocks, y*xs2);
	}
	printf("\n");

#if 1
	for(y=0; y<ys2; y++)
	{
		for(x=0; x<xs2; x++)
		{
			idx=bidx[y*xs2+x];
			
//			if(uidx[idx]<16)
			if(uidx[idx]<8)
			{
				BGBBTJ_FiltLBR_GetImageBlock(
					irgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
					xstr, ystr, tblk);

//				k=mmse+((mmse*(32-uidx[idx]))>>1);
//				k=mmse+((mmse*(16-uidx[idx]))>>1);
//				k=mmse+((mmse*(16-uidx[idx]))>>2);
				k=mmse+((mmse*(8-uidx[idx]))>>2);
//				k=mmse+(mmse*(16-uidx[idx]));
				i=BGBBTJ_FiltLBR_LookupMatchIndexBlockSkip(
					tblk, mmse, k, idx);
				if(i>0)
				{
					bidx[y*xs2+x]=i;
				}
			}
			
//			BGBBTJ_FiltLBR_AddIndexBlock(idx, tblk);
//			bidx[y*xs2+x]=idx;
		}
	}
#endif

#if 1
	for(y=0; y<ys2; y++)
	{
//		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
//			y, ys2, filtlbr_n_blocks, y*xs2);
		for(x=0; x<xs2; x++)
		{
			BGBBTJ_FiltLBR_GetImageBlock(irgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
				xstr, ystr, tblk);
//			idx=BGBBTJ_FiltLBR_GetMatchIndexBlock(tblk, mmse);
			idx=bidx[y*xs2+x];
			BGBBTJ_FiltLBR_AddIndexBlock(idx, tblk);
//			bidx[y*xs2+x]=idx;
		}

//		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
//			y, ys2, filtlbr_n_blocks, y*xs2);
	}
//	printf("\n");
#endif

	if(!orgba)return;

	for(y=0; y<ys2; y++)
		for(x=0; x<xs2; x++)
	{
		idx=bidx[y*xs2+x];

#if 0
		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
			y, ys2, filtlbr_n_blocks, y*xs2);

		BGBBTJ_FiltLBR_GetImageBlock(irgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
			xstr, ystr, tblk);
//		idx1=BGBBTJ_FiltLBR_LookupMatchIndexBlock(tblk, mmse);
		idx1=BGBBTJ_FiltLBR_GetMatchIndexBlock(tblk, mmse);
		if(idx1>=0)idx=idx1;
#endif

		BGBBTJ_FiltLBR_GetIndexBlock(idx, tblk);
		BGBBTJ_FiltLBR_SetImageBlock(orgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
			xstr, ystr, tblk);
	}
//	printf("\n");
	
	free(bidx);
//	free(filtlbr_block_vals);
//	free(filtlbr_block_yval);
//	free(filtlbr_block_cvals);
//	free(filtlbr_block_cyval);
//	free(filtlbr_block_cnt);

	printf("BGBBTJ_FiltLBR_FilterImage: Done\n");
}

/**
 * Filter patch image, where irgba and orgba give the input and output images.
 * xs and ys give the size, and qf gives the quality (low 8 bits, 0-100).
 * Patch images will try to reuse blocks from a prior image.
 */
BGBBTJ_API void BGBBTJ_FiltLBR_FilterPatchImageB(
	byte *orgba, byte *irgba, int xs, int ys, int qf)
{
	byte tblk[BLKSZ2*4];
	int onchn[1024];
	int *bidx;
	int x, y, xs2, ys2, xstr, ystr;
	int idx, idx1, mmse, onb;
	int i;
	
	if((qf&255)>=100)
	{
		memcpy(orgba, irgba, xs*ys*4);
		return;
	}

	printf("BGBBTJ_FiltLBR_FilterImage: Begin\n");

	onb=filtlbr_n_blocks;
	for(i=0; i<1024; i++)
		onchn[i]=filtlbr_chains[i];

	BGBBTJ_FiltLBR_CheckSetupImage(xs, ys, qf);

	xs2=(xs+BLKSZ-1)/BLKSZ;
	ys2=(ys+BLKSZ-1)/BLKSZ;

	bidx=malloc(xs2*ys2*sizeof(int));

	xstr=4; ystr=xs*4;
//	mmse=95-(qf&255);
//	mmse=90-(qf&255);
//	mmse=100-(qf&255);
//	mmse=256-(qf&255);

//	mmse=1.0+10.0*(pow(100.0/(qf&255), 2)-1.0);
	mmse=1.0+10.0*((100.0/(qf&255))-1.0);
//	mmse=1.0+20.0*((100.0/(qf&255))-1.0);

	if(mmse<0)mmse=0;
	mmse=mmse*mmse;

	for(y=0; y<ys2; y++)
	{
		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
			y, ys2, filtlbr_n_blocks, y*xs2);
		for(x=0; x<xs2; x++)
		{
			BGBBTJ_FiltLBR_GetImageBlock(irgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
				xstr, ystr, tblk);
			idx=BGBBTJ_FiltLBR_GetMatchIndexBlock(tblk, mmse);
			bidx[y*xs2+x]=idx;
		}

		printf("BGBBTJ_FiltLBR_FilterImage: %d/%d %d/%d\r",
			y, ys2, filtlbr_n_blocks, y*xs2);
	}
	printf("\n");

#if 1
	for(y=0; y<ys2; y++)
	{
		for(x=0; x<xs2; x++)
		{
			BGBBTJ_FiltLBR_GetImageBlock(irgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
				xstr, ystr, tblk);
			idx=bidx[y*xs2+x];
			if(idx<onb)continue;
			BGBBTJ_FiltLBR_AddIndexBlock(idx, tblk);
		}
	}
#endif

	for(y=0; y<ys2; y++)
		for(x=0; x<xs2; x++)
	{
		idx=bidx[y*xs2+x];

		BGBBTJ_FiltLBR_GetIndexBlock(idx, tblk);
		BGBBTJ_FiltLBR_SetImageBlock(orgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
			xstr, ystr, tblk);
	}

	//restore prior state
	filtlbr_n_blocks=onb;
	for(i=0; i<1024; i++)
		filtlbr_chains[i]=onchn[i];

	free(bidx);
	printf("BGBBTJ_FiltLBR_FilterImage: Done\n");
}

BGBBTJ_API void BGBBTJ_FiltLBR_PreFilterImage_Reduce(
	byte *rgba, int xs, int ys, int qf)
{
	byte tblk[BLKSZ2*4], tblk2[BLKSZ2*4];
	byte tdblk[16];
	int x, y, xs2, ys2, xstr, ystr;
	int pxa, pxb, pxc, pxd;
	int cr, cg, cb, ca;
	int idx, idx1, mmse, onb;
	int i, j;

	xs2=(xs+BLKSZ-1)/BLKSZ;
	ys2=(ys+BLKSZ-1)/BLKSZ;

	xstr=4;
	ystr=xs*xstr;

	mmse=1.0+10.0*((100.0/(qf&255))-1.0);
//	mmse=1.0+20.0*((100.0/(qf&255))-1.0);

	if(mmse<0)mmse=0;
	mmse=mmse*mmse;

	for(y=0; y<ys2; y++)
	{
		for(x=0; x<xs2; x++)
		{
			BGBBTJ_FiltLBR_GetImageBlock(rgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
				xstr, ystr, tblk);
//			idx=BGBBTJ_FiltLBR_GetMatchIndexBlock(tblk, mmse);
//			bidx[y*xs2+x]=idx;

			for(i=0; i<2; i++)
				for(j=0; j<2; j++)
			{
				pxa=((i*2+0)*4+j*2+0)*4;	pxb=((i*2+0)*4+j*2+1)*4;
				pxc=((i*2+1)*4+j*2+0)*4;	pxd=((i*2+1)*4+j*2+1)*4;
				cr=(tblk[pxa+0]+tblk[pxb+0]+tblk[pxc+0]+tblk[pxd+0])>>2;
				cg=(tblk[pxa+1]+tblk[pxb+1]+tblk[pxc+1]+tblk[pxd+1])>>2;
				cb=(tblk[pxa+2]+tblk[pxb+2]+tblk[pxc+2]+tblk[pxd+2])>>2;
				ca=(tblk[pxa+3]+tblk[pxb+3]+tblk[pxc+3]+tblk[pxd+3])>>2;
				tblk2[pxa+0]=cr;	tblk2[pxb+0]=cr;
				tblk2[pxc+0]=cr;	tblk2[pxd+0]=cr;
				tblk2[pxa+1]=cg;	tblk2[pxb+1]=cg;
				tblk2[pxc+1]=cg;	tblk2[pxd+1]=cg;
				tblk2[pxa+2]=cb;	tblk2[pxb+2]=cb;
				tblk2[pxc+2]=cb;	tblk2[pxd+2]=cb;
				tblk2[pxa+3]=ca;	tblk2[pxb+3]=ca;
				tblk2[pxc+3]=ca;	tblk2[pxd+3]=ca;
			}

			i=BGBBTJ_FiltLBR_CompareBlock(tblk2, tblk);
			if((i*i)<=mmse)
			{
				BGBBTJ_FiltLBR_SetImageBlock(
					rgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
					xstr, ystr, tblk2);
				memcpy(tblk, tblk2, BLKSZ2*4);
			}

#if 0
			BGBBTJ_BCn_EncodeBlockDXT1F(
				tdblk, tblk, 4, 4*4, 3);
			BGBBTJ_BCn_DecodeBlockDXT1(tdblk, tblk2, 4, 4*4, 3);

			i=BGBBTJ_FiltLBR_CompareBlock(tblk2, tblk);
			if((i*i)<=mmse)
			{
				BGBBTJ_FiltLBR_SetImageBlock(
					rgba+(y*BLKSZ*ystr)+(x*BLKSZ*xstr),
					xstr, ystr, tblk2);
				memcpy(tblk, tblk2, BLKSZ2*4);
			}
#endif
		}
	}
}

BGBBTJ_API void BGBBTJ_FiltLBR_FilterImage(
	byte *orgba, byte *irgba, int xs, int ys, int qf)
{
	byte *trgba, *tblk;
	int fmt;

	if((qf&255)>90)
	{
		BGBBTJ_FiltLBR_FilterImageB(orgba, irgba, xs, ys, qf);
		return;
	}
	
	trgba=malloc(xs*ys*4);
	tblk=malloc(((xs+3)/4)*((ys+3)/4)*16);
	
	fmt=BGBBTJ_JPG_BC3;
//	if(fmt<75)
//		{ fmt=BGBBTJ_JPG_BC3F; }
//	if(fmt<50)
//		{ fmt=BGBBTJ_JPG_BC1A; }
	
	BGBBTJ_BCn_EncodeImageDXTn(tblk, irgba, xs, ys, 4, fmt);
	BGBBTJ_BCn_DecodeImageDXTn(tblk, trgba, xs, ys, 4, fmt);

	BGBBTJ_FiltLBR_ColorQuantizeImage(trgba, trgba, xs, ys, qf);
	
//	BGBBTJ_FiltLBR_PreFilterImage_Reduce(trgba, xs, ys, qf);
	
	BGBBTJ_FiltLBR_FilterImageB(orgba, trgba, xs, ys, qf);

//	BGBBTJ_FiltLBR_PreFilterImage_Reduce(orgba, xs, ys, qf);

//	BGBBTJ_FiltLBR_ColorQuantizeImage(orgba, orgba, xs, ys, qf);

	free(trgba);
	free(tblk);
	
//	BGBBTJ_FiltLBR_StatImageBlocks(orgba, xs, ys, qf);
//	BGBBTJ_FiltLBR_StatImageBlocks(irgba, xs, ys, qf);
}

BGBBTJ_API void BGBBTJ_FiltLBR_FilterPatchImage(
	byte *orgba, byte *irgba, int xs, int ys, int qf)
{
	byte *trgba, *tblk;

	if((qf&255)>90)
	{
		BGBBTJ_FiltLBR_FilterPatchImageB(orgba, irgba, xs, ys, qf);
		return;
	}
	
	trgba=malloc(xs*ys*4);
	tblk=malloc(((xs+3)/4)*((ys+3)/4)*16);
	
	BGBBTJ_BCn_EncodeImageDXTn(tblk, irgba, xs, ys, 4, BGBBTJ_JPG_BC3);
	BGBBTJ_BCn_DecodeImageDXTn(tblk, trgba, xs, ys, 4, BGBBTJ_JPG_BC3);
	BGBBTJ_FiltLBR_FilterPatchImageB(orgba, trgba, xs, ys, qf);

//	BGBBTJ_FiltLBR_ColorQuantizeImage(orgba, orgba, xs, ys, qf);

#if 0
	BGBBTJ_BCn_EncodeImageDXTn(tblk, orgba, xs, ys, 4, BGBBTJ_JPG_BC3);
#endif

	free(trgba);
	free(tblk);
}

BGBBTJ_API void BGBBTJ_FiltLBR_ColorQuantizeImage(
	byte *orgba, byte *irgba, int xs, int ys, int qf)
{
	int cr, cg, cb, ca;
	int cy, cu, cv;
	int i, j, k, n;

//	return;

	if((qf&255)>50)
	{
		if(orgba!=irgba)
			{ memcpy(orgba, irgba, xs*ys*4); }
		return;
	}
	
	n=xs*ys;
	for(i=0; i<n; i++)
	{
		cr=irgba[i*4+0];
		cg=irgba[i*4+1];
		cb=irgba[i*4+2];
		ca=irgba[i*4+3];

#if 0
		cr=((cr+21)/43)*43;
		cg=((cg+21)/43)*43;
		cb=((cb+21)/43)*43;
		cr=(cr<0)?0:((cr>255)?255:cr);
		cg=(cg<0)?0:((cg>255)?255:cg);
		cb=(cb<0)?0:((cb>255)?255:cb);
#endif

#if 1
		cy=(cr+2*cg+cb)>>2;
		cu=(cb-cg)+128;
		cv=(cr-cg)+128;
//		cu=((cb-cg)/2)+128;
//		cv=((cr-cg)/2)+128;

		cu=((cu-128)*1.5)+128;
		cv=((cv-128)*1.5)+128;

#if 1
//		cy=(cy*10+128)>>8;
//		cu=(cu*5+128)>>8;
//		cv=(cv*5+128)>>8;

//		cy=(cy*10+127)>>8;
//		cu=(cu*5+127)>>8;
//		cv=(cv*5+127)>>8;

		cy=(cy*10+128)>>8;
		cu=(((cu-128)*5+128)>>8)+2;
		cv=(((cv-128)*5+128)>>8)+2;

//		cy=(cy*10)>>8;
//		cu=(cu*5)>>8;
//		cv=(cv*5)>>8;

//		ca=ca>>4;
		cy=(cy<0)?0:((cy>9)?9:cy);
		cu=(cu<0)?0:((cu>4)?4:cu);
		cv=(cv<0)?0:((cv>4)?4:cv);
		
//		cy=(cy* 6554+128)>>8;
//		cu=(cu*13107+128)>>8;
//		cv=(cv*13107+128)>>8;

//		cy=(((cy-2)* 6554+128)>>8)+128;
		cy=(cy* 6554+128)>>8;
		cu=(((cu-2)*13107+128)>>8)+128;
		cv=(((cv-2)*13107+128)>>8)+128;

//		ca=ca<<4;
#endif

//		cu-=128; cv-=128;
//		cu=(cu-128)*2; cv=(cv-128)*2;
		cu=(cu-128)*0.67; cv=(cv-128)*0.67;

		cg=cy-((cu+cv)>>2);
		cb=cg+cu;
		cr=cg+cv;

		cr=(cr<0)?0:((cr>255)?255:cr);
		cg=(cg<0)?0:((cg>255)?255:cg);
		cb=(cb<0)?0:((cb>255)?255:cb);
#endif

		orgba[i*4+0]=cr;
		orgba[i*4+1]=cg;
		orgba[i*4+2]=cb;
		orgba[i*4+3]=ca;
	}
}

#if 0
BGBBTJ_API void BGBBTJ_FiltLBR_StatImageBlocks(
	byte *rgba, int xs, int ys, int qf)
{
	int *colors;
	int *bpat;
	byte *tbuf, *tcda;
	byte *tblk, *sb;
	int cr, cg, cb;
	int cya, cua, cva, cyb, cub, cvb;
	int i, j, k, l, n, nc, np;
	int stm, stn, sta;


	n=((xs+3)/4)*((ys+3)/4);

	colors=malloc(65536*sizeof(int));
	memset(colors, 0, 65536*sizeof(int));

	bpat=malloc(n*sizeof(int));
	tbuf=malloc(1<<22);

	tblk=malloc(n*16);
	BGBBTJ_BCn_EncodeImageDXTn(tblk, rgba, xs, ys, 4, BGBBTJ_JPG_BC3);

	tcda=malloc(n*6);
	
	printf("BGBBTJ_FiltLBR_StatImageBlocks:\n");

	np=0;
	for(i=0; i<n; i++)
	{
		sb=tblk+i*16+8;
		colors[sb[0]|(sb[1]<<8)]++;
		colors[sb[2]|(sb[3]<<8)]++;
		
#if 1
//		k=sb[4]|(sb[5]<<8)|(sb[6]<<16)|(sb[7]<<24);

#if 1
		k=(sb[4]&15)|((sb[5]&15)<<4);
		j=((sb[4]>>4)&15)|(((sb[5]>>4)&15)<<4);
		k|=j<<8;
		j=(sb[6]&15)|((sb[7]&15)<<4);
		k|=j<<16;
		j=((sb[6]>>4)&15)|(((sb[7]>>4)&15)<<4);
		k|=j<<24;
#endif
		
		for(j=0; j<np; j++)
			if(bpat[j]==k)
				break;
		if(j>=np)
		{
			j=np++;
			bpat[j]=k;

			tcda[j*4+0]=sb[0];
			tcda[j*4+1]=sb[1];
			tcda[j*4+2]=sb[2];
			tcda[j*4+3]=sb[3];

			if(j)
			{
//				k=sb[0]|(sb[1]<<8)|(sb[2]<<16)|(sb[3]<<24);
//				l=sb[0-16]|(sb[1-16]<<8)|(sb[2-16]<<16)|(sb[3-16]<<24);

				k=sb[0]|(sb[1]<<8);
				l=sb[0-16]|(sb[1-16]<<8);

				k=k-l;
				tcda[j*4+0]=k;
				tcda[j*4+1]=k>>8;
//				tcda[j*4+2]=k>>16;
//				tcda[j*4+3]=k>>24;

				k=sb[2]|(sb[3]<<8);
				l=sb[2-16]|(sb[3-16]<<8);

				k=k-l;
				tcda[j*4+2]=k;
				tcda[j*4+3]=k>>8;

//				tcda[j*4+0]=sb[0]-sb[-16];
//				tcda[j*4+1]=sb[1]-sb[-15];
//				tcda[j*4+2]=sb[2]-sb[-14];
//				tcda[j*4+3]=sb[3]-sb[-13];

//				tcda[j*4+0]=sb[0]-tcda[(j-1)*4+0];
//				tcda[j*4+1]=sb[1]-tcda[(j-1)*4+1];
//				tcda[j*4+2]=sb[2]-tcda[(j-1)*4+2];
//				tcda[j*4+3]=sb[3]-tcda[(j-1)*4+3];
			}

#if 0
			k=sb[0]|(sb[1]<<8);
			cb=(k&0x001F)<<3;
			cg=(k&0x07E0)>>3;
			cr=(k&0xF800)>>8;
//			tcda[j*6+0]=(cr+2*cg+cb)>>2;
//			tcda[j*6+1]=cb-cg;
//			tcda[j*6+2]=cr-cg;
			cya=(cr+2*cg+cb)>>2;
			cua=cb-cg;	cva=cr-cg;

			k=sb[2]|(sb[3]<<8);
			cb=(k&0x001F)<<3;
			cg=(k&0x07E0)>>3;
			cr=(k&0xF800)>>8;
//			tcda[j*6+3]=(cr+2*cg+cb)>>2;
//			tcda[j*6+4]=cb-cg;
//			tcda[j*6+5]=cr-cg;
			cyb=(cr+2*cg+cb)>>2;
			cub=cb-cg;	cvb=cr-cg;

			tcda[j*6+0]=cya;
			tcda[j*6+1]=cua;
			tcda[j*6+2]=cva;
			tcda[j*6+3]=cyb-cya;
			tcda[j*6+4]=cub-cua;
			tcda[j*6+5]=cvb-cva;
#endif
		}
#endif
	}
	
	nc=0; stm=99999; stn=0; sta=0;
	for(i=0; i<65536; i++)
	{
		if(colors[i])
		{
			if(colors[i]<stm)
				stm=colors[i];
			if(colors[i]>stn)
				stn=colors[i];
			sta+=colors[i];
			nc++;
		}
	}

	sta/=nc;

	printf("BGBBTJ_FiltLBR_NumColors: Nc=%d Stm=%d Stn=%d Sta=%d\n",
		nc, stm, stn, sta);
	printf("BGBBTJ_FiltLBR_NumPatterns: %d\n", np);

	i=PDZ2_EncodeStreamLvl(bpat, tbuf, np*4, 1<<22, 9);
	printf("BGBBTJ_FiltLBR_BPatSz: %d -> %d\n", np*4, i);

//	i=PDZ2_EncodeStreamLvl(tcda, tbuf, np*6, 1<<22, 9);
//	printf("BGBBTJ_FiltLBR_TcdaSz: %d -> %d, R=%d\n", np*6, i, np*4);

	i=PDZ2_EncodeStreamLvl(tcda, tbuf, np*4, 1<<22, 9);
	printf("BGBBTJ_FiltLBR_TcdaSz: %d -> %d, R=%d\n", np*4, i, np*4);

	printf("BGBBTJ_FiltLBR_StatImageBlocks: OK\n");
}
#endif

#if 1
BGBBTJ_API void BGBBTJ_FiltLBR_StatImageBlocks(
	byte *rgba, int xs, int ys, int qf)
{
	int stats[1024];
	byte *tbuf, *lbuf, *tlcbuf, *tlpbuf;
	byte *tpbuf, *tplbuf;
	byte *tzbuf, *tzlbuf;
	byte *tblk, *sb;
	u64 li, lj;
	int cr, cg, cb;
	int cya, cua, cva, cyb, cub, cvb;
	int i, j, k, l, n, nc, np;
	int stm, stn, sta, sz, szlb, szp, szplb;


	n=((xs+3)/4)*((ys+3)/4);

	tbuf=malloc(1<<22);
	lbuf=malloc(1<<22);
	tblk=malloc(2*n*16);
	BGBBTJ_BCn_EncodeImageDXTn(tblk, rgba, xs, ys, 4, BGBBTJ_JPG_BC3);
	BGBBTJ_BCn_EncodeImageDXTn(tblk+n*16, rgba, xs, ys, 4, BGBBTJ_JPG_BC3);
	sz=BGBBTJ_PackBCn_EncodeBlocks2DXT5(
		tbuf, lbuf, tblk, n, ((xs+3)/4), &szlb);

	tpbuf=malloc(1<<22);
	tplbuf=malloc(1<<22);
	szp=BGBBTJ_PackBCn_EncodePatchBlocks2DXT5(
		tpbuf, tplbuf, tblk, n, ((xs+3)/4), &szplb);
	
	printf("BGBBTJ_FiltLBR_StatImageBlocks: Sz=%d, SzLb=%d\n", sz, szlb);
	printf("BGBBTJ_FiltLBR_StatImageBlocks: SzP=%d, SzLbP=%d\n", szp, szplb);

	for(i=0; i<1024; i++)stats[i]=0;
//	BGBBTJ_PackBCn_StatBlockArray2(tbuf, stats, 2*n, ((xs+3)/4));
	BGBBTJ_PackBCn_StatBlockArray2(tpbuf, stats, 2*n, ((xs+3)/4));

	for(i=0; i<32; i++)
	{
		printf("B%3d: ", i*8);
		for(j=0; j<8; j++)
		{
			printf("%5d ", stats[i*8+j]);
		}
		printf("\n");
	}

	for(i=0; i<32; i++)
	{
		printf("I%3d: ", i*8);
		for(j=0; j<8; j++)
		{
			printf("%5d ", stats[256+i*8+j]);
		}
		printf("\n");
	}

	for(i=0; i<32; i++)
	{
		printf("L%3d: ", i*8);
		for(j=0; j<8; j++)
		{
			printf("%5d ", stats[512+i*8+j]);
		}
		printf("\n");
	}

	tzbuf=malloc(1<<22);
	tzlbuf=malloc(1<<22);
	
	tlcbuf=malloc(1<<22);
	tlpbuf=malloc(1<<22);

	lj=0;
	for(i=0; i<(szlb/8); i++)
	{
		li=*(u64 *)(lbuf+(i*8));
//		*(u32 *)(lbuf+(i*8))=li^lj;
//		lj=li;

		j=*(u32 *)(lbuf+(i*8+0));
		*(u32 *)(tlcbuf+i*4)=j;

		j=*(u32 *)(lbuf+(i*8+4));
		*(u32 *)(tlpbuf+i*4)=j;
	}

	i=PDZ2_EncodeStreamLvl(tbuf, tzbuf, sz, 1<<22, 9);
	printf("BGBBTJ_FiltLBR_StatImageBlocks: TzBuf %d -> %d\n", sz, i);

	j=PDZ2_EncodeStreamLvl(lbuf, tzlbuf, szlb, 1<<22, 9);
	printf("BGBBTJ_FiltLBR_StatImageBlocks: TzlBuf %d -> %d\n", szlb, j);

	printf("BGBBTJ_FiltLBR_StatImageBlocks: TotBuf %d -> %d\n", sz+szlb, i+j);

	j=PDZ2_EncodeStreamLvl(tlcbuf, tzlbuf, szlb/2, 1<<22, 9);
	printf("BGBBTJ_FiltLBR_StatImageBlocks: TzlcBuf %d -> %d\n", szlb/2, j);

	k=PDZ2_EncodeStreamLvl(tlpbuf, tzlbuf, szlb/2, 1<<22, 9);
	printf("BGBBTJ_FiltLBR_StatImageBlocks: TzlpBuf %d -> %d\n", szlb/2, k);

	printf("BGBBTJ_FiltLBR_StatImageBlocks: TotBufB %d -> %d\n",
		sz+szlb, i+j+k);
}
#endif
#include <bgbbtj.h>
#include <math.h>

#define DCTSZ	8
#define DCTSZ2	64

#define JPG_SOF0	0xC0
#define JPG_SOF1	0xC1
#define JPG_SOF2	0xC2
#define JPG_SOF3	0xC3
#define JPG_DHT		0xC4
#define JPG_SOF5	0xC5
#define JPG_SOF6	0xC6
#define JPG_SOF7	0xC7
#define JPG_JPG		0xC8
#define JPG_SOF9	0xC9
#define JPG_SOF10	0xCA
#define JPG_SOF11	0xCB
#define JPG_DAC		0xCC
#define JPG_SOF13	0xCD
#define JPG_SOF14	0xCE
#define JPG_SOF15	0xCF

#define JPG_RST0	0xD0
#define JPG_RST1	0xD1
#define JPG_RST2	0xD2
#define JPG_RST3	0xD3
#define JPG_RST4	0xD4
#define JPG_RST5	0xD5
#define JPG_RST6	0xD6
#define JPG_RST7	0xD7

#define JPG_SOI		0xD8
#define JPG_EOI		0xD9
#define JPG_SOS		0xDA
#define JPG_DQT		0xDB
#define JPG_DNL		0xDC
#define JPG_DRI		0xDD
#define JPG_DHP		0xDE
#define JPG_EXP		0xDF

#define JPG_APP0	0xE0
#define JPG_APP1	0xE1
#define JPG_APP2	0xE2
#define JPG_APP3	0xE3
#define JPG_APP4	0xE4
#define JPG_APP5	0xE5
#define JPG_APP6	0xE6
#define JPG_APP7	0xE7
#define JPG_APP8	0xE8
#define JPG_APP9	0xE9
#define JPG_APP10	0xEA
#define JPG_APP11	0xEB
#define JPG_APP12	0xEC
#define JPG_APP13	0xED
#define JPG_APP14	0xEE
#define JPG_APP15	0xEF

#define JPG_JPG0	0xF0
#define JPG_JPG1	0xF1
#define JPG_JPG2	0xF2
#define JPG_JPG3	0xF3
#define JPG_JPG4	0xF4
#define JPG_JPG5	0xF5
#define JPG_JPG6	0xF6
#define JPG_JPG7	0xF7
#define JPG_JPG8	0xF8
#define JPG_JPG9	0xF9
#define JPG_JPG10	0xFA
#define JPG_JPG11	0xFB
#define JPG_JPG12	0xFC
#define JPG_JPG13	0xFD
#define JPG_COM		0xFE

char *btj_jfe_marker[]={
"SOF0", "SOF1", "SOF2", "SOF3", "DHT", "SOF5", "SOF6", "SOF7",
"JPG", "SOF9", "SOF10", "SOF11", "DAC", "SOF13", "SOF14", "SOF15",
"RST0", "RST1", "RST2", "RST3", "RST4", "RST5", "RST6", "RST7",
"SOI", "EOI", "SOS", "DQT", "DNL", "DRI", "DHP", "EXP",
"APP0", "APP1", "APP2", "APP3", "APP4", "APP5", "APP6", "APP7", 
"APP8", "APP9", "APP10", "APP11", "APP12", "APP13", "APP14", "APP15", 
"JPG0", "JPG1", "JPG2", "JPG3", "JPG4", "JPG5", "JPG6", "JPG7", 
"JPG8", "JPG9", "JPG10", "JPG11", "JPG12", "JPG13", "COM", ""
};

static const byte btj_jfe_zigzag[64]={
 0,  1,  5,  6, 14, 15, 27, 28,
 2,  4,  7, 13, 16, 26, 29, 42,
 3,  8, 12, 17, 25, 30, 41, 43,
 9, 11, 18, 24, 31, 40, 44, 53,
10, 19, 23, 32, 39, 45, 52, 54,
20, 22, 33, 38, 46, 51, 55, 60,
21, 34, 37, 47, 50, 56, 59, 61,
35, 36, 48, 49, 57, 58, 62, 63
};

static const byte btj_jfe_zigzag2[64]={
 0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63
};

ushort btj_jfeh_code[4][256];

static const byte btj_jfeh_len[4][256]={
{  6,  4,  3,  3,  2,  2,  3,  5,  7,  9, 10, 10, 10, 10, 10, 11,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
},
{  4,  2,  4,  3,  4,  5,  6,  7,  8, 13, 14, 16, 16, 15, 15, 15,
15,  3,  5,  7,  9, 12, 13, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  5,  7, 10, 13, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16,
16,  5,  8, 11, 13, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16,
11,  6, 10, 12, 15, 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11,  6, 10, 15, 14, 15, 15, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11,  7, 10, 13, 15, 15, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11,  7, 10, 15, 16, 15, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11,  7, 11, 14, 15, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11,  5, 13, 15, 15, 11, 11, 11, 11, 11, 11, 11, 11, 16, 16, 16,
16,  8, 12, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
16,  9, 12, 13, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
16,  9, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
16, 10, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
16, 11, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15,
10, 12, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16,
},
{  2,  2,  2,  3,  4,  5,  8,  8,  9,  9,  8,  8,  8,  8,  9, 10,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
},
{  3,  2,  3,  3,  5,  7, 11, 14, 15, 16, 16, 16, 16, 16, 16, 16,
16,  3,  5,  8, 11, 12, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15,
15,  4,  7, 11, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  5,  9, 11, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  6, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  6, 11, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  7, 13, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  7, 12, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  8, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  8, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  9, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15,  9, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 12, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
11, 12, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16,
}
};

#if 1
void BTJ_JFE_TransDCT_Horiz(short *iblk, int *oblk)
{
	int ib0, ib1, ib2, ib3, ib4, ib5, ib6, ib7;
	int ib0p7, ib1p6, ib2p5, ib3p4;
	int ib0n7, ib1n6, ib2n5, ib3n4;
	int ib0p7n3n4, ib1p6n2n5;

	ib0=iblk[0]-128;	ib1=iblk[1]-128;
	ib2=iblk[2]-128;	ib3=iblk[3]-128;
	ib4=iblk[4]-128;	ib5=iblk[5]-128;
	ib6=iblk[6]-128;	ib7=iblk[7]-128;

	ib0p7=ib0+ib7;	ib1p6=ib1+ib6;
	ib2p5=ib2+ib5;	ib3p4=ib3+ib4;
	ib0n7=ib0-ib7;	ib1n6=ib1-ib6;
	ib2n5=ib2-ib5;	ib3n4=ib3-ib4;

	oblk[0]=(ib0p7+ib1p6+ib2p5+ib3p4)*91;
	oblk[4]=(ib0p7-ib1p6-ib2p5+ib3p4)*91;

	ib0p7n3n4=ib0p7-ib3p4;
	ib1p6n2n5=ib1p6-ib2p5;
	oblk[2]=ib0p7n3n4*118 +ib1p6n2n5* 49;
	oblk[6]=ib0p7n3n4* 49 -ib1p6n2n5*118;

	oblk[1]=ib0n7*126 +ib1n6*106 +ib2n5* 71 +ib3n4* 25;
	oblk[3]=ib0n7*106 -ib1n6* 25 -ib2n5*126 -ib3n4* 71;
	oblk[5]=ib0n7* 71 -ib1n6*126 +ib2n5* 25 +ib3n4*106;
	oblk[7]=ib0n7* 25 -ib1n6* 71 +ib2n5*106 -ib3n4*126;
}

void BTJ_JFE_TransDCT_Vert2(int *iblk, short *oblk)
{
	int ib0, ib1, ib2, ib3, ib4, ib5, ib6, ib7;
	int ob0, ob1, ob2, ob3, ob4, ob5, ob6, ob7;
	int ib0p7, ib1p6, ib2p5, ib3p4;
	int ib0n7, ib1n6, ib2n5, ib3n4;
	int ib0p7n3n4, ib1p6n2n5;

	ib0=iblk[ 0];	ib1=iblk[ 8];
	ib2=iblk[16];	ib3=iblk[24];
	ib4=iblk[32];	ib5=iblk[40];
	ib6=iblk[48];	ib7=iblk[56];

	ib0p7=ib0+ib7;	ib1p6=ib1+ib6;
	ib2p5=ib2+ib5;	ib3p4=ib3+ib4;
	ib0n7=ib0-ib7;	ib1n6=ib1-ib6;
	ib2n5=ib2-ib5;	ib3n4=ib3-ib4;

	ob0=(ib0p7+ib1p6+ib2p5+ib3p4)*91;
	ob4=(ib0p7-ib1p6-ib2p5+ib3p4)*91;

	ib0p7n3n4=ib0p7-ib3p4;
	ib1p6n2n5=ib1p6-ib2p5;
	ob2=ib0p7n3n4*118 +ib1p6n2n5* 49;
	ob6=ib0p7n3n4* 49 -ib1p6n2n5*118;

	ob1=ib0n7*126 +ib1n6*106 +ib2n5* 71 +ib3n4* 25;
	ob3=ib0n7*106 -ib1n6* 25 -ib2n5*126 -ib3n4* 71;
	ob5=ib0n7* 71 -ib1n6*126 +ib2n5* 25 +ib3n4*106;
	ob7=ib0n7* 25 -ib1n6* 71 +ib2n5*106 -ib3n4*126;

	oblk[ 0]=(ob0+32768)>>16;	oblk[ 8]=(ob1+32768)>>16;
	oblk[16]=(ob2+32768)>>16;	oblk[24]=(ob3+32768)>>16;
	oblk[32]=(ob4+32768)>>16;	oblk[40]=(ob5+32768)>>16;
	oblk[48]=(ob6+32768)>>16;	oblk[56]=(ob7+32768)>>16;
}

void BTJ_JFE_TransDCT(short *iblk, short *oblk)
{
	int s[DCTSZ2];
	int i, j;

	BTJ_JFE_TransDCT_Horiz(iblk+ 0, s+ 0);
	BTJ_JFE_TransDCT_Horiz(iblk+ 8, s+ 8);
	BTJ_JFE_TransDCT_Horiz(iblk+16, s+16);
	BTJ_JFE_TransDCT_Horiz(iblk+24, s+24);
	BTJ_JFE_TransDCT_Horiz(iblk+32, s+32);
	BTJ_JFE_TransDCT_Horiz(iblk+40, s+40);
	BTJ_JFE_TransDCT_Horiz(iblk+48, s+48);
	BTJ_JFE_TransDCT_Horiz(iblk+56, s+56);

	BTJ_JFE_TransDCT_Vert2(s+0, oblk+0);
	BTJ_JFE_TransDCT_Vert2(s+1, oblk+1);
	BTJ_JFE_TransDCT_Vert2(s+2, oblk+2);
	BTJ_JFE_TransDCT_Vert2(s+3, oblk+3);
	BTJ_JFE_TransDCT_Vert2(s+4, oblk+4);
	BTJ_JFE_TransDCT_Vert2(s+5, oblk+5);
	BTJ_JFE_TransDCT_Vert2(s+6, oblk+6);
	BTJ_JFE_TransDCT_Vert2(s+7, oblk+7);
}
#endif

#if 1
void BTJ_JFEH_QuantBlock(BGBBTJ_JFE_Context *ctx,
	short *ibuf, short *obuf, int qid)
{
	short tbuf[64];
	short *cs, *ct;
	int *qt;
	byte *zt;
	int i, j;

#if 0
	//HACK: DC Range Trap
	if((ibuf[0]>=2048) || (ibuf[0]<=-2048))
	{
		i=ibuf[0];
		if(ibuf[0]>=2048)ibuf[0]=2048;
		if(ibuf[0]<=-2048)ibuf[0]=-2048;
		printf("BTJ_JFEH_QuantBlock: DC Range Trap %d\n", i);
	}
#endif

#if 1
	qt=ctx->qtfp[qid];

//	0,  1,  5,  6, 14, 15, 27, 28,
	tbuf[ 0]=((ibuf[ 0]*qt[ 0])+2048)>>12;
	tbuf[ 1]=((ibuf[ 1]*qt[ 1])+2048)>>12;
	tbuf[ 5]=((ibuf[ 2]*qt[ 2])+2048)>>12;
	tbuf[ 6]=((ibuf[ 3]*qt[ 3])+2048)>>12;
	tbuf[14]=((ibuf[ 4]*qt[ 4])+2048)>>12;
	tbuf[15]=((ibuf[ 5]*qt[ 5])+2048)>>12;
	tbuf[27]=((ibuf[ 6]*qt[ 6])+2048)>>12;
	tbuf[28]=((ibuf[ 7]*qt[ 7])+2048)>>12;

//	2,  4,  7, 13, 16, 26, 29, 42,
	tbuf[ 2]=((ibuf[ 8]*qt[ 8])+2048)>>12;
	tbuf[ 4]=((ibuf[ 9]*qt[ 9])+2048)>>12;
	tbuf[ 7]=((ibuf[10]*qt[10])+2048)>>12;
	tbuf[13]=((ibuf[11]*qt[11])+2048)>>12;
	tbuf[16]=((ibuf[12]*qt[12])+2048)>>12;
	tbuf[26]=((ibuf[13]*qt[13])+2048)>>12;
	tbuf[29]=((ibuf[14]*qt[14])+2048)>>12;
	tbuf[42]=((ibuf[15]*qt[15])+2048)>>12;

//	3,  8, 12, 17, 25, 30, 41, 43,
	tbuf[ 3]=((ibuf[16]*qt[16])+2048)>>12;
	tbuf[ 8]=((ibuf[17]*qt[17])+2048)>>12;
	tbuf[12]=((ibuf[18]*qt[18])+2048)>>12;
	tbuf[17]=((ibuf[19]*qt[19])+2048)>>12;
	tbuf[25]=((ibuf[20]*qt[20])+2048)>>12;
	tbuf[30]=((ibuf[21]*qt[21])+2048)>>12;
	tbuf[41]=((ibuf[22]*qt[22])+2048)>>12;
	tbuf[43]=((ibuf[23]*qt[23])+2048)>>12;

//	9, 11, 18, 24, 31, 40, 44, 53,
	tbuf[ 9]=((ibuf[24]*qt[24])+2048)>>12;
	tbuf[11]=((ibuf[25]*qt[25])+2048)>>12;
	tbuf[18]=((ibuf[26]*qt[26])+2048)>>12;
	tbuf[24]=((ibuf[27]*qt[27])+2048)>>12;
	tbuf[31]=((ibuf[28]*qt[28])+2048)>>12;
	tbuf[40]=((ibuf[29]*qt[29])+2048)>>12;
	tbuf[44]=((ibuf[30]*qt[30])+2048)>>12;
	tbuf[53]=((ibuf[31]*qt[31])+2048)>>12;

//	10, 19, 23, 32, 39, 45, 52, 54,
	tbuf[10]=((ibuf[32]*qt[32])+2048)>>12;
	tbuf[19]=((ibuf[33]*qt[33])+2048)>>12;
	tbuf[23]=((ibuf[34]*qt[34])+2048)>>12;
	tbuf[32]=((ibuf[35]*qt[35])+2048)>>12;
	tbuf[39]=((ibuf[36]*qt[36])+2048)>>12;
	tbuf[45]=((ibuf[37]*qt[37])+2048)>>12;
	tbuf[52]=((ibuf[38]*qt[38])+2048)>>12;
	tbuf[54]=((ibuf[39]*qt[39])+2048)>>12;

//	20, 22, 33, 38, 46, 51, 55, 60,
	tbuf[20]=((ibuf[40]*qt[40])+2048)>>12;
	tbuf[22]=((ibuf[41]*qt[41])+2048)>>12;
	tbuf[33]=((ibuf[42]*qt[42])+2048)>>12;
	tbuf[38]=((ibuf[43]*qt[43])+2048)>>12;
	tbuf[46]=((ibuf[44]*qt[44])+2048)>>12;
	tbuf[51]=((ibuf[45]*qt[45])+2048)>>12;
	tbuf[55]=((ibuf[46]*qt[46])+2048)>>12;
	tbuf[60]=((ibuf[47]*qt[47])+2048)>>12;

//	21, 34, 37, 47, 50, 56, 59, 61,
	tbuf[21]=((ibuf[48]*qt[48])+2048)>>12;
	tbuf[34]=((ibuf[49]*qt[49])+2048)>>12;
	tbuf[37]=((ibuf[50]*qt[50])+2048)>>12;
	tbuf[47]=((ibuf[51]*qt[51])+2048)>>12;
	tbuf[50]=((ibuf[52]*qt[52])+2048)>>12;
	tbuf[56]=((ibuf[53]*qt[53])+2048)>>12;
	tbuf[59]=((ibuf[54]*qt[54])+2048)>>12;
	tbuf[61]=((ibuf[55]*qt[55])+2048)>>12;

//	35, 36, 48, 49, 57, 58, 62, 63
	tbuf[35]=((ibuf[56]*qt[56])+2048)>>12;
	tbuf[36]=((ibuf[57]*qt[57])+2048)>>12;
	tbuf[48]=((ibuf[58]*qt[58])+2048)>>12;
	tbuf[49]=((ibuf[59]*qt[59])+2048)>>12;
	tbuf[57]=((ibuf[60]*qt[60])+2048)>>12;
	tbuf[58]=((ibuf[61]*qt[61])+2048)>>12;
	tbuf[62]=((ibuf[62]*qt[62])+2048)>>12;
	tbuf[63]=((ibuf[63]*qt[63])+2048)>>12;

	memcpy(obuf, tbuf, 64*sizeof(short));
#endif

#if 0
	cs=ibuf; qt=ctx->qtfp[qid]; zt=btj_jfe_zigzag;
	for(i=0; i<8; i++)
	{
		tbuf[zt[0]]=((cs[0]*qt[0])+2048)>>12;
		tbuf[zt[1]]=((cs[1]*qt[1])+2048)>>12;
		tbuf[zt[2]]=((cs[2]*qt[2])+2048)>>12;
		tbuf[zt[3]]=((cs[3]*qt[3])+2048)>>12;
		tbuf[zt[4]]=((cs[4]*qt[4])+2048)>>12;
		tbuf[zt[5]]=((cs[5]*qt[5])+2048)>>12;
		tbuf[zt[6]]=((cs[6]*qt[6])+2048)>>12;
		tbuf[zt[7]]=((cs[7]*qt[7])+2048)>>12;
		cs+=8; qt+=8; zt+=8;
	}
	memcpy(obuf, tbuf, 64*sizeof(short));
#endif
}
#endif

void BTJ_JFEH_SetupQuantTabDivFP(BGBBTJ_JFE_Context *ctx, int qid)
{
	int i;
	
	for(i=0; i<64; i++)
		ctx->qtfp[qid][i]=4096.0/ctx->qt[qid][i]+0.5;
}

//Encoder
#if 1
void BTJ_JFEH_WriteBit(BGBBTJ_JFE_Context *ctx, int i)
{
	ctx->pos--;
	ctx->win|=i<<ctx->pos;
	if(ctx->pos<=24)
	{
		i=(ctx->win>>24)&0xFF;
		*ctx->ct++=i;
		if(i==0xFF)*ctx->ct++=0x00;
		ctx->win<<=8;
		ctx->pos+=8;
	}
}

void BTJ_JFEH_WriteNBits(BGBBTJ_JFE_Context *ctx, int i, int n)
{
//	i&=(1<<n)-1;

	ctx->pos-=n;
	ctx->win|=i<<ctx->pos;
	while(ctx->pos<=24)
	{
		i=(ctx->win>>24)&0xFF;
		*ctx->ct++=i;
		if(i==0xFF)*ctx->ct++=0x00;
		ctx->win<<=8;
		ctx->pos+=8;
	}
}

void BTJ_JFEH_FlushBits(BGBBTJ_JFE_Context *ctx)
{
	int i;
	while(ctx->pos<32)
	{
		i=(ctx->win>>24)&0xFF;
		*ctx->ct++=i;
		if(i==0xFF)*ctx->ct++=0x00;
		ctx->win<<=8;
		ctx->pos+=8;
	}
}
#endif

void BTJ_JFEH_EncodeSymbol(BGBBTJ_JFE_Context *ctx, int tab, int v)
{
	BTJ_JFEH_WriteNBits(ctx, btj_jfeh_code[tab][v], btj_jfeh_len[tab][v]);
}

void BTJ_JFEH_EncodeVal(BGBBTJ_JFE_Context *ctx, int tab, int z, int v)
{
	int i, j, k;

	if(!v) { BTJ_JFEH_EncodeSymbol(ctx, tab, z<<4); return; }

	if(v>0)
	{
		i=1;
		while(v>=(1<<i))i++;
		BTJ_JFEH_EncodeSymbol(ctx, tab, (z<<4)|i);
		BTJ_JFEH_WriteNBits(ctx, v, i);
		return;
	}

	i=1; j=-v; while(j>=(1<<i))i++;
	BTJ_JFEH_EncodeSymbol(ctx, tab, (z<<4)|i);

	k=(1<<i)-(j+1);
	BTJ_JFEH_WriteNBits(ctx, k, i);
	return;
}

void BTJ_JFEH_EncodeBlock(BGBBTJ_JFE_Context *ctx,
	short *buf, int dctab, int actab)
{
	int i, j, k;

	BTJ_JFEH_EncodeVal(ctx, dctab, 0, buf[0]);

	i=1;
	while(i<64)
	{
		j=buf[i];
		if(j)
		{
			BTJ_JFEH_EncodeVal(ctx, actab, 0, j);
			i++;
			continue;
		}

		j=i+1;
		while(1)
		{
#if 1
			if(j<56)
			{
				if(buf[j])break;
				if(buf[++j])break;
				if(buf[++j])break;
				if(buf[++j])break;
				if(buf[++j])break;
				if(buf[++j])break;
				if(buf[++j])break;
				if(buf[++j])break;
				continue;
			}else
			{
				while(1)
				{
					if(j>=64)
					{
						BTJ_JFEH_EncodeSymbol(ctx, actab, 0);
						return;
					}
					if(buf[j])break;
					j++;
				}
				break;
			}
#endif

#if 0
			if(j>=64)
			{
				BTJ_JFEH_EncodeSymbol(ctx, actab, 0);
				return;
			}
			if(buf[j])break;
			j++;
#endif
		}

		k=j-i;
//		while((j-i)>15)
		while(k>15)
		{
			BTJ_JFEH_EncodeSymbol(ctx, actab, 15<<4);
			i+=16; k=j-i;
		}

//		k=j-i;
		BTJ_JFEH_EncodeVal(ctx, actab, k, buf[j]);
		i=j+1;
	}
}

void BTJ_JFE_GetImgBlk2Y_RGB(short *blk, int xo, int yo,
	byte *img, int xs, int ys, int xs2, int ys2, int ssz)
{
	byte *ib;
	short *ob;
	int sx0, sx1, sx2, sx3, sx4, sx5, sx6, sx7;
	int i, j, k;

	if(((xo+8)>xs) || ((ys-yo-8)<0))
	{
		//goes off edge of image
		for(i=0; i<8; i++)
			for(j=0; j<8; j++)
		{
			k=(ys-(yo+i)-1);
			if(((xo+j)>=xs) || (k<0))
				{ blk[i*8+j]=0; continue; }
			ib=img+((k*xs)+xo+j)*ssz;
			blk[i*8+j]=(19595*ib[0] + 38470*ib[1] +
				7471*ib[2] + 32768)>>16;
		}

		return;
	}

	if(ssz==4)
	{
		for(i=0; i<8; i++)
		{
			ib=img+(((ys-(yo+i)-1)*xs)+xo)*ssz;
			ob=blk+(i*8);
			ob[0]=(19595*ib[ 0] + 38470*ib[ 1] + 7471*ib[ 2] + 32768)>>16;
			ob[1]=(19595*ib[ 4] + 38470*ib[ 5] + 7471*ib[ 6] + 32768)>>16;
			ob[2]=(19595*ib[ 8] + 38470*ib[ 9] + 7471*ib[10] + 32768)>>16;
			ob[3]=(19595*ib[12] + 38470*ib[13] + 7471*ib[14] + 32768)>>16;
			ob[4]=(19595*ib[16] + 38470*ib[17] + 7471*ib[18] + 32768)>>16;
			ob[5]=(19595*ib[20] + 38470*ib[21] + 7471*ib[22] + 32768)>>16;
			ob[6]=(19595*ib[24] + 38470*ib[25] + 7471*ib[26] + 32768)>>16;
			ob[7]=(19595*ib[28] + 38470*ib[29] + 7471*ib[30] + 32768)>>16;
		}
	}else
	{
		sx0=0;     sx1=ssz;   sx2=2*ssz; sx3=3*ssz;
		sx4=4*ssz; sx5=5*ssz; sx6=6*ssz; sx7=7*ssz;
		for(i=0; i<8; i++)
		{
			ib=img+(((ys-(yo+i)-1)*xs)+xo)*ssz;
			ob=blk+(i*8);
			ob[0]=(19595*ib[sx0+0] + 38470*ib[sx0+1] + 7471*ib[sx0+2] + 32768)>>16;
			ob[1]=(19595*ib[sx1+0] + 38470*ib[sx1+1] + 7471*ib[sx1+2] + 32768)>>16;
			ob[2]=(19595*ib[sx2+0] + 38470*ib[sx2+1] + 7471*ib[sx2+2] + 32768)>>16;
			ob[3]=(19595*ib[sx3+0] + 38470*ib[sx3+1] + 7471*ib[sx3+2] + 32768)>>16;
			ob[4]=(19595*ib[sx4+0] + 38470*ib[sx4+1] + 7471*ib[sx4+2] + 32768)>>16;
			ob[5]=(19595*ib[sx5+0] + 38470*ib[sx5+1] + 7471*ib[sx5+2] + 32768)>>16;
			ob[6]=(19595*ib[sx6+0] + 38470*ib[sx6+1] + 7471*ib[sx6+2] + 32768)>>16;
			ob[7]=(19595*ib[sx7+0] + 38470*ib[sx7+1] + 7471*ib[sx7+2] + 32768)>>16;
		}
	}
}

void BTJ_JFE_GetImgBlk2Y_BGR(short *blk, int xo, int yo,
	byte *img, int xs, int ys, int xs2, int ys2, int ssz)
{
	byte *ib;
	short *ob;
	int sx0, sx1, sx2, sx3, sx4, sx5, sx6, sx7;
	int i, j, k;

	if(((xo+8)>xs) || ((ys-yo-8)<0))
	{
		//goes off edge of image
		for(i=0; i<8; i++)
			for(j=0; j<8; j++)
		{
			k=(ys-(yo+i)-1);
			if(((xo+j)>=xs) || (k<0))
				{ blk[i*8+j]=0; continue; }
			ib=img+((k*xs)+xo+j)*ssz;
			blk[i*8+j]=(19595*ib[2] + 38470*ib[1] +
				7471*ib[0] + 32768)>>16;
		}

		return;
	}

	if(ssz==4)
	{
		for(i=0; i<8; i++)
		{
			ib=img+(((ys-(yo+i)-1)*xs)+xo)*ssz;
			ob=blk+(i*8);
			ob[0]=(19595*ib[ 2] + 38470*ib[ 1] + 7471*ib[ 0] + 32768)>>16;
			ob[1]=(19595*ib[ 6] + 38470*ib[ 5] + 7471*ib[ 4] + 32768)>>16;
			ob[2]=(19595*ib[10] + 38470*ib[ 9] + 7471*ib[ 8] + 32768)>>16;
			ob[3]=(19595*ib[14] + 38470*ib[13] + 7471*ib[12] + 32768)>>16;
			ob[4]=(19595*ib[18] + 38470*ib[17] + 7471*ib[16] + 32768)>>16;
			ob[5]=(19595*ib[22] + 38470*ib[21] + 7471*ib[20] + 32768)>>16;
			ob[6]=(19595*ib[26] + 38470*ib[25] + 7471*ib[24] + 32768)>>16;
			ob[7]=(19595*ib[30] + 38470*ib[29] + 7471*ib[28] + 32768)>>16;
		}
	}else
	{
		sx0=0;     sx1=ssz;   sx2=2*ssz; sx3=3*ssz;
		sx4=4*ssz; sx5=5*ssz; sx6=6*ssz; sx7=7*ssz;
		for(i=0; i<8; i++)
		{
			ib=img+(((ys-(yo+i)-1)*xs)+xo)*ssz;
			ob=blk+(i*8);
			ob[0]=(19595*ib[sx0+2] + 38470*ib[sx0+1] + 
				7471*ib[sx0+0] + 32768)>>16;
			ob[1]=(19595*ib[sx1+2] + 38470*ib[sx1+1] + 
				7471*ib[sx1+0] + 32768)>>16;
			ob[2]=(19595*ib[sx2+2] + 38470*ib[sx2+1] + 
				7471*ib[sx2+0] + 32768)>>16;
			ob[3]=(19595*ib[sx3+2] + 38470*ib[sx3+1] + 
				7471*ib[sx3+0] + 32768)>>16;
			ob[4]=(19595*ib[sx4+2] + 38470*ib[sx4+1] + 
				7471*ib[sx4+0] + 32768)>>16;
			ob[5]=(19595*ib[sx5+2] + 38470*ib[sx5+1] + 
				7471*ib[sx5+0] + 32768)>>16;
			ob[6]=(19595*ib[sx6+2] + 38470*ib[sx6+1] + 
				7471*ib[sx6+0] + 32768)>>16;
			ob[7]=(19595*ib[sx7+2] + 38470*ib[sx7+1] + 
				7471*ib[sx7+0] + 32768)>>16;
		}
	}
}

void BTJ_JFE_GetImgBlk2UV_RGB(
	short *ublk, short *vblk, int xo, int yo,
	byte *img, int xs, int ys, int xs2, int ys2, int ssz)
{
	byte *ib0, *ib1;
	short *obu, *obv;
	int cr, cg, cb, cu, cv;
	int i, j, k;

//	if(((xo+16)>xs) || ((2*ys2-yo-1)>ys))
	if(((xo+16)>xs) || ((ys-yo-16)<0))
	{
		//goes off edge of image
		for(i=0; i<8; i++)
			for(j=0; j<8; j++)
		{
			if((xo+2*j+1)>=xs)
				{ ublk[i*8+j]=0; vblk[i*8+j]=0; continue; }
			k=(ys-(yo+i*2+1)-1);
//			if(k>=ys)
			if(k<0)
				{ ublk[i*8+j]=0; vblk[i*8+j]=0; continue; }

			ib0=img+(((ys-(yo+i*2+0)-1)*xs)+xo+j*2)*ssz;
			ib1=img+(((ys-(yo+i*2+1)-1)*xs)+xo+j*2)*ssz;
			obu=ublk+(i*8)+j; obv=vblk+(i*8)+j;

			cr=(ib0[0]+ib0[ssz+0]+ib1[0]+ib1[ssz+0])>>2;
			cg=(ib0[1]+ib0[ssz+1]+ib1[1]+ib1[ssz+1])>>2;
			cb=(ib0[2]+ib0[ssz+2]+ib1[2]+ib1[ssz+2])>>2;
			cu=-11056*cr -21712*cg +32768*cb;
			cv= 32768*cr -27440*cg - 5328*cb;
			obu[0]=((cu+32768)>>16)+128;
			obv[0]=((cv+32768)>>16)+128;
		}

		return;
	}

	if(ssz==4)
	{
		for(i=0; i<8; i++)
		{
			ib0=img+(((ys-(yo+i*2+0)-1)*xs)+xo)*ssz;
			ib1=img+(((ys-(yo+i*2+1)-1)*xs)+xo)*ssz;
			obu=ublk+(i*8); obv=vblk+(i*8);

			for(j=0; j<2; j++)
			{
				cr=(ib0[0]+ib0[4]+ib1[0]+ib1[4])>>2;
				cg=(ib0[1]+ib0[5]+ib1[1]+ib1[5])>>2;
				cb=(ib0[2]+ib0[6]+ib1[2]+ib1[6])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[0]=((cu+32768)>>16)+128;
				obv[0]=((cv+32768)>>16)+128;

				cr=(ib0[ 8]+ib0[12]+ib1[ 8]+ib1[12])>>2;
				cg=(ib0[ 9]+ib0[13]+ib1[ 9]+ib1[13])>>2;
				cb=(ib0[10]+ib0[14]+ib1[10]+ib1[14])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[1]=((cu+32768)>>16)+128;
				obv[1]=((cv+32768)>>16)+128;

				cr=(ib0[16]+ib0[20]+ib1[16]+ib1[20])>>2;
				cg=(ib0[17]+ib0[21]+ib1[17]+ib1[21])>>2;
				cb=(ib0[18]+ib0[22]+ib1[18]+ib1[22])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[2]=((cu+32768)>>16)+128;
				obv[2]=((cv+32768)>>16)+128;

				cr=(ib0[24]+ib0[28]+ib1[24]+ib1[28])>>2;
				cg=(ib0[25]+ib0[29]+ib1[25]+ib1[29])>>2;
				cb=(ib0[26]+ib0[30]+ib1[26]+ib1[30])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[3]=((cu+32768)>>16)+128;
				obv[3]=((cv+32768)>>16)+128;

				ib0+=32; ib1+=32; obu+=4; obv+=4;
			}
		}
	}else
	{
		for(i=0; i<8; i++)
		{
			ib0=img+(((ys-(yo+i*2+0)-1)*xs)+xo)*ssz;
			ib1=img+(((ys-(yo+i*2+1)-1)*xs)+xo)*ssz;
			obu=ublk+(i*8); obv=vblk+(i*8);

			for(j=0; j<8; j++)
			{
				cr=(ib0[0]+ib0[ssz+0]+ib1[0]+ib1[ssz+0])>>2;
				cg=(ib0[1]+ib0[ssz+1]+ib1[1]+ib1[ssz+1])>>2;
				cb=(ib0[2]+ib0[ssz+2]+ib1[2]+ib1[ssz+2])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[0]=((cu+32768)>>16)+128;
				obv[0]=((cv+32768)>>16)+128;
				ib0+=2*ssz; ib1+=2*ssz; obu++; obv++;
			}
		}
	}
}

void BTJ_JFE_GetImgBlk2UV_BGR(
	short *ublk, short *vblk, int xo, int yo,
	byte *img, int xs, int ys, int xs2, int ys2, int ssz)
{
	byte *ib0, *ib1;
	short *obu, *obv;
	int cr, cg, cb, cu, cv;
	int i, j, k;

//	if(((xo+16)>xs) || ((2*ys2-yo-1)>ys))
	if(((xo+16)>xs) || ((ys-yo-16)<0))
	{
		//goes off edge of image
		for(i=0; i<8; i++)
			for(j=0; j<8; j++)
		{
			k=(ys-(yo+i*2+1)-1);
			if(((xo+2*j+1)>=xs) || (k<0))
				{ ublk[i*8+j]=0; vblk[i*8+j]=0; continue; }

			ib0=img+(((ys-(yo+i*2+0)-1)*xs)+xo+j*2)*ssz;
			ib1=img+(((ys-(yo+i*2+1)-1)*xs)+xo+j*2)*ssz;
			obu=ublk+(i*8)+j; obv=vblk+(i*8)+j;

			cb=(ib0[0]+ib0[ssz+0]+ib1[0]+ib1[ssz+0])>>2;
			cg=(ib0[1]+ib0[ssz+1]+ib1[1]+ib1[ssz+1])>>2;
			cr=(ib0[2]+ib0[ssz+2]+ib1[2]+ib1[ssz+2])>>2;
			cu=-11056*cr -21712*cg +32768*cb;
			cv= 32768*cr -27440*cg - 5328*cb;
			obu[0]=((cu+32768)>>16)+128;
			obv[0]=((cv+32768)>>16)+128;
		}

		return;
	}

	if(ssz==4)
	{
		for(i=0; i<8; i++)
		{
			ib0=img+(((ys-(yo+i*2+0)-1)*xs)+xo)*ssz;
			ib1=img+(((ys-(yo+i*2+1)-1)*xs)+xo)*ssz;
			obu=ublk+(i*8); obv=vblk+(i*8);

			for(j=0; j<2; j++)
			{
				cb=(ib0[0]+ib0[4]+ib1[0]+ib1[4])>>2;
				cg=(ib0[1]+ib0[5]+ib1[1]+ib1[5])>>2;
				cr=(ib0[2]+ib0[6]+ib1[2]+ib1[6])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[0]=((cu+32768)>>16)+128;
				obv[0]=((cv+32768)>>16)+128;

				cb=(ib0[ 8]+ib0[12]+ib1[ 8]+ib1[12])>>2;
				cg=(ib0[ 9]+ib0[13]+ib1[ 9]+ib1[13])>>2;
				cr=(ib0[10]+ib0[14]+ib1[10]+ib1[14])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[1]=((cu+32768)>>16)+128;
				obv[1]=((cv+32768)>>16)+128;

				cb=(ib0[16]+ib0[20]+ib1[16]+ib1[20])>>2;
				cg=(ib0[17]+ib0[21]+ib1[17]+ib1[21])>>2;
				cr=(ib0[18]+ib0[22]+ib1[18]+ib1[22])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[2]=((cu+32768)>>16)+128;
				obv[2]=((cv+32768)>>16)+128;

				cb=(ib0[24]+ib0[28]+ib1[24]+ib1[28])>>2;
				cg=(ib0[25]+ib0[29]+ib1[25]+ib1[29])>>2;
				cr=(ib0[26]+ib0[30]+ib1[26]+ib1[30])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[3]=((cu+32768)>>16)+128;
				obv[3]=((cv+32768)>>16)+128;

				ib0+=32; ib1+=32; obu+=4; obv+=4;
			}
		}
	}else
	{
		for(i=0; i<8; i++)
		{
			ib0=img+(((ys-(yo+i*2+0)-1)*xs)+xo)*ssz;
			ib1=img+(((ys-(yo+i*2+1)-1)*xs)+xo)*ssz;
			obu=ublk+(i*8); obv=vblk+(i*8);

			for(j=0; j<8; j++)
			{
				cb=(ib0[0]+ib0[ssz+0]+ib1[0]+ib1[ssz+0])>>2;
				cg=(ib0[1]+ib0[ssz+1]+ib1[1]+ib1[ssz+1])>>2;
				cr=(ib0[2]+ib0[ssz+2]+ib1[2]+ib1[ssz+2])>>2;
				cu=-11056*cr -21712*cg +32768*cb;
				cv= 32768*cr -27440*cg - 5328*cb;
				obu[0]=((cu+32768)>>16)+128;
				obv[0]=((cv+32768)>>16)+128;
				ib0+=2*ssz; ib1+=2*ssz; obu++; obv++;
			}
		}
	}
}

void BTJ_JFE_FilterImageDCT2(byte *ibuf,
	short *ybuf, short *ubuf, short *vbuf, int xs, int ys,
	int qf, int pf)
{
	short ublk[DCTSZ2], vblk[DCTSZ2];
	short blk[DCTSZ2];
	int xs2, ys2, xs3, ys3, ssz;
	int xs2n, ys2n, xs3n, ys3n;
	int x2, y2;
	int i, j, k, l;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	xs2n=xs2/8;
	ys2n=ys2/8;

	xs3n=xs3/8;
	ys3n=ys3/8;

#if 1
	if((pf==BGBBTJ_JPG_RGBA) || (pf==BGBBTJ_JPG_RGB))
	{
		ssz=4;
		if(pf==BGBBTJ_JPG_RGB)ssz=3;
		k=0;
		for(i=0; i<ys3n; i++)
			for(j=0; j<xs3n; j++)
		{
			x2=j*2; y2=i*2;
			l=(y2+0)*xs2n+x2+0;
			BTJ_JFE_GetImgBlk2Y_RGB(blk, x2*DCTSZ, y2*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);
			l++;
			BTJ_JFE_GetImgBlk2Y_RGB(blk, (x2+1)*DCTSZ, y2*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);
			l=(y2+1)*xs2n+x2+0;
			BTJ_JFE_GetImgBlk2Y_RGB(blk, x2*DCTSZ, (y2+1)*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);
			l++;
			BTJ_JFE_GetImgBlk2Y_RGB(blk, (x2+1)*DCTSZ, (y2+1)*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);

			BTJ_JFE_GetImgBlk2UV_RGB(ublk, vblk,
				x2*DCTSZ, y2*DCTSZ, ibuf, xs, ys, xs3, ys3, ssz);
			BTJ_JFE_TransDCT(ublk, ubuf+k*DCTSZ2);
			BTJ_JFE_TransDCT(vblk, vbuf+k*DCTSZ2);
			k++;
		}
		
		return;
	}

	if((pf==BGBBTJ_JPG_BGRA) || (pf==BGBBTJ_JPG_BGR))
	{
		ssz=4;
		if(pf==BGBBTJ_JPG_BGR)ssz=3;
		k=0;
		for(i=0; i<ys3n; i++)
			for(j=0; j<xs3n; j++)
		{
			x2=j*2; y2=i*2;
			l=(y2+0)*xs2n+x2+0;
			BTJ_JFE_GetImgBlk2Y_BGR(blk, x2*DCTSZ, y2*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);
			l++;
			BTJ_JFE_GetImgBlk2Y_BGR(blk, (x2+1)*DCTSZ, y2*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);
			l=(y2+1)*xs2n+x2+0;
			BTJ_JFE_GetImgBlk2Y_BGR(blk, x2*DCTSZ, (y2+1)*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);
			l++;
			BTJ_JFE_GetImgBlk2Y_BGR(blk, (x2+1)*DCTSZ, (y2+1)*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+l*DCTSZ2);

			BTJ_JFE_GetImgBlk2UV_BGR(ublk, vblk,
				x2*DCTSZ, y2*DCTSZ, ibuf, xs, ys, xs3, ys3, ssz);
			BTJ_JFE_TransDCT(ublk, ubuf+k*DCTSZ2);
			BTJ_JFE_TransDCT(vblk, vbuf+k*DCTSZ2);
			k++;
		}
		
		return;
	}
#endif

	if((pf==BGBBTJ_JPG_RGBA) || (pf==BGBBTJ_JPG_BGRA) ||
		(pf==BGBBTJ_JPG_RGB) || (pf==BGBBTJ_JPG_BGR))
	{
		ssz=4;
		if((pf==BGBBTJ_JPG_RGB) || (pf==BGBBTJ_JPG_BGR))ssz=3;
	
		k=0;
		for(i=0; i<(ys2/DCTSZ); i++)
			for(j=0; j<(xs2/DCTSZ); j++)
		{
			BTJ_JFE_GetImgBlk2Y_RGB(blk, j*DCTSZ, i*DCTSZ,
				ibuf, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+k*DCTSZ2);
			k++;
		}
	}else if((pf==BGBBTJ_JPG_ARGB) || (pf==BGBBTJ_JPG_ABGR))
	{
		ssz=4;
		k=0;
		for(i=0; i<(ys2/DCTSZ); i++)
			for(j=0; j<(xs2/DCTSZ); j++)
		{
			BTJ_JFE_GetImgBlk2Y_RGB(blk, j*DCTSZ, i*DCTSZ,
				ibuf+1, xs, ys, xs2, ys2, ssz);
			BTJ_JFE_TransDCT(blk, ybuf+k*DCTSZ2);
			k++;
		}
	}

	if((pf==BGBBTJ_JPG_RGBA) || (pf==BGBBTJ_JPG_RGB))
	{
		ssz=4;
		if(pf==BGBBTJ_JPG_RGB)ssz=3;

		k=0;
		for(i=0; i<(ys3/DCTSZ); i++)
			for(j=0; j<(xs3/DCTSZ); j++)
		{
			BTJ_JFE_GetImgBlk2UV_RGB(ublk, vblk,
				2*j*DCTSZ, 2*i*DCTSZ, ibuf, xs, ys, xs3, ys3, ssz);
			BTJ_JFE_TransDCT(ublk, ubuf+k*DCTSZ2);
			BTJ_JFE_TransDCT(vblk, vbuf+k*DCTSZ2);
			k++;
		}
	}else if((pf==BGBBTJ_JPG_BGRA) || (pf==BGBBTJ_JPG_BGR))
	{
		ssz=4;
		if(pf==BGBBTJ_JPG_BGR)ssz=3;

		k=0;
		for(i=0; i<(ys3/DCTSZ); i++)
			for(j=0; j<(xs3/DCTSZ); j++)
		{
			BTJ_JFE_GetImgBlk2UV_BGR(ublk, vblk,
				2*j*DCTSZ, 2*i*DCTSZ, ibuf, xs, ys, xs3, ys3, ssz);
			BTJ_JFE_TransDCT(ublk, ubuf+k*DCTSZ2);
			BTJ_JFE_TransDCT(vblk, vbuf+k*DCTSZ2);
			k++;
		}
	}else if(pf==BGBBTJ_JPG_ARGB)
	{
		ssz=4; k=0;
		for(i=0; i<(ys3/DCTSZ); i++)
			for(j=0; j<(xs3/DCTSZ); j++)
		{
			BTJ_JFE_GetImgBlk2UV_RGB(ublk, vblk,
				2*j*DCTSZ, 2*i*DCTSZ, ibuf+1, xs, ys, xs3, ys3, ssz);
			BTJ_JFE_TransDCT(ublk, ubuf+k*DCTSZ2);
			BTJ_JFE_TransDCT(vblk, vbuf+k*DCTSZ2);
			k++;
		}
	}else if(pf==BGBBTJ_JPG_ABGR)
	{
		ssz=4; k=0;
		for(i=0; i<(ys3/DCTSZ); i++)
			for(j=0; j<(xs3/DCTSZ); j++)
		{
			BTJ_JFE_GetImgBlk2UV_BGR(ublk, vblk,
				2*j*DCTSZ, 2*i*DCTSZ, ibuf+1, xs, ys, xs3, ys3, ssz);
			BTJ_JFE_TransDCT(ublk, ubuf+k*DCTSZ2);
			BTJ_JFE_TransDCT(vblk, vbuf+k*DCTSZ2);
			k++;
		}
	}
}


void BTJ_JFE_EmitDQT(BGBBTJ_JFE_Context *ctx, int n)
{
	int i;

	*ctx->ct++=0xFF;
	*ctx->ct++=JPG_DQT;

	i=64+3;
	*ctx->ct++=i>>8;
	*ctx->ct++=i&0xFF;

	*ctx->ct++=n;
	for(i=0; i<64; i++)
		*ctx->ct++=ctx->qt[n][btj_jfe_zigzag2[i]];
}

void BTJ_JFE_EmitSOF(BGBBTJ_JFE_Context *ctx, int xs, int ys)
{
	int i;

	*ctx->ct++=0xFF;
	*ctx->ct++=JPG_SOF0;

	i=8+3*3;
	*ctx->ct++=i>>8;	//Lf
	*ctx->ct++=i&0xFF;

	*ctx->ct++=8; 	//P

	*ctx->ct++=ys>>8;	//Y
	*ctx->ct++=ys&0xFF;	//Y
	*ctx->ct++=xs>>8;	//X
	*ctx->ct++=xs&0xFF;	//X

	*ctx->ct++=3;	//Nf

	*ctx->ct++=1;	//Ci
	*ctx->ct++=0x22;	//Hi Vi
	*ctx->ct++=0;	//Tqi
	*ctx->ct++=2;	//Ci
	*ctx->ct++=0x11;	//Hi Vi
	*ctx->ct++=1;	//Tqi
	*ctx->ct++=3;	//Ci
	*ctx->ct++=0x11;	//Hi Vi
	*ctx->ct++=1;	//Tqi
}

void BTJ_JFE_EmitSOS(BGBBTJ_JFE_Context *ctx)
{
	int i;

	*ctx->ct++=0xFF;
	*ctx->ct++=JPG_SOS;

	i=6+3*2;
	*ctx->ct++=i>>8;	//Lf
	*ctx->ct++=i&0xFF;

	*ctx->ct++=3; 	//Ns

	*ctx->ct++=1;	//Csi
	*ctx->ct++=0x00;	//Tdi Tai
	*ctx->ct++=2;	//Csi
	*ctx->ct++=0x11;	//Tdi Tai
	*ctx->ct++=3;	//Csi
	*ctx->ct++=0x11;	//Tdi Tai

	*ctx->ct++=0; 	//Ss
	*ctx->ct++=63; 	//Se
	*ctx->ct++=0x00; 	//Ah Al
}

void BTJ_JFE_EmitDHT(BGBBTJ_JFE_Context *ctx, int tab)
{
	byte *p;
	int i, j, k;

	*ctx->ct++=0xFF;
	*ctx->ct++=JPG_DHT;

	p=ctx->ct;
	*ctx->ct++=0;	//Lf
	*ctx->ct++=0;

	i=(tab/2)|((tab&1)<<4);
	*ctx->ct++=i; 	//Tc Th

//	tab<<=8;
	for(i=1; i<=16; i++)
	{
		k=0;
		for(j=0; j<256; j++)
			if(btj_jfeh_len[tab][j]==i)
				k++;
		*ctx->ct++=k; 	//Li
	}

	k=0;
	for(i=1; i<=16; i++)
	{
		k<<=1;
		for(j=0; j<256; j++)
			if(btj_jfeh_len[tab][j]==i)
		{
			*ctx->ct++=j; 	//Vi
			btj_jfeh_code[tab][j]=k++;
		}
	}

//	printf("DHT %04X\n", k);

	i=ctx->ct-p;
	p[0]=i>>8;	//Lf
	p[1]=i&0xFF;
}

void BTJ_JFE_EmitDHT2(BGBBTJ_JFE_Context *ctx)
{
	static int init=0;
	static byte *tab=NULL;
	static int tabsz;
	byte *ct0;
	int i;
	
	if(!init)
	{
		ct0=ctx->ct;
		BTJ_JFE_EmitDHT(ctx, 0);
		BTJ_JFE_EmitDHT(ctx, 1);
		BTJ_JFE_EmitDHT(ctx, 2);
		BTJ_JFE_EmitDHT(ctx, 3);
		i=ctx->ct-ct0;
		tab=malloc(i);
		tabsz=i;
		memcpy(tab, ct0, i);
		init=1;
		return;
	}
	
	memcpy(ctx->ct, tab, tabsz);
	ctx->ct+=tabsz;
}

static const int pdjpg_ijg_qtab_y[64] = {
16, 11, 10, 16,  24,  40,  51,  61,
12, 12, 14, 19,  26,  58,  60,  55,
14, 13, 16, 24,  40,  57,  69,  56,
14, 17, 22, 29,  51,  87,  80,  62,
18, 22, 37, 56,  68, 109, 103,  77,
24, 35, 55, 64,  81, 104, 113,  92,
49, 64, 78, 87, 103, 121, 120, 101,
72, 92, 95, 98, 112, 100, 103,  99};

static const int pdjpg_ijg_qtab_uv[64] = {
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
99, 99, 99, 99, 99, 99, 99, 99,
47, 66, 99, 99, 99, 99, 99, 99,
24, 26, 56, 99, 99, 99, 99, 99,
18, 21, 26, 66, 99, 99, 99, 99,
17, 18, 24, 47, 99, 99, 99, 99};

void BTJ_JFE_MakeQuantTabFastIJG_Y(byte *tab, float qf)
{
	double s, q;
	int i, j;

	q=(qf*100);
	s=(q<50)?5000/q:(200-2*q);
	for(i=0; i<64; i++)
	{
		j=(int)((s * pdjpg_ijg_qtab_y[i]+50)/100);
		j=(j<1)?1:((j<256)?j:255);
		tab[i]=j;
	}
}

void BTJ_JFE_MakeQuantTabFastIJG_UV(byte *tab, float qf)
{
	double s, q;
	int i, j;

	q=(qf*100);
	s=(q<50)?5000/q:(200-2*q);
	for(i=0; i<64; i++)
	{
		j=(int)((s*pdjpg_ijg_qtab_uv[i]+50)/100);
		j=(j<1)?1:((j<256)?j:255);
		tab[i]=j;
	}
}


BGBBTJ_API BGBBTJ_JFE_Context *BTJ_JFE_AllocContext(void)
{
	BGBBTJ_JFE_Context *ctx;
	
	ctx=gcalloc(sizeof(BGBBTJ_JFE_Context));
	return(ctx);
}

BGBBTJ_API void BTJ_JFE_FreeContext(
	BGBBTJ_JFE_Context *ctx)
{
	gcfree(ctx);
}

BGBBTJ_API void BTJ_JFE_FlushEncodeFast(
	BGBBTJ_JFE_Context *ctx)
{
}

BGBBTJ_API int BTJ_JFE_EncodeFast(byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	static BGBBTJ_JFE_Context cctx;
//	memset(&cctx, 0, sizeof(BGBBTJ_JFE_Context));
	return(BTJ_JFE_EncodeFastCtx(&cctx, ibuf, obuf,
		xs, ys, qf, pf));
}

BGBBTJ_API int BTJ_JFE_EncodeFast2(byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	BGBBTJ_JFE_Context cctx;
	int i;
	
	memset(&cctx, 0, sizeof(BGBBTJ_JFE_Context));
	i=BTJ_JFE_EncodeFastCtx(&cctx, ibuf, obuf,
		xs, ys, qf, pf);
	return(i);
}

BGBBTJ_API int BTJ_JFE_EncodeFastCtx(
	BGBBTJ_JFE_Context *ctx,
	byte *ibuf, byte *obuf,
	int xs, int ys, int qf, int pf)
{
	short *tp;
	int xs2, ys2, xs3, ys3;
	int xs2b, ys2b, xs3b, ys3b;
	int i, j, k, l, n;

	xs2=((xs+7)/8)*8;
	ys2=((ys+7)/8)*8;
	xs3=((xs+15)/16)*8;
	ys3=((ys+15)/16)*8;

	if(!ctx->ydb || (xs!=ctx->lxs) || (ys!=ctx->lys))
	{
		if(ctx->ydb)
		{
			free(ctx->ydb);
			free(ctx->udb);
			free(ctx->vdb);
		}

		ctx->ydb=malloc((xs2+8)*(ys2+16)*sizeof(short));
		ctx->udb=malloc((xs3+8)*(ys3+8)*sizeof(short));
		ctx->vdb=malloc((xs3+8)*(ys3+8)*sizeof(short));

		ctx->lxs=xs;
		ctx->lys=ys;
	}

	BTJ_JFE_FilterImageDCT2(ibuf,
		ctx->ydb, ctx->udb, ctx->vdb, xs, ys, qf, pf);

	if(qf!=ctx->lqf)
	{
		BTJ_JFE_MakeQuantTabFastIJG_Y(ctx->qt[0], (qf&255)/100.0);
		BTJ_JFE_MakeQuantTabFastIJG_UV(ctx->qt[1], (qf&255)/100.0);
		BTJ_JFEH_SetupQuantTabDivFP(ctx, 0);
		BTJ_JFEH_SetupQuantTabDivFP(ctx, 1);
		ctx->lqf=qf;
	}

	xs2b=xs2/8; ys2b=ys2/8;
	xs3b=xs3/8; ys3b=ys3/8;

	l=0;
	for(i=0; i<ys3b; i++)
		for(j=0; j<xs3b; j++)
	{
		tp=ctx->ydb+((i*2+0)*xs2b+j*2+0)*64;
		BTJ_JFEH_QuantBlock(ctx, tp, tp, 0);
		tp[0]-=l; l=tp[0]+l;

		tp=ctx->ydb+((i*2+0)*xs2b+j*2+1)*64;
		BTJ_JFEH_QuantBlock(ctx, tp, tp, 0);
		tp[0]-=l; l=tp[0]+l;

		tp=ctx->ydb+((i*2+1)*xs2b+j*2+0)*64;
		BTJ_JFEH_QuantBlock(ctx, tp, tp, 0);
		tp[0]-=l; l=tp[0]+l;

		tp=ctx->ydb+((i*2+1)*xs2b+j*2+1)*64;
		BTJ_JFEH_QuantBlock(ctx, tp, tp, 0);
		tp[0]-=l; l=tp[0]+l;
	}

	j=xs3b*ys3b; k=0; l=0;
	for(i=0; i<j; i++)
	{
		BTJ_JFEH_QuantBlock(ctx, ctx->udb+i*64, ctx->udb+i*64, 1);
		BTJ_JFEH_QuantBlock(ctx, ctx->vdb+i*64, ctx->vdb+i*64, 1);
		ctx->udb[i*64+0]-=k; k=ctx->udb[i*64+0]+k;
		ctx->vdb[i*64+0]-=l; l=ctx->vdb[i*64+0]+l;
	}

	ctx->ct=obuf;
	ctx->win=0;
	ctx->pos=32;

	*ctx->ct++=0xFF;
	*ctx->ct++=JPG_SOI;

	BTJ_JFE_EmitDQT(ctx, 0);
	BTJ_JFE_EmitDQT(ctx, 1);

	BTJ_JFE_EmitSOF(ctx, xs, ys);

	BTJ_JFE_EmitDHT2(ctx);

//	BTJ_JFE_EmitDHT(ctx, 0);
//	BTJ_JFE_EmitDHT(ctx, 1);
//	BTJ_JFE_EmitDHT(ctx, 2);
//	BTJ_JFE_EmitDHT(ctx, 3);

	BTJ_JFE_EmitSOS(ctx);

	for(i=0; i<ys3b; i++)
		for(j=0; j<xs3b; j++)
	{
		BTJ_JFEH_EncodeBlock(ctx, ctx->ydb+((i*2+0)*xs2b+j*2+0)*64, 0, 1);
		BTJ_JFEH_EncodeBlock(ctx, ctx->ydb+((i*2+0)*xs2b+j*2+1)*64, 0, 1);
		BTJ_JFEH_EncodeBlock(ctx, ctx->ydb+((i*2+1)*xs2b+j*2+0)*64, 0, 1);
		BTJ_JFEH_EncodeBlock(ctx, ctx->ydb+((i*2+1)*xs2b+j*2+1)*64, 0, 1);

		k=i*xs3b+j;
		BTJ_JFEH_EncodeBlock(ctx, ctx->udb+k*64, 2, 3);
		BTJ_JFEH_EncodeBlock(ctx, ctx->vdb+k*64, 2, 3);
	}

	BTJ_JFEH_FlushBits(ctx);

	*ctx->ct++=0xFF;
	*ctx->ct++=JPG_EOI;

	i=ctx->ct-obuf;

	return(i);
}
/*
DXTn Fast Mip-Mapping
*/

#include <bgbbtj.h>

//0000 -> 00
//0001 -> 01
//0010 -> 01
//0011 -> 10
//0100 -> 01
//0101 -> 01
//0110 -> 10
//0111 -> 10
//1000 -> 01
//1001 -> 10
//1010 -> 10
//1011 -> 10
//1100 -> 10
//1101 -> 10
//1110 -> 11
//1111 -> 11

static int bgbbtj_bcnmip_horizlut4[16]=
{
0,1,1,2, 1,1,2,2, 1,2,2,2, 2,2,3,3
};

static int bgbbtj_bcnmip_vertilut4[16]=
{
0x00, 0x01, 0x02, 0x03,
0x10, 0x11, 0x12, 0x13,
0x20, 0x21, 0x22, 0x23,
0x30, 0x31, 0x32, 0x33,
};

static int bgbbtj_bcnmip_horizlut[256];
static int bgbbtj_bcnmip_vertilut[256];
static byte *bgbbtj_bcnmip_horzlut;
static byte *bgbbtj_bcnmip_vertlut;

void BGBBTJ_BCnMip_Init()
{
	static int init=0;
	int i, j;

	if(init)return;
	init=1;
	
	for(i=0; i<256; i++)
	{
		bgbbtj_bcnmip_horizlut[i]=
			(bgbbtj_bcnmip_horizlut4[i>>4]<<2)|
			 bgbbtj_bcnmip_horizlut4[i&15];

		bgbbtj_bcnmip_vertilut[i]=
			(bgbbtj_bcnmip_vertilut4[i>>4]<<8)|
			 bgbbtj_bcnmip_vertilut4[i&15];
	}
	
	bgbbtj_bcnmip_horzlut=malloc(65536);
	bgbbtj_bcnmip_vertlut=malloc(65536);

	for(i=0; i<65536; i++)
	{
		bgbbtj_bcnmip_horzlut[i]=
			(bgbbtj_bcnmip_horizlut[(i>>8)&255]<<4)|
			 bgbbtj_bcnmip_horizlut[(i>>0)&255];

		j=(	bgbbtj_bcnmip_vertilut[(i>>8)&255]<<2)|
			bgbbtj_bcnmip_vertilut[(i>>0)&255];
		bgbbtj_bcnmip_vertlut[i]=
			(bgbbtj_bcnmip_horizlut[(j>>8)&255]<<4)|
			 bgbbtj_bcnmip_horizlut[(j>>0)&255];
	}
}

void BGBBTJ_BCnMip_MergeBlockHorizDXT5B(byte *dst, byte *srca, byte *srcb)
{
	byte clr[16], clrb[8];
	int i, j;
	
	clr[ 0]=srca[1]&0xF8;
	clr[ 1]=((srca[1]<<5)|(srca[0]>>3))&0xFC;
	clr[ 2]=(srca[0]<<3)&0xF8;
	clr[ 4]=srca[3]&0xF8;
	clr[ 5]=((srca[3]<<5)|(srca[2]>>3))&0xFC;
	clr[ 6]=(srca[2]<<3)&0xF8;
	clr[ 8]=srcb[1]&0xF8;
	clr[ 9]=((srcb[1]<<5)|(srcb[0]>>3))&0xFC;
	clr[10]=(srcb[0]<<3)&0xF8;
	clr[12]=srcb[3]&0xF8;
	clr[13]=((srcb[3]<<5)|(srcb[2]>>3))&0xFC;
	clr[14]=(srcb[2]<<3)&0xF8;
	
	clrb[0]=(clr[0]+clr[ 8]+1)>>1;
	clrb[1]=(clr[1]+clr[ 9]+1)>>1;
	clrb[2]=(clr[2]+clr[10]+1)>>1;
	clrb[4]=(clr[4]+clr[12]+1)>>1;
	clrb[5]=(clr[5]+clr[13]+1)>>1;
	clrb[6]=(clr[6]+clr[14]+1)>>1;

	i=((clrb[0]<<8)&0xF800) | ((clrb[1]<<3)&0x07E0) | (clrb[2]>>3);
	j=((clrb[4]<<8)&0xF800) | ((clrb[5]<<3)&0x07E0) | (clrb[6]>>3);
	dst[0]=i;		dst[1]=i>>8;
	dst[2]=j;		dst[3]=j>>8;

	if(i==j)
	{
		dst[4]=0;	dst[5]=0;
		dst[6]=0;	dst[7]=0;
		return;
	}

//	dst[4]=(bgbbtj_bcnmip_horizlut[srca[4]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[4]];
//	dst[5]=(bgbbtj_bcnmip_horizlut[srca[5]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[5]];
//	dst[6]=(bgbbtj_bcnmip_horizlut[srca[6]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[6]];
//	dst[7]=(bgbbtj_bcnmip_horizlut[srca[7]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[7]];

	dst[4]=bgbbtj_bcnmip_horzlut[(srca[4]<<8)|srcb[4]];
	dst[5]=bgbbtj_bcnmip_horzlut[(srca[5]<<8)|srcb[5]];
	dst[6]=bgbbtj_bcnmip_horzlut[(srca[6]<<8)|srcb[6]];
	dst[7]=bgbbtj_bcnmip_horzlut[(srca[7]<<8)|srcb[7]];
}

void BGBBTJ_BCnMip_MergeBlockVertDXT5B(byte *dst, byte *srca, byte *srcb)
{
	byte clr[16], clrb[8];
	int i, j;
	
	clr[ 0]=srca[1]&0xF8;
	clr[ 1]=((srca[1]<<5)|(srca[0]>>3))&0xFC;
	clr[ 2]=(srca[0]<<3)&0xF8;
	clr[ 4]=srca[3]&0xF8;
	clr[ 5]=((srca[3]<<5)|(srca[2]>>3))&0xFC;
	clr[ 6]=(srca[2]<<3)&0xF8;
	clr[ 8]=srcb[1]&0xF8;
	clr[ 9]=((srcb[1]<<5)|(srcb[0]>>3))&0xFC;
	clr[10]=(srcb[0]<<3)&0xF8;
	clr[12]=srcb[3]&0xF8;
	clr[13]=((srcb[3]<<5)|(srcb[2]>>3))&0xFC;
	clr[14]=(srcb[2]<<3)&0xF8;
	
	clrb[0]=(clr[0]+clr[ 8]+1)>>1;
	clrb[1]=(clr[1]+clr[ 9]+1)>>1;
	clrb[2]=(clr[2]+clr[10]+1)>>1;
	clrb[4]=(clr[4]+clr[12]+1)>>1;
	clrb[5]=(clr[5]+clr[13]+1)>>1;
	clrb[6]=(clr[6]+clr[14]+1)>>1;

	i=((clrb[0]<<8)&0xF800) | ((clrb[1]<<3)&0x07E0) | (clrb[2]>>3);
	j=((clrb[4]<<8)&0xF800) | ((clrb[5]<<3)&0x07E0) | (clrb[6]>>3);
	dst[0]=i;		dst[1]=i>>8;
	dst[2]=j;		dst[3]=j>>8;

	if(i==j)
	{
		dst[4]=0;	dst[5]=0;
		dst[6]=0;	dst[7]=0;
		return;
	}

//	dst[4]=(bgbbtj_bcnmip_horizlut[srca[4]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[4]];
//	dst[5]=(bgbbtj_bcnmip_horizlut[srca[5]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[5]];
//	dst[6]=(bgbbtj_bcnmip_horizlut[srca[6]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[6]];
//	dst[7]=(bgbbtj_bcnmip_horizlut[srca[7]]<<4)|
//		bgbbtj_bcnmip_horizlut[srcb[7]];

	dst[4]=bgbbtj_bcnmip_vertlut[(srca[4]<<8)|srcb[4]];
	dst[5]=bgbbtj_bcnmip_vertlut[(srca[5]<<8)|srcb[5]];
	dst[6]=bgbbtj_bcnmip_vertlut[(srca[6]<<8)|srcb[6]];
	dst[7]=bgbbtj_bcnmip_vertlut[(srca[7]<<8)|srcb[7]];
}

void BGBBTJ_BCnMip_MergeBlockDXT5C(byte *dst,
	byte *srca, byte *srcb,
	byte *srcc, byte *srcd)
{
	static const char idxtab[16]=
		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };

	byte *srcn[4];
	short clrn[4][8];
	short clyn[4][4];
	short pxyn[4][16];
	short clr[8];
	short pxy[16];
	int mcy, ncy, acy;
	int mcr, mcg, mcb;
	int ncr, ncg, ncb;
	int p0, p1, p2, p3;
	int l0, l1, l2, l3;
	int i, j, k, l;
	
	srcn[0]=srca; srcn[1]=srcb;
	srcn[2]=srcc; srcn[3]=srcd;
	mcy=512; ncy=-512;
	for(i=0; i<4; i++)
	{
		clrn[i][0]=srcn[i][1]&0xF8 + 4;
		clrn[i][1]=((srcn[i][1]<<5)|(srcn[i][0]>>3))&0xFC + 2;
		clrn[i][2]=(srcn[i][0]<<3)&0xF8 + 4;
		clrn[i][3]=(clrn[i][0]+2*clrn[i][1]+clrn[i][2]+2)>>2;
		clrn[i][4]=srcn[i][3]&0xF8 + 4;
		clrn[i][5]=((srcn[i][3]<<5)|(srcn[i][2]>>3))&0xFC + 2;
		clrn[i][6]=(srcn[i][2]<<3)&0xF8 + 4;
		clrn[i][7]=(clrn[i][4]+2*clrn[i][5]+clrn[i][6]+2)>>2;

		if(clrn[i][3]<mcy)
		{
			clr[0]=clrn[i][0];
			clr[1]=clrn[i][1];
			clr[2]=clrn[i][2];
			mcy=clrn[i][3];
		}

		if(clrn[i][7]>ncy)
		{
			clr[4]=clrn[i][4];
			clr[5]=clrn[i][5];
			clr[6]=clrn[i][6];
			ncy=clrn[i][7];
		}

		clyn[i][0]=clrn[i][3];
		clyn[i][1]=clrn[i][7];
		clyn[i][2]=(11*clyn[i][0]+ 5*clyn[i][1]+8)>>4;
		clyn[i][3]=( 5*clyn[i][0]+11*clyn[i][1]+8)>>4;

		j=srcn[i][4];
		pxyn[i][ 0]=clyn[i][(j>>6)&3];
		pxyn[i][ 1]=clyn[i][(j>>4)&3];
		pxyn[i][ 2]=clyn[i][(j>>2)&3];
		pxyn[i][ 3]=clyn[i][(j>>0)&3];
		j=srcn[i][5];
		pxyn[i][ 4]=clyn[i][(j>>6)&3];
		pxyn[i][ 5]=clyn[i][(j>>4)&3];
		pxyn[i][ 6]=clyn[i][(j>>2)&3];
		pxyn[i][ 7]=clyn[i][(j>>0)&3];
		j=srcn[i][6];
		pxyn[i][ 8]=clyn[i][(j>>6)&3];
		pxyn[i][ 9]=clyn[i][(j>>4)&3];
		pxyn[i][10]=clyn[i][(j>>2)&3];
		pxyn[i][11]=clyn[i][(j>>0)&3];
		j=srcn[i][7];
		pxyn[i][12]=clyn[i][(j>>6)&3];
		pxyn[i][13]=clyn[i][(j>>4)&3];
		pxyn[i][14]=clyn[i][(j>>2)&3];
		pxyn[i][15]=clyn[i][(j>>0)&3];
	}

#if 1
	mcr=(clrn[0][0]+clrn[1][0]+clrn[2][0]+clrn[3][0]+2)>>2;
	mcg=(clrn[0][1]+clrn[1][1]+clrn[2][1]+clrn[3][1]+2)>>2;
	mcb=(clrn[0][2]+clrn[1][2]+clrn[2][2]+clrn[3][2]+2)>>2;

	ncr=(clrn[0][4]+clrn[1][4]+clrn[2][4]+clrn[3][4]+2)>>2;
	ncg=(clrn[0][5]+clrn[1][5]+clrn[2][5]+clrn[3][5]+2)>>2;
	ncb=(clrn[0][6]+clrn[1][6]+clrn[2][6]+clrn[3][6]+2)>>2;
	
	l0=(mcr+2*mcg+mcb+2)>>2;
	l1=(ncr+2*ncg+ncb+2)>>2;
	if(l0) { l2=(256*mcy)/l0; }
	if(l1) { l3=(256*ncy)/l1; }
	
	mcr=(mcr*l2+128)>>8;
	mcg=(mcg*l2+128)>>8;
	mcb=(mcb*l2+128)>>8;
	ncr=(ncr*l3+128)>>8;
	ncg=(ncg*l3+128)>>8;
	ncb=(ncb*l3+128)>>8;
#endif

//	mcr=clr[0]; mcg=clr[1]; mcb=clr[2];
//	ncr=clr[4]; ncg=clr[5]; ncb=clr[6];

	mcr=((mcr+3)>>3)<<3;
	mcg=((mcg+1)>>2)<<2;
	mcb=((mcb+3)>>3)<<3;
	ncr=((ncr+5)>>3)<<3;
	ncg=((ncg+3)>>2)<<2;
	ncb=((ncb+5)>>3)<<3;

	mcr=(mcr<0)?0:((mcr>255)?255:mcr);
	mcg=(mcg<0)?0:((mcg>255)?255:mcg);
	mcb=(mcb<0)?0:((mcb>255)?255:mcb);
	ncr=(ncr<0)?0:((ncr>255)?255:ncr);
	ncg=(ncg<0)?0:((ncg>255)?255:ncg);
	ncb=(ncb<0)?0:((ncb>255)?255:ncb);

	i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
	j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);

//	i=((clr[0]<<8)&0xF800) | ((clr[1]<<3)&0x07E0) | (clr[2]>>3);
//	j=((clr[4]<<8)&0xF800) | ((clr[5]<<3)&0x07E0) | (clr[6]>>3);
	dst[0]=i;		dst[1]=i>>8;
	dst[2]=j;		dst[3]=j>>8;

	if(i==j)
	{
		dst[4]=0;	dst[5]=0;
		dst[6]=0;	dst[7]=0;
		return;
	}
	
	for(i=0; i<2; i++)
		for(j=0; j<2; j++)
	{
		k=i*8+j*2; l=i*2+j;
		pxy[k+0]=(pxyn[l][ 0]+pxyn[l][ 1]+pxyn[l][ 4]+pxyn[l][ 5])>>2;
		pxy[k+1]=(pxyn[l][ 2]+pxyn[l][ 3]+pxyn[l][ 6]+pxyn[l][ 7])>>2;
		pxy[k+4]=(pxyn[l][ 8]+pxyn[l][ 9]+pxyn[l][12]+pxyn[l][13])>>2;
		pxy[k+5]=(pxyn[l][10]+pxyn[l][11]+pxyn[l][14]+pxyn[l][15])>>2;
	}
	
#if 0
	pxy[ 0]=(pxyn[0][ 0]+pxyn[0][ 1]+pxyn[0][ 4]+pxyn[0][ 5])>>2;
	pxy[ 1]=(pxyn[0][ 2]+pxyn[0][ 3]+pxyn[0][ 6]+pxyn[0][ 7])>>2;
	pxy[ 2]=(pxyn[1][ 0]+pxyn[1][ 1]+pxyn[1][ 4]+pxyn[1][ 5])>>2;
	pxy[ 3]=(pxyn[1][ 2]+pxyn[1][ 3]+pxyn[1][ 6]+pxyn[1][ 7])>>2;
	pxy[ 4]=(pxyn[0][ 8]+pxyn[0][ 9]+pxyn[0][ 8]+pxyn[0][ 9])>>2;
	pxy[ 5]=(pxyn[0][10]+pxyn[0][11]+pxyn[0][14]+pxyn[0][15])>>2;
	pxy[ 6]=(pxyn[1][ 8]+pxyn[1][ 9]+pxyn[1][10]+pxyn[1][11])>>2;
	pxy[ 7]=(pxyn[1][10]+pxyn[1][11]+pxyn[1][14]+pxyn[1][15])>>2;
	pxy[ 8]=(pxyn[2][ 0]+pxyn[2][ 1]+pxyn[2][ 4]+pxyn[2][ 5])>>2;
	pxy[ 9]=(pxyn[2][ 2]+pxyn[2][ 3]+pxyn[2][ 6]+pxyn[2][ 7])>>2;
	pxy[10]=(pxyn[3][ 0]+pxyn[3][ 1]+pxyn[3][ 4]+pxyn[3][ 5])>>2;
	pxy[11]=(pxyn[3][ 2]+pxyn[3][ 3]+pxyn[3][ 6]+pxyn[3][ 7])>>2;
	pxy[12]=(pxyn[2][ 8]+pxyn[2][ 9]+pxyn[2][ 8]+pxyn[2][ 9])>>2;
	pxy[13]=(pxyn[2][10]+pxyn[2][11]+pxyn[2][14]+pxyn[2][15])>>2;
	pxy[14]=(pxyn[3][ 8]+pxyn[3][ 9]+pxyn[3][10]+pxyn[3][11])>>2;
	pxy[15]=(pxyn[3][10]+pxyn[3][11]+pxyn[3][14]+pxyn[3][15])>>2;
#endif

	acy=(mcy+ncy)>>1;			//Median Luma
	l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
	l3=-2048;

	p0=idxtab[(((pxy[ 0]-acy)*l1+l3)>>13)+8];
	p1=idxtab[(((pxy[ 1]-acy)*l1+l3)>>13)+8];
	p2=idxtab[(((pxy[ 2]-acy)*l1+l3)>>13)+8];
	p3=idxtab[(((pxy[ 3]-acy)*l1+l3)>>13)+8];
	dst[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[ 4]-acy)*l1+l3)>>13)+8];
	p1=idxtab[(((pxy[ 5]-acy)*l1+l3)>>13)+8];
	p2=idxtab[(((pxy[ 6]-acy)*l1+l3)>>13)+8];
	p3=idxtab[(((pxy[ 7]-acy)*l1+l3)>>13)+8];
	dst[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[ 8]-acy)*l1+l3)>>13)+8];
	p1=idxtab[(((pxy[ 9]-acy)*l1+l3)>>13)+8];
	p2=idxtab[(((pxy[10]-acy)*l1+l3)>>13)+8];
	p3=idxtab[(((pxy[11]-acy)*l1+l3)>>13)+8];
	dst[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[12]-acy)*l1+l3)>>13)+8];
	p1=idxtab[(((pxy[13]-acy)*l1+l3)>>13)+8];
	p2=idxtab[(((pxy[14]-acy)*l1+l3)>>13)+8];
	p3=idxtab[(((pxy[15]-acy)*l1+l3)>>13)+8];
	dst[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
}


void BGBBTJ_BCnMip_MergeBlockDXT5B(byte *dst,
	byte *srca, byte *srcb,
	byte *srcc, byte *srcd)
{
//	byte tmpa[8], tmpb[8];

//	BGBBTJ_BCnMip_MergeBlockHorizDXT5B(tmpa, srca, srcb);
//	BGBBTJ_BCnMip_MergeBlockHorizDXT5B(tmpb, srcc, srcd);
//	BGBBTJ_BCnMip_MergeBlockVertDXT5B(dst, tmpa, tmpb);

	BGBBTJ_BCnMip_MergeBlockDXT5C(dst, srca, srcb, srcc, srcd);
}

BGBBTJ_API void BGBBTJ_BCnMip_MergeDXT5B(
	byte *dst, byte *src, int xs, int ys, int stride)
{
	byte *srca, *srcb, *srcc, *srcd, *dsta;
	int xs2, ys2;
	int xs3, ys3;
	int i, j, k;

	if((xs<=4) || (ys<=4))
	{
		BGBBTJ_BCnMip_MergeBlockDXT5B(dst, src, src, src, src);
		return;
	}

	if((xs<=8) || (ys<=8))
	{
		srca=src+0*stride; srcb=src+1*stride;
		srcc=src+2*stride; srcd=src+3*stride;
		BGBBTJ_BCnMip_MergeBlockDXT5B(dst, srca, srcb, srcc, srcd);
		return;
	}

	xs2=xs>>2; ys2=ys>>2;
	xs3=xs>>3; ys3=ys>>3;

	for(i=0; i<ys3; i++)
		for(j=0; j<xs3; j++)
	{
		k=(i*2+0)*xs2+(j*2+0); srca=src+k*stride;
		k=(i*2+0)*xs2+(j*2+1); srcb=src+k*stride;
		k=(i*2+1)*xs2+(j*2+0); srcc=src+k*stride;
		k=(i*2+1)*xs2+(j*2+1); srcd=src+k*stride;
		k=i*xs3+j; dsta=dst+k*stride;
		BGBBTJ_BCnMip_MergeBlockDXT5B(dsta, srca, srcb, srcc, srcd);
	}
}

BGBBTJ_API void BGBBTJ_BCnMip_MergeDXT5(
	byte *dst, byte *src, int xs, int ys)
{
	BGBBTJ_BCnMip_Init();

	BGBBTJ_BCnMip_MergeDXT5B(dst+8, src+8, xs, ys, 16);
}
#include <bgbbtj.h>

int BGBBTJ_BCn_DistRGB(byte *rgb0, byte *rgb1)
{
	int dr, dg, db, dy;
	int d, y0, y1;
	
	y0=(rgb0[0]+(2*rgb0[1])+rgb0[2])>>2;
	y1=(rgb1[0]+(2*rgb1[1])+rgb1[2])>>2;

	dr=rgb0[0]-rgb1[0];
	dg=rgb0[1]-rgb1[1];
	db=rgb0[2]-rgb1[2];
	dy=y0-y1;
	
	d=dr*dr + dg*dg + db*db + dy*dy;
	return(d);
}

int BGBBTJ_BCn_IndexRGB_Clr2(byte *rgb, byte *clr0, byte *clr1)
{
	int bi, bd, d;

	if(rgb[3]<128)return(3);

	bi=0; bd=BGBBTJ_BCn_DistRGB(clr0, rgb);
	d=BGBBTJ_BCn_DistRGB(clr1, rgb);
	if(d<bd) { bi=1; bd=d; }
	return(bi);
}

int BGBBTJ_BCn_IndexRGB_Clr3(byte *rgb,
	byte *clr0, byte *clr1, byte *clr2)
{
	int bi, bd, d;
	
	if(rgb[3]<128)return(3);
	
	bi=0; bd=BGBBTJ_BCn_DistRGB(clr0, rgb);
	
	d=BGBBTJ_BCn_DistRGB(clr1, rgb);
	if(d<bd) { bi=1; bd=d; }
	d=BGBBTJ_BCn_DistRGB(clr2, rgb);
	if(d<bd) { bi=2; bd=d; }
	return(bi);
}

int BGBBTJ_BCn_IndexRGB_Clr4(byte *rgb,
	byte *clr0, byte *clr1, byte *clr2, byte *clr3)
{
	int bi, bd, d;
	
	bi=0; bd=BGBBTJ_BCn_DistRGB(clr0, rgb);
	
	d=BGBBTJ_BCn_DistRGB(clr1, rgb);
	if(d<bd) { bi=1; bd=d; }
	d=BGBBTJ_BCn_DistRGB(clr2, rgb);
	if(d<bd) { bi=2; bd=d; }
	d=BGBBTJ_BCn_DistRGB(clr3, rgb);
	if(d<bd) { bi=3; bd=d; }
	return(bi);
}

void BGBBTJ_BCn_EncodeBlockDXT1_Clr4(byte *block,
	byte *clr0, byte *clr1, byte *clr2, byte *clr3,
	byte *rgba,
	int xstride, int ystride)
{
	int cr, cg, cb;
	int p0, p1, p2, p3;
	int i;

//	block[0]=(clr0[0]&0xF8) | (clr0[1]>>5);
//	block[1]=((clr0[1]<<3)&0xE0) | (clr0[2]>>3);
//	block[2]=(clr1[0]&0xF8) | (clr1[1]>>5);
//	block[3]=((clr1[1]<<3)&0xE0) | (clr1[2]>>3);

//	block[0]=((clr0[1]<<3)&0xE0) | (clr0[2]>>3);
//	block[1]=(clr0[0]&0xF8) | (clr0[1]>>5);
//	block[2]=((clr1[1]<<3)&0xE0) | (clr1[2]>>3);
//	block[3]=(clr1[0]&0xF8) | (clr1[1]>>5);
	
	cr=(clr0[0]+4)>>3;
	cg=(clr0[1]+2)>>2;
	cb=(clr0[2]+4)>>3;
	if(cr>31)cr=31;
	if(cg>63)cg=63;
	if(cb>31)cb=31;

	block[0]=cb|(cg<<5);
	block[1]=(cg>>3)|(cr<<3);

	cr=(clr1[0]+4)>>3;
	cg=(clr1[1]+2)>>2;
	cb=(clr1[2]+4)>>3;
	if(cr>31)cr=31;
	if(cg>63)cg=63;
	if(cb>31)cb=31;

	block[2]=cb|(cg<<5);
	block[3]=(cg>>3)|(cr<<3);

	for(i=0; i<4; i++)
	{
		if(clr3)
		{
			p0=BGBBTJ_BCn_IndexRGB_Clr4(rgba+(0*xstride)+(i*ystride),
				clr0, clr1, clr2, clr3);
			p1=BGBBTJ_BCn_IndexRGB_Clr4(rgba+(1*xstride)+(i*ystride),
				clr0, clr1, clr2, clr3);
			p2=BGBBTJ_BCn_IndexRGB_Clr4(rgba+(2*xstride)+(i*ystride),
				clr0, clr1, clr2, clr3);
			p3=BGBBTJ_BCn_IndexRGB_Clr4(rgba+(3*xstride)+(i*ystride),
				clr0, clr1, clr2, clr3);
		}else if(clr2)
		{
			p0=BGBBTJ_BCn_IndexRGB_Clr3(rgba+(0*xstride)+(i*ystride),
				clr0, clr1, clr2);
			p1=BGBBTJ_BCn_IndexRGB_Clr3(rgba+(1*xstride)+(i*ystride),
				clr0, clr1, clr2);
			p2=BGBBTJ_BCn_IndexRGB_Clr3(rgba+(2*xstride)+(i*ystride),
				clr0, clr1, clr2);
			p3=BGBBTJ_BCn_IndexRGB_Clr3(rgba+(3*xstride)+(i*ystride),
				clr0, clr1, clr2);
		}else
		{
			p0=BGBBTJ_BCn_IndexRGB_Clr2(rgba+(0*xstride)+(i*ystride),
				clr0, clr1);
			p1=BGBBTJ_BCn_IndexRGB_Clr2(rgba+(1*xstride)+(i*ystride),
				clr0, clr1);
			p2=BGBBTJ_BCn_IndexRGB_Clr2(rgba+(2*xstride)+(i*ystride),
				clr0, clr1);
			p3=BGBBTJ_BCn_IndexRGB_Clr2(rgba+(3*xstride)+(i*ystride),
				clr0, clr1);
		}
		block[4+i]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
}

int BGBBTJ_BCn_ClrTo565(byte *clr, byte *oclr)
{
	int cr, cg, cb;
	int i;

	cr=(clr[0]+4)>>3;
	cg=(clr[1]+2)>>2;
	cb=(clr[2]+4)>>3;
	if(cr>31)cr=31;
	if(cg>63)cg=63;
	if(cb>31)cb=31;
	
	if(oclr)
	{
		oclr[0]=cr<<3;
		oclr[1]=cg<<2;
		oclr[2]=cb<<3;
	}
	
	i=cb|(cg<<5)|(cr<<11);
	return(i);
}

void BGBBTJ_BCn_EncodeBlockDXT1(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
	int min[4], max[4], avg[3];
	byte clr0[4], clr1[4], clr2[4], clr3[4];
	int cr, cg, cb, cy;
	int i, j, k;
	
	min[0]=255;	min[1]=255;	min[2]=255; min[3]= 384;
	max[0]=  0;	max[1]=  0;	max[2]=  0; max[3]=-384;
	avg[0]=  0;	avg[1]=  0;	avg[2]=  0;

	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+0];
		cg=rgba[k+1];
		cb=rgba[k+2];
		cy=(cr+2*cg+cb)>>2;
		
		if(cy<min[3])
			{ min[0]=cr; min[1]=cg; min[2]=cb; min[3]=cy; }
		if(cy>max[3])
			{ max[0]=cr; max[1]=cg; max[2]=cb; max[3]=cy; }
		
#if 0
		if(cr<min[0])min[0]=cr;
		if(cg<min[1])min[1]=cg;
		if(cb<min[2])min[2]=cb;
		if(cr>max[0])max[0]=cr;
		if(cg>max[1])max[1]=cg;
		if(cb>max[2])max[2]=cb;
#endif
		avg[0]+=cr;
		avg[1]+=cg;
		avg[2]+=cb;
	}
	
	avg[0]=(avg[0]+8)>>4;
	avg[1]=(avg[1]+8)>>4;
	avg[2]=(avg[2]+8)>>4;
	if(avg[0]>255)avg[0]=255;
	if(avg[1]>255)avg[1]=255;
	if(avg[2]>255)avg[2]=255;

#if 0
	clr0[0]=(min[0]*11+avg[0]*5)>>4;
	clr0[1]=(min[1]*11+avg[1]*5)>>4;
	clr0[2]=(min[2]*11+avg[2]*5)>>4;
	clr1[0]=(max[0]*11+avg[0]*5)>>4;
	clr1[1]=(max[1]*11+avg[1]*5)>>4;
	clr1[2]=(max[2]*11+avg[2]*5)>>4;
#endif

#if 1
	clr0[0]=min[0];
	clr0[1]=min[1];
	clr0[2]=min[2];
	clr1[0]=max[0];
	clr1[1]=max[1];
	clr1[2]=max[2];
#endif

	if(nclr>=0)
	{
//		i=BGBBTJ_BCn_ClrTo565(clr0, NULL);
//		j=BGBBTJ_BCn_ClrTo565(clr1, NULL);
		i=BGBBTJ_BCn_ClrTo565(clr0, clr0);
		j=BGBBTJ_BCn_ClrTo565(clr1, clr1);
		if(j<i)
//		if(j>i)
		{
			k=clr0[0]; clr0[0]=clr1[0]; clr1[0]=k;
			k=clr0[1]; clr0[1]=clr1[1]; clr1[1]=k;
			k=clr0[2]; clr0[2]=clr1[2]; clr1[2]=k;
		}
	}else
	{
//		i=BGBBTJ_BCn_ClrTo565(clr0, NULL);
//		j=BGBBTJ_BCn_ClrTo565(clr1, NULL);
		i=BGBBTJ_BCn_ClrTo565(clr0, clr0);
		j=BGBBTJ_BCn_ClrTo565(clr1, clr1);
		if(j>i)
//		if(j<i)
		{
			k=clr0[0]; clr0[0]=clr1[0]; clr1[0]=k;
			k=clr0[1]; clr0[1]=clr1[1]; clr1[1]=k;
			k=clr0[2]; clr0[2]=clr1[2]; clr1[2]=k;
		}
		
		if((i==j) && (nclr==(-4)))
		{
			nclr=3;
		}
	}

	switch(nclr)
	{
	case 2:
	case -2:
		BGBBTJ_BCn_EncodeBlockDXT1_Clr4(block,
			clr0, clr1, NULL, NULL,
			rgba, xstride, ystride);
		break;
	case 3:
	case -3:
		clr2[0]=(clr0[0]+clr1[0])>>1;
		clr2[1]=(clr0[1]+clr1[1])>>1;
		clr2[2]=(clr0[2]+clr1[2])>>1;
		BGBBTJ_BCn_EncodeBlockDXT1_Clr4(block,
			clr0, clr1, clr2, NULL,
			rgba, xstride, ystride);
		break;
	case 4:
	case -4:
		clr2[0]=(clr0[0]*171+clr1[0]*85+128)>>8;
		clr2[1]=(clr0[1]*171+clr1[1]*85+128)>>8;
		clr2[2]=(clr0[2]*171+clr1[2]*85+128)>>8;
		clr3[0]=(clr0[0]*85+clr1[0]*171+128)>>8;
		clr3[1]=(clr0[1]*85+clr1[1]*171+128)>>8;
		clr3[2]=(clr0[2]*85+clr1[2]*171+128)>>8;
		BGBBTJ_BCn_EncodeBlockDXT1_Clr4(block,
			clr0, clr1, clr2, clr3,
			rgba, xstride, ystride);
		break;
	}
}

void BGBBTJ_BCn_EncodeBlockDXT1F(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
//	int min[3], max[3], avg[3];
	byte clr0[4], clr1[4];
	byte pxy[16];
	int p0, p1, p2, p3;
	int mcr, mcg, mcb, mcy;
	int ncr, ncg, ncb, ncy;
	int acr, acg, acb;
	int cr, cg, cb, cy, acy;
	int i, j, k;
	
	mcr=255; mcg=255; mcb=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0;

	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+0];
		cg=rgba[k+1];
		cb=rgba[k+2];
		cy=(cr+2*cg+cb)>>2;
		pxy[i*4+j]=cy;

		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
//		if(cr<mcr)mcr=cr;
//		if(cg<mcg)mcg=cg;
//		if(cb<mcb)mcb=cb;
//		if(cr>ncr)ncr=cr;
//		if(cg>ncg)ncg=cg;
//		if(cb>ncb)ncb=cb;
		acr+=cr;
		acg+=cg;
		acb+=cb;
	}
	
	acr=acr>>4;
	acg=acg>>4;
	acb=acb>>4;

	clr0[0]=(mcr*11+acr*5)>>4;
	clr0[1]=(mcg*11+acg*5)>>4;
	clr0[2]=(mcb*11+acb*5)>>4;
	clr1[0]=(ncr*11+acr*5)>>4;
	clr1[1]=(ncg*11+acg*5)>>4;
	clr1[2]=(ncb*11+acb*5)>>4;

	block[0]=((clr0[1]<<3)&0xE0) | (clr0[2]>>3);
	block[1]=(clr0[0]&0xF8) | (clr0[1]>>5);
	block[2]=((clr1[1]<<3)&0xE0) | (clr1[2]>>3);
	block[3]=(clr1[0]&0xF8) | (clr1[1]>>5);
	
	clr0[3]=(clr0[0]+2*clr0[1]+clr0[2])>>2;
	clr1[3]=(clr1[0]+2*clr1[1]+clr1[2])>>2;

	acy=(clr0[3]+clr1[3])>>1;

#if 0
	for(i=0; i<4; i++)
	{
		k=i*4;
		p0=-((acy-pxy[k+0])>>16);
		p1=-((acy-pxy[k+1])>>16);
		p2=-((acy-pxy[k+2])>>16);
		p3=-((acy-pxy[k+3])>>16);
		block[4+i]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
#endif

	p0=-((acy-pxy[ 0])>>16);
	p1=-((acy-pxy[ 1])>>16);
	p2=-((acy-pxy[ 2])>>16);
	p3=-((acy-pxy[ 3])>>16);
	block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[ 4])>>16);
	p1=-((acy-pxy[ 5])>>16);
	p2=-((acy-pxy[ 6])>>16);
	p3=-((acy-pxy[ 7])>>16);
	block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[ 8])>>16);
	p1=-((acy-pxy[ 9])>>16);
	p2=-((acy-pxy[10])>>16);
	p3=-((acy-pxy[11])>>16);
	block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[12])>>16);
	p1=-((acy-pxy[13])>>16);
	p2=-((acy-pxy[14])>>16);
	p3=-((acy-pxy[15])>>16);
	block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
}

#if 1
void BGBBTJ_BCn_EncodeBlockDXT1A(byte *block,
	byte *rgba, int xstride, int ystride)
{
	static char idxtaba[16]=
		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };
	static char idxtabb[16]=
		{ 1,1,1,1, 1,1,3,3, 2,2,0,0, 0,0,0,0 };
	static char idxtabc[16]=
		{ 0,0,0,0, 0,0,2,2, 2,2,1,1, 1,1,1,1 };
	static char idxtabd[16]=
		{ 1,1,1,1, 1,1,2,2, 2,2,0,0, 0,0,0,0 };
	byte pxa[16], pxy[16];
	char *idxtab;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int l0, l1, l2, l3a, l3b;
	int mcr, mcg, mcb, mca, mcy;
	int ncr, ncg, ncb, nca, ncy;
	int acr, acg, acb, aca, acy;
	int mcr2, mcg2, mcb2, mcy2;
	int ncr2, ncg2, ncb2, ncy2;
//	int mcr3, mcg3, mcb3, mcy3;
//	int ncr3, ncg3, ncb3, ncy3;
	int mcr3r, mcg3r, mcb3r, ncr3r, ncg3r, ncb3r;
	int mcr3g, mcg3g, mcb3g, ncr3g, ncg3g, ncb3g;
	int mcr3b, mcg3b, mcb3b, ncr3b, ncg3b, ncb3b;
	int cr, cg, cb, ca, cy;
	int dr, dg, db, da, dy, alty;
	int drr, dgr, dbr, drg, dgg, dbg, drb, dgb, dbb;
	int i, j, k, l;
	
	mcr=255; mcg=255; mcb=255; mca=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; nca=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0; aca=  0; acy=  0;
	mcr2=255; mcg2=255; mcb2=255; mcy2=255;
	ncr2=  0; ncg2=  0; ncb2=  0; ncy2=  0;
//	mcr3=255; mcg3=255; mcb3=255; mcy3=255;
//	ncr3=  0; ncg3=  0; ncb3=  0; ncy3=  0;
	mcr3r=255; mcg3r=255; mcb3r=255;
	ncr3r=  0; ncg3r=  0; ncb3r=  0;
	mcr3g=255; mcg3g=255; mcb3g=255;
	ncr3g=  0; ncg3g=  0; ncb3g=  0;
	mcr3b=255; mcg3b=255; mcb3b=255;
	ncr3b=  0; ncg3b=  0; ncb3b=  0;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+0];	cg=rgba[k+1];
		cb=rgba[k+2];	ca=rgba[k+3];
		cy=(cr+(2*cg)+cb)>>2;		//Luma

		if(xstride==3)
			{ ca=255; }

		pxa[i*4+j]=ca;
		pxy[i*4+j]=cy;

		//Find Mins/Maxs
//		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
//		if((cy<mcy) && (ca>=64)) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if((cy>ncy) && (ca>=64)) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
		if(ca<mca) { mca=ca; }
		if(ca>nca) { nca=ca; }

		if(cy<mcy)
		{
			if(ca>=64) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
			mcr2=cr; mcg2=cg; mcb2=cb; mcy2=cy;
		}
		if(cy>ncy)
		{
			if(ca>=64) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
			ncr2=cr; ncg2=cg; ncb2=cb; ncy2=cy;
		}
		
//		if(cr<mcr3) { mcr3=cr; }
//		if(cg<mcg3) { mcg3=cg; }
//		if(cb<mcb3) { mcb3=cb; }
//		if(cr>ncr3) { ncr3=cr; }
//		if(cg>ncg3) { ncg3=cg; }
//		if(cb>ncb3) { ncb3=cb; }

#if 0
		if(cr<mcr3r) { mcr3r=cr; mcg3r=cg; mcb3r=cb; }
		if(cg<mcg3g) { mcr3g=cr; mcg3g=cg; mcb3g=cb; }
		if(cb<mcb3b) { mcr3b=cr; mcg3b=cg; mcb3b=cb; }
		if(cr>ncr3r) { ncr3r=cr; ncg3r=cg; ncb3r=cb; }
		if(cg>ncg3g) { ncr3g=cr; ncg3g=cg; ncb3g=cb; }
		if(cb>ncb3b) { ncr3b=cr; ncg3b=cg; ncb3b=cb; }
#endif

		acr+=cr; acg+=cg;
		acb+=cb; acy+=cy;
	}

#if 1
	if(nca<64)
	{
		mcr=mcr2; mcg=mcg2; mcb=mcb2; mcy=mcy2;
		ncr=ncr2; ncg=ncg2; ncb=ncb2; ncy=ncy2;
	}
#endif

	alty=0;

#if 0
	drr=ncr3r-mcr3r;	dgr=ncg3r-mcg3r;	dbr=ncb3r-mcb3r;
	drg=ncr3g-mcr3g;	dgg=ncg3g-mcg3g;	dbg=ncb3g-mcb3g;
	drb=ncr3b-mcr3b;	dgb=ncg3b-mcg3b;	dbb=ncb3b-mcb3b;
	dy=ncy-mcy;
//	if((dr>dy) || (dg>dy) || (db>dy))
	if((drr>dy) || (dgg>dy) || (dbb>dy))
	{
		if((drr>dgg) && (drr>dbb))
		{
			mcr=mcr3r; mcg=mcg3r; mcb=mcb3r;
			ncr=ncr3r; ncg=ncg3r; ncb=ncb3r;
		}else if(dgg>=dbb)
		{
			mcr=mcr3g; mcg=mcg3g; mcb=mcb3g;
			ncr=ncr3g; ncg=ncg3g; ncb=ncb3g;
		}else
		{
			mcr=mcr3b; mcg=mcg3b; mcb=mcb3b;
			ncr=ncr3b; ncg=ncg3b; ncb=ncb3b;
		}

		mcy=255; ncy=0;

		dr=ncr-mcr;
		dg=ncg-mcg;
		db=ncb-mcb;

		//normalize
		da=sqrt((dr*dr)+(dg*dg)+(db*db));
		dr=(256*dr)/da;
		dg=(256*dg)/da;
		db=(256*db)/da;

		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=(i*ystride)+(j*xstride);
			cr=rgba[k+0];	cg=rgba[k+1];
			cb=rgba[k+2];
//			cy=(cr+(2*cg)+cb)>>2;		//Luma
			cy=(cr*dr+cg*dg+cb*db)>>8;

			pxy[i*4+j]=cy;

			if(cy<mcy) { mcy=cy; }
			if(cy>ncy) { ncy=cy; }
		}
		
		alty=1;
	}
#endif

#if 0
	dr=ncr3-mcr3;	dg=ncg3-mcg3;
	db=ncb3-mcb3;	dy=ncy-mcy;
	if((dr>dy) || (dg>dy) || (db>dy))
	{
		mcr=mcr3; mcg=mcg3; mcb=mcb3; mcy=mcy3;
		ncr=ncr3; ncg=ncg3; ncb=ncb3; ncy=ncy3;
		mcy=255; ncy=0;

		//normalize
		da=sqrt((dr*dr)+(dg*dg)+(db*db));
		dr=(256*dr)/da;
		dg=(256*dg)/da;
		db=(256*db)/da;

		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=(i*ystride)+(j*xstride);
			cr=rgba[k+0];	cg=rgba[k+1];
			cb=rgba[k+2];
//			cy=(cr+(2*cg)+cb)>>2;		//Luma
			cy=(cr*dr+cg*dg+cb*db)>>8;

			pxy[i*4+j]=cy;

			if(cy<mcy) { mcy=cy; }
			if(cy>ncy) { ncy=cy; }
		}
		
		alty=1;
	}
#endif

#if 0
	if(nca<64)
	{
		cr=rgba[0];	cg=rgba[1];
		cb=rgba[2];	ca=rgba[3];
		
		cy=(cr+(2*cg)+cb)>>2;		//Luma
		mcr=cr; mcg=cg; mcb=cb; mcy=cy;
		ncr=cr; ncg=cg; ncb=cb; ncy=cy;
	}
#endif

#if 1
	acr=(acr+8)>>4;
	acg=(acg+8)>>4;
	acb=(acb+8)>>4;
	acy=(acr+(2*acg)+acb)>>2;

	if(!alty)
	{
		l=(256*mcy)/(acy+1);
		cr=(acr*l+128)>>8;
		cg=(acg*l+128)>>8;
		cb=(acb*l+128)>>8;
	
//		mcr=(mcr+cr)>>1;
//		mcg=(mcg+cg)>>1;
//		mcb=(mcb+cb)>>1;

		mcr=(3*mcr+cr)>>2;
		mcg=(3*mcg+cg)>>2;
		mcb=(3*mcb+cb)>>2;
	
		l=(256*ncy)/(acy+1);
		cr=(acr*l+128)>>8;
		cg=(acg*l+128)>>8;
		cb=(acb*l+128)>>8;
	
//		ncr=(ncr+cr)>>1;
//		ncg=(ncg+cg)>>1;
//		ncb=(ncb+cb)>>1;

		ncr=(3*ncr+cr)>>2;
		ncg=(3*ncg+cg)>>2;
		ncb=(3*ncb+cb)>>2;
	}
#endif

#if 1
	mcr=((mcr+3)>>3)<<3;
	mcg=((mcg+1)>>2)<<2;
	mcb=((mcb+3)>>3)<<3;
	ncr=((ncr+5)>>3)<<3;
	ncg=((ncg+3)>>2)<<2;
	ncb=((ncb+5)>>3)<<3;
	mcr=(mcr<0)?0:((mcr>255)?255:mcr);
	mcg=(mcg<0)?0:((mcg>255)?255:mcg);
	mcb=(mcb<0)?0:((mcb>255)?255:mcb);
	ncr=(ncr<0)?0:((ncr>255)?255:ncr);
	ncg=(ncg<0)?0:((ncg>255)?255:ncg);
	ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif

	aca=(mca+nca)>>1;			//Median Alpha
	acy=(mcy+ncy)>>1;			//Median Luma
	l0=49152/(nca-aca+1);		//Fix-Point Scale (Alpha)
	l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
	l2=65536-2048;

	if(nca<128)
//	if(0)
	{
		//Fully Transparent Block
		i=((acr<<8)&0xF800) | ((acg<<3)&0x07E0) | ((acb>>3)&0x001F);
		block[0]=i;	block[1]=i>>8;
		block[2]=i;	block[3]=i>>8;

		block[4]=255;	block[5]=255;
		block[6]=255;	block[7]=255;
	}else
		if((mcr==ncr) && (mcg==ncg) && (mcb==ncb) && (mca==nca))
//		if(0)
	{	
		//Flat Color Block
		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
		if(j<=i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
		}

		if(i!=j)
		{
			block[4]=(2<<6)|(3<<4)|(2<<2)|3;
			block[5]=(3<<6)|(2<<4)|(3<<2)|2;
			block[6]=(2<<6)|(3<<4)|(2<<2)|3;
			block[7]=(3<<6)|(2<<4)|(3<<2)|2;
		}else
		{
			block[4]=0;	block[5]=0;
			block[6]=0;	block[7]=0;
		}
	}else
		if(mca>=128)
//		if(0)
	{
		//Emit RGB Block (Opaque)

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(j<i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtaba;
		}else if(i<j)
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabb;
		}else
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13];
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13];
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13];
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13];
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}else
	{
		//Emit RGB Block (Alpha)

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(i<=j)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabd;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13] | (((pxa[ 0]-128)>>10)&3);
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13] | (((pxa[ 1]-128)>>10)&3);
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13] | (((pxa[ 2]-128)>>10)&3);
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13] | (((pxa[ 3]-128)>>10)&3);
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13] | (((pxa[ 4]-128)>>10)&3);
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13] | (((pxa[ 5]-128)>>10)&3);
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13] | (((pxa[ 6]-128)>>10)&3);
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13] | (((pxa[ 7]-128)>>10)&3);
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13] | (((pxa[ 8]-128)>>10)&3);
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13] | (((pxa[ 9]-128)>>10)&3);
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13] | (((pxa[10]-128)>>10)&3);
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13] | (((pxa[11]-128)>>10)&3);
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13] | (((pxa[12]-128)>>10)&3);
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13] | (((pxa[13]-128)>>10)&3);
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13] | (((pxa[14]-128)>>10)&3);
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13] | (((pxa[15]-128)>>10)&3);
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
}
#endif

#if 1
void BGBBTJ_BCn_EncodeBlockDXT1B(byte *block,
	byte *rgba, int xstride, int ystride)
{
	static char idxtaba[16]=
		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };
	static char idxtabb[16]=
		{ 1,1,1,1, 1,1,3,3, 2,2,0,0, 0,0,0,0 };
	static char idxtabc[16]=
		{ 0,0,0,0, 0,0,2,2, 2,2,1,1, 1,1,1,1 };
	byte pxa[16], pxy[16];
	char *idxtab;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int l0, l1, l2, l3a, l3b;
	int mcr, mcg, mcb, mca, mcy;
	int ncr, ncg, ncb, nca, ncy;
	int mcr2, mcg2, mcb2, mcy2;
	int ncr2, ncg2, ncb2, ncy2;

	int acr, acg, acb, aca, acy;
	int cr, cg, cb, ca, cy;
	int i, j, k, l;
	
	mcr=255; mcg=255; mcb=255; mca=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; nca=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0; aca=  0; acy=  0;
	mcr2=255; mcg2=255; mcb2=255; mcy2=255;
	ncr2=  0; ncg2=  0; ncb2=  0; ncy2=  0;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+0];	cg=rgba[k+1];
		cb=rgba[k+2];	ca=rgba[k+3];
		cy=(cr+(2*cg)+cb)>>2;		//Luma

		pxa[i*4+j]=ca;
		pxy[i*4+j]=cy;

		//Find Mins/Maxs
//		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
//		if((cy<mcy) && (ca>=64)) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if((cy>ncy) && (ca>=64)) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }

		if(cy<mcy)
		{
			if(ca>=64) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
			mcr2=cr; mcg2=cg; mcb2=cb; mcy2=cy;
		}
		if(cy>ncy)
		{
			if(ca>=64) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
			ncr2=cr; ncg2=cg; ncb2=cb; ncy2=cy;
		}

		if(ca<mca) { mca=ca; }
		if(ca>nca) { nca=ca; }
		
		acr+=cr; acg+=cg;
		acb+=cb; acy+=cy;
	}

#if 1
	if(nca<64)
	{
		mcr=mcr2; mcg=mcg2; mcb=mcb2; mcy=mcy2;
		ncr=ncr2; ncg=ncg2; ncb=ncb2; ncy=ncy2;
	}
#endif

#if 0
	if(nca<64)
	{
		cr=rgba[0];	cg=rgba[1];
		cb=rgba[2];	ca=rgba[3];
		
		cy=(cr+(2*cg)+cb)>>2;		//Luma
		mcr=cr; mcg=cg; mcb=cb; mcy=cy;
		ncr=cr; ncg=cg; ncb=cb; ncy=cy;
	}
#endif

#if 1
	acr=(acr+8)>>4;
	acg=(acg+8)>>4;
	acb=(acb+8)>>4;
	acy=(acr+(2*acg)+acb)>>2;
	
	l=(256*mcy)/(acy+1);
	cr=(acr*l+128)>>8;
	cg=(acg*l+128)>>8;
	cb=(acb*l+128)>>8;
	
	mcr=(mcr+cr)>>1;
	mcg=(mcg+cg)>>1;
	mcb=(mcb+cb)>>1;
	

	l=(256*ncy)/(acy+1);
	cr=(acr*l+128)>>8;
	cg=(acg*l+128)>>8;
	cb=(acb*l+128)>>8;
	
	ncr=(ncr+cr)>>1;
	ncg=(ncg+cg)>>1;
	ncb=(ncb+cb)>>1;
#endif

	aca=(mca+nca)>>1;			//Median Alpha
	acy=(mcy+ncy)>>1;			//Median Luma
	l0=49152/(nca-aca+1);		//Fix-Point Scale (Alpha)
	l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
	l2=65536-2048;

	if((mcr==ncr) && (mcg==ncg) && (mcb==ncb))
	{
		//Flat Color Block
#if 1
		mcr=((mcr+3)>>3)<<3;
		mcg=((mcg+1)>>2)<<2;
		mcb=((mcb+3)>>3)<<3;
		ncr=((ncr+5)>>3)<<3;
		ncg=((ncg+3)>>2)<<2;
		ncb=((ncb+5)>>3)<<3;
		mcr=(mcr<0)?0:((mcr>255)?255:mcr);
		mcg=(mcg<0)?0:((mcg>255)?255:mcg);
		mcb=(mcb<0)?0:((mcb>255)?255:mcb);
		ncr=(ncr<0)?0:((ncr>255)?255:ncr);
		ncg=(ncg<0)?0:((ncg>255)?255:ncg);
		ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif
		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
		if(j<=i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
		}

		if(i!=j)
		{
			block[4]=(2<<6)|(3<<4)|(2<<2)|3;
			block[5]=(3<<6)|(2<<4)|(3<<2)|2;
			block[6]=(2<<6)|(3<<4)|(2<<2)|3;
			block[7]=(3<<6)|(2<<4)|(3<<2)|2;
		}else
		{
			block[4]=0;	block[5]=0;
			block[6]=0;	block[7]=0;
		}
	}else
	{
		//Emit RGB Block
#if 1
		mcr=((mcr+3)>>3)<<3;
		mcg=((mcg+1)>>2)<<2;
		mcb=((mcb+3)>>3)<<3;
		ncr=((ncr+5)>>3)<<3;
		ncg=((ncg+3)>>2)<<2;
		ncb=((ncb+5)>>3)<<3;
		mcr=(mcr<0)?0:((mcr>255)?255:mcr);
		mcg=(mcg<0)?0:((mcg>255)?255:mcg);
		mcb=(mcb<0)?0:((mcb>255)?255:mcb);
		ncr=(ncr<0)?0:((ncr>255)?255:ncr);
		ncg=(ncg<0)?0:((ncg>255)?255:ncg);
		ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(j<i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtaba;
		}else if(i<j)
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabb;
		}else
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13];
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13];
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13];
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13];
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
}
#endif


BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT1(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
//		BGBBTJ_BCn_EncodeBlockDXT1(
//			block+(i*xs1+j)*8,
//			rgba+(i*4*xs+j*4)*stride,
//			stride, xs*stride, -4);

//		BGBBTJ_BCn_EncodeBlockDXT1B(
//			block+(i*xs1+j)*8,
//			rgba+(i*4*xs+j*4)*stride,
//			stride, xs*stride);

		BGBBTJ_BCn_EncodeBlockDXT1A(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride);
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT1A(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
//		BGBBTJ_BCn_EncodeBlockDXT1(
//			block+(i*xs1+j)*8,
//			rgba+(i*4*xs+j*4)*stride,
//			stride, xs*stride, 3);

		BGBBTJ_BCn_EncodeBlockDXT1A(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride);
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT1F(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockDXT1F(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 3);
	}
}


void BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(byte *block,
	short *pxy, short *pxu, short *pxv)
{
	static const char idxtab[16]=
		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };

	int p0, p1, p2, p3;
	int mcy, ncy, acy;
	int acr, acg, acb;
	int mcu, mcv;
	int ncu, ncv;
	int cy, cu, cv;
	int cra, cga, cba;
	int crb, cgb, cbb;
//	int u1, v1, l0, l1, l2;
	int l0, l1, l2, l3, l4, l5;
	int u0, v0, u1, v1, u2, v2, u3, v3;
	int i, j, k;

#if 0
	mcy=255; ncy=0;
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=pxy[i*8+j];
		if(k<mcy)mcy=k;
		if(k>ncy)ncy=k;
	}
#endif

#if 1
	u0=pxu[0]; v0=pxv[0];
	u1=pxu[1]; v1=pxv[1];
	u2=pxu[8]; v2=pxv[8];
	u3=pxu[9]; v3=pxv[9];

//	cu=(pxu[0]+pxu[1]+pxu[8]+pxu[9])>>2;
//	cv=(pxv[0]+pxv[1]+pxv[8]+pxv[9])>>2;

	mcy=pxy[0];	ncy=mcy;
	mcu=u0; mcv=v0; ncu=u0; ncv=v0;
	i=pxy[1];
	if(i<mcy) { mcy=i; mcu=u0; mcv=v0; }
	else if(i>ncy) { ncy=i; ncu=u0; ncv=v0; }
	i=pxy[2];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }
	i=pxy[3];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }

	i=pxy[8];
	if(i<mcy) { mcy=i; mcu=u0; mcv=v0; }
	else if(i>ncy) { ncy=i; ncu=u0; ncv=v0; }
	i=pxy[9];
	if(i<mcy) { mcy=i; mcu=u0; mcv=v0; }
	else if(i>ncy) { ncy=i; ncu=u0; ncv=v0; }
	i=pxy[10];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }
	i=pxy[11];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }

	i=pxy[16];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[17];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[18];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }
	i=pxy[19];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }

	i=pxy[24];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[25];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[26];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }
	i=pxy[27];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }
#endif

#if 0
	cu=(pxu[0]+pxu[1]+pxu[8]+pxu[9])>>2;
	cv=(pxv[0]+pxv[1]+pxv[8]+pxv[9])>>2;

	mcy=pxy[0];	ncy=mcy;
	i=pxy[ 1];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 2];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 3];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 8];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 9];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[10];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[11];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[16];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[17];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[18];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[19];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[24];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[25];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[26];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[27];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
#endif

	acy=(mcy+ncy)>>1;

#if 0
	u1=cu-128; v1=cv-128;
//	l0=91881*v1;
//	l1=-22554*u1-46802*v1;
//	l2=116130*u1;

	l0=359*v1;
	l1=-88*u1-183*v1;
	l2=454*u1;

	cra=(256*mcy+l0)>>8;	cga=(256*mcy+l1)>>8;	cba=(256*mcy+l2)>>8;
	crb=(256*ncy+l0)>>8;	cgb=(256*ncy+l1)>>8;	cbb=(256*ncy+l2)>>8;
#endif

#if 1
	u0=mcu-128; v0=mcv-128;
	u1=ncu-128; v1=ncv-128;

//	u1=cu-128; v1=cv-128;

//	l0=91881*v1;
//	l1=-22554*u1-46802*v1;
//	l2=116130*u1;

	l0=359*v0;
	l1=-88*u0-183*v0;
	l2=454*u0;

	l3=359*v1;
	l4=-88*u1-183*v1;
	l5=454*u1;

	cra=(256*mcy+l0)>>8;	cga=(256*mcy+l1)>>8;	cba=(256*mcy+l2)>>8;
	crb=(256*ncy+l3)>>8;	cgb=(256*ncy+l4)>>8;	cbb=(256*ncy+l5)>>8;
#endif

	if((cra|cga|cba|crb|cgb|cbb)&(~255))
	{
		cra=(cra<0)?0:((cra>255)?255:cra);
		cga=(cga<0)?0:((cga>255)?255:cga);
		cba=(cba<0)?0:((cba>255)?255:cba);
		crb=(crb<0)?0:((crb>255)?255:crb);
		cgb=(cgb<0)?0:((cgb>255)?255:cgb);
		cbb=(cbb<0)?0:((cbb>255)?255:cbb);
	}

	i=((cra<<8)&0xF800) | ((cga<<3)&0x07E0) | (cba>>3);
	j=((crb<<8)&0xF800) | ((cgb<<3)&0x07E0) | (cbb>>3);
	block[0]=i;		block[1]=i>>8;
	block[2]=j;		block[3]=j>>8;

	if(i==j)
	{
		block[4]=0;	block[5]=0;
		block[6]=0;	block[7]=0;
		return;
	}

#if 1
//	l0=(256+64)/(ncy-mcy+1);
//	l0=(256+64)/(ncy-acy+1);
//	l0=65536/(ncy-acy+1);
	l0=32768/(ncy-acy+1);

	p0=idxtab[(((pxy[24]-acy)*l0)>>13)+8];
	p1=idxtab[(((pxy[25]-acy)*l0)>>13)+8];
	p2=idxtab[(((pxy[26]-acy)*l0)>>13)+8];
	p3=idxtab[(((pxy[27]-acy)*l0)>>13)+8];
	block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[16]-acy)*l0)>>13)+8];
	p1=idxtab[(((pxy[17]-acy)*l0)>>13)+8];
	p2=idxtab[(((pxy[18]-acy)*l0)>>13)+8];
	p3=idxtab[(((pxy[19]-acy)*l0)>>13)+8];
	block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[ 8]-acy)*l0)>>13)+8];
	p1=idxtab[(((pxy[ 9]-acy)*l0)>>13)+8];
	p2=idxtab[(((pxy[10]-acy)*l0)>>13)+8];
	p3=idxtab[(((pxy[11]-acy)*l0)>>13)+8];
	block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[ 0]-acy)*l0)>>13)+8];
	p1=idxtab[(((pxy[ 1]-acy)*l0)>>13)+8];
	p2=idxtab[(((pxy[ 2]-acy)*l0)>>13)+8];
	p3=idxtab[(((pxy[ 3]-acy)*l0)>>13)+8];
	block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
#endif

#if 0
	l0=256/(ncy-mcy+1);
	for(i=0; i<4; i++)
	{
		p0=idxtab[(((pxy[(3-i)*8+0]-acy)*l0)>>13)+8];
		p1=idxtab[(((pxy[(3-i)*8+1]-acy)*l0)>>13)+8];
		p2=idxtab[(((pxy[(3-i)*8+2]-acy)*l0)>>13)+8];
		p3=idxtab[(((pxy[(3-i)*8+3]-acy)*l0)>>13)+8];
		block[4+i]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
#endif

#if 0
	p0=-((acy-pxy[ 0])>>16);
	p1=-((acy-pxy[ 1])>>16);
	p2=-((acy-pxy[ 2])>>16);
	p3=-((acy-pxy[ 3])>>16);
	block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[ 8])>>16);
	p1=-((acy-pxy[ 9])>>16);
	p2=-((acy-pxy[10])>>16);
	p3=-((acy-pxy[11])>>16);
	block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[16])>>16);
	p1=-((acy-pxy[17])>>16);
	p2=-((acy-pxy[18])>>16);
	p3=-((acy-pxy[19])>>16);
	block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[24])>>16);
	p1=-((acy-pxy[25])>>16);
	p2=-((acy-pxy[26])>>16);
	p3=-((acy-pxy[27])>>16);
	block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
#endif
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT1F_YUV(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(
			block+(i*xs1+j)*8,
			(short *)(rgba+(i*xs1+j)*16),
			(short *)(rgba+(i*xs1+j)*16),
			(short *)(rgba+(i*xs1+j)*16));
	}
}


void BGBBTJ_BCn_EncodeBlockDXT1A_YUV420(byte *block,
	short *pxy, short *pxu, short *pxv, int ab)
{
	static const char idxtab[16]=
		{ 0,0,0,0, 0,2,2,2, 2,2,2,1, 1,1,1,1 };

	int p0, p1, p2, p3;
	int mcy, ncy, acy;
	int acr, acg, acb;
	int mcu, mcv;
	int ncu, ncv;
	int cy, cu, cv;
	int cra, cga, cba;
	int crb, cgb, cbb;
//	int u1, v1, l0, l1, l2;
	int l0, l1, l2, l3, l4, l5;
	int u0, v0, u1, v1, u2, v2, u3, v3;
	int i, j, k;

	if(ab==0xFFFF)
	{
		BGBBTJ_BCn_EncodeBlockDXT1F_YUV420(block, pxy, pxu, pxv);
		return;
	}
	
	if(ab==0x0000)
	{
		block[0]=0x00;	block[1]=0x00;
		block[2]=0x00;	block[3]=0x00;
		block[4]=0xFF;	block[5]=0xFF;
		block[6]=0xFF;	block[7]=0xFF;
		return;
	}

#if 1
	u0=pxu[0]; v0=pxv[0];
	u1=pxu[1]; v1=pxv[1];
	u2=pxu[8]; v2=pxv[8];
	u3=pxu[9]; v3=pxv[9];

//	cu=(pxu[0]+pxu[1]+pxu[8]+pxu[9])>>2;
//	cv=(pxv[0]+pxv[1]+pxv[8]+pxv[9])>>2;

	mcy=pxy[0];	ncy=mcy;
	mcu=u0; mcv=v0; ncu=u0; ncv=v0;
	i=pxy[1];
	if(i<mcy) { mcy=i; mcu=u0; mcv=v0; }
	else if(i>ncy) { ncy=i; ncu=u0; ncv=v0; }
	i=pxy[2];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }
	i=pxy[3];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }

	i=pxy[8];
	if(i<mcy) { mcy=i; mcu=u0; mcv=v0; }
	else if(i>ncy) { ncy=i; ncu=u0; ncv=v0; }
	i=pxy[9];
	if(i<mcy) { mcy=i; mcu=u0; mcv=v0; }
	else if(i>ncy) { ncy=i; ncu=u0; ncv=v0; }
	i=pxy[10];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }
	i=pxy[11];
	if(i<mcy) { mcy=i; mcu=u1; mcv=v1; }
	else if(i>ncy) { ncy=i; ncu=u1; ncv=v1; }

	i=pxy[16];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[17];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[18];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }
	i=pxy[19];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }

	i=pxy[24];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[25];
	if(i<mcy) { mcy=i; mcu=u2; mcv=v2; }
	else if(i>ncy) { ncy=i; ncu=u2; ncv=v2; }
	i=pxy[26];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }
	i=pxy[27];
	if(i<mcy) { mcy=i; mcu=u3; mcv=v3; }
	else if(i>ncy) { ncy=i; ncu=u3; ncv=v3; }
#endif

#if 0
	cu=(pxu[0]+pxu[1]+pxu[8]+pxu[9])>>2;
	cv=(pxv[0]+pxv[1]+pxv[8]+pxv[9])>>2;

	mcy=pxy[0];	ncy=mcy;
	i=pxy[ 1];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 2];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 3];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 8];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[ 9];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[10];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[11];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[16];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[17];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[18];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[19];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[24];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[25];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[26];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
	i=pxy[27];	j=(i-mcy)>>24; k=(ncy-i)>>24;
	mcy=(j&i)|((~j)&mcy); ncy=(k&i)|((~k)&ncy);
#endif

	acy=(mcy+ncy)>>1;

	u0=mcu-128; v0=mcv-128;
	u1=ncu-128; v1=ncv-128;

//	u1=cu-128; v1=cv-128;

//	l0=91881*v1;
//	l1=-22554*u1-46802*v1;
//	l2=116130*u1;

	l0=359*v0;
	l1=-88*u0-183*v0;
	l2=454*u0;

	l3=359*v1;
	l4=-88*u1-183*v1;
	l5=454*u1;

	cra=(256*mcy+l0)>>8;	cga=(256*mcy+l1)>>8;	cba=(256*mcy+l2)>>8;
	crb=(256*ncy+l3)>>8;	cgb=(256*ncy+l4)>>8;	cbb=(256*ncy+l5)>>8;
	if((cra|cga|cba|crb|cgb|cbb)&(~255))
	{
		cra=(cra<0)?0:((cra>255)?255:cra);
		cga=(cga<0)?0:((cga>255)?255:cga);
		cba=(cba<0)?0:((cba>255)?255:cba);
		crb=(crb<0)?0:((crb>255)?255:crb);
		cgb=(cgb<0)?0:((cgb>255)?255:cgb);
		cbb=(cbb<0)?0:((cbb>255)?255:cbb);
	}

	i=((cra<<8)&0xF800) | ((cga<<3)&0x07E0) | (cba>>3);
	j=((crb<<8)&0xF800) | ((cgb<<3)&0x07E0) | (cbb>>3);
	block[0]=i;		block[1]=i>>8;
	block[2]=j;		block[3]=j>>8;

	if(i==j)
	{
		block[4]=0;	block[5]=0;
		block[6]=0;	block[7]=0;
		return;
	}

#if 1
//	l0=(256+64)/(ncy-mcy+1);
//	l0=(256+64)/(ncy-acy+1);
//	l0=65536/(ncy-acy+1);
	l0=32768/(ncy-acy+1);

	p0=idxtab[(((pxy[24]-acy)*l0)>>13)+8]|(((ab>> 3)-1)&3);
	p1=idxtab[(((pxy[25]-acy)*l0)>>13)+8]|(((ab>> 2)-1)&3);
	p2=idxtab[(((pxy[26]-acy)*l0)>>13)+8]|(((ab>> 1)-1)&3);
	p3=idxtab[(((pxy[27]-acy)*l0)>>13)+8]|(((ab>> 0)-1)&3);
	block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[16]-acy)*l0)>>13)+8]|(((ab>> 7)-1)&3);
	p1=idxtab[(((pxy[17]-acy)*l0)>>13)+8]|(((ab>> 6)-1)&3);
	p2=idxtab[(((pxy[18]-acy)*l0)>>13)+8]|(((ab>> 5)-1)&3);
	p3=idxtab[(((pxy[19]-acy)*l0)>>13)+8]|(((ab>> 4)-1)&3);
	block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[ 8]-acy)*l0)>>13)+8]|(((ab>>11)-1)&3);
	p1=idxtab[(((pxy[ 9]-acy)*l0)>>13)+8]|(((ab>>10)-1)&3);
	p2=idxtab[(((pxy[10]-acy)*l0)>>13)+8]|(((ab>> 9)-1)&3);
	p3=idxtab[(((pxy[11]-acy)*l0)>>13)+8]|(((ab>> 8)-1)&3);
	block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=idxtab[(((pxy[ 0]-acy)*l0)>>13)+8]|(((ab>>15)-1)&3);
	p1=idxtab[(((pxy[ 1]-acy)*l0)>>13)+8]|(((ab>>14)-1)&3);
	p2=idxtab[(((pxy[ 2]-acy)*l0)>>13)+8]|(((ab>>13)-1)&3);
	p3=idxtab[(((pxy[ 3]-acy)*l0)>>13)+8]|(((ab>>12)-1)&3);
	block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
#endif
}


void BGBBTJ_BCn_EncodeBlockDXT1F_BGRA(byte *block,
	byte *rgba, int xstride, int ystride, int nclr)
{
	byte clr0[4], clr1[4];
	byte pxy[16];
	int p0, p1, p2, p3;
	int mcr, mcg, mcb, mcy;
	int ncr, ncg, ncb, ncy;
	int acr, acg, acb;
	int cr, cg, cb, cy, acy;
	int i, j, k;
	
	mcr=255; mcg=255; mcb=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0;

	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+2];
		cg=rgba[k+1];
		cb=rgba[k+0];
		cy=(cr+2*cg+cb)>>2;
		pxy[i*4+j]=cy;

		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
		acr+=cr; acg+=cg; acb+=cb;
	}
	
	acr=acr>>4;
	acg=acg>>4;
	acb=acb>>4;

	clr0[0]=(mcr*11+acr*5)>>4;
	clr0[1]=(mcg*11+acg*5)>>4;
	clr0[2]=(mcb*11+acb*5)>>4;
	clr1[0]=(ncr*11+acr*5)>>4;
	clr1[1]=(ncg*11+acg*5)>>4;
	clr1[2]=(ncb*11+acb*5)>>4;

	block[0]=((clr0[1]<<3)&0xE0) | (clr0[2]>>3);
	block[1]=(clr0[0]&0xF8) | (clr0[1]>>5);
	block[2]=((clr1[1]<<3)&0xE0) | (clr1[2]>>3);
	block[3]=(clr1[0]&0xF8) | (clr1[1]>>5);
	
	clr0[3]=(clr0[0]+2*clr0[1]+clr0[2])>>2;
	clr1[3]=(clr1[0]+2*clr1[1]+clr1[2])>>2;

	acy=(clr0[3]+clr1[3])>>1;

	p0=-((acy-pxy[ 0])>>16);
	p1=-((acy-pxy[ 1])>>16);
	p2=-((acy-pxy[ 2])>>16);
	p3=-((acy-pxy[ 3])>>16);
	block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[ 4])>>16);
	p1=-((acy-pxy[ 5])>>16);
	p2=-((acy-pxy[ 6])>>16);
	p3=-((acy-pxy[ 7])>>16);
	block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[ 8])>>16);
	p1=-((acy-pxy[ 9])>>16);
	p2=-((acy-pxy[10])>>16);
	p3=-((acy-pxy[11])>>16);
	block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	p0=-((acy-pxy[12])>>16);
	p1=-((acy-pxy[13])>>16);
	p2=-((acy-pxy[14])>>16);
	p3=-((acy-pxy[15])>>16);
	block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT1F_BGRA(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockDXT1F_BGRA(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 3);
	}
}


#if 0
void BGBBTJ_BCn_EncodeBlockDXT1A_BGRA(byte *block,
	byte *rgba, int xstride, int ystride)
{
	static char idxtaba[16]=
		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };
	static char idxtabb[16]=
		{ 1,1,1,1, 1,1,3,3, 2,2,0,0, 0,0,0,0 };
	static char idxtabc[16]=
		{ 0,0,0,0, 0,0,2,2, 2,2,1,1, 1,1,1,1 };
	static char idxtabd[16]=
		{ 1,1,1,1, 1,1,2,2, 2,2,0,0, 0,0,0,0 };
	byte pxa[16], pxy[16];
	char *idxtab;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int l0, l1, l2, l3a, l3b;
	int mcr, mcg, mcb, mca, mcy;
	int ncr, ncg, ncb, nca, ncy;
	int acr, acg, acb, aca, acy;
	int mcr2, mcg2, mcb2, mcy2;
	int ncr2, ncg2, ncb2, ncy2;
	int mcr3, mcg3, mcb3, mcy3;
	int ncr3, ncg3, ncb3, ncy3;
	int mcr3r, mcg3r, mcb3r, ncr3r, ncg3r, ncb3r;
	int mcr3g, mcg3g, mcb3g, ncr3g, ncg3g, ncb3g;
	int mcr3b, mcg3b, mcb3b, ncr3b, ncg3b, ncb3b;
	int dr, dg, db, da, dy, alty;
	int drr, dgr, dbr, drg, dgg, dbg, drb, dgb, dbb;
	int cr, cg, cb, ca, cy;
	int i, j, k, l;

#if 1
	mcr=255; mcg=255; mcb=255; mca=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; nca=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0; aca=  0; acy=  0;
	mcr2=255; mcg2=255; mcb2=255; mcy2=255;
	ncr2=  0; ncg2=  0; ncb2=  0; ncy2=  0;
	mcr3=255; mcg3=255; mcb3=255; mcy3=255;
	ncr3=  0; ncg3=  0; ncb3=  0; ncy3=  0;
	mcr3r=255; mcg3r=255; mcb3r=255;
	ncr3r=  0; ncg3r=  0; ncb3r=  0;
	mcr3g=255; mcg3g=255; mcb3g=255;
	ncr3g=  0; ncg3g=  0; ncb3g=  0;
	mcr3b=255; mcg3b=255; mcb3b=255;
	ncr3b=  0; ncg3b=  0; ncb3b=  0;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+2];	cg=rgba[k+1];
		cb=rgba[k+0];	ca=rgba[k+3];
		cy=(cr+(2*cg)+cb)>>2;		//Luma

		if(xstride==3)
			{ ca=255; }

		pxa[i*4+j]=ca;
		pxy[i*4+j]=cy;

		//Find Mins/Maxs
//		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
//		if((cy<mcy) && (ca>=64)) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if((cy>ncy) && (ca>=64)) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
		if(ca<mca) { mca=ca; }
		if(ca>nca) { nca=ca; }

		if(cy<mcy)
		{
			if(ca>=64) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
			mcr2=cr; mcg2=cg; mcb2=cb; mcy2=cy;
		}
		if(cy>ncy)
		{
			if(ca>=64) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
			ncr2=cr; ncg2=cg; ncb2=cb; ncy2=cy;
		}
		
		if(cr<mcr3) { mcr3=cr; }
		if(cg<mcg3) { mcg3=cg; }
		if(cb<mcb3) { mcb3=cb; }
		if(cr>ncr3) { ncr3=cr; }
		if(cg>ncg3) { ncg3=cg; }
		if(cb>ncb3) { ncb3=cb; }

		if(cr<mcr3r) { mcr3r=cr; mcg3r=cg; mcb3r=cb; }
		if(cg<mcg3g) { mcr3g=cr; mcg3g=cg; mcb3g=cb; }
		if(cb<mcb3b) { mcr3b=cr; mcg3b=cg; mcb3b=cb; }
		if(cr>ncr3r) { ncr3r=cr; ncg3r=cg; ncb3r=cb; }
		if(cg>ncg3g) { ncr3g=cr; ncg3g=cg; ncb3g=cb; }
		if(cb>ncb3b) { ncr3b=cr; ncg3b=cg; ncb3b=cb; }

		acr+=cr; acg+=cg;
		acb+=cb; acy+=cy;
	}
#endif

#if 0	
	mcr=255; mcg=255; mcb=255; mca=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; nca=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0; aca=  0; acy=  0;

	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+2];	cg=rgba[k+1];
		cb=rgba[k+0];	ca=rgba[k+3];
		cy=(cr+(2*cg)+cb)>>2;		//Luma

		if(xstride==3)
			{ ca=255; }

		pxa[i*4+j]=ca;
		pxy[i*4+j]=cy;

		//Find Mins/Maxs
		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
		if(ca<mca) { mca=ca; }
		if(ca>nca) { nca=ca; }
		
		acr+=cr; acg+=cg;
		acb+=cb; acy+=cy;
	}
#endif

	alty=0;

#if 0
	drr=ncr3r-mcr3r;	dgr=ncg3r-mcg3r;	dbr=ncb3r-mcb3r;
	drg=ncr3g-mcr3g;	dgg=ncg3g-mcg3g;	dbg=ncb3g-mcb3g;
	drb=ncr3b-mcr3b;	dgb=ncg3b-mcg3b;	dbb=ncb3b-mcb3b;
	dy=ncy-mcy;
//	if((dr>dy) || (dg>dy) || (db>dy))
	if((drr>dy) || (dgg>dy) || (dbb>dy))
	{
		if((drr>dgg) && (drr>dbb))
		{
			mcr=mcr3r; mcg=mcg3r; mcb=mcb3r;
			ncr=ncr3r; ncg=ncg3r; ncb=ncb3r;
		}else if(dgg>=dbb)
		{
			mcr=mcr3g; mcg=mcg3g; mcb=mcb3g;
			ncr=ncr3g; ncg=ncg3g; ncb=ncb3g;
		}else
		{
			mcr=mcr3b; mcg=mcg3b; mcb=mcb3b;
			ncr=ncr3b; ncg=ncg3b; ncb=ncb3b;
		}

		mcy=255; ncy=0;

		dr=ncr-mcr;
		dg=ncg-mcg;
		db=ncb-mcb;

		//normalize
		da=sqrt((dr*dr)+(dg*dg)+(db*db));
		dr=(256*dr)/da;
		dg=(256*dg)/da;
		db=(256*db)/da;

		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=(i*ystride)+(j*xstride);
			cr=rgba[k+2];	cg=rgba[k+1];
			cb=rgba[k+0];
//			cy=(cr+(2*cg)+cb)>>2;		//Luma
			cy=(cr*dr+cg*dg+cb*db)>>8;

			pxy[i*4+j]=cy;

			if(cy<mcy) { mcy=cy; }
			if(cy>ncy) { ncy=cy; }
		}
		
		alty=1;
	}
#endif

#if 0
	dr=ncr3-mcr3;	dg=ncg3-mcg3;
	db=ncb3-mcb3;	dy=ncy-mcy;
	if((dr>dy) || (dg>dy) || (db>dy))
	{
		mcr=mcr3; mcg=mcg3; mcb=mcb3; mcy=mcy3;
		ncr=ncr3; ncg=ncg3; ncb=ncb3; ncy=ncy3;
		mcy=255; ncy=0;

		//normalize
		da=sqrt((dr*dr)+(dg*dg)+(db*db));
		dr=(256*dr)/da;
		dg=(256*dg)/da;
		db=(256*db)/da;

		for(i=0; i<4; i++)
			for(j=0; j<4; j++)
		{
			k=(i*ystride)+(j*xstride);
			cr=rgba[k+2];	cg=rgba[k+1];
			cb=rgba[k+0];
//			cy=(cr+(2*cg)+cb)>>2;		//Luma
			cy=(cr*dr+cg*dg+cb*db)>>8;

			pxy[i*4+j]=cy;

			if(cy<mcy) { mcy=cy; }
			if(cy>ncy) { ncy=cy; }
		}
		
		alty=1;
	}
#endif

#if 1
	acr=(acr+8)>>4;
	acg=(acg+8)>>4;
	acb=(acb+8)>>4;
	acy=(acr+(2*acg)+acb)>>2;
	
	if(!alty)
	{
		l=(256*mcy)/(acy+1);
		cr=(acr*l+128)>>8;
		cg=(acg*l+128)>>8;
		cb=(acb*l+128)>>8;
	
		mcr=(3*mcr+cr)>>2;
		mcg=(3*mcg+cg)>>2;
		mcb=(3*mcb+cb)>>2;
	
		l=(256*ncy)/(acy+1);
		cr=(acr*l+128)>>8;
		cg=(acg*l+128)>>8;
		cb=(acb*l+128)>>8;
	
		ncr=(3*ncr+cr)>>2;
		ncg=(3*ncg+cg)>>2;
		ncb=(3*ncb+cb)>>2;
	}
#endif

#if 1
	mcr=((mcr+3)>>3)<<3;
	mcg=((mcg+1)>>2)<<2;
	mcb=((mcb+3)>>3)<<3;
	ncr=((ncr+5)>>3)<<3;
	ncg=((ncg+3)>>2)<<2;
	ncb=((ncb+5)>>3)<<3;
	mcr=(mcr<0)?0:((mcr>255)?255:mcr);
	mcg=(mcg<0)?0:((mcg>255)?255:mcg);
	mcb=(mcb<0)?0:((mcb>255)?255:mcb);
	ncr=(ncr<0)?0:((ncr>255)?255:ncr);
	ncg=(ncg<0)?0:((ncg>255)?255:ncg);
	ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif

	aca=(mca+nca)>>1;			//Median Alpha
	acy=(mcy+ncy)>>1;			//Median Luma
	l0=49152/(nca-aca+1);		//Fix-Point Scale (Alpha)
	l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
	l2=65536-2048;

	if(nca<128)
//	if(0)
	{
		//Fully Transparent Block
		i=((acr<<8)&0xF800) | ((acg<<3)&0x07E0) | ((acb>>3)&0x001F);
		block[0]=i;	block[1]=i>>8;
		block[2]=i;	block[3]=i>>8;

		block[4]=255;	block[5]=255;
		block[6]=255;	block[7]=255;
	}else
		if((mcr==ncr) && (mcg==ncg) && (mcb==ncb) && (mca==nca))
//		if(0)
	{	
		//Flat Color Block
		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
		if(j<=i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
		}

		if(i!=j)
		{
			block[4]=(2<<6)|(3<<4)|(2<<2)|3;
			block[5]=(3<<6)|(2<<4)|(3<<2)|2;
			block[6]=(2<<6)|(3<<4)|(2<<2)|3;
			block[7]=(3<<6)|(2<<4)|(3<<2)|2;
		}else
		{
			block[4]=0;	block[5]=0;
			block[6]=0;	block[7]=0;
		}
	}else
		if(mca>=128)
//		if(0)
	{
		//Emit RGB Block (Opaque)

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(j<i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtaba;
		}else if(i<j)
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabb;
		}else
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13];
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13];
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13];
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13];
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}else
	{
		//Emit RGB Block (Alpha)

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(i<=j)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabd;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13] | (((pxa[ 0]-128)>>10)&3);
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13] | (((pxa[ 1]-128)>>10)&3);
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13] | (((pxa[ 2]-128)>>10)&3);
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13] | (((pxa[ 3]-128)>>10)&3);
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13] | (((pxa[ 4]-128)>>10)&3);
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13] | (((pxa[ 5]-128)>>10)&3);
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13] | (((pxa[ 6]-128)>>10)&3);
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13] | (((pxa[ 7]-128)>>10)&3);
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13] | (((pxa[ 8]-128)>>10)&3);
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13] | (((pxa[ 9]-128)>>10)&3);
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13] | (((pxa[10]-128)>>10)&3);
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13] | (((pxa[11]-128)>>10)&3);
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13] | (((pxa[12]-128)>>10)&3);
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13] | (((pxa[13]-128)>>10)&3);
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13] | (((pxa[14]-128)>>10)&3);
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13] | (((pxa[15]-128)>>10)&3);
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
}
#endif



#if 1
void BGBBTJ_BCn_EncodeBlockDXT1A_BGRA(byte *block,
	byte *rgba, int xstride, int ystride)
{
	static char idxtaba[16]=
		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };
	static char idxtabb[16]=
		{ 1,1,1,1, 1,1,3,3, 2,2,0,0, 0,0,0,0 };
	static char idxtabc[16]=
		{ 0,0,0,0, 0,0,2,2, 2,2,1,1, 1,1,1,1 };
	static char idxtabd[16]=
		{ 1,1,1,1, 1,1,2,2, 2,2,0,0, 0,0,0,0 };
	byte pxa[16], pxyy[16], pxyr[16], pxyg[16], pxyb[16];
	byte *pxy;
	char *idxtab;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int l0, l1, l2, l3a, l3b;
	int mcr, mcg, mcb, mca, mcy;
	int ncr, ncg, ncb, nca, ncy;
	int acr, acg, acb, aca, acy;
	int mcr2, mcg2, mcb2, mcy2;
	int ncr2, ncg2, ncb2, ncy2;
	int mcr3, mcg3, mcb3, mcy3;
	int ncr3, ncg3, ncb3, ncy3;
	int mcr3r, mcg3r, mcb3r, ncr3r, ncg3r, ncb3r, mcy3r, ncy3r;
	int mcr3g, mcg3g, mcb3g, ncr3g, ncg3g, ncb3g, mcy3g, ncy3g;
	int mcr3b, mcg3b, mcb3b, ncr3b, ncg3b, ncb3b, mcy3b, ncy3b;
	int dr, dg, db, da, dy, alty;
	int drr, dgr, dbr, drg, dgg, dbg, drb, dgb, dbb;
	int cr, cg, cb, ca, cy, cyr, cyg, cyb;
	int i, j, k, l;

#if 1
	mcr=255; mcg=255; mcb=255; mca=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; nca=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0; aca=  0; acy=  0;
	mcr2=255; mcg2=255; mcb2=255; mcy2=255;
	ncr2=  0; ncg2=  0; ncb2=  0; ncy2=  0;
	mcr3=255; mcg3=255; mcb3=255; mcy3=255;
	ncr3=  0; ncg3=  0; ncb3=  0; ncy3=  0;
	mcr3r=255; mcg3r=255; mcb3r=255; mcy3r=255;
	ncr3r=  0; ncg3r=  0; ncb3r=  0; ncy3r=  0;
	mcr3g=255; mcg3g=255; mcb3g=255; mcy3g=255;
	ncr3g=  0; ncg3g=  0; ncb3g=  0; ncy3g=  0;
	mcr3b=255; mcg3b=255; mcb3b=255; mcy3b=255;
	ncr3b=  0; ncg3b=  0; ncb3b=  0; ncy3b=  0;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+2];	cg=rgba[k+1];
		cb=rgba[k+0];	ca=rgba[k+3];
//		cy=(cr+(2*cg)+cb)>>2;		//Luma

		cy =(5*cr+8*cg+3*cb)>>4;		//Luma (Default)
//		cyr=(8*cr+5*cg+3*cb)>>4;
		cyr=(8*cr+2*cg+6*cb)>>4;
		cyg=(8*cr+6*cg+2*cb)>>4;
		cyb=(2*cr+6*cg+8*cb)>>4;

		if(xstride==3)
			{ ca=255; }

		pxa[i*4+j]=ca;
//		pxy[i*4+j]=cy;

		pxyy[i*4+j]=cy;
		pxyr[i*4+j]=cyr;
		pxyg[i*4+j]=cyg;
		pxyb[i*4+j]=cyb;

		//Find Mins/Maxs
//		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
//		if((cy<mcy) && (ca>=64)) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
//		if((cy>ncy) && (ca>=64)) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
		if(ca<mca) { mca=ca; }
		if(ca>nca) { nca=ca; }

		if(cy<mcy)
		{
			if(ca>=64) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
			mcr2=cr; mcg2=cg; mcb2=cb; mcy2=cy;
		}
		if(cy>ncy)
		{
			if(ca>=64) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
			ncr2=cr; ncg2=cg; ncb2=cb; ncy2=cy;
		}

		if(cyr<mcy3r) { mcr3r=cr; mcg3r=cg; mcb3r=cb; mcy3r=cyr; }
		if(cyr>ncy3r) { ncr3r=cr; ncg3r=cg; ncb3r=cb; ncy3r=cyr; }
		if(cyg<mcy3g) { mcr3g=cr; mcg3g=cg; mcb3g=cb; mcy3g=cyg; }
		if(cyg>ncy3g) { ncr3g=cr; ncg3g=cg; ncb3g=cb; ncy3g=cyg; }
		if(cyb<mcy3b) { mcr3b=cr; mcg3b=cg; mcb3b=cb; mcy3b=cyb; }
		if(cyb>ncy3b) { ncr3b=cr; ncg3b=cg; ncb3b=cb; ncy3b=cyb; }
		
//		if(cr<mcr3) { mcr3=cr; }
//		if(cg<mcg3) { mcg3=cg; }
//		if(cb<mcb3) { mcb3=cb; }
//		if(cr>ncr3) { ncr3=cr; }
//		if(cg>ncg3) { ncg3=cg; }
//		if(cb>ncb3) { ncb3=cb; }

//		if(cr<mcr3r) { mcr3r=cr; mcg3r=cg; mcb3r=cb; }
//		if(cg<mcg3g) { mcr3g=cr; mcg3g=cg; mcb3g=cb; }
//		if(cb<mcb3b) { mcr3b=cr; mcg3b=cg; mcb3b=cb; }
//		if(cr>ncr3r) { ncr3r=cr; ncg3r=cg; ncb3r=cb; }
//		if(cg>ncg3g) { ncr3g=cr; ncg3g=cg; ncb3g=cb; }
//		if(cb>ncb3b) { ncr3b=cr; ncg3b=cg; ncb3b=cb; }

		acr+=cr; acg+=cg;
		acb+=cb; acy+=cy;
	}
#endif

	alty=0;

	pxy=pxyy;
	
	dy=ncy-mcy;
	dr=ncy3r-mcy3r;
	dg=ncy3g-mcy3g;
	db=ncy3b-mcy3b;
	if(dr>dy)
	{
		mcr=mcr3r; mcg=mcg3r; mcb=mcb3r; mcy=mcy3r;
		ncr=ncr3r; ncg=ncg3r; ncb=ncb3r; ncy=ncy3r;
		pxy=pxyr; dy=ncy-mcy; alty=0;
	}
	if(dg>dy)
	{
		mcr=mcr3g; mcg=mcg3g; mcb=mcb3g; mcy=mcy3g;
		ncr=ncr3g; ncg=ncg3g; ncb=ncb3g; ncy=ncy3g;
		pxy=pxyg; dy=ncy-mcy; alty=0;
	}
	if(db>dy)
	{
		mcr=mcr3b; mcg=mcg3b; mcb=mcb3b; mcy=mcy3b;
		ncr=ncr3b; ncg=ncg3b; ncb=ncb3b; ncy=ncy3b;
		pxy=pxyb; dy=ncy-mcy; alty=0;
	}

#if 1
	acr=(acr+8)>>4;
	acg=(acg+8)>>4;
	acb=(acb+8)>>4;
	
	if(!alty)
	{
		acy=(acr+(2*acg)+acb)>>2;
		mcy3=(mcr+(2*mcg)+mcb)>>2;
		ncy3=(ncr+(2*ncg)+ncb)>>2;

//		l=(256*mcy)/(acy+1);
		l=(256*mcy3)/(acy+1);
		cr=(acr*l+128)>>8;
		cg=(acg*l+128)>>8;
		cb=(acb*l+128)>>8;
	
		mcr=(3*mcr+cr)>>2;
		mcg=(3*mcg+cg)>>2;
		mcb=(3*mcb+cb)>>2;
	
//		l=(256*ncy)/(acy+1);
		l=(256*ncy3)/(acy+1);
		cr=(acr*l+128)>>8;
		cg=(acg*l+128)>>8;
		cb=(acb*l+128)>>8;
	
		ncr=(3*ncr+cr)>>2;
		ncg=(3*ncg+cg)>>2;
		ncb=(3*ncb+cb)>>2;
	}
#endif

#if 0
	mcr=((mcr+3)>>3)<<3;
	mcg=((mcg+1)>>2)<<2;
	mcb=((mcb+3)>>3)<<3;
	ncr=((ncr+5)>>3)<<3;
	ncg=((ncg+3)>>2)<<2;
	ncb=((ncb+5)>>3)<<3;
	mcr=(mcr<0)?0:((mcr>255)?255:mcr);
	mcg=(mcg<0)?0:((mcg>255)?255:mcg);
	mcb=(mcb<0)?0:((mcb>255)?255:mcb);
	ncr=(ncr<0)?0:((ncr>255)?255:ncr);
	ncg=(ncg<0)?0:((ncg>255)?255:ncg);
	ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif

#if 1
	mcr=BGBBTJ_BCn_RoundColorNearest5Bits(mcr);
	mcg=BGBBTJ_BCn_RoundColorNearest6Bits(mcg);
	mcb=BGBBTJ_BCn_RoundColorNearest5Bits(mcb);
	ncr=BGBBTJ_BCn_RoundColorNearest5Bits(ncr);
	ncg=BGBBTJ_BCn_RoundColorNearest6Bits(ncg);
	ncb=BGBBTJ_BCn_RoundColorNearest5Bits(ncb);
#endif

	aca=(mca+nca)>>1;			//Median Alpha
	acy=(mcy+ncy)>>1;			//Median Luma
	l0=49152/(nca-aca+1);		//Fix-Point Scale (Alpha)
	l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
	l2=65536-2048;

	if(nca<128)
//	if(0)
	{
		//Fully Transparent Block
		i=((acr<<8)&0xF800) | ((acg<<3)&0x07E0) | ((acb>>3)&0x001F);
		block[0]=i;	block[1]=i>>8;
		block[2]=i;	block[3]=i>>8;

		block[4]=255;	block[5]=255;
		block[6]=255;	block[7]=255;
	}else
		if((mcr==ncr) && (mcg==ncg) && (mcb==ncb) && (mca==nca))
//		if(0)
	{	
		//Flat Color Block
		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
		if(j<=i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
		}

		if(i!=j)
		{
			block[4]=(2<<6)|(3<<4)|(2<<2)|3;
			block[5]=(3<<6)|(2<<4)|(3<<2)|2;
			block[6]=(2<<6)|(3<<4)|(2<<2)|3;
			block[7]=(3<<6)|(2<<4)|(3<<2)|2;
		}else
		{
			block[4]=0;	block[5]=0;
			block[6]=0;	block[7]=0;
		}
	}else
		if(mca>=128)
//		if(0)
	{
		//Emit RGB Block (Opaque)

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(j<i)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtaba;
		}else if(i<j)
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabb;
		}else
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13];
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13];
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13];
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13];
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}else
	{
		//Emit RGB Block (Alpha)

		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[0]=i;	block[1]=i>>8;
//		block[2]=j;	block[3]=j>>8;

		if(i<=j)
		{
			block[0]=i;	block[1]=i>>8;
			block[2]=j;	block[3]=j>>8;
			idxtab=idxtabc;
		}else
		{
			block[0]=j;	block[1]=j>>8;
			block[2]=i;	block[3]=i>>8;
			idxtab=idxtabd;
		}

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13] | (((pxa[ 0]-128)>>10)&3);
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13] | (((pxa[ 1]-128)>>10)&3);
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13] | (((pxa[ 2]-128)>>10)&3);
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13] | (((pxa[ 3]-128)>>10)&3);
		block[4]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13] | (((pxa[ 4]-128)>>10)&3);
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13] | (((pxa[ 5]-128)>>10)&3);
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13] | (((pxa[ 6]-128)>>10)&3);
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13] | (((pxa[ 7]-128)>>10)&3);
		block[5]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13] | (((pxa[ 8]-128)>>10)&3);
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13] | (((pxa[ 9]-128)>>10)&3);
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13] | (((pxa[10]-128)>>10)&3);
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13] | (((pxa[11]-128)>>10)&3);
		block[6]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13] | (((pxa[12]-128)>>10)&3);
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13] | (((pxa[13]-128)>>10)&3);
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13] | (((pxa[14]-128)>>10)&3);
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13] | (((pxa[15]-128)>>10)&3);
		block[7]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
}
#endif


BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT1A_BGRA(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockDXT1A_BGRA(
			block+(i*xs1+j)*8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride);
	}
}
#include <bgbbtj.h>

#if 1
void BGBBTJ_BCn_EncodeBlockDXT5(byte *block,
	byte *rgba, int xstride, int ystride)
{
//	static const char idxtab[16]=
//		{ 0,0,0,0, 0,0,2,2, 3,3,1,1, 1,1,1,1 };
	static const char idxtab[16]=
		{ 1,1,1,1, 1,1,3,3, 2,2,0,0, 0,0,0,0 };
	static const char idxtab2[16]=
		{ 0,0,0,0, 2,2,3,3, 4,4,5,5, 1,1,1,1 };
	byte pxa[16], pxy[16];
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int l0, l1, l2, l3a, l3b;
	int mcr, mcg, mcb, mca, mcy;
	int ncr, ncg, ncb, nca, ncy;
	int acr, acg, acb, aca, acy;
	int cr, cg, cb, ca, cy;
	int i, j, k, l;
	
	mcr=255; mcg=255; mcb=255; mca=255; mcy=255;
	ncr=  0; ncg=  0; ncb=  0; nca=  0; ncy=  0;
	acr=  0; acg=  0; acb=  0; aca=  0; acy=  0;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=(i*ystride)+(j*xstride);
		cr=rgba[k+0];	cg=rgba[k+1];
		cb=rgba[k+2];	ca=rgba[k+3];
		cy=(cr+(2*cg)+cb)>>2;		//Luma

		pxa[i*4+j]=ca;
		pxy[i*4+j]=cy;

		//Find Mins/Maxs
		if(cy<mcy) { mcr=cr; mcg=cg; mcb=cb; mcy=cy; }
		if(cy>ncy) { ncr=cr; ncg=cg; ncb=cb; ncy=cy; }
		if(ca<mca) { mca=ca; }
		if(ca>nca) { nca=ca; }
		
		acr+=cr; acg+=cg;
		acb+=cb; acy+=cy;
	}

#if 1
	acr=(acr+8)>>4;
	acg=(acg+8)>>4;
	acb=(acb+8)>>4;
	acy=(acr+(2*acg)+acb)>>2;
	
	l=(256*mcy)/(acy+1);
	cr=(acr*l+128)>>8;
	cg=(acg*l+128)>>8;
	cb=(acb*l+128)>>8;
	
//	mcr=(11*mcr+5*cr+8)>>4;
//	mcg=(11*mcg+5*cg+8)>>4;
//	mcb=(11*mcb+5*cb+8)>>4;
//	mcr=(5*mcr+11*cr+8)>>4;
//	mcg=(5*mcg+11*cg+8)>>4;
//	mcb=(5*mcb+11*cb+8)>>4;
	mcr=(mcr+cr)>>1;
	mcg=(mcg+cg)>>1;
	mcb=(mcb+cb)>>1;
	

	l=(256*ncy)/(acy+1);
	cr=(acr*l+128)>>8;
	cg=(acg*l+128)>>8;
	cb=(acb*l+128)>>8;
	
//	ncr=(11*ncr+5*cr+8)>>4;
//	ncg=(11*ncg+5*cg+8)>>4;
//	ncb=(11*ncb+5*cb+8)>>4;
//	ncr=(5*ncr+11*cr+8)>>4;
//	ncg=(5*ncg+11*cg+8)>>4;
//	ncb=(5*ncb+11*cb+8)>>4;
	ncr=(ncr+cr)>>1;
	ncg=(ncg+cg)>>1;
	ncb=(ncb+cb)>>1;
#endif

	aca=(mca+nca)>>1;			//Median Alpha
	acy=(mcy+ncy)>>1;			//Median Luma
	l0=49152/(nca-aca+1);		//Fix-Point Scale (Alpha)
	l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
//	l2=4096;
//	l3=4096;
//	l2=-4096;
//	l3=-4096;
	l2=65536-2048;
//	l3a=65536-2048;
//	l3b=65536-2048;
//	l3b=65536;

	if(mca==nca)
	{
		block[0]=mca; block[1]=nca;
		block[2]=0;	block[3]=0;
		block[4]=0;	block[5]=0;
		block[6]=0;	block[7]=0;
	}else
	{
		//Emit Alpha Block
		block[0]=mca;
		block[1]=nca;
	
		p0=idxtab2[((pxa[ 0]-aca)*l0+l2)>>13];
		p1=idxtab2[((pxa[ 1]-aca)*l0+l2)>>13];
		p2=idxtab2[((pxa[ 2]-aca)*l0+l2)>>13];
		p3=idxtab2[((pxa[ 3]-aca)*l0+l2)>>13];
		p4=idxtab2[((pxa[ 4]-aca)*l0+l2)>>13];
		p5=idxtab2[((pxa[ 5]-aca)*l0+l2)>>13];
		p6=idxtab2[((pxa[ 6]-aca)*l0+l2)>>13];
		p7=idxtab2[((pxa[ 7]-aca)*l0+l2)>>13];
		block[2]=p0|(p1<<3)|(p2<<6);
		block[3]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
		block[4]=(p5>>1)|(p6<<2)|(p7<<5);
		p0=idxtab2[((pxa[ 8]-aca)*l0+l2)>>13];
		p1=idxtab2[((pxa[ 9]-aca)*l0+l2)>>13];
		p2=idxtab2[((pxa[10]-aca)*l0+l2)>>13];
		p3=idxtab2[((pxa[11]-aca)*l0+l2)>>13];
		p4=idxtab2[((pxa[12]-aca)*l0+l2)>>13];
		p5=idxtab2[((pxa[13]-aca)*l0+l2)>>13];
		p6=idxtab2[((pxa[14]-aca)*l0+l2)>>13];
		p7=idxtab2[((pxa[15]-aca)*l0+l2)>>13];
		block[5]=p0|(p1<<3)|(p2<<6);
		block[6]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
		block[7]=(p5>>1)|(p6<<2)|(p7<<5);
	}

	if((mcr==ncr) && (mcg==ncg) && (mcb==ncb))
	{
		//Flat Color Block
#if 1
		mcr=((mcr+3)>>3)<<3;
		mcg=((mcg+1)>>2)<<2;
		mcb=((mcb+3)>>3)<<3;
		ncr=((ncr+5)>>3)<<3;
		ncg=((ncg+3)>>2)<<2;
		ncb=((ncb+5)>>3)<<3;
		mcr=(mcr<0)?0:((mcr>255)?255:mcr);
		mcg=(mcg<0)?0:((mcg>255)?255:mcg);
		mcb=(mcb<0)?0:((mcb>255)?255:mcb);
		ncr=(ncr<0)?0:((ncr>255)?255:ncr);
		ncg=(ncg<0)?0:((ncg>255)?255:ncg);
		ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif
		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[ 8]=i;	block[ 9]=i>>8;
//		block[10]=j;	block[11]=j>>8;
		block[ 8]=j;	block[ 9]=j>>8;
		block[10]=i;	block[11]=i>>8;
		block[12]=(2<<6)|(3<<4)|(2<<2)|3;
		block[13]=(3<<6)|(2<<4)|(3<<2)|2;
		block[14]=(2<<6)|(3<<4)|(2<<2)|3;
		block[15]=(3<<6)|(2<<4)|(3<<2)|2;
	}else
	{
		//Emit RGB Block
#if 0
		mcr=((mcr+4)>>3)<<3;
		mcg=((mcg+2)>>2)<<2;
		mcb=((mcb+4)>>3)<<3;
		ncr=((ncr+4)>>3)<<3;
		ncg=((ncg+2)>>2)<<2;
		ncb=((ncb+4)>>3)<<3;
		mcr=(mcr<0)?0:((mcr>255)?255:mcr);
		mcg=(mcg<0)?0:((mcg>255)?255:mcg);
		mcb=(mcb<0)?0:((mcb>255)?255:mcb);
		ncr=(ncr<0)?0:((ncr>255)?255:ncr);
		ncg=(ncg<0)?0:((ncg>255)?255:ncg);
		ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif

#if 1
		mcr=((mcr+3)>>3)<<3;
		mcg=((mcg+1)>>2)<<2;
		mcb=((mcb+3)>>3)<<3;
		ncr=((ncr+5)>>3)<<3;
		ncg=((ncg+3)>>2)<<2;
		ncb=((ncb+5)>>3)<<3;
		mcr=(mcr<0)?0:((mcr>255)?255:mcr);
		mcg=(mcg<0)?0:((mcg>255)?255:mcg);
		mcb=(mcb<0)?0:((mcb>255)?255:mcb);
		ncr=(ncr<0)?0:((ncr>255)?255:ncr);
		ncg=(ncg<0)?0:((ncg>255)?255:ncg);
		ncb=(ncb<0)?0:((ncb>255)?255:ncb);
#endif

//		mcy=(mcr+(2*mcg)+mcb)>>2;
//		ncy=(ncr+(2*ncg)+ncb)>>2;
//		acy=(mcy+ncy)>>1;			//Median Luma

//		l1=32768/(ncy-acy+1);		//Fix-Point Scale (Luma)
//		l1=(32768-8192)/(ncy-acy+1);		//Fix-Point Scale (Luma)
		l1=(32768-6144)/(ncy-acy+1);		//Fix-Point Scale (Luma)
//		l1=(16384)/(ncy-acy+1);		//Fix-Point Scale (Luma)

//		l3a=65536-2048;
//		l3b=65536-2048;
//		l3b=65536;
//		l3a=65536;
//		l3b=65536+2048;
		l3a=65536-1024;
		l3b=65536+1024;

		i=((mcr<<8)&0xF800) | ((mcg<<3)&0x07E0) | ((mcb>>3)&0x001F);
		j=((ncr<<8)&0xF800) | ((ncg<<3)&0x07E0) | ((ncb>>3)&0x001F);
//		block[ 8]=i;	block[ 9]=i>>8;
//		block[10]=j;	block[11]=j>>8;
		block[ 8]=j;	block[ 9]=j>>8;
		block[10]=i;	block[11]=i>>8;

		p0=idxtab[((pxy[ 0]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 1]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[ 2]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[ 3]-acy)*l1+l3b)>>13];
		block[12]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 4]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[ 5]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[ 6]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[ 7]-acy)*l1+l3a)>>13];
		block[13]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[ 8]-acy)*l1+l3a)>>13];
		p1=idxtab[((pxy[ 9]-acy)*l1+l3b)>>13];
		p2=idxtab[((pxy[10]-acy)*l1+l3a)>>13];
		p3=idxtab[((pxy[11]-acy)*l1+l3b)>>13];
		block[14]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
		p0=idxtab[((pxy[12]-acy)*l1+l3b)>>13];
		p1=idxtab[((pxy[13]-acy)*l1+l3a)>>13];
		p2=idxtab[((pxy[14]-acy)*l1+l3b)>>13];
		p3=idxtab[((pxy[15]-acy)*l1+l3a)>>13];
		block[15]=(p3<<6)|(p2<<4)|(p1<<2)|p0;
	}
}
#endif

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT5(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockDXT5(
			block+(i*xs1+j)*16,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride);
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT5F(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
//		BGBBTJ_BCn_EncodeBlockBC4(
		BGBBTJ_BCn_EncodeBlockBC4L(
			block+(i*xs1+j)*16,
			rgba+(i*4*xs+j*4)*stride+3,
			stride, xs*stride);
		BGBBTJ_BCn_EncodeBlockDXT1F(
			block+(i*xs1+j)*16+8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride, 4);
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeIdxImageAlphaDXT5(byte *block,
	byte *rgba, int xs, int ys, int stride, int idx)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockBC4(
			block+(i*xs1+j)*16,
			rgba+(i*4*xs+j*4)*stride+idx,
			stride, xs*stride);
//		BGBBTJ_BCn_EncodeBlockDXT1F(
//			block+(i*xs1+j)*16+8,
//			rgba+(i*4*xs+j*4)*stride,
//			stride, xs*stride, 4);
	}
}

BGBBTJ_API void BGBBTJ_BCn_FillImageAlphaDXT5(byte *block,
	int val, int xs, int ys)
{
	int xs1, ys1;
	int i, j;
	
	xs1=xs>>2; ys1=ys>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_FillBlockBC4(
			block+(i*xs1+j)*16, val);
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT5B(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	int xs1, ys1;
	int i, j;
	
	xs1=(xs+3)>>2; ys1=(ys+3)>>2;
	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		BGBBTJ_BCn_EncodeBlockBC4(
			block+(i*xs1+j)*16,
			rgba+(i*4*xs+j*4)*stride+3,
			stride, xs*stride);
		BGBBTJ_BCn_EncodeBlockDXT1B(
			block+(i*xs1+j)*16+8,
			rgba+(i*4*xs+j*4)*stride,
			stride, xs*stride);
	}
}

BGBBTJ_API void BGBBTJ_BCn_EncodeImageDXT5B_Mip(byte *block,
	byte *rgba, int xs, int ys, int stride)
{
	byte *ct, *ct1;
	byte *cs, *cs1;
	int xs1, ys1;
	int xs2, ys2;
	int xs3, ys3;

	xs1=xs; ys1=ys;

	xs2=xs1; ys2=ys1; cs=rgba; ct=block;
	while((xs2>0) || (ys2>0))
	{
		if(!xs2)xs2++;
		if(!ys2)ys2++;
		xs3=(xs2+3)/4;
		ys3=(ys2+3)/4;
//		n+=xs3*ys3;
		cs1=cs+(xs2*ys2)*4;
		ct1=ct+(xs3*ys3)*16;
//		BGBBTJ_Tex_HalfSampleDest(ct0, ct, xs2, ys2);
		BGBBTJ_BCn_EncodeImageDXT5B(ct, cs, xs2, ys2, stride);
		xs2>>=1; ys2>>=1;
		cs=cs1; ct=ct1;
	}
}



BGBBTJ_API void BGBBTJ_BCn_DeblockImageDXT5(byte *iblk,
	byte *oblk, int xs, int ys)
{
	byte *cs, *ct, *cs0, *cs1;
	int cr, cg, cb;
	int cr0, cg0, cb0, cr1, cg1, cb1;
	int cra0, cga0, cba0, cra1, cga1, cba1;
	int crb0, cgb0, cbb0, crb1, cgb1, cbb1;
	int cra, cga, cba;
	int crb, cgb, cbb;
	int xs1, ys1;
	int clra, clrb;
	int clra0, clrb0;
	int clra1, clrb1;
	int clra2, clrb2;
	int clra3, clrb3;
	int i, j, k, l, n;

	xs1=(xs+3)/4;
	ys1=(ys+3)/4;
	n=xs1*ys1;

	for(i=0; i<ys1; i++)
		for(j=0; j<xs1; j++)
	{
		cs=iblk+(i*xs1+j)*16;
		ct=oblk+(i*xs1+j)*16;
		
		clra=cs[ 8]|(cs[ 9]<<8);
		clrb=cs[10]|(cs[11]<<8);
		
		if((clra!=clrb) ||
			((i<1) || ((i+1)>=ys1)) ||
			((j<1) || ((j+1)>=xs1)))
		{
			if(cs!=ct)
				{ bgbbtj_bt1c_memcpy16(ct, cs); }
			continue;
		}

		cs0=iblk+((i-1)*xs1+j)*16;
		cs1=iblk+((i+1)*xs1+j)*16;
		clra0=cs0[ 8]|(cs0[ 9]<<8);
		clrb0=cs0[10]|(cs0[11]<<8);
		clra1=cs1[ 8]|(cs1[ 9]<<8);
		clrb1=cs1[10]|(cs1[11]<<8);

//		if((clra0!=clrb0) || (clra1!=clrb1) ||
//			((clra==clra0) && (clra==clra1)))
//		{
//			if(cs!=ct)
//				{ bgbbtj_bt1c_memcpy16(ct, cs); }
//			continue;
//		}

		if(cs!=ct)
			{ bgbbtj_bt1c_memcpy8(ct, cs); }

		cr=(clra>>11)&31; cr=(cr<<3)|(cr>>2);
		cg=(clra>> 5)&63; cg=(cg<<2)|(cg>>4);
		cb=(clra    )&31; cb=(cb<<3)|(cb>>2);
//		cr0=(clra0>>11)&31; cr0=(cr0<<3)|(cr0>>2);
//		cg0=(clra0>> 5)&63; cg0=(cg0<<2)|(cg0>>4);
//		cb0=(clra0    )&31; cb0=(cb0<<3)|(cb0>>2);
//		cr1=(clra1>>11)&31; cr1=(cr1<<3)|(cr1>>2);
//		cg1=(clra1>> 5)&63; cg1=(cg1<<2)|(cg1>>4);
//		cb1=(clra1    )&31; cb1=(cb1<<3)|(cb1>>2);

		cra0=(clra0>>11)&31; cra0=(cra0<<3)|(cra0>>2);
		cga0=(clra0>> 5)&63; cga0=(cga0<<2)|(cga0>>4);
		cba0=(clra0    )&31; cba0=(cba0<<3)|(cba0>>2);
		cra1=(clra1>>11)&31; cra1=(cra1<<3)|(cra1>>2);
		cga1=(clra1>> 5)&63; cga1=(cga1<<2)|(cga1>>4);
		cba1=(clra1    )&31; cba1=(cba1<<3)|(cba1>>2);

		crb0=(clra0>>11)&31; crb0=(crb0<<3)|(crb0>>2);
		cgb0=(clra0>> 5)&63; cgb0=(cgb0<<2)|(cgb0>>4);
		cbb0=(clra0    )&31; cbb0=(cbb0<<3)|(cbb0>>2);
		crb1=(clra1>>11)&31; crb1=(crb1<<3)|(crb1>>2);
		cgb1=(clra1>> 5)&63; cgb1=(cgb1<<2)|(cgb1>>4);
		cbb1=(clra1    )&31; cbb1=(cbb1<<3)|(cbb1>>2);

		cr0=(cra0+crb0)>>1; cr1=(cra1+crb1)>>1;
		cg0=(cga0+cgb0)>>1; cg1=(cga1+cgb1)>>1;
		cb0=(cba0+cbb0)>>1; cb1=(cba1+cbb1)>>1;

//		cra=(11*cr+5*cr0)>>4;
//		cga=(11*cg+5*cg0)>>4;
//		cba=(11*cb+5*cb0)>>4;
//		crb=(11*cr+5*cr1)>>4;
//		cgb=(11*cg+5*cg1)>>4;
//		cbb=(11*cb+5*cb1)>>4;

//		cra=(5*cr+11*cr0)>>4;
//		cga=(5*cg+11*cg0)>>4;
//		cba=(5*cb+11*cb0)>>4;
//		crb=(5*cr+11*cr1)>>4;
//		cgb=(5*cg+11*cg1)>>4;
//		cbb=(5*cb+11*cb1)>>4;

		cra=(cr+cr0)>>1;
		cga=(cg+cg0)>>1;
		cba=(cb+cb0)>>1;
		crb=(cr+cr1)>>1;
		cgb=(cg+cg1)>>1;
		cbb=(cb+cb1)>>1;

		clra=((cra<<8)&0xF800) | ((cga<<3)&0x07E0) | ((cba>>3)&0x001F);
		clrb=((crb<<8)&0xF800) | ((cgb<<3)&0x07E0) | ((cbb>>3)&0x001F);
		ct[ 8]=clra;	ct[ 9]=clra>>8;
		ct[10]=clrb;	ct[11]=clrb>>8;

//		ct[12]=(2<<6)|(3<<4)|(2<<2)|3;
//		ct[13]=(3<<6)|(2<<4)|(3<<2)|2;
//		ct[14]=(2<<6)|(3<<4)|(2<<2)|3;
//		ct[15]=(3<<6)|(2<<4)|(3<<2)|2;

		ct[12]=(2<<6)|(0<<4)|(2<<2)|0;
		ct[13]=(3<<6)|(2<<4)|(3<<2)|2;
		ct[14]=(2<<6)|(3<<4)|(2<<2)|3;
		ct[15]=(3<<6)|(1<<4)|(3<<2)|1;

//		ct[ 8]=cs[ 8];			ct[ 9]=cs[ 9];
//		ct[10]=cs[10];			ct[11]=cs[11];
//		ct[12]=cs[15];			ct[13]=cs[14];
//		ct[14]=cs[13];			ct[15]=cs[12];
	}
}
#include <bgbbtj.h>

int BGBBTJ_BCn_IndexBC4Y(int val, int min, int max)
{
	int y, r, v;

	if(val==min)return(0);
	if(val==max)return(1);
	if(val==0)return(6);
	if(val==255)return(7);
	
	y=val-min;
	r=max-min;
	
	v=y*(256/(r+1));
	v=(v+32)>>6;
	if(v<0)v=0;
	if(v>3)v=3;
	return(v+2);
}

void BGBBTJ_BCn_FillBlockBC4(byte *block, int val)
{
	block[0]=val; block[1]=val;
	block[2]=0;	block[3]=0;	block[4]=0;
	block[5]=0;	block[6]=0;	block[7]=0;
	return;
}

void BGBBTJ_BCn_EncodeBlockBC4(byte *block,
	byte *rgba, int xstride, int ystride)
{
	int min, max, avg;
	int cy;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int i, j;

	min=255; max=0; avg=0;
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		cy=rgba[(i*ystride)+(j*xstride)+0];
		if(cy<min)min=cy;
		if(cy>max)max=cy;
		avg+=cy;
	}
	avg=(avg+8)>>4;
	
	if(min==max)
	{
		block[0]=min;
		block[1]=max;
		block[2]=0;	block[3]=0;	block[4]=0;
		block[5]=0;	block[6]=0;	block[7]=0;
		return;
	}
	
	block[0]=min;
	block[1]=max;

	p0=BGBBTJ_BCn_IndexBC4Y(rgba[(0*xstride)+(0*ystride)], min, max);
	p1=BGBBTJ_BCn_IndexBC4Y(rgba[(1*xstride)+(0*ystride)], min, max);
	p2=BGBBTJ_BCn_IndexBC4Y(rgba[(2*xstride)+(0*ystride)], min, max);
	p3=BGBBTJ_BCn_IndexBC4Y(rgba[(3*xstride)+(0*ystride)], min, max);

	p4=BGBBTJ_BCn_IndexBC4Y(rgba[(0*xstride)+(1*ystride)], min, max);
	p5=BGBBTJ_BCn_IndexBC4Y(rgba[(1*xstride)+(1*ystride)], min, max);
	p6=BGBBTJ_BCn_IndexBC4Y(rgba[(2*xstride)+(1*ystride)], min, max);
	p7=BGBBTJ_BCn_IndexBC4Y(rgba[(3*xstride)+(1*ystride)], min, max);

	block[2]=p0|(p1<<3)|(p2<<6);
	block[3]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
	block[4]=(p5>>1)|(p6<<2)|(p7<<5);
	
//	block[2]=(p7<<5)|(p6<<2)|(p5>>1);
//	block[3]=(p5<<7)|(p4<<4)|(p3<<1)|(p2>>2);
//	block[4]=(p2<<6)|(p1<<3)|p0;

//	block[4]=(p7<<5)|(p6<<2)|(p5>>1);
//	block[3]=(p5<<7)|(p4<<4)|(p3<<1)|(p2>>2);
//	block[2]=(p2<<6)|(p1<<3)|p0;

	p0=BGBBTJ_BCn_IndexBC4Y(rgba[(0*xstride)+(2*ystride)], min, max);
	p1=BGBBTJ_BCn_IndexBC4Y(rgba[(1*xstride)+(2*ystride)], min, max);
	p2=BGBBTJ_BCn_IndexBC4Y(rgba[(2*xstride)+(2*ystride)], min, max);
	p3=BGBBTJ_BCn_IndexBC4Y(rgba[(3*xstride)+(2*ystride)], min, max);

	p4=BGBBTJ_BCn_IndexBC4Y(rgba[(0*xstride)+(3*ystride)], min, max);
	p5=BGBBTJ_BCn_IndexBC4Y(rgba[(1*xstride)+(3*ystride)], min, max);
	p6=BGBBTJ_BCn_IndexBC4Y(rgba[(2*xstride)+(3*ystride)], min, max);
	p7=BGBBTJ_BCn_IndexBC4Y(rgba[(3*xstride)+(3*ystride)], min, max);
	
	block[5]=p0|(p1<<3)|(p2<<6);
	block[6]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
	block[7]=(p5>>1)|(p6<<2)|(p7<<5);

//	block[5]=(p7<<5)|(p6<<2)|(p5>>1);
//	block[6]=(p5<<7)|(p4<<4)|(p3<<1)|(p2>>2);
//	block[7]=(p2<<6)|(p1<<3)|p0;

//	block[7]=(p7<<5)|(p6<<2)|(p5>>1);
//	block[6]=(p5<<7)|(p4<<4)|(p3<<1)|(p2>>2);
//	block[5]=(p2<<6)|(p1<<3)|p0;
}


int BGBBTJ_BCn_IndexBC4YL(int val, int min, int max)
{
	int y, r, v;

	if(val==min)return(0);
	if(val==max)return(1);
	if(val==0)return(6);
	if(val==255)return(7);
	
	v=(min+max)>>1;
	return((val>v)?4:3);
	
//	y=val-min;
//	r=max-min;
	
//	v=y*(256/(r+1));
//	v=(v+32)>>6;
//	v&=~1;
//	if(v<0)v=0;
//	if(v>3)v=3;
//	return(v+2);
}

void BGBBTJ_BCn_EncodeBlockBC4L(byte *block,
	byte *rgba, int xstride, int ystride)
{
	int min, max, avg;
	int cy;
	int p0, p1, p2, p3, p4, p5, p6, p7;
	int i, j;

	min=255; max=0; avg=0;
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		cy=rgba[(i*ystride)+(j*xstride)+0];
		if(cy<min)min=cy;
		if(cy>max)max=cy;
		avg+=cy;
	}
	avg=(avg+8)>>4;
	
	if(min==max)
	{
		block[0]=min;
		block[1]=max;
		block[2]=0;	block[3]=0;	block[4]=0;
		block[5]=0;	block[6]=0;	block[7]=0;
		return;
	}
	
	block[0]=min;
	block[1]=max;

	p0=BGBBTJ_BCn_IndexBC4YL(rgba[(0*xstride)+(0*ystride)], min, max);
	p1=BGBBTJ_BCn_IndexBC4YL(rgba[(1*xstride)+(0*ystride)], min, max);
	p2=BGBBTJ_BCn_IndexBC4YL(rgba[(2*xstride)+(0*ystride)], min, max);
	p3=BGBBTJ_BCn_IndexBC4YL(rgba[(3*xstride)+(0*ystride)], min, max);

	p4=BGBBTJ_BCn_IndexBC4YL(rgba[(0*xstride)+(1*ystride)], min, max);
	p5=BGBBTJ_BCn_IndexBC4YL(rgba[(1*xstride)+(1*ystride)], min, max);
	p6=BGBBTJ_BCn_IndexBC4YL(rgba[(2*xstride)+(1*ystride)], min, max);
	p7=BGBBTJ_BCn_IndexBC4YL(rgba[(3*xstride)+(1*ystride)], min, max);

	block[2]=p0|(p1<<3)|(p2<<6);
	block[3]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
	block[4]=(p5>>1)|(p6<<2)|(p7<<5);

	p0=BGBBTJ_BCn_IndexBC4YL(rgba[(0*xstride)+(2*ystride)], min, max);
	p1=BGBBTJ_BCn_IndexBC4YL(rgba[(1*xstride)+(2*ystride)], min, max);
	p2=BGBBTJ_BCn_IndexBC4YL(rgba[(2*xstride)+(2*ystride)], min, max);
	p3=BGBBTJ_BCn_IndexBC4YL(rgba[(3*xstride)+(2*ystride)], min, max);

	p4=BGBBTJ_BCn_IndexBC4YL(rgba[(0*xstride)+(3*ystride)], min, max);
	p5=BGBBTJ_BCn_IndexBC4YL(rgba[(1*xstride)+(3*ystride)], min, max);
	p6=BGBBTJ_BCn_IndexBC4YL(rgba[(2*xstride)+(3*ystride)], min, max);
	p7=BGBBTJ_BCn_IndexBC4YL(rgba[(3*xstride)+(3*ystride)], min, max);
	
	block[5]=p0|(p1<<3)|(p2<<6);
	block[6]=(p2>>2)|(p3<<1)|(p4<<4)|(p5<<7);
	block[7]=(p5>>1)|(p6<<2)|(p7<<5);
}

void BGBBTJ_BCn_EncodeBlockBC4Y8x8(byte *block, short *y)
{
	byte yb[16];
	int i, j, k;
	
	for(i=0; i<4; i++)
		for(j=0; j<4; j++)
	{
		k=y[i*8+j];
		if(k<0)k=0;
		if(k>255)k=255;
		yb[(3-i)*4+j]=k;
	}

	BGBBTJ_BCn_EncodeBlockBC4L(block, yb, 1, 4);
}
