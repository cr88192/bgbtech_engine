#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
	static int pl[(1<<16)];
	int np;
	unsigned long long i, j, k;

	np=0;

	for(i=2; i<65536; i++)
	{
//		if(((i-1)>>16)!=(i>>16))fprintf(stderr, "%d\n", i);

		for(j=0; j<np; j++)
		{
			if(!(i%pl[j]))break;	//value is not prime

			k=pl[j];
			if((k*k)>i)
			{
				pl[np++]=i;
				break;	//value is prime
			}
		}
		if(j<np)continue;

		pl[np++]=i;
	}

	printf("NP %d\n", np);

	for(i=0; i<(np/12); i++)
	{
		for(j=0; j<12; j++)
			printf(" %4d,", pl[i*12+j]);
		printf("\n");
	}
	for(j=0; j<(np%12); j++)
		printf(" %4d,", pl[i*12+j]);
	printf("\n");
}
/*
Reverse Preprocessing Step
Process and rebuild parse trees in reverse order for reasons of building a
forwards context (and possible rebuilding of future statements).
*/

#include <bgbscr1.h>

elem BS1_SComp_ReverseStepStmt(BS1_SVMCState *ctx, elem l)
{
	return(l);
}

elem BS1_SComp_ReverseStepBlock(BS1_SVMCState *ctx, elem l)
{
	elem t, r;
	if(!BS1_CONSP(l))return(l);
	r=BS1_SComp_ReverseStepBlock(ctx, CDR(l));
	t=BS1_SComp_ReverseStepStmt(ctx, CAR(l));

	if((t==CAR(l)) && (r==CDR(l)))
		return(l);

	t=CONS(t, r);
	BS1_GC_CheckRef(l);
	return(t);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>


int BS1_CComp_CompileBinary(BS1_SVMCState *ctx, elem l)
{
	elem ln, rn, lt, rt;
	elem t0, t1;
	int lc, rc;

	int i, j, k;

	ln=BS1_CComp_ReduceExpr(ctx, CADR(l));
	rn=BS1_CComp_ReduceExpr(ctx, CADDR(l));

	lt=BS1_CComp_InferExprClean(ctx, ln, &lc);
	rt=BS1_CComp_InferExprClean(ctx, rn, &rc);


	if(lt==BS1_MM_NULL)return(0);
	if(rt==BS1_MM_NULL)return(0);

	if((lt==rt) && (lt==KEYSYM("int")))
	{
		i=-1;

		if(FORM_IS(l, "+"))i=BS1_SOP_ADD_FN;
		if(FORM_IS(l, "-"))i=BS1_SOP_SUB_FN;
		if(FORM_IS(l, "*"))i=BS1_SOP_MUL_FN;
		if(FORM_IS(l, "/"))i=BS1_SOP_DIV_FN;
		if(FORM_IS(l, "\\"))i=BS1_SOP_IDIV_FN;
		if(FORM_IS(l, "%"))i=BS1_SOP_MOD_FN;
		if(FORM_IS(l, "&"))i=BS1_SOP_AND_FN;
		if(FORM_IS(l, "|"))i=BS1_SOP_OR_FN;
		if(FORM_IS(l, "^"))i=BS1_SOP_XOR_FN;

		if(FORM_IS(l, "<<"))i=BS1_SOP_SHL_FN;
		if(FORM_IS(l, ">>"))i=BS1_SOP_SHR_FN;
		if(FORM_IS(l, "**"))i=BS1_SOP_EXP_FN;

		if(FORM_IS(l, "<"))i=BS1_SOP_CMP_L_FN;
		if(FORM_IS(l, ">"))i=BS1_SOP_CMP_G_FN;
		if(FORM_IS(l, "<="))i=BS1_SOP_CMP_LE_FN;
		if(FORM_IS(l, ">="))i=BS1_SOP_CMP_GE_FN;
		if(FORM_IS(l, "=="))i=BS1_SOP_CMP_E_FN;
		if(FORM_IS(l, "!="))i=BS1_SOP_CMP_NE_FN;
		if(FORM_IS(l, "==="))i=BS1_SOP_CMP_E_FN;
		if(FORM_IS(l, "!=="))i=BS1_SOP_CMP_NE_FN;

		if(i<0)return(0);

		if(((i==BS1_SOP_ADD_FN) || (i==BS1_SOP_SUB_FN)) &&
			(BS1_FIXNUMP(ln) || BS1_FIXNUMP(rn)))
		{
			if(BS1_FIXNUMP(ln)) { t0=rn; t1=ln; }
				else { t0=ln; t1=rn; }

			j=TOINT(t1);
			if(!j)
			{
				BS1_CComp_CompileExpr(ctx, t0);
				return(1);
			}

			k=1;
			if(i==BS1_SOP_SUB_FN)
			{
				j=-j;

				//handle case of sides flipped
				if(BS1_FIXNUMP(ln))k=0;
			}

			if(k && (j>0) && (j<256))
			{
				BS1_CComp_CompileExpr(ctx, t0);
				if(j<3)
				{
					if(j==1)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_INC2_FN;
					return(1);
				}

				*ctx->ip++=BS1_SOP_ADD_FN_C;
				*ctx->ip++=j;
				return(1);
			}
			if(k && (j<0) && (j>-256))
			{
				BS1_CComp_CompileExpr(ctx, t0);
				if(j>-3)
				{
					if(j==-1)*ctx->ip++=BS1_SOP_DEC_FN;
					else *ctx->ip++=BS1_SOP_DEC2_FN;
					return(1);
				}

				*ctx->ip++=BS1_SOP_SUB_FN_C;
				*ctx->ip++=-j;
				return(1);
			}
		}

		if((i==BS1_SOP_MUL_FN) &&
			(BS1_FIXNUMP(ln) || BS1_FIXNUMP(rn)))
		{
			if(BS1_FIXNUMP(ln)) { t0=rn; t1=ln; }
				else { t0=ln; t1=rn; }

			j=TOINT(t1);
			if(!j)
			{
				*ctx->ip++=BS1_SOP_PUSH_0;
				return(1);
			}

			k=0;
			if(j<0) { j=-j; k=1; }

			if(j<256)
			{
				BS1_CComp_CompileExpr(ctx, t0);
				*ctx->ip++=BS1_SOP_MUL_FN_C;
				*ctx->ip++=j;
				if(k)*ctx->ip++=BS1_SOP_NEG_FN;
				return(1);
			}
		}

		if(((i==BS1_SOP_SHL_FN) || (i==BS1_SOP_SHR_FN) ||
			(i==BS1_SOP_EXP_FN)) && BS1_FIXNUMP(rn))
		{
			j=TOINT(rn);
			if(!j && ((i==BS1_SOP_SHL_FN) || (i==BS1_SOP_SHR_FN)))
			{
				BS1_CComp_CompileExpr(ctx, ln);
				return(1);
			}
			if(!j && (i==BS1_SOP_EXP_FN))
			{
				*ctx->ip++=BS1_SOP_PUSH_1;
				return(1);
			}

			if((j>0) && (j<256))
			{
				if(i==BS1_SOP_SHL_FN)i=BS1_SOP_SHL_FN_C;
				if(i==BS1_SOP_SHR_FN)i=BS1_SOP_SHR_FN_C;
				if(i==BS1_SOP_EXP_FN)i=BS1_SOP_EXP_FN_C;

				BS1_CComp_CompileExpr(ctx, ln);
				*ctx->ip++=i;
				*ctx->ip++=j;
				return(1);
			}
		}

		if(lc && rc && EQUALP(ln, rn))
		{
			BS1_CComp_CompileExpr(ctx, ln);
			*ctx->ip++=BS1_SOP_DUP_F;
			*ctx->ip++=i;
			return(1);
		}

		BS1_CComp_CompileExpr(ctx, ln);
		BS1_CComp_CompileExpr(ctx, rn);
		*ctx->ip++=i;

		return(1);
	}

	i=0; j=0;
	if(lt==KEYSYM("int"))i=1;
	if(lt==KEYSYM("float"))i=1;
	if(rt==KEYSYM("int"))j=1;
	if(rt==KEYSYM("float"))j=1;

	if(i && j)
	{
		i=-1;

		if(FORM_IS(l, "+"))i=BS1_SOP_ADD_FL;
		if(FORM_IS(l, "-"))i=BS1_SOP_SUB_FL;
		if(FORM_IS(l, "*"))i=BS1_SOP_MUL_FL;
		if(FORM_IS(l, "/"))i=BS1_SOP_DIV_FL;

		if(FORM_IS(l, "<"))i=BS1_SOP_CMP_L_FL;
		if(FORM_IS(l, ">"))i=BS1_SOP_CMP_G_FL;
		if(FORM_IS(l, "<="))i=BS1_SOP_CMP_LE_FL;
		if(FORM_IS(l, ">="))i=BS1_SOP_CMP_GE_FL;
		if(FORM_IS(l, "=="))i=BS1_SOP_CMP_E_FL;
		if(FORM_IS(l, "!="))i=BS1_SOP_CMP_NE_FL;

		if(i<0)return(0);

		if(lc && rc && EQUALP(ln, rn))
		{
			BS1_CComp_CompileExpr(ctx, ln);
			*ctx->ip++=BS1_SOP_DUP_F;
			*ctx->ip++=i;
		}


		BS1_CComp_CompileExpr(ctx, ln);
		if(lt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;

		BS1_CComp_CompileExpr(ctx, rn);
		if(rt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;

		*ctx->ip++=i;

		return(1);
	}

	return(0);
}

void BS1_CComp_EmitOp(BS1_SVMCState *ctx, elem i)
{
	if(i>=192)
	{
		*ctx->ip++=(i>>8)+192;
		*ctx->ip++=i&0xFF;
	}else *ctx->ip++=i;
}

int BS1_CComp_CheckLexical(BS1_SVMCState *ctx, elem l)
{
	elem c, t;
	int i;

	if(!BS1_SYMBOLP(l))return(-1);

	c=ctx->lenv; i=0;
	while(BS1_CONSP(c))
	{
		if(CAR(c)==l)break;
		c=CDR(c);
		i++;
	}

	if(BS1_CONSP(c))return(i);
	return(-1);
}


void BS1_CComp_CompileAssign(BS1_SVMCState *ctx, elem l)
{
	elem c, ct, cv, t;
	int i, j;

#if 0
	c=ctx->lenv; ct=ctx->tenv; cv=ctx->venv;
	i=0; j=0;
	while(BS1_CONSP(c))
	{
		if(c==ctx->llenv)i=1;
		if(CAR(c)==l)break;
		c=CDR(c); ct=CDR(ct); cv=CDR(cv);
		j++;
	}
	if(BS1_CONSP(c) && i)ctx->cap++;

	if(BS1_CONSP(c))
	{
		t=CAR(ct);
		BS1_TY_SetCar(cv, BS1_MM_NULL);

		if(t!=BS1_MM_NULL)
		{
			i=BS1_CComp_IndexLit(ctx, t);
			*ctx->ip++=BS1_SOP_CAST;
			BS1_CComp_EncIDX(ctx, i);
		}

		if((t==KEYSYM("int")) || (t==KEYSYM("float")))
		{
			*ctx->ip++=BS1_SOP_LSTORE_F;
			*ctx->ip++=j;
			return;
		}

		*ctx->ip++=BS1_SOP_LSTORE;
		*ctx->ip++=j;
		return;
	}
#endif

	i=BS1_CComp_IndexLit(ctx, l);
	*ctx->ip++=BS1_SOP_STORE;
	BS1_CComp_EncIDX(ctx, i);
}

void BS1_CComp_CompileForm(BS1_SVMCState *ctx, elem l)
{
	byte *ips[64];
	byte *ip0, *ip1, *ip2;
	elem c, d, t, u, v;
	int i, j;

	if(FORM_IS(l, "return"))
	{
		BS1_CComp_CompileExpr(ctx, CADR(l));
		if(!ctx->tail)
			*ctx->ip++=BS1_SOP_RET;
		return;
	}

	if(FORM_IS(l, "set!"))
	{
		BS1_CComp_CompileExpr(ctx, CADDR(l));

		i=BS1_CComp_RegIdx(CADR(l));
		if(i>=0)
		{
			*ctx->ip++=BS1_SOP_DUP_R;
			*ctx->ip++=i;
			return;
		}

		*ctx->ip++=BS1_SOP_DUP;
		BS1_CComp_CompileAssign(ctx, CADR(l));
		return;
	}

	if((FORM_IS(l, "setindex!")) || (FORM_IS(l, "vector-set!")))
	{
		t=CADDDR(l);
		u=BS1_CComp_InferExpr(ctx, t);
		BS1_CComp_CompileExpr(ctx, t);
		if((u==KEYSYM("int")) || (u==KEYSYM("float")))
				*ctx->ip++=BS1_SOP_DUP_F;
			else *ctx->ip++=BS1_SOP_DUP;

		if(BS1_FIXNUMP(CADDR(l)))
		{
			i=TOINT(CADDR(l));
			BS1_CComp_CompileExpr(ctx, CADR(l));
			*ctx->ip++=BS1_SOP_STOREINDEX_I;
			BS1_CComp_EncVLI(ctx, i);
			return;
		}

//		BS1_CComp_CompileExpr(ctx, CADDDR(l));
//		*ctx->ip++=BS1_SOP_DUP;
		BS1_CComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_EXCH;
		BS1_CComp_CompileExpr(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_EXCH;
		*ctx->ip++=BS1_SOP_STOREINDEX;
		return;
	}

	if((FORM_IS(l, "getindex")) || (FORM_IS(l, "vector-ref")))
	{
		if(BS1_FIXNUMP(CADDR(l)))
		{
			i=TOINT(CADDR(l));

			BS1_CComp_CompileExpr(ctx, CADR(l));
			*ctx->ip++=BS1_SOP_LOADINDEX_I;
			BS1_CComp_EncVLI(ctx, i);
			return;
		}

		BS1_CComp_CompileExpr(ctx, CADR(l));
		BS1_CComp_CompileExpr(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_LOADINDEX;
		return;
	}

	if(FORM_IS(l, "objref"))
	{
		BS1_CComp_CompileExpr(ctx, CADR(l));

		i=BS1_CComp_IndexLit(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_LOADINDEX_S;
		BS1_CComp_EncVLI(ctx, i);

		return;
	}

	if(FORM_IS(l, "objset!"))
	{
		t=CADDDR(l);
		u=BS1_CComp_InferExpr(ctx, t);
		BS1_CComp_CompileExpr(ctx, t);
		if((u==KEYSYM("int")) || (u==KEYSYM("float")))
				*ctx->ip++=BS1_SOP_DUP_I;
			else
		{
			*ctx->ip++=BS1_SOP_DUP;
			BS1_CComp_EncTy(ctx, u);
		}

		BS1_CComp_CompileExpr(ctx, CADR(l));
		i=BS1_CComp_IndexLit(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_STOREINDEX_S;
		BS1_CComp_EncTyIdx(ctx, u, i);

		return;
	}

	if(FORM_IS(l, "preinc!") || FORM_IS(l, "predec!"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		u=BS1_CComp_InferExpr(ctx, t);
		if(FORM_IS(l, "preinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;

		if(BS1_SYMBOLP(t))
		{
			BS1_CComp_CompileExpr(ctx, t);

			if(u==KEYSYM("int"))
			{
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_DEC_FN;
				*ctx->ip++=BS1_SOP_DUP_F;
			}else
			{
				*ctx->ip++=BS1_SOP_UNARYOP;
				BS1_CComp_EncTyIdx(ctx, u, i);
				*ctx->ip++=BS1_SOP_DUP;
				BS1_CComp_EncTy(ctx, u);
			}

			BS1_CComp_CompileAssign(ctx, t);
			return;
		}

		return;
	}

	if(FORM_IS(l, "postinc!") || FORM_IS(l, "postdec!"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		u=BS1_CComp_InferExpr(ctx, t);
		if(FORM_IS(l, "postinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;

		if(BS1_SYMBOLP(t))
		{
			BS1_CComp_CompileExpr(ctx, t);

			if(u==KEYSYM("int"))
			{
				*ctx->ip++=BS1_SOP_DUP_I;
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_DEC_FN;
			}else
			{
				*ctx->ip++=BS1_SOP_DUP;
				BS1_CComp_EncTy(ctx, u);
				*ctx->ip++=BS1_SOP_UNARYOP;
				BS1_CComp_EncTyIdx(ctx, u, i);
			}

			BS1_CComp_CompileAssign(ctx, t);
			return;
		}

		return;
	}


	if(FORM_IS(l, "if"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		i=BS1_CComp_BoolExpr(ctx, t);
		if(i==1)
		{
			BS1_CComp_CompileExpr(ctx, CADDR(l));
			return;
		}
		if(i==0)
		{
			if(BS1_CONSP(CDDDR(l)))
				BS1_CComp_CompileExpr(ctx, CADDDR(l));
			return;
		}

		BS1_CComp_CompileJCF(ctx, t);
		ip0=ctx->ip;

		BS1_CComp_CompileExprT(ctx, CADDR(l));

		if(ctx->tail)
		{
			if(!FORM_IS(CADDR(l), "funcall"))
				*ctx->ip++=BS1_SOP_RET;
		}else
		{
			*ctx->ip++=BS1_SOP_JMP;
			*ctx->ip++=0;
			*ctx->ip++=0;
			ip1=ctx->ip;
		}

		i=ctx->ip-ip0;
		*(ip0-2)=i&0xFF;
		*(ip0-1)=(i>>8)&0xFF;

		if(BS1_CONSP(CDDDR(l)))
			BS1_CComp_CompileExprT(ctx, CADDDR(l));
			else *ctx->ip++=BS1_SOP_PUSH_NULL;

		if(!ctx->tail)
		{
			i=ctx->ip-ip1;
			*(ip1-2)=i&0xFF;
			*(ip1-1)=(i>>8)&0xFF;
		}

		return;
	}

	if(FORM_IS(l, "begin"))
	{
		c=CDR(l);
		while(1)
		{
			if(BS1_CONSP(CDR(c)))
			{
				BS1_CComp_CompileStatement(ctx, CAR(c));
				c=CDR(c);
				continue;
			}

			BS1_CComp_CompileExprT(ctx, CAR(c));
			break;
		}

		return;
	}

	if((FORM_IS(l, "and")) || (FORM_IS(l, "or")))
	{
		if(FORM_IS(l, "and"))j=BS1_SOP_JMP_FALSE;
		if(FORM_IS(l, "or"))j=BS1_SOP_JMP_TRUE;

		i=0; c=CDR(l);
		while(1)
		{
			if(BS1_CONSP(CDR(c)))
			{
				BS1_CComp_CompileExpr(ctx, CAR(c));
				*ctx->ip++=BS1_SOP_DUP;

				*ctx->ip++=j;
				*ctx->ip++=0;
				*ctx->ip++=0;
				ips[i++]=ctx->ip;

				*ctx->ip++=BS1_SOP_POP;

				c=CDR(c);
				continue;
			}

			BS1_CComp_CompileExprT(ctx, CAR(c));

			while(i>0)
			{
				i--;
				j=ctx->ip-ips[i];
				*(ips[i]-2)=j&0xFF;
				*(ips[i]-1)=(j>>8)&0xFF;
			}

			break;
		}

		return;
	}

	if(FORM_IS(l, "unary"))
	{
		BS1_CComp_CompileExpr(ctx, CADDR(l));

		i=-1;
		if(CADR(l)==SYM("+"))i=BS1_OPR_POS;
		if(CADR(l)==SYM("-"))i=BS1_OPR_NEG;
		if(CADR(l)==SYM("~"))i=BS1_OPR_NOT;
		if(CADR(l)==SYM("!"))i=BS1_OPR_LNOT;
		if(CADR(l)==SYM("*"))i=BS1_OPR_UMUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_UDIV;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_UIDIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_UMOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_UAND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_UOR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_UXOR;
		if(CADR(l)==SYM("&&"))i=BS1_OPR_ULAND;
		if(CADR(l)==SYM("||"))i=BS1_OPR_ULOR;
		if(CADR(l)==SYM("^^"))i=BS1_OPR_ULXOR;

		*ctx->ip++=BS1_SOP_UNARYOP;
		*ctx->ip++=i;
		return;
	}

	if(FORM_IS(l, "binary"))
	{
		i=BS1_CComp_CompileBinary(ctx, CDR(l));
		if(i)return;

		BS1_CComp_CompileExpr(ctx, CADDR(l));
		BS1_CComp_CompileExpr(ctx, CADDDR(l));

		i=-1;
		if(CADR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CADR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CADR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CADR(l)==SYM("**"))i=BS1_OPR_EXP;

		if(CADR(l)==SYM("+."))i=BS1_OPR_DADD;
		if(CADR(l)==SYM("-."))i=BS1_OPR_DSUB;
		if(CADR(l)==SYM("*."))i=BS1_OPR_DMUL;
		if(CADR(l)==SYM("/."))i=BS1_OPR_DDIV;
		if(CADR(l)==SYM("\\."))i=BS1_OPR_DIDIV;
		if(CADR(l)==SYM("%."))i=BS1_OPR_DMOD;
		if(CADR(l)==SYM("&."))i=BS1_OPR_DAND;
		if(CADR(l)==SYM("|."))i=BS1_OPR_DOR;
		if(CADR(l)==SYM("^."))i=BS1_OPR_DXOR;

		if(CADR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CADR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CADR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CADR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CADR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CADR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CADR(l)==SYM("<"))i=BS1_OPR_L;
		if(CADR(l)==SYM(">"))i=BS1_OPR_G;
		if(CADR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CADR(l)==SYM(">="))i=BS1_OPR_GE;

		*ctx->ip++=BS1_SOP_BINARYOP;
		*ctx->ip++=i;
		return;
	}

	if(FORM_IS(l, "funcall"))
	{
		if(BS1_SYMBOLP(CADR(l)))
		{
			i=BS1_CComp_CompileSpecial(ctx, CDR(l));
			if(i>0)return;
		}

		*ctx->ip++=BS1_SOP_MARK;
		c=CDDR(l);
		while(BS1_CONSP(c))
		{
			BS1_CComp_CompileExpr(ctx, CAR(c));
			c=CDR(c);
		}

		if(CADR(l)==ctx->cf_n)
		{
			if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL_CF;
				else *ctx->ip++=BS1_SOP_CALL_CF;
			return;
		}

		if(BS1_SYMBOLP(CADR(l)))
		{
			i=BS1_CComp_IndexLit(ctx, CADR(l));
			if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL_S;
				else *ctx->ip++=BS1_SOP_CALL_S;
			BS1_CComp_EncIDX(ctx, i);
			return;
		}

		BS1_CComp_CompileExpr(ctx, CADR(l));
		if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL;
			else *ctx->ip++=BS1_SOP_CALL;
		return;
	}

	if(FORM_IS(l, "methodcall"))
	{
		*ctx->ip++=BS1_SOP_MARK;
		c=CDDDR(l);
		while(BS1_CONSP(c))
		{
			BS1_CComp_CompileExpr(ctx, CAR(c));
			c=CDR(c);
		}

		BS1_CComp_CompileExpr(ctx, CADR(l));

		i=BS1_CComp_IndexLit(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_CComp_EncIDX(ctx, i);

		if(ctx->tail)*ctx->ip++=BS1_SOP_METHODTAILCALL;
			else *ctx->ip++=BS1_SOP_METHODCALL;
		return;
	}

	printf("unhandled expr %s\n", BS1_TY_GetSymbol(CAR(l)));
	*ctx->ip++=BS1_SOP_PUSH_NULL;
}

void BS1_CComp_CompileExprT(BS1_SVMCState *ctx, elem l)
{
	float f;
	elem t, c, ct, cv;
	int i, j;

	l=BS1_CComp_ReduceExpr(ctx, l);

	if(BS1_CONSP(l))
	{
		BS1_CComp_CompileForm(ctx, l);
		return;
	}

	if(BS1_SYMBOLP(l))
	{
		i=BS1_CComp_RegIdx(l);
		if(i>=0)
		{
			*ctx->ip++=BS1_SOP_PUSH_R;
			*ctx->ip++=i;
			return;
		}

		//take note of any captured variables
		c=ctx->lenv; ct=ctx->tenv; cv=ctx->venv; i=0; j=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==l)break;
			c=CDR(c); ct=CDR(ct); cv=CDR(cv);
			j++;
		}
		if(BS1_CONSP(c) && i)ctx->cap++;

		if(!BS1_CONSP(c))
		{
			if((l==SYM("self")) || (l==SYM("this")))
				{ *ctx->ip++=BS1_SOP_PUSHSELF; return; }
			if(l==SYM("true"))
				{ *ctx->ip++=BS1_SOP_PUSH_TRUE; return; }
			if(l==SYM("false"))
				{ *ctx->ip++=BS1_SOP_PUSH_FALSE; return; }
			if(l==SYM("null"))
				{ *ctx->ip++=BS1_SOP_PUSH_NULL; return; }
		}

		if((l==ctx->cf_n) && (!BS1_CONSP(c) || i))
			{ *ctx->ip++=BS1_SOP_PUSH_CF; return; }

#if 0
		if(BS1_CONSP(c) && i)printf("CCAP: %s\n",
			BS1_TY_GetSymbol(l));
		if(BS1_CONSP(c) && !i)printf("LOC: %s\n",
			BS1_TY_GetSymbol(l));
		if(!BS1_CONSP(c))printf("OBJ: %s\n",
			BS1_TY_GetSymbol(l));
#endif

		if(BS1_CONSP(c))
		{
			t=CAR(ct);
			if((t==KEYSYM("int")) || (t==KEYSYM("float")))
			{
				*ctx->ip++=BS1_SOP_LLOAD_F;
				*ctx->ip++=j;
				return;
			}

			*ctx->ip++=BS1_SOP_LLOAD;
			*ctx->ip++=j;
			return;
		}

		i=BS1_CComp_IndexLit(ctx, l);
		*ctx->ip++=BS1_SOP_LOAD;
		BS1_CComp_EncIDX(ctx, i);
		return;
	}

	if(l==BS1_MM_NULL)
		{ *ctx->ip++=BS1_SOP_PUSH_NULL; }
	else if(l==BS1_MM_TRUE)
		{ *ctx->ip++=BS1_SOP_PUSH_TRUE; }
	else if(l==BS1_MM_FALSE)
		{ *ctx->ip++=BS1_SOP_PUSH_FALSE; }
	else if(BS1_FIXNUMP(l))
	{
		i=BS1_TOINT(l);
		*ctx->ip++=BS1_SOP_PUSH_I;
		BS1_CComp_EncSVLI(ctx, i);
		return;
	}else if(BS1_FLONUMP(l))
	{
		f=BS1_TOFLOAT(l);
		i=(int)(rint(f*100));
//		printf("%f %f %f\n", f, i/100.0, f-(i/100.0));
		if((-32768<=i) && (i<=32767) && ( (f==(i/100.0)) ||
			((fabs(f-(i/100.0))<=0.0001) && ((i>100) || (i<-100))) ))
		{
			*ctx->ip++=BS1_SOP_PUSH_SV_F;
			*ctx->ip++=i&0xFF;
			*ctx->ip++=(i>>8)&0xFF;
			return;
		}

		i=BS1_CComp_IndexLit2(ctx, l);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_CComp_EncIDX(ctx, i);
		return;
	}else
	{
		i=BS1_CComp_IndexLit(ctx, l);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_CComp_EncIDX(ctx, i);
	}
}

void BS1_CComp_CompileExpr(BS1_SVMCState *ctx, elem l)
{
	int i;

	i=ctx->tail;
	ctx->tail=0;
	BS1_CComp_CompileExprT(ctx, l);
	ctx->tail=i;
}

void BS1_CComp_CompileExprTail(BS1_SVMCState *ctx, elem l)
{
	int i;

	i=ctx->tail;
	ctx->tail=1;
	BS1_CComp_CompileExprT(ctx, l);
	ctx->tail=i;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>

static int bs1_ccomp_seq=1;

int BS1_CComp_IndexLit(BS1_SVMCState *ctx, elem l)
{
	int i;

	for(i=0; ctx->lit[i]; i++)
		if(BS1_Opr_IsEqual(ctx->lit[i], l))
			return(i);
	ctx->lit[i]=l;
	return(i);
}

int BS1_CComp_IndexLit2(BS1_SVMCState *ctx, elem l)
{
	int i;

	for(i=0; ctx->lit[i]; i++)
		if(ctx->lit[i]==l)
			return(i);
	ctx->lit[i]=l;
	return(i);
}

void BS1_CComp_EncVLI(BS1_SVMCState *ctx, long long i)
{
	if(i>=0x100000000000000)
	{
		*ctx->ip++=0xFF;
		*ctx->ip++=(i>>56)&0xFF;
		*ctx->ip++=(i>>48)&0xFF;
		*ctx->ip++=(i>>40)&0xFF;
		*ctx->ip++=(i>>32)&0xFF;
		*ctx->ip++=(i>>24)&0xFF;
		*ctx->ip++=(i>>16)&0xFF;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x2000000000000)
	{
		*ctx->ip++=(i>>56)|0xFE;
		*ctx->ip++=(i>>48)&0xFF;
		*ctx->ip++=(i>>40)&0xFF;
		*ctx->ip++=(i>>32)&0xFF;
		*ctx->ip++=(i>>24)&0xFF;
		*ctx->ip++=(i>>16)&0xFF;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x40000000000)
	{
		*ctx->ip++=(i>>48)|0xFC;
		*ctx->ip++=(i>>40)&0xFF;
		*ctx->ip++=(i>>32)&0xFF;
		*ctx->ip++=(i>>24)&0xFF;
		*ctx->ip++=(i>>16)&0xFF;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x800000000)
	{
		*ctx->ip++=(i>>40)|0xF8;
		*ctx->ip++=(i>>32)&0xFF;
		*ctx->ip++=(i>>24)&0xFF;
		*ctx->ip++=(i>>16)&0xFF;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x10000000)
	{
		*ctx->ip++=(i>>32)|0xF0;
		*ctx->ip++=(i>>24)&0xFF;
		*ctx->ip++=(i>>16)&0xFF;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x200000)
	{
		*ctx->ip++=(i>>24)|0xE0;
		*ctx->ip++=(i>>16)&0xFF;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x4000)
	{
		*ctx->ip++=(i>>16)|0xC0;
		*ctx->ip++=(i>>8)&0xFF;
		*ctx->ip++=i&255;
		return;
	}

	if(i>=0x80)
	{
		*ctx->ip++=(i>>8)|0x80;
		*ctx->ip++=i&255;
		return;
	}

	*ctx->ip++=i;
}

void BS1_CComp_EncSVLI(BS1_SVMCState *ctx, long long i)
{
	i=(i>=0)?(i*2):(((-i)*2)-1);
	BS1_CComp_EncVLI(ctx, i);
}

void BS1_CComp_EncVLI2(BS1_SVMCState *ctx, int i, int j)
{
	int k;

	if((i>14) && (j>14))
	{
		*ctx->ip++=0xFF;
		BS1_CComp_EncVLI(ctx, i);
		BS1_CComp_EncVLI(ctx, j);
	}else if(i>14)
	{
		*ctx->ip++=0xF0|j;
		BS1_CComp_EncVLI(ctx, i);
	}else if(j>14)
	{
		*ctx->ip++=0x0F|(i<<4);
		BS1_CComp_EncVLI(ctx, j);
	}else
	{
		*ctx->ip++=(i<<4)|j;
	}
}

void BS1_CComp_EncVLI3(BS1_SVMCState *ctx, int i, int j, int k)
{
	int l;

	l=0;
	l|=((i<31)?i:31)<<10;
	l|=((j<31)?j:31)<<5;
	l|=((k<31)?k:31)<<0;

	*ctx->ip++=l;
	if(i>=31)BS1_CComp_EncVLI(ctx, i);
	if(j>=31)BS1_CComp_EncVLI(ctx, j);
	if(k>=31)BS1_CComp_EncVLI(ctx, k);
}

void BS1_CComp_EncIDX(BS1_SVMCState *ctx, int i)
{
	BS1_CComp_EncVLI(ctx, i);
}

void BS1_CComp_EncTy(BS1_SVMCState *ctx, elem n)
{
	int i;
	i=BS1_CComp_IndexLit(ctx, n);
	BS1_CComp_EncVLI(ctx, i);
}

void BS1_CComp_EncTyIdx(BS1_SVMCState *ctx, elem n, int j)
{
	int i;
	i=BS1_CComp_IndexLit(ctx, n);
	BS1_CComp_EncVLI2(ctx, i, j);
}


int BS1_CComp_LookupLabel(BS1_SVMCState *ctx, char *name)
{
	int i;

	for(i=0; i<ctx->n_lbl; i++)
		if(!strcmp(ctx->lbl_name[i], name))
			return(i);
	return(-1);
}

void BS1_CComp_EmitGoto(BS1_SVMCState *ctx, char *name, byte *ip)
{
	int i;

	i=BS1_CComp_LookupLabel(ctx, name);
	if(i<0)i=ctx->n_lbl++;
	ctx->lbl_name[i]=strdup(name);
	ctx->lbl_dest[i]=NULL;
	BS1_CComp_EncVLI(ctx, i);
}

void BS1_CComp_EmitLabel(BS1_SVMCState *ctx, char *name, byte *ip)
{
	int i;

	i=BS1_CComp_LookupLabel(ctx, name);
	if(i<0)i=ctx->n_lbl++;
	ctx->lbl_name[i]=strdup(name);
	ctx->lbl_dest[i]=ip;
}

char *BS1_CComp_GenSym()
{
	char buf[32];

	sprintf(buf, "gs$%d", bs1_ccomp_seq++);
	return(BS1_RStrDup(buf));
}

int BS1_CComp_RegIdx(elem t)
{
	char *s;

	if(!BS1_SYMBOLP(t))return(-1);
	s=BS1_TOSYM(t);
	if(s[0]!='$')return(-1);
	if((s[1]<'0') || (s[1]>'9'))return(-1);
	return(atoi(s+1));
}

void BS1_CComp_CompileBreak(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->breakstack[ctx->breakstackpos-1];
	*ctx->ip++=BS1_SOPC_JMP;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileContinue(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->contstack[ctx->contstackpos-1];
	*ctx->ip++=BS1_SOP_JMP;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileBreakFalse(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->breakstack[ctx->breakstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_FALSE;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileBreakTrue(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->breakstack[ctx->breakstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_TRUE;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileContinueFalse(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->contstack[ctx->contstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_FALSE;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileContinueTrue(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->contstack[ctx->contstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_TRUE;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}


void BS1_CComp_CompileJmp(BS1_SVMCState *ctx, char *s)
{
	*ctx->ip++=BS1_SOP_JMP;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileJmpFalse(BS1_SVMCState *ctx, char *s)
{
	*ctx->ip++=BS1_SOP_JMP_FALSE;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileJmpTrue(BS1_SVMCState *ctx, char *s)
{
	*ctx->ip++=BS1_SOP_JMP_TRUE;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileJmpCond(BS1_SVMCState *ctx, int i, char *s)
{
	*ctx->ip++=BS1_SOP_JMP_COND_B;
	*ctx->ip++=i;
	BS1_CComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_CComp_CompileJCO(BS1_SVMCState *ctx, int op, elem ln, elem rn)
{
	elem lt, rt;
	elem t0, t1;
	int i, j, k;

	ln=BS1_CComp_ReduceExpr(ctx, ln);
	rn=BS1_CComp_ReduceExpr(ctx, rn);
	lt=BS1_CComp_InferExpr(ctx, ln);
	rt=BS1_CComp_InferExpr(ctx, rn);


	if(BS1_FIXNUMP(ln) || BS1_FLONUMP(ln))
	{
		switch(op)
		{
			case BS1_OPR_L: op=BS1_OPR_G; break;
			case BS1_OPR_G: i=BS1_OPR_L; break;
			case BS1_OPR_LE: i=BS1_OPR_GE; break;
			case BS1_OPR_GE: i=BS1_OPR_LE; break;
			default: break;
		}

		t0=ln; t1=lt;
		ln=rn; lt=rt;
		rn=t0; rt=t1;
	}

#if 1
	j=BS1_CComp_CheckLexical(ctx, ln);
	k=BS1_CComp_CheckLexical(ctx, rn);

	if((lt==rt) && (lt==KEYSYM("int")) && (j>=0) && (k>=0) &&
		!ctx->i_cap)
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_LFN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_LFN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_LFN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_LFN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_LFN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_LFN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_LFN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_LFN; break;
			default: break;
		}

		BS1_CComp_EmitOp(ctx, i);
		*ctx->ip++=j;
		*ctx->ip++=k;
		return;
	}

	if((lt==KEYSYM("int")) && (j>=0) && (rn==BS1_MM_FIXNUM_0) &&
		!ctx->i_cap)
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_LZFN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_LZFN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_LZFN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_LZFN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_LZFN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_LZFN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_LZFN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_LZFN; break;
			default: break;
		}

		BS1_CComp_EmitOp(ctx, i);
		*ctx->ip++=j;
		return;
	}

	if((lt==KEYSYM("int")) && (j>=0) && BS1_FIXNUMP(rn) &&
		(TOINT(rn)>-128) && (TOINT(rn)<128) &&
		!ctx->i_cap)
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_LFNC; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_LFNC; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_LFNC; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_LFNC; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_LFNC; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_LFNC; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_LFNC; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_LFNC; break;
			default: break;
		}

		BS1_CComp_EmitOp(ctx, i);
		*ctx->ip++=j;
		*ctx->ip++=TOINT(rn);
		return;
	}
#endif

	if((lt==KEYSYM("int")) && (rn==BS1_MM_FIXNUM_0))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_ZFN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_ZFN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_ZFN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_ZFN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_ZFN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_ZFN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_ZFN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_ZFN; break;
			default: break;
		}
		BS1_CComp_CompileExpr(ctx, ln);
		BS1_CComp_EmitOp(ctx, i);
		return;
	}

	if((lt==KEYSYM("int")) && BS1_FIXNUMP(rn) &&
		(TOINT(rn)>-128) && (TOINT(rn)<128))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_FNC; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_FNC; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_FNC; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_FNC; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_FNC; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_FNC; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_FNC; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_FNC; break;
			default: break;
		}
		BS1_CComp_CompileExpr(ctx, ln);
		BS1_CComp_EmitOp(ctx, i);
		*ctx->ip++=TOINT(rn);
		return;
	}

	if((lt==rt) && (lt==KEYSYM("int")))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_FN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_FN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_FN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_FN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_FN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_FN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_FN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_FN; break;
			default: break;
		}

		BS1_CComp_CompileExpr(ctx, ln);
		BS1_CComp_CompileExpr(ctx, rn);
		BS1_CComp_EmitOp(ctx, i);
		return;
	}

	if(((lt==KEYSYM("int")) || (lt==KEYSYM("float"))) &&
		((rt==KEYSYM("int")) || (rt==KEYSYM("float"))))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_FL; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_FL; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_FL; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_FL; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_FL; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_FL; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_FL; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_FL; break;
			default: break;
		}

		BS1_CComp_CompileExpr(ctx, ln);
		if(lt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;
		BS1_CComp_CompileExpr(ctx, rn);
		if(rt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;

		BS1_CComp_EmitOp(ctx, i);
		return;
	}

	BS1_CComp_CompileExpr(ctx, ln);
	BS1_CComp_CompileExpr(ctx, rn);
	*ctx->ip++=BS1_SOP_JMP_COND_B;
	*ctx->ip++=op;
}

void BS1_CComp_CompileJCT(BS1_SVMCState *ctx, elem l)
{
	elem t;
	int i;

	l=BS1_CComp_ReduceExpr(ctx, l);
	t=BS1_CComp_InferExpr(ctx, l);

	if(FORM_IS(l, "unary") && (CADR(l)==SYM("!")))
	{
		BS1_CComp_CompileJCF(ctx, CADDR(l));
		return;
	}

	i=-1;
	if(FORM_IS_BINARY(l, "=="))i=BS1_OPR_EQV;
	if(FORM_IS_BINARY(l, "!="))i=BS1_OPR_NEQV;
	if(FORM_IS_BINARY(l, "==="))i=BS1_OPR_EQ;
	if(FORM_IS_BINARY(l, "!=="))i=BS1_OPR_NEQ;
	if(FORM_IS_BINARY(l, "<"))i=BS1_OPR_L;
	if(FORM_IS_BINARY(l, ">"))i=BS1_OPR_G;
	if(FORM_IS_BINARY(l, "<="))i=BS1_OPR_LE;
	if(FORM_IS_BINARY(l, ">="))i=BS1_OPR_GE;

	if(i<0)
	{
		i=BS1_CComp_CheckLexical(ctx, l);
		if((t==KEYSYM("int")) && (i>=0) && !ctx->i_cap)
		{
			BS1_CComp_EmitOp(ctx, BS1_SOP_JMP_NE_LZFN);
			*ctx->ip++=i;
			return;
		}

		if(t==KEYSYM("int"))
		{
			BS1_CComp_CompileExpr(ctx, l);
			BS1_CComp_EmitOp(ctx, BS1_SOP_JMP_NE_ZFN);
			return;
		}

		BS1_CComp_CompileExpr(ctx, l);
		*ctx->ip++=BS1_SOP_JMP_TRUE;
		return;
	}

	BS1_CComp_CompileJCO(ctx, i, CADDR(l), CADDDR(l));
}

void BS1_CComp_CompileJCF(BS1_SVMCState *ctx, elem l)
{
	elem t;
	int i;

	l=BS1_CComp_ReduceExpr(ctx, l);
	t=BS1_CComp_InferExpr(ctx, l);

	if(FORM_IS(l, "unary") && (CADR(l)==SYM("!")))
	{
		BS1_CComp_CompileJCT(ctx, CADDR(l));
		return;
	}

	i=-1;
	if(FORM_IS_BINARY(l, "=="))i=BS1_OPR_NEQV;
	if(FORM_IS_BINARY(l, "!="))i=BS1_OPR_EQV;
	if(FORM_IS_BINARY(l, "==="))i=BS1_OPR_NEQ;
	if(FORM_IS_BINARY(l, "!=="))i=BS1_OPR_EQ;
	if(FORM_IS_BINARY(l, "<"))i=BS1_OPR_GE;
	if(FORM_IS_BINARY(l, ">"))i=BS1_OPR_LE;
	if(FORM_IS_BINARY(l, "<="))i=BS1_OPR_G;
	if(FORM_IS_BINARY(l, ">="))i=BS1_OPR_L;

	if(i<0)
	{
		i=BS1_CComp_CheckLexical(ctx, l);
		if((t==KEYSYM("int")) && (i>=0) && !ctx->i_cap)
		{
			BS1_CComp_EmitOp(ctx, BS1_SOP_JMP_E_LZFN);
			*ctx->ip++=i;
			return;
		}

		if(t==KEYSYM("int"))
		{
			BS1_CComp_CompileExpr(ctx, l);
			BS1_CComp_EmitOp(ctx, BS1_SOP_JMP_E_ZFN);
			return;
		}

		BS1_CComp_CompileExpr(ctx, l);
		*ctx->ip++=BS1_SOP_JMP_FALSE;
		return;
	}

	BS1_CComp_CompileJCO(ctx, i, CADDR(l), CADDDR(l));
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>


int BS1_CComp_BoolExpr(BS1_SVMCState *ctx, elem l)
{
	if(l==BS1_MM_FALSE)return(0);
	if(l==BS1_MM_NULL)return(0);
	if(l==BS1_MM_FIXNUM)return(0);
	if(l==BS1_MM_FLONUM)return(0);

	if(l==BS1_MM_TRUE)return(1);
	if(BS1_FIXNUMP(l))return(1);
	if(BS1_FLONUMP(l))return(1);
	return(-1);
}

int BS1_CComp_IsExpr(elem l)
{
	if(BS1_CONSP(l))return(1);
	if(BS1_SYMBOLP(l))return(1);
	return(0);
}

elem BS1_CComp_ReduceForm(BS1_SVMCState *ctx, elem l)
{
	elem c, t, x;
	int i, j;

	if(CAR(l)==SYM("unary"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_CComp_IsExpr(t))return(l);

		if(CADR(l)==SYM("!"))
		{
			if(CAR(t)==SYM("=="))return(CONSS("!=", CDR(t)));
			if(CAR(t)==SYM("!="))return(CONSS("==", CDR(t)));
			if(CAR(t)==SYM("==="))return(CONSS("!==", CDR(t)));
			if(CAR(t)==SYM("!=="))return(CONSS("===", CDR(t)));

			if(CAR(t)==SYM("<"))return(CONSS(">=", CDR(t)));
			if(CAR(t)==SYM(">"))return(CONSS("<=", CDR(t)));
			if(CAR(t)==SYM("<="))return(CONSS(">", CDR(t)));
			if(CAR(t)==SYM(">="))return(CONSS("<", CDR(t)));
		}

		i=-1;
		if(CADR(l)==SYM("+"))i=BS1_OPR_POS;
		if(CADR(l)==SYM("-"))i=BS1_OPR_NEG;
		if(CADR(l)==SYM("~"))i=BS1_OPR_NOT;
		if(CADR(l)==SYM("!"))i=BS1_OPR_LNOT;

		if(i<0)return(l);

		l=BS1_Opr_Unary(i, t);
		return(l);
	}


	if(FORM_IS(l, "binary"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_CComp_IsExpr(t))return(l);

		x=BS1_CComp_ReduceExpr(ctx, CADDDR(l));
		if(BS1_CComp_IsExpr(x))return(l);

		i=-1;
		if(CADR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CADR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CADR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CADR(l)==SYM("**"))i=BS1_OPR_EXP;

		if(CADR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CADR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CADR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CADR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CADR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CADR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CADR(l)==SYM("<"))i=BS1_OPR_L;
		if(CADR(l)==SYM(">"))i=BS1_OPR_G;
		if(CADR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CADR(l)==SYM(">="))i=BS1_OPR_GE;

		if((CADR(l)==SYM("/")) && BS1_FIXNUMP(t) && BS1_FIXNUMP(x))
			return(BS1_TY_Rational(TOINT(t), TOINT(x)));

		if(i<0)return(l);

		l=BS1_Opr_Binary(i, t, x);
		return(l);
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		i=BS1_CComp_BoolExpr(ctx, t);
		if(i==1)
		{
			l=BS1_CComp_ReduceExpr(ctx, CADDR(l));
			return(l);
		}
		if(i==0)
		{
			t=BS1_MM_NULL;
			if(BS1_CONSP(CDDDR(l)))
				t=BS1_CComp_ReduceExpr(ctx, CADDDR(l));
			return(t);
		}
		return(l);
	}

	if(CAR(l)==SYM("begin"))
	{
		if(CDDR(l)==BS1_MM_NULL)
		{
			t=BS1_CComp_ReduceExpr(ctx, CADR(l));
			return(t);
		}

		return(l);
	}

	return(l);
}

elem BS1_CComp_ReduceExpr(BS1_SVMCState *ctx, elem l)
{
	elem t, cn, cv, ct;
	if(BS1_CONSP(l))
	{
		t=BS1_CComp_ReduceForm(ctx, l);
		return(t);
	}

	if(BS1_SYMBOLP(l))
	{
		if(l==SYM("I"))return(BS1_COMPLEX_I(1));
		if(l==SYM("PI"))return(FLONUM(M_PI));
		if(l==SYM("E"))return(FLONUM(M_E));

		cn=ctx->lenv;
		ct=ctx->tenv;
		cv=ctx->venv;

		if(ctx->cap)return(l);

		while(BS1_CONSP(cn) && (cn!=ctx->lenv))
		{
			if((CAR(cn)==l) && (CAR(cv)!=BS1_MM_NULL))
				return(CAR(cv));

			cn=CDR(cn);
			ct=CDR(ct);
			cv=CDR(cv);
		}
	}
	return(l);
}


elem BS1_CComp_InferTypeBase(elem l)
{
	char b[64];
	char *s, *t;
	elem n;
	int i;

	if(BS1_CONSP(l))
	{
		n=CADR(l);

		if(BS1_KEYWORDP(n))
		{
			s=TOSYM(n); t=b;
			while(*s && (*s!='$'))*t++=*s++;
			*t++=0;

			i=TOINT(CADDR(l));
			if(*s=='$')i|=atoi(s+1);
			if((i&1) && (b[0]!='u'))
			{
				BS1_StrCpy(b+1, b);
				b[0]='u';
			}

			n=KEYSYM(b);
		}

		return(n);
	}

	if(BS1_KEYWORDP(l))
	{
		s=TOSYM(l); t=b;
		while(*s && (*s!='$'))*t++=*s++;
		*t++=0;

		return(KEYSYM(b));
	}
}

int BS1_CComp_InferIsIntP(elem t)
{
	if(t==KEYSYM("char"))return(1);
	if(t==KEYSYM("uchar"))return(1);

	if(t==KEYSYM("byte"))return(1);
	if(t==KEYSYM("sbyte"))return(1);
	if(t==KEYSYM("short"))return(1);
	if(t==KEYSYM("ushort"))return(1);
	if(t==KEYSYM("int"))return(1);
	if(t==KEYSYM("uint"))return(1);
	return(0);
}

int BS1_CComp_InferIsLongP(elem t)
{
	if(BS1_CComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("long"))return(1);
	if(t==KEYSYM("ulong"))return(1);
	return(0);
}

int BS1_CComp_InferIsFloatP(elem t)
{
	if(BS1_CComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("float"))return(1);
	return(0);
}

int BS1_CComp_InferIsDoubleP(elem t)
{
	if(BS1_CComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("float"))return(1);
	if(t==KEYSYM("double"))return(1);
	return(0);
}

int BS1_CComp_InferIsNumP(elem t)
{
	if(BS1_CComp_InferIsIntP(t))return(1);
	if(BS1_CComp_InferIsLongP(t))return(1);
	if(BS1_CComp_InferIsFloatP(t))return(1);
	if(BS1_CComp_InferIsDoubleP(t))return(1);
	return(0);
}

elem BS1_CComp_InferIsInt(elem t)
{
	if(BS1_CComp_InferIsIntP(t))
		return(KEYSYM("int"));
	return(BS1_MM_NULL);
}

elem BS1_CComp_InferIsLong(elem t)
{
	if(BS1_CComp_InferIsIntP(t))
		return(KEYSYM("int"));
	if(BS1_CComp_InferIsLongP(t))
		return(KEYSYM("long"));
	return(BS1_MM_NULL);
}

elem BS1_CComp_InferIsNum(elem t)
{
	if(BS1_CComp_InferIsIntP(t))
		return(KEYSYM("int"));
	if(BS1_CComp_InferIsLongP(t))
		return(KEYSYM("long"));
	if(BS1_CComp_InferIsFloatP(t))
		return(KEYSYM("float"));
	if(BS1_CComp_InferIsDoubleP(t))
		return(KEYSYM("double"));
	return(BS1_MM_NULL);
}

elem BS1_CComp_InferForm(BS1_SVMCState *ctx, elem l)
{
	elem c, t, x, n;
	int i;

	if(CAR(l)==SYM("cast"))
	{
		t=BS1_CComp_InferExpr(ctx, CADDR(l));
		return(CADR(l));
	}

	if((CAR(l)==SYM("unary")) && (CADR(l)==SYM("!")))
	{
		t=BS1_CComp_InferExpr(ctx, CADDR(l));
		return(KEYSYM("bool"));
	}

	if((CAR(l)==SYM("unary")) && (CADR(l)==SYM("~")))
	{
		t=BS1_CComp_InferExpr(ctx, CADR(l));
		return(BS1_CComp_InferIsLong(t));
	}

//	if((CAR(l)==SYM("-")) && !BS1_CONSP(CDDR(l)))
//	{
//		t=BS1_CComp_InferExpr(ctx, CADR(l));
//		return(BS1_CComp_InferIsNum(t));
//	}

	if(FORM_IS(l, "binary") && CADR(l)==SYM("/"))
	{
		t=BS1_CComp_InferExpr(ctx, CADDR(l));
		x=BS1_CComp_InferExpr(ctx, CADDDR(l));

		i=BS1_CComp_InferIsNumP(t) &&
			BS1_CComp_InferIsNumP(x);
		if(!i)return(BS1_MM_NULL);

		n=KEYSYM("float");
		if(t==KEYSYM("double"))n=t;
		if(x==KEYSYM("double"))n=x;
		return(n);
	}

	if(FORM_IS(l, "binary") && (CADR(l)==SYM("\\")))
	{
		t=BS1_CComp_InferExpr(ctx, CADDR(l));
		x=BS1_CComp_InferExpr(ctx, CADDDR(l));

		return(KEYSYM("int"));
	}

//	if((CAR(l)==SYM("+")) || (CAR(l)==SYM("-")) ||
//		(CAR(l)==SYM("*")) ||
//		(CAR(l)==SYM("%")) || (CAR(l)==SYM("&")) ||
//		(CAR(l)==SYM("|")) || (CAR(l)==SYM("^")))

	if(FORM_IS(l, "binary") && (
		(CADR(l)==SYM("+")) || (CADR(l)==SYM("-")) ||
		(CADR(l)==SYM("*")) || (CADR(l)==SYM("%")) ||
		(CADR(l)==SYM("&")) || (CADR(l)==SYM("|")) ||
		(CADR(l)==SYM("^"))))
	{
		t=BS1_CComp_InferExpr(ctx, CADDR(l));

		x=t; c=CDDDR(l);
		while(BS1_CONSP(c))
		{
			t=BS1_CComp_InferExpr(ctx, CAR(c));
			if(t!=x)return(BS1_MM_NULL);
			c=CDR(c);
		}
		return(x);
	}

	if(FORM_IS(l, "binary") &&
		((CADR(l)==SYM("<<")) || (CADR(l)==SYM(">>"))))
	{
		t=BS1_CComp_InferExpr(ctx, CADDR(l));
		x=BS1_CComp_InferExpr(ctx, CADDDR(l));

		i=BS1_CComp_InferIsIntP(t) &&
			BS1_CComp_InferIsIntP(x);
		if(i)return(t);
		return(BS1_MM_NULL);
	}

//	if((CAR(l)==SYM("==")) || (CAR(l)==SYM("===")) ||
//		(CAR(l)==SYM("!=")) || (CAR(l)==SYM("!==")) ||
//		(CAR(l)==SYM("<")) || (CAR(l)==SYM(">")) ||
//		(CAR(l)==SYM("<=")) || (CAR(l)==SYM(">=")))

	if(FORM_IS(l, "binary") && (
		(CADR(l)==SYM("==")) || (CADR(l)==SYM("===")) ||
		(CADR(l)==SYM("!=")) || (CADR(l)==SYM("!==")) ||
		(CADR(l)==SYM("<"))  || (CADR(l)==SYM(">")) ||
		(CADR(l)==SYM("<=")) || (CADR(l)==SYM(">="))))
	{
		return(KEYSYM("bool"));
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		i=BS1_CComp_BoolExpr(ctx, t);
		if(i==1)
		{
			t=BS1_CComp_InferExpr(ctx, CADDR(l));
			return(t);
		}
		if(i==0)
		{
			t=BS1_MM_NULL;
			if(BS1_CONSP(CDDDR(l)))
				t=BS1_CComp_InferExpr(ctx, CADDDR(l));
			return(t);
		}

		x=BS1_MM_NULL;
		t=BS1_CComp_InferExpr(ctx, CADDR(l));
		if(BS1_CONSP(CDDDR(l)))
			x=BS1_CComp_InferExpr(ctx, CADDDR(l));
		if(t!=x)return(BS1_MM_NULL);
		return(t);
	}

	if(CAR(l)==SYM("funcall"))
	{
#if 0
		printf("Infer Func: ");
		BS1_TY_Print(CADR(l));
		printf("=");
		BS1_TY_Print(ctx->cf_n);
		printf("\n");
#endif

		ctx->i_cx_p=0;
		if(CADR(l)==ctx->cf_n)
		{
			t=BS1_CComp_InferTypeBase(ctx->cf_ty);
			return(t);
//			return(ctx->cf_ty);
		}
		return(BS1_MM_NULL);
	}

	ctx->i_cx_p=0;
	return(BS1_MM_NULL);
}

elem BS1_CComp_InferExpr(BS1_SVMCState *ctx, elem l)
{
	elem t, cn, cv, ct;

	l=BS1_CComp_ReduceExpr(ctx, l);

//	printf("Infer Reduce: ");
//	BS1_TY_PrintLN(l);

	if(BS1_CONSP(l))
	{
		t=BS1_CComp_InferForm(ctx, l);
		return(t);
	}

	if(BS1_SYMBOLP(l))
	{
		if(l==SYM("I"))return(KEYSYM("complex"));
		if(l==SYM("PI"))return(KEYSYM("float"));
		if(l==SYM("E"))return(KEYSYM("float"));

		cn=ctx->lenv;
		ct=ctx->tenv;
		cv=ctx->venv;

		while(BS1_CONSP(cn))
		{
			if(CAR(cn)==l)
			{
				t=BS1_CComp_InferTypeBase(CAR(ct));
				return(t);
			}
			cn=CDR(cn);
			ct=CDR(ct);
			cv=CDR(cv);
		}

		return(BS1_MM_NULL);
	}

	if(l==BS1_MM_NULL)return(KEYSYM("null"));
	if(l==BS1_MM_TRUE)return(KEYSYM("bool"));
	if(l==BS1_MM_FALSE)return(KEYSYM("bool"));

	if(BS1_FIXNUMP(l))return(KEYSYM("int"));
	if(BS1_FLONUMP(l))return(KEYSYM("float"));
	if(BS1_CHARP(l))return(KEYSYM("char"));

	if(BS1_STRINGP(l))return(KEYSYM("string"));
	if(BS1_KEYWORDP(l))return(KEYSYM("keyword"));

	if(BS1_ARRAYP(l))return(KEYSYM("array"));
	if(BS1_FVECTORP(l))return(KEYSYM("vector"));

	return(BS1_MM_NULL);
}

elem BS1_CComp_InferExprClean(BS1_SVMCState *ctx, elem l, int *cp)
{
	elem t;

	ctx->i_cx_p=1;
	t=BS1_CComp_InferExpr(ctx, l);
	*cp=ctx->i_cx_p;

	return(t);
}


int BS1_CComp_GuessCloseForm(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	if(FORM_IS(l, "lambda"))return(1);
	if(FORM_IS(l, "rlambda"))return(1);
	if(FORM_IS(l, "defun"))return(1);
	if(FORM_IS(l, "define") && BS1_CONSP(CADR(l)))
		return(1);

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		i=i||BS1_CComp_GuessCloseExpr(ctx, CAR(c));
		c=CDR(c);
	}
	return(i);
}

int BS1_CComp_GuessCloseExpr(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	if(BS1_CONSP(l))
		return(BS1_CComp_GuessCloseForm(ctx, l));

	if(BS1_SYMBOLP(l))
	{
		c=ctx->lenv; i=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==l)break;
			c=CDR(c);
		}

		if(BS1_CONSP(c))return(i);
		return(0);
	}

	return(0);
}

int BS1_CComp_GuessCloseBlock(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		i=i||BS1_CComp_GuessCloseExpr(ctx, CAR(c));
		c=CDR(c);
	}
	return(i);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>


int BS1_CComp_CompileSwitch(BS1_SVMCState *ctx, elem l)
{
	char **cl, *s;
	byte *ip;
	int i, j, ncl;
	elem c, t, u, v;

	cl=BS1_MM_RAlloc(4096*sizeof(char *));

	ncl=0; c=CDDR(l);
	while(BS1_CONSP(c))
	{
		if(FORM_IS(CAR(c), "case") ||
			FORM_IS(CAR(c), "case_default"))
		{
			cl[ncl++]=BS1_CComp_GenSym();
			c=CDR(c);
			continue;
		}
		c=CDR(c);
	}

	BS1_CComp_CompileExpr(ctx, CADR(l));

	i=0; c=CDDR(l);
	while(BS1_CONSP(c))
	{
		if(FORM_IS(CAR(c), "case"))
		{
			*ctx->ip++=BS1_SOP_DUP;
			BS1_CComp_CompileExpr(ctx, CADAR(c));

//			*ctx->ip++=BS1_SOP_BINARYOP;
//			*ctx->ip++=BS1_OPR_EQV;
//			BS1_CComp_CompileJmpTrue(ctx, cl[i++]);

			BS1_CComp_CompileJmpCond(ctx, BS1_OPR_EQV, cl[i++]);
			c=CDR(c);
			continue;
		}

		if(FORM_IS(CAR(c), "case_default"))
		{
			BS1_CComp_CompileJmp(ctx, cl[i++]);
			c=CDR(c);
			continue;
		}
		c=CDR(c);
	}


	s=BS1_CComp_GenSym();
	ctx->breakstack[ctx->breakstackpos++]=s;
	BS1_CComp_CompileBreak(ctx);

	i=0; c=CDDR(l);
	while(BS1_CONSP(c))
	{
		if(FORM_IS(CAR(c), "case") ||
			FORM_IS(CAR(c), "case_default"))
		{
			BS1_CComp_EmitLabel(ctx, cl[i++], ctx->ip);
			c=CDR(c);
			continue;
		}

		BS1_CComp_CompileStatement(ctx, CAR(c));
		c=CDR(c);
	}

	BS1_CComp_EmitLabel(ctx, s, ctx->ip);
	*ctx->ip++=BS1_SOP_POP;

	ctx->breakstackpos--;
	return;
}

void BS1_CComp_CompileStatement(BS1_SVMCState *ctx, elem l)
{
	byte *ip0, *ip1;
	elem c, ct, cv, t, n, u, v, n1;
	char *s, *s1, *s2;
	int i, j, k;

	l=BS1_CComp_ReduceExpr(ctx, l);

	//references/literals are useless in statement position
	if(!BS1_CONSP(l))
	{
		if(l==BS1_MM_NULL)return;	//empty statement

		printf("useless expression in statement position\n");
		return;
	}

	if(CAR(l)==SYM("switch"))
	{
		BS1_CComp_CompileSwitch(ctx, l);
		return;
	}

	if(CAR(l)==SYM("goto"))
	{
		*ctx->ip++=BS1_SOP_JMP;
		BS1_CComp_EmitGoto(ctx,
			BS1_TY_GetSymbol(CADR(l)), ctx->ip);
		return;
	}

	if(CAR(l)==SYM("label"))
	{
		BS1_CComp_EmitLabel(ctx,
			BS1_TY_GetSymbol(CADR(l)), ctx->ip);
		return;
	}

	if(CAR(l)==SYM("continue"))
	{
		s=ctx->contstack[ctx->contstackpos-1];
		BS1_CComp_EmitJmp(ctx, s);
		return;
	}

	if(CAR(l)==SYM("break"))
	{
		s=ctx->breakstack[ctx->breakstackpos-1];
		BS1_CComp_EmitJmp(ctx, s);
		return;
	}

	if(CAR(l)==SYM("return"))
	{
		BS1_CComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_RET;
		return;
	}

	if(CAR(l)==SYM("set!"))
	{
		t=CADR(l);
		c=ctx->lenv; ct=ctx->tenv; cv=ctx->venv;
		i=0; j=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==t)break;
			c=CDR(c); ct=CDR(ct); cv=CDR(cv);
			j++;
		}
		if(BS1_CONSP(c) && i)ctx->cap++;

		if(BS1_CONSP(c))
		{
			t=BS1_CComp_InferExpr(ctx, CADDR(l));
			n=CAR(ct);

			if((n!=BS1_MM_NULL) && (t==BS1_MM_NULL))
			{
				i=BS1_CComp_IndexLit(ctx, n);
				*ctx->ip++=BS1_SOP_CAST;
				BS1_CComp_EncIDX(ctx, i);
				t=n;
			}

			if((n!=BS1_MM_NULL) && (t!=n))
			{
				printf("warn: inferencer violation\n");
				BS1_TY_SetCar(ct, BS1_MM_NULL);
			}

			BS1_TY_SetCar(cv, BS1_MM_NULL);

			if((t==KEYSYM("int")) || (t==KEYSYM("float")))
			{
				BS1_CComp_CompileExpr(ctx, CADDR(l));
				*ctx->ip++=BS1_SOP_LSTORE_F;
				*ctx->ip++=j;
				return;
			}

			BS1_CComp_CompileExpr(ctx, CADDR(l));
			*ctx->ip++=BS1_SOP_LSTORE;
			*ctx->ip++=j;
			return;
		}


		BS1_CComp_CompileExpr(ctx, CADDR(l));
		i=BS1_CComp_IndexLit(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_STORE;
		BS1_CComp_EncIDX(ctx, i);

		return;
	}

	if((CAR(l)==SYM("setindex!")) || (CAR(l)==SYM("vector-set!")))
	{
		BS1_CComp_CompileExpr(ctx, CADDDR(l));
		BS1_CComp_CompileExpr(ctx, CADDR(l));
		BS1_CComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_STOREINDEX;
		return;
	}

	if(FORM_IS(l, "preinc!") || FORM_IS(l, "predec!") ||
		FORM_IS(l, "postinc!") || FORM_IS(l, "postdec!"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		u=BS1_CComp_InferExpr(ctx, t);

		if(FORM_IS(l, "preinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;
		if(FORM_IS(l, "postinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;

		if(BS1_SYMBOLP(t) && (u==KEYSYM("int")))
		{
			c=ctx->lenv;
			k=0; j=0;
			while(BS1_CONSP(c))
			{
				if(c==ctx->llenv)k=1;
				if(CAR(c)==t)break;
				c=CDR(c); j++;
			}

			if(BS1_CONSP(c))
			{
				if(k)ctx->cap++;
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_LINC_FN;
					else *ctx->ip++=BS1_SOP_LDEC_FN;
				*ctx->ip++=j;
				return;
			}
		}

		if(BS1_SYMBOLP(t))
		{
			BS1_CComp_CompileExpr(ctx, t);

			if(u==KEYSYM("int"))
			{
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_DEC_FN;
			}else
			{
				*ctx->ip++=BS1_SOP_UNARYOP;
				*ctx->ip++=i;
			}

			BS1_CComp_CompileAssign(ctx, t);
			return;
		}

		return;
	}

	if(CAR(l)==SYM("vars"))
	{
		c=CADR(l);
		while(BS1_CONSP(c))
		{
			n=CAR(c);
			v=BS1_MM_NULL;

			if(BS1_CONSP(CAR(n)))
			{
				v=CADR(n);
				n=CAR(n);
			}

			n=CAR(n);
			t=CDR(n);

			if(v!=BS1_MM_NULL)
			{
				BS1_CComp_CompileExpr(ctx, v);
				i=BS1_CComp_IndexLit(ctx, n);
//				if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
//					else *ctx->ip++=BS1_SOP_BIND;

				*ctx->ip++=BS1_SOP_STORE;
//				BS1_CComp_EncIDX(ctx, i);
				BS1_CComp_EncTyIdx(ctx, t, i);
			}

			if(ctx->lvl)
			{
				n1=BS1_MM_NULL;
				if(!BS1_CComp_IsExpr(v))n1=v;

				SET(ctx->lenv, CONS(n, ctx->lenv));
				SET(ctx->tenv, CONS(t, ctx->tenv));
				SET(ctx->venv, CONS(n1, ctx->venv));
			}else if(!ctx->olvl)
			{
				n1=BS1_MM_NULL;
				if(!BS1_CComp_IsExpr(v))n1=v;

				SET(ctx->mlenv, CONS(n, ctx->mlenv));
				SET(ctx->mtenv, CONS(t, ctx->mtenv));
				SET(ctx->mvenv, CONS(n1, ctx->mvenv));
			}

			c=CDR(c);
		}
		return;
	}

	if(CAR(l)==SYM("defun"))
	{
		if(!ctx->lvl && !ctx->olvl)
		{
			t=BS1_CComp_CompileBlock(ctx,
				LIST2(CADR(l), CADDR(l)),
				CADDDR(l), CDDDDR(l));

			i=BS1_CComp_IndexLit(ctx, t);
			*ctx->ip++=BS1_SOP_PUSH;
			BS1_CComp_EncIDX(ctx, i);

			SET(ctx->mfcns, CONS(t, ctx->mfcns));

			i=BS1_CComp_IndexLit(ctx, CADDR(l));
			*ctx->ip++=BS1_SOP_BIND;
			BS1_CComp_EncIDX(ctx, i);

			return;
		}


//		t=CONS2S("lambda", CADDDR(l), CDDDDR(l));

		t=CONS3S("rlambda", LIST2(CADR(l), CADDR(l)),
			CADDDR(l), CDDDDR(l));

		BS1_TY_PrintLN(t);

		BS1_CComp_CompileExpr(ctx, t);
		i=BS1_CComp_IndexLit(ctx, CADDR(l));
		if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
			else *ctx->ip++=BS1_SOP_BIND;
		BS1_CComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		i=BS1_CComp_BoolExpr(ctx, t);
		if(i==1)
		{
			BS1_CComp_CompileStatement(ctx, CADDR(l));
			return;
		}
		if(i==0)
		{
			if(BS1_CONSP(CDDDR(l)))
				BS1_CComp_CompileStatement(ctx, CADDDR(l));
			return;
		}

		BS1_CComp_CompileJCF(ctx, t);
		ip0=ctx->ip;


		BS1_CComp_CompileStatement(ctx, CADDR(l));

		if(BS1_CONSP(CDDDR(l)))
		{
			*ctx->ip++=BS1_SOP_JMP;
			*ctx->ip++=0;
			*ctx->ip++=0;
			ip1=ctx->ip;

			i=ctx->ip-ip0;
			*(ip0-2)=i&0xFF;
			*(ip0-1)=(i>>8)&0xFF;

			BS1_CComp_CompileStatement(ctx, CADDDR(l));
			ip0=ip1;
		}
		i=ctx->ip-ip0;
		*(ip0-2)=i&0xFF;
		*(ip0-1)=(i>>8)&0xFF;
		return;
	}

	if(CAR(l)==SYM("begin"))
	{
		c=CDR(l);
		while(BS1_CONSP(c))
		{
			BS1_CComp_CompileStatement(ctx, CAR(c));
			c=CDR(c);
		}
		return;
	}

	if(CAR(l)==SYM("for"))
	{
		s1=BS1_CComp_GenSym();
		s2=BS1_CComp_GenSym();

		ctx->contstack[ctx->contstackpos++]=s1;
		ctx->breakstack[ctx->breakstackpos++]=s2;

		BS1_CComp_CompileStatement(ctx, CADR(l));

		BS1_CComp_EmitLabel(ctx, s1, ctx->ip);

//		BS1_CComp_CompileExpr(ctx, CADDR(l));
//		BS1_CComp_CompileBreakFalse(ctx);

		BS1_CComp_CompileJCF(ctx, CADDR(l));
		BS1_CComp_EmitGoto(ctx, s2);

		BS1_CComp_CompileStatement(ctx, CADDDDR(l));

		BS1_CComp_CompileStatement(ctx, CADDDR(l));
		BS1_CComp_CompileContinue(ctx);

		BS1_CComp_EmitLabel(ctx, s2, ctx->ip);

		ctx->contstackpos--;
		ctx->breakstackpos--;
		return;
	}

	if(CAR(l)==SYM("while"))
	{
		s1=BS1_CComp_GenSym();
		s2=BS1_CComp_GenSym();

		ctx->contstack[ctx->contstackpos++]=s1;
		ctx->breakstack[ctx->breakstackpos++]=s2;

		BS1_CComp_EmitLabel(ctx, s1, ctx->ip);

		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		i=BS1_CComp_BoolExpr(ctx, t);

		if(i==0)return;

		if(i==1)
		{
			BS1_CComp_CompileStatement(ctx, CADDR(l));
			BS1_CComp_CompileContinue(ctx);

			BS1_CComp_EmitLabel(ctx, s2, ctx->ip);

			ctx->contstackpos--;
			ctx->breakstackpos--;
			return;
		}

//		BS1_CComp_CompileExpr(ctx, t);
//		BS1_CComp_CompileBreakFalse(ctx);

		BS1_CComp_CompileJCF(ctx, t);
		BS1_CComp_EmitGoto(ctx, s2, ctx->ip);

		BS1_CComp_CompileStatement(ctx, CADDR(l));

		BS1_CComp_CompileContinue(ctx);
		BS1_CComp_EmitLabel(ctx, s2, ctx->ip);

		ctx->contstackpos--;
		ctx->breakstackpos--;
		return;
	}


	if(CAR(l)==SYM("do_while"))
	{
		s1=BS1_CComp_GenSym();
		s2=BS1_CComp_GenSym();
		ctx->contstack[ctx->contstackpos++]=s1;
		ctx->breakstack[ctx->breakstackpos++]=s2;

		BS1_CComp_EmitLabel(ctx, s1, ctx->ip);

		BS1_CComp_CompileStatement(ctx, CADDR(l));

		t=BS1_CComp_ReduceExpr(ctx, CADR(l));
		i=BS1_CComp_BoolExpr(ctx, t);
		if(i==0)return;

		if(i==1)
		{
			BS1_CComp_CompileContinue(ctx);
			BS1_CComp_EmitLabel(ctx, s2, ctx->ip);
			ctx->contstackpos--;
			ctx->breakstackpos--;
			return;
		}

//		BS1_CComp_CompileExpr(ctx, t);
//		BS1_CComp_CompileContinueTrue(ctx);

		BS1_CComp_CompileJCT(ctx, t);
		BS1_CComp_EmitGoto(ctx, s1, ctx->ip);

		BS1_CComp_EmitLabel(ctx, s2, ctx->ip);

		ctx->contstackpos--;
		ctx->breakstackpos--;
		return;
	}


	BS1_CComp_CompileExpr(ctx, l);
	*ctx->ip++=BS1_SOP_POP;
}


elem BS1_CComp_CompileBlock(BS1_SVMCState *lctx,
	elem name, elem args, elem body)
{
	BS1_SVMBlock *blk;
	BS1_SVMCState *ctx;

	char **gname, **lname;
	byte **gdest, **ldest;
	char **cname, **bname;

	elem *lit;
	byte *ip, *cip, *ipe;

	elem fargs, blkn;
	elem c, t, u;
	int i, j, k;

	ctx=malloc(sizeof(BS1_SVMCState));
	memset(ctx, 0, sizeof(BS1_SVMCState));

	gname=malloc(4096*sizeof(char *));
	gdest=malloc(4096*sizeof(byte *));
	lname=malloc(256*sizeof(char *));
	ldest=malloc(256*sizeof(byte *));

	cname=malloc(16*sizeof(char *));
	bname=malloc(16*sizeof(char *));

	ctx->goto_name=gname;
	ctx->goto_dest=gdest;
	ctx->lbl_name=lname;
	ctx->lbl_dest=ldest;

	ctx->contstack=cname;
	ctx->breakstack=bname;

	SET(ctx->lenv, lctx->lenv);
	SET(ctx->llenv, ctx->lenv);
	SET(ctx->tenv, lctx->tenv);
	SET(ctx->ltenv, ctx->tenv);
	SET(ctx->venv, lctx->venv);
	SET(ctx->lvenv, ctx->venv);

	if(BS1_CONSP(name))
	{
		ctx->cf_n=CADR(name);
		ctx->cf_ty=CAR(name);
	}else ctx->cf_n=name;
	blkn=ctx->cf_n;

	c=args; u=BS1_MM_NULL;
	while(BS1_CONSP(c))
	{
		t=CAR(c);
		if(BS1_CONSP(t))
		{
			SET(ctx->lenv, CONS(CADR(t), ctx->lenv));
			SET(ctx->tenv, CONS(CAR(t), ctx->tenv));
			SET(ctx->venv, CONS(BS1_MM_NULL, ctx->venv));
			u=CONS(CADR(t), u);
		}else
		{
			SET(ctx->lenv, CONS(CAR(c), ctx->lenv));
			SET(ctx->tenv, CONS(BS1_MM_NULL, ctx->tenv));
			SET(ctx->venv, CONS(BS1_MM_NULL, ctx->venv));
			u=CONS(t, u);
		}
		c=CDR(c);
	}

	if(c!=BS1_MM_NULL)
	{
		ctx->lenv=CONS(c, ctx->lenv);
		fargs=BS1_MM_NULL;
		ctx->i_cap=1;
	}else
	{
		fargs=BS1_TY_NReverse(u);
		ctx->i_cap=BS1_CComp_GuessCloseBlock(ctx, body);
	}

	body=BS1_CComp_ReverseStepBlock(ctx, body);

	lit=malloc(4096*sizeof(elem));
	memset(lit, 0, 4096*sizeof(elem));
	ip=malloc(65536);

	ctx->lvl=lctx->lvl+1;
	ctx->lit=lit;
	ctx->ip=ip;

	if(BS1_CONSP(body))
	{
		c=body;
		while(BS1_CONSP(c))
		{
			if(BS1_CONSP(CDR(c)))
			{
				t=BS1_CComp_ReverseStepBlock(ctx, CDR(c));
				BS1_CComp_CompileStatement(ctx, CAR(c));
				c=t;
				continue;
			}else
			{
				BS1_CComp_CompileExprTail(ctx, CAR(c));
				break;
			}
		}

		*ctx->ip++=BS1_SOP_RET;
	}else
	{
		*ctx->ip++=BS1_SOP_PUSH_NULL;
		*ctx->ip++=BS1_SOP_RET;
	}

//	printf("gotos %d, labels %d\n", ctx->n_goto, ctx->n_lbl);

	if(ctx->cap)fargs=BS1_MM_NULL;

	//resolve gotos
	for(i=0; i<ctx->n_goto; i++)
	{
		for(j=0; j<ctx->n_lbl; j++)
			if(!strcmp(lname[j], gname[i]))
		{
			k=ldest[j]-gdest[i];
//			printf("res goto %s %s, %08X->%08X (%d)\n",
//				gname[i], lname[j], gdest[i], ldest[j], k);

			*(gdest[i]-2)=k&0xFF;
			*(gdest[i]-1)=(k>>8)&0xFF;
			break;
		}

		if(j>=ctx->n_lbl)
			printf("missing label %s\n", gname[i]);
	}


	t=BS1_MM_AllocObj(BS1_TYH_SVMBLK, sizeof(BS1_SVMBlock));
	blk=BS1_TY_GetObjData(t);

	SET(blk->name, blkn);
	SET(blk->args, args);
	SET(blk->fargs, fargs);
	SET(blk->exps, body);

	for(i=0; lit[i]; i++);
	u=BS1_TY_NewArrayFromArray(lit, i);
	SET(blk->lit, u);

	blk->szbody=ctx->ip-ip;
	blk->body=malloc(blk->szbody);
	memcpy(blk->body, ip, blk->szbody);

	lctx->cap=lctx->cap||ctx->cap;

	CLEAR(ctx->lenv);
	CLEAR(ctx->llenv);

	for(i=0; i<ctx->n_goto; i++)free(gname[i]);
	for(i=0; i<ctx->n_lbl; i++)free(lname[i]);
	free(gname);
	free(gdest);
	free(lname);
	free(ldest);

	free(cname);
	free(bname);

	free(lit);
	free(ip);
	free(ctx);

	if(fargs)
	{
		ip=blk->body;
		ipe=blk->body+blk->szbody;

		while(ip<ipe)
		{
			if(*ip==BS1_SOP_LLOAD_F)*ip=BS1_SOP_LLOAD_F2;
			if(*ip==BS1_SOP_LSTORE_F)*ip=BS1_SOP_LSTORE_F2;
			if(*ip==BS1_SOP_LINC_FN)*ip=BS1_SOP_LINC_FN2;
			if(*ip==BS1_SOP_LDEC_FN)*ip=BS1_SOP_LDEC_FN2;
			ip=BS1_CComp_NextOpcode(ip);
		}
	}

#if 1
	printf("BLK %s, SA %s\n", TOSTRING(blkn), fargs?"Yes":"No");

	ip=blk->body;
	ipe=blk->body+blk->szbody;

	while(ip<ipe)
	{
		ip=BS1_CComp_DumpOpcode(ip, blk->lit);
	}

	printf("\n");
#endif

//	BS1_JIT_CompileBlock(t);

	return(t);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *in_txt="bs1_types.txt";
char *out_c="core/bs1_types.c";
char *out_h="include/bs1_types.h";

char *hash[65536];

int main()
{
	char buf[256];
	FILE *fd;
	char *s, *t;
	int i, j, k, n;

	memset(hash, 0, 65536*sizeof(char *));
	hash[0]="";
	n=0;

	fd=fopen(in_txt, "rt");
	if(!fd)
	{
		printf("fail open %s\n", in_txt);
		return(-1);
	}

	while(!feof(fd))
	{
		memset(buf, 0, 256);
		fgets(buf, 255, fd);

		s=buf;
		while(*s && (*s<=' '))s++;
		if(!*s)continue;
		if(*s==';')continue;
		if(*s=='#')continue;
		if(*s=='/')continue;

		t=buf;
		while(*s && (*s>' '))*t++=*s++;
		*t++=0;

		i=0; s=buf;
		while(*s)i=(i*65521)+(*s++);
		for(j=0; j<256; j++)
		{
			i*=65521;
			k=(i>>16)&0xFFFF;

			if(!hash[k])
			{
				hash[k]=strdup(buf);
				break;
			}
			if(!strcmp(buf, hash[k]))
				break;
		}

		if(j>=256)
		{
			printf("fail hash '%s'\n", buf);
		}

#if 0
		s=buf;
		while(*s)
		{
			if(!hash[i])
			{
				hash[i]=strdup(buf);
				if(i>n)n=i;
				break;
			}
			if(!strcmp(buf, hash[i]))
				break;

			i=(i>>14)^(i<<2)^(*s++);
			i&=0xFFFF;
		}

		if(!*s)
		{
			printf("fail hash '%s'\n", buf);
		}
#endif
	}
	fclose(fd);

	fd=fopen(out_c, "wt");
	fprintf(fd, "/* Autogenerated source */\n\n");

	fprintf(fd, "char *bs1_tyh_strs[]={\n");
	for(i=1; i<65536; i++)if(hash[i])
		fprintf(fd, "\"%s\",\n", hash[i]);
	fprintf(fd, "\"\"};\n\n");

	fprintf(fd, "int bs1_tyh_idx[]={\n");
	for(i=1; i<65536; i++)if(hash[i])
		fprintf(fd, "0x%04X,\n", i);
	fprintf(fd, "0};\n");

	fclose(fd);

	fd=fopen(out_h, "wt");
	fprintf(fd, "/* Autogenerated header */\n\n");

	for(i=1; i<65536; i++)if(hash[i])
	{
		strcpy(buf, hash[i]);
		s=buf;
		while(*s)
		{
			if((*s>='a') && (*s<='z'))
				*s=*s-'a'+'A';
			if(!((*s>='A') && (*s<='Z')))*s='_';
			s++;
		}

		if(!strcmp(buf, "_"))strcpy(buf, "UNDERSCORE");

		fprintf(fd, "#define BS1_TYH_%s\t0x%04X\n", buf, i);
	}

	return(0);
}
#include <stdio.h>
#include <time.h>

int fib(int x)
{
	if(x>2)return(fib(x-1)+fib(x-2));
	return(1);
}

int ltst(int x)
{
	int i, j;

	j=0;
	for(i=0; i<x; i++)j++;

	return(j);
}

int main()
{
	int i, t, dt;

	t=clock();

	i=fib(36);
//	i=ltst(100000000);

	dt=clock()-t;
	printf("%d %fms\n", i, (dt*1000.0)/CLOCKS_PER_SEC);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *in_txt;
char *out_c;
char *out_h;
char *out_suf, *out_suf2;

char *ops[16384];
char *args[16384];
char *sfis[16384];

char *kralloc_buffer=NULL;
int kralloc_pos=0;

void *kralloc(int sz)
{
	char *s;

	if(!kralloc_buffer)kralloc_buffer=malloc(262144);
	if((kralloc_pos+sz)>=262144)kralloc_pos=0;

	s=kralloc_buffer+kralloc_pos;
	kralloc_pos+=sz;
	return((void *)s);
}

char **ksplit(char *s)
{
	char **a, *t;
	int i;

	a=kralloc(64*sizeof(char *));
	i=0;
	while(*s)
	{
		while(*s && (*s<=' '))s++;
		if(!*s)break;
		if(*s=='#')break;
		if(*s==';')break;
		if((s[0]=='/') && (s[1]=='/'))
			break;

		t=kralloc(256);
		a[i++]=t;

		if(*s=='"')
		{
			s++;
			while(*s && (*s!='"'))*t++=*s++;
			if(*s=='"')s++;

			*t++=0;
			continue;
		}

		while(*s && (*s>' '))*t++=*s++;
		*t++=0;
	}
	a[i]=NULL;

	return(a);
}

int is_sfi(char *s)
{
	while(*s)
	{
		if(*s=='=')return(1);
		s++;
	}
	return(0);
}

int main(int argc, char *argv[])
{
	char buf[256];
	FILE *fd;
	char *s, *t, **a;
	int i, j, k, l, n;

	in_txt="bs1_ops.txt";
	out_c="core/bs1_ops.c";
	out_h="include/bs1_ops.h";
	out_suf="";
	out_suf2="S";

	if(argc>1)
	{
		sprintf(buf, "bs1_ops%s.txt", argv[1]);
		in_txt=strdup(buf);

		sprintf(buf, "core/bs1_ops%s.c", argv[1]);
		out_c=strdup(buf);

		sprintf(buf, "include/bs1_ops%s.h", argv[1]);
		out_h=strdup(buf);

		sprintf(buf, "%s", argv[1]);
		out_suf=strdup(buf);

		t=buf; while(*t)
			{ if(*t>='a' && *t<='z')*t=*t-'a'+'A'; t++; }
		out_suf2=strdup(buf);
	}

	memset(ops, 0, 16384*sizeof(char *));
	memset(args, 0, 16384*sizeof(char *));
	memset(sfis, 0, 16384*sizeof(char *));

	fd=fopen(in_txt, "rt");
	if(!fd)
	{
		printf("fail open %s\n", in_txt);
		return(-1);
	}

	n=0;
	while(!feof(fd))
	{
		memset(buf, 0, 256);
		fgets(buf, 255, fd);

		s=buf;
		while(*s && (*s<=' '))s++;
		if(!*s)continue;
		if(*s==';')continue;
		if(*s=='#')continue;
		if(*s=='/')continue;

		a=ksplit(s);
		if(!a[0])continue;

		i=atoi(a[1]);
		ops[i]=strdup(a[0]);
		if(a[2])
		{
			if(strcmp(a[2], "-"))
			{
				if(!is_sfi(a[2]))
				{
					args[i]=strdup(a[2]);

					if(a[3] && strcmp(a[3], "-"))
						sfis[i]=strdup(a[3]);
				}else sfis[i]=strdup(a[2]);
			}else
			{
				if(a[3] && strcmp(a[3], "-"))
					sfis[i]=strdup(a[3]);
			}
		}

		if(i>=n)n=i+1;
	}
	fclose(fd);

	fd=fopen(out_c, "wt");
	fprintf(fd, "/* Autogenerated source */\n");

	j=0; k=0; l=0;
	for(i=0; i<n; i++)
	{
		if(ops[i])j++;
		if(args[i])k++;
		if(sfis[i])l++;
	}

	fprintf(fd, "/* OPS %d, W/Args %d, W/Flow %d */\n\n", j, k, l);

	fprintf(fd, "int bs1_ops%s_nops=%d;\n\n", out_suf, n);

	fprintf(fd, "char *bs1_ops%s_strs[]={\n", out_suf);
	j=0;
	for(i=0; i<n; i++)
	{
		s=ops[i];
		if(!s)s="";

		strcpy(buf, s);
		s=buf;
		while(*s)
		{
			if((*s>='A') && (*s<='Z'))
				*s=*s-'A'+'a';
			s++;
		}


		fprintf(fd, "\"%s\", ", buf);
		j+=strlen(buf)+4;

		if(j>64)
		{
			fprintf(fd, "\n");
			j=0;
		}
	}
	fprintf(fd, "\"\"};\n\n");

	fprintf(fd, "char *bs1_ops%s_args[]={\n", out_suf);
	j=0;
	for(i=0; i<n; i++)
	{
		s=args[i];
		if(!s)s="";

		fprintf(fd, "\"%s\", ", s);
		j+=strlen(s)+4;

		if(j>64)
		{
			fprintf(fd, "\n");
			j=0;
		}
	}
	fprintf(fd, "\"\"};\n\n");

	fprintf(fd, "char *bs1_ops%s_sfis[]={\n", out_suf);
	j=0;
	for(i=0; i<n; i++)
	{
		s=sfis[i];
		if(!s)s="";

		fprintf(fd, "\"%s\", ", s);
		j+=strlen(s)+4;

		if(j>64)
		{
			fprintf(fd, "\n");
			j=0;
		}
	}
	fprintf(fd, "\"\"};\n\n");

	fclose(fd);

	fd=fopen(out_h, "wt");
	fprintf(fd, "/* Autogenerated header */\n\n");

	for(i=0; i<n; i++)if(ops[i])
	{
		strcpy(buf, ops[i]);
		s=buf;
		while(*s)
		{
			if((*s>='a') && (*s<='z'))
				*s=*s-'a'+'A';
			s++;
		}

		j=(31-strlen(buf))/8;
		fprintf(fd, "#define BS1_%sOP_%s", out_suf2, buf, i);
		while(j--)fprintf(fd, "\t");
		fprintf(fd, "%d\n", i);
	}

	return(0);
}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef unsigned int u32;
typedef unsigned long long u64;

void BS1_LXI_Div64(u32 *a, u32 *b, u32 *c)
{
	u64 l, m;

	l=((u64)(a[1]))<<32;
	l+=a[0];
	l/=b[0];

	if(b[1])
	{
		m=((u64)(a[1]))<<32;
		m+=a[0];
		m=(m/b[1])>>32;
		l-=m;
	}

	c[1]=(l>>32)&0xFFFFFFFF;
	c[0]=l&0xFFFFFFFF;	
}

u32 div32(u32 q, u32 d)
{
	int i, j;

	j=0;
	for(i=32; i>=0; i--)
	{
		if((((u64)d)<<i)>q)
			continue;
		q-=d<<i;
		j|=1<<i;
	}

	return(j);
}

u32 rcp32(u32 v)
{
	u32 i, j, k;
	if(v<2)return(0);

	i=0x80000000; j=i>>1;

	while(v)
	{
		if(v&1)i-=j;
		j>>=1;
		v>>=1;
	}

	return(i);
}

int main()
{
	u32 mi[2], mj[2], mk[2];
	u64 li, lj, lk;
	u32 i, j, k, l;

	for(i=0; i<16; i++)
	{
		j=rand()<<16;
		k=rand();
		printf("%08X %08X %08X %08X\n", j, k, j/k, div32(j, k));
	}

#if 0
	for(i=0; i<16; i++)
	{
		li=(1LL<<48)*sin((M_PI*(i+1))/8);
		lj=(1LL<<48)*cos((M_PI*(i+1))/8);
		li^=lj;

//		lj=(1LL<<20)*(M_PI*(i*i*i*i+1));
		lj=(1LL<<20)*(M_PI*(i*i+1));
		if(lj==0)lj=1;
//		lk=li/lj;

		lk=(1LL<<32)/lj;

		printf("%08X%08X ", (u32)(li>>32), (u32)li);
		printf("%08X%08X ", (u32)(lj>>32), (u32)lj);
		printf("%08X%08X ", (u32)(lk>>32), (u32)lk);

		printf("%08X\n", rcp32((u32)lj));

		mi[1]=(u32)(li>>32); mi[0]=(u32)li;
		mj[1]=(u32)(lj>>32); mj[0]=(u32)lj;

		BS1_LXI_Div64(mi, mj, mk);
//		printf("%08X%08X\n", mk[1], mk[0]);
	}
#endif
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>
#include <bgbasm.h>

extern int bs1_opsr_nops;
extern char *bs1_opsr_strs[];
extern char *bs1_opsr_args[];
extern char *bs1_opsr_sfis[];

int BS1_RPNIL_LookupOpcode(char *name)
{
	int i;

	for(i=0; i<bs1_opsr_nops; i++)
		if(!strcmp(bs1_opsr_strs[i], name))
			return(i);
	return(-1);
}

byte *BS1_RPNIL_EncodeOpcode(byte *ip, int n)
{
	if(n>=192)
	{
		*ip++=0xC0+(n>>8);
		*ip++=n&0xFF;
		return(ip);
	}

	*ip++=n;
	return(ip);
}

byte *BS1_RPNIL_EncVLI(byte *ip, long long i)
{
	if(i>=0x100000000000000LL)
	{
		*ip++=0xFF;
		*ip++=(i>>56)&0xFF;
		*ip++=(i>>48)&0xFF;
		*ip++=(i>>40)&0xFF;
		*ip++=(i>>32)&0xFF;
		*ip++=(i>>24)&0xFF;
		*ip++=(i>>16)&0xFF;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x2000000000000LL)
	{
		*ip++=(i>>56)|0xFE;
		*ip++=(i>>48)&0xFF;
		*ip++=(i>>40)&0xFF;
		*ip++=(i>>32)&0xFF;
		*ip++=(i>>24)&0xFF;
		*ip++=(i>>16)&0xFF;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x40000000000LL)
	{
		*ip++=(i>>48)|0xFC;
		*ip++=(i>>40)&0xFF;
		*ip++=(i>>32)&0xFF;
		*ip++=(i>>24)&0xFF;
		*ip++=(i>>16)&0xFF;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x800000000LL)
	{
		*ip++=(i>>40)|0xF8;
		*ip++=(i>>32)&0xFF;
		*ip++=(i>>24)&0xFF;
		*ip++=(i>>16)&0xFF;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x10000000)
	{
		*ip++=(i>>32)|0xF0;
		*ip++=(i>>24)&0xFF;
		*ip++=(i>>16)&0xFF;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x200000)
	{
		*ip++=(i>>24)|0xE0;
		*ip++=(i>>16)&0xFF;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x4000)
	{
		*ip++=(i>>16)|0xC0;
		*ip++=(i>>8)&0xFF;
		*ip++=i&255;
		return(ip);
	}

	if(i>=0x80)
	{
		*ip++=(i>>8)|0x80;
		*ip++=i&255;
		return(ip);
	}

	*ip++=i;
	return(ip);
}

byte *BS1_RPNIL_EncSVLI(byte *ip, long long i)
{
	i=(i>=0)?(i*2):(((-i)*2)-1);
	ip=BS1_RPNIL_EncVLI(ip, i);
	return(ip);
}


int BS1_RPNIL_ParseType(char **str, int *sz)
{
	char b[64], b2[64];
	char *s;
	int ty, ty2;
	int i;

	s=*str;
	s=BASM_Parse_Token(s, b, &ty);
	if(strcmp(b, ":"))return(0);
	s=BASM_Parse_Token(s, b, &ty);

	i=0;
	if(b[0]=='B')i=BS1_ILT_BYTE;
	if(b[0]=='W')i=BS1_ILT_WORD;
	if(b[0]=='I')i=BS1_ILT_INT;
	if(b[0]=='L')i=BS1_ILT_LONG;
	if(b[0]=='F')i=BS1_ILT_FLOAT;
	if(b[0]=='D')i=BS1_ILT_DOUBLE;
	if(b[0]=='P')i=BS1_ILT_POINTER;

	if(sz)*sz=1;
	if((b[1]>='0') && (b[1]<='9'))
		if(sz)*sz=atoi(b+1);

	*str=s;
	return(i);
}

BS1_ILBlock *BS1_RPNIL_ParseBlock(char **str)
{
	static byte *buf=NULL;
	static char **sym;
	static char **arn;
	static int *art;
	static int *ars;

	char b[64], b2[64];

	long long li, lj, lk;
	BS1_ILBlock *blk;
	byte *ip;
	char *s, *t;
	int ty, ty2;
	int i, n, nlbl, nsym;

	blk=malloc(sizeof(BS1_ILBlock));
	memset(blk, 0, sizeof(BS1_ILBlock));

	if(!buf)
	{
		buf=malloc(1<<16);
		sym=malloc(4096*sizeof(char *));
		arn=malloc(4096*sizeof(char *));
		art=malloc(4096*sizeof(int));
		ars=malloc(4096*sizeof(int));
	}

	s=*str;
	s=BASM_Parse_Token(s, b, &ty);

	if(ty!=BASM_TOKEN_NAME)
	{
		free(blk);
		return(NULL);
	}

	blk->name=strdup(b);
	blk->rty=BS1_RPNIL_ParseType(&s, NULL);

	n=0;
	while(1)
	{
		BASM_Parse_Token(s, b, &ty);

		if(ty!=BASM_TOKEN_NAME)break;
		if(!strcmp(b, "VARS"))break;
		if(!strcmp(b, "BODY"))break;
		if(!strcmp(b, "END"))break;

		s=BASM_Parse_Token(s, b, &ty);
		arn[n]=strdup(b);
		art[n]=BS1_RPNIL_ParseType(&s, NULL);
		n++;
	}

	if(n)
	{
		blk->argn=malloc((n+1)*sizeof(char *));
		blk->argt=malloc((n+1)*sizeof(int));
		blk->narg=n;

		for(i=0; i<n; i++)
			{ blk->argn[i]=arn[i];	blk->argt[i]=art[i]; }
		blk->argn[n]=NULL;
	}

	BASM_Parse_Token(s, b, &ty);
	if(!strcmp(b, "VARS"))
	{
		s=BASM_Parse_Token(s, b, &ty);

		n=0;
		while(1)
		{
			BASM_Parse_Token(s, b, &ty);

			if(ty!=BASM_TOKEN_NAME)break;
			if(!strcmp(b, "VARS"))break;
			if(!strcmp(b, "BODY"))break;
			if(!strcmp(b, "END"))break;

			s=BASM_Parse_Token(s, b, &ty);
			arn[n]=strdup(b);
			art[n]=BS1_RPNIL_ParseType(&s, &ars[n]);
			n++;
		}

		if(n)
		{
			blk->varn=malloc((n+1)*sizeof(char *));
			blk->vart=malloc((n+1)*sizeof(int));
			blk->vars=malloc((n+1)*sizeof(int));
			blk->nvar=n;

			for(i=0; i<n; i++)
			{
				blk->varn[i]=arn[i];
				blk->vart[i]=art[i];
				blk->vars[i]=ars[i];
			}
			blk->varn[n]=NULL;
		}
	}

	ip=buf;
	BASM_Parse_Token(s, b, &ty);
	if(!strcmp(b, "BODY"))
	{
		s=BASM_Parse_Token(s, b, &ty);

		nlbl=0; nsym=0;
		while(1)
		{
			BASM_Parse_Token(s, b, &ty);
			if(!strcmp(b, "END"))break;

			s=BASM_Parse_Token(s, b, &ty);

			if(ty==BASM_TOKEN_NUMBER)
			{
//				li=basm_atoi(b);
				li=atoi(b);
				i=BS1_ROP_PUSH_I;

				if(*s=='L') { i=BS1_ROP_PUSH_L; s++; }
				if(li>=(1LL<<31)) i=BS1_ROP_PUSH_L;
				if(li<=(-(1LL<<31))) i=BS1_ROP_PUSH_L;

				ip=BS1_RPNIL_EncodeOpcode(ip, i);
				ip=BS1_RPNIL_EncSVLI(ip, li);

				continue;
			}

			if(b[0]=='$')
			{
				if((b[1]>='0') && (b[1]<='9'))
				{
//					li=basm_atoi(b+1);
					li=atoi(b+1);
					i=BS1_ROP_PUSH_LI;
					ip=BS1_RPNIL_EncodeOpcode(ip, i);
					ip=BS1_RPNIL_EncSVLI(ip, li);
					continue;
				}

				for(i=0; i<nsym; i++)
					if(!strcmp(sym[i], b+1))
						break;
				if(i>=nsym)
				{
					i=nsym++;
					sym[i]=strdup(b+1);
				}

				ip=BS1_RPNIL_EncodeOpcode(ip,
					BS1_ROP_PUSH_RS);
				ip=BS1_RPNIL_EncVLI(ip, i);
				continue;
			}


			if(!strcmp(b, ":"))
			{
				s=BASM_Parse_Token(s, b, &ty);

				for(i=0; i<nlbl; i++)
					if(!strcmp(arn[i], b))
						break;
				if(i>=nlbl)
				{
					i=nlbl++;
					arn[i]=strdup(b);
				}

				ip=BS1_RPNIL_EncodeOpcode(ip,
					BS1_ROP_PUSH_JI);
				ip=BS1_RPNIL_EncVLI(ip, i);
				continue;
			}


			if(ty!=BASM_TOKEN_NAME)
			{
				printf("BS1_RPNIL_ParseBlock: "
					"Bad Token %s\n", b);
				continue;
			}

			if(*s==':')
			{

				for(i=0; i<nlbl; i++)
					if(!strcmp(arn[i], b))
						break;
				if(i>=nlbl)
				{
					i=nlbl++;
					arn[i]=strdup(b);
				}

				art[i]=ip-buf;
				s++;
				continue;
			}

			i=BS1_RPNIL_LookupOpcode(b);
			if(i>=0)
			{
				ip=BS1_RPNIL_EncodeOpcode(ip, i);
				continue;
			}

			printf("BS1_RPNIL_ParseBlock: "
				"Unknown Opcode %s\n", b);
		}
	}

	if(nlbl)
	{
		blk->lbln=malloc((nlbl+1)*sizeof(char *));
		blk->lblo=malloc((nlbl+1)*sizeof(int));
		blk->nlbl=nlbl;

		for(i=0; i<nlbl; i++)
			{ blk->lbln[i]=arn[i];	blk->lblo[i]=art[i]; }
		blk->lbln[nlbl]=NULL;
	}

	if(nsym)
	{
		blk->sym=malloc((nsym+1)*sizeof(char *));
		blk->nsym=nsym;

		for(i=0; i<nsym; i++)blk->sym[i]=sym[i];
		blk->sym[nsym]=NULL;
	}

	if(ip>buf)
	{
		i=ip-buf;
		blk->body=malloc(i);
		blk->szbody=i;

		memcpy(blk->body, buf, i);
	}


	BASM_Parse_Token(s, b, &ty);
	if(!strcmp(b, "END"))
		s=BASM_Parse_Token(s, b, &ty);

	return(blk);
}

void BS1_RPNIL_FreeBlock(BS1_ILBlock *blk)
{
	int i;

	for(i=0; i<blk->narg; i++)free(blk->argn[i]);
	for(i=0; i<blk->nvar; i++)free(blk->varn[i]);
	for(i=0; i<blk->nlbl; i++)free(blk->lbln[i]);
	for(i=0; i<blk->nsym; i++)free(blk->sym[i]);

	free(blk->name);

	free(blk->argn);
	free(blk->argt);

	free(blk->varn);
	free(blk->vart);
	free(blk->vars);

	free(blk->lbln);
	free(blk->lblo);

	free(blk->sym);
	free(blk->body);
}

void BS1_RPNIL_ProcessBuffer(char *buf)
{
	char b[64], b2[64];
	BS1_ILBlock *blk;
	char *s, *t;
	int ty, ty2;

	s=buf;

	while(*s)
	{
		s=BASM_Parse_Token(s, b, &ty);

		if(!strcmp(b, "BLOCK"))
		{
			blk=BS1_RPNIL_ParseBlock(&s);
			BS1_RPNIL_TransBlock(blk);
			BS1_RPNIL_FreeBlock(blk);
		}
	}
}
#include <bgbscr1.h>
#include <bgbasm.h>

extern int bs1_opsr_nops;
extern char *bs1_opsr_strs[];
extern char *bs1_opsr_args[];
extern char *bs1_opsr_sfis[];

int bs1_rpnil_curop;

int BS1_RPNIL_DecVLI(byte **rip)
{
	byte *ip;
	int i;

	ip=*rip;
	if(*ip<0x80)
	{
		i=*ip++;
		*rip=ip; return(i);
	}

	if(*ip<0xC0)
	{
		i=(*ip++)&0x3F;
		i=(i<<8)|(*ip++);
		*rip=ip; return(i);
	}

	if(*ip<0xE0)
	{
		i=(*ip++)&0x1F;
		i=(i<<8)|(*ip++);
		i=(i<<8)|(*ip++);
		*rip=ip; return(i);
	}

	if(*ip<0xF0)
	{
		i=(*ip++)&0x0F;
		i=(i<<8)|(*ip++);
		i=(i<<8)|(*ip++);
		i=(i<<8)|(*ip++);
		*rip=ip; return(i);
	}

	if(*ip<0xF8)
	{
		i=(*ip++)&0x07;
		i=(i<<8)|(*ip++);
		i=(i<<8)|(*ip++);
		i=(i<<8)|(*ip++);
		i=(i<<8)|(*ip++);
		*rip=ip; return(i);
	}

	printf("BS1_RPNIL_DecVLI: Overflow\n");
	return(0);
}

int BS1_RPNIL_DecSVLI(byte **rip)
{
	int i;

	i=BS1_RPNIL_DecVLI(rip);
	i=(i&1)?(-((i>>1)+1)):(i>>1);
	return(i);
}


void BS1_RPNIL_UpdateStack(BS1_ILContext *ctx, int op)
{
	char *sfi, *s;

	sfi=bs1_opsr_sfis[op];

	s=sfi;
	while(*s && *s!='=')
	{
		if(*s>='A' && *s<='Z')
		{
			s++;
			continue;
		}
		ctx->tstackpos--;
		s++;
	}

	if(*s=='=')s++;
	while(*s)
	{
		if(*s>='A' && *s<='Z')
		{
			s++;
			continue;
		}

		ctx->tstackpos++;
		s++;
	}
}


void BS1_RPNIL_PushLitInt(BS1_ILContext *ctx, int v)
{
	int i;

	i=ctx->lipos++;
	ctx->listack[i]=v;
}

int BS1_RPNIL_PopLitInt(BS1_ILContext *ctx)
{
	ctx->lipos--;
	return(ctx->listack[ctx->lipos]);
}

void BS1_RPNIL_PushSymInt(BS1_ILContext *ctx, int v)
{
	int i;

	i=ctx->lspos++;
	ctx->lsstack[i]=v;
}

int BS1_RPNIL_PopSymInt(BS1_ILContext *ctx)
{
	ctx->lspos--;
	return(ctx->lsstack[ctx->lspos]);
}

char *BS1_RPNIL_PopSymStr(BS1_ILContext *ctx)
{
	int i;
	ctx->lspos--;
	i=ctx->lsstack[ctx->lspos];
	return(ctx->blk->sym[i]);
}

char *BS1_RPNIL_PopJmpStr(BS1_ILContext *ctx)
{
	int i;

	i=BS1_RPNIL_PopLitInt(ctx);
	return(ctx->blk->lbln[i]);
}

void BS1_RPNIL_SyncStack(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
	}

	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
	}
}

void BS1_RPNIL_PopEAX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		ctx->flags&=~BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("mov eax, edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PopEAX: Warn: Implicit Conversion L->I\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		return;
	}

	basm_print("pop eax\n");
}

void BS1_RPNIL_PopEDX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		if(ctx->flags&BS1_RILFL_TOPEDX)
		{
			basm_print("push edx\n");
			ctx->flags&=~BS1_RILFL_TOPEDX;
			return;
		}

		basm_print("mov edx, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		ctx->flags&=~BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PopEDX: Warn: Implicit Conversion L->I\n");
		basm_print("mov edx, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		return;
	}

	basm_print("pop edx\n");
}

void BS1_RPNIL_PopEDAX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		printf("BS1_RPNIL_PopEDAX: Warn: Implicit Conversion I->L\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		basm_print("cdq\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		printf("BS1_RPNIL_PopEDX: Warn: Implicit Conversion I->L\n");
		basm_print("mov eax, edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		basm_print("cdq\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		return;
	}

	basm_print("pop eax\n");
	basm_print("pop edx\n");
}

void BS1_RPNIL_PushEAX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		printf("BS1_RPNIL_PushEAX: Warn: Possible EAX Thrashing\n");
		basm_print("push eax\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		//note: should control 1/2 args in regs
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		ctx->flags|=BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PushEAX: Warn: Possible EAX Thrashing(L)\n");
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		ctx->flags|=BS1_RILFL_TOPEAX;
		return;
	}

	ctx->flags|=BS1_RILFL_TOPEAX;
}

void BS1_RPNIL_PushEDX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		ctx->flags|=BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		printf("BS1_RPNIL_PushEDX: Warn: Possible EDX Thrashing\n");
		basm_print("push edx\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PushEDX: Warn: Possible EDX Thrashing(L)\n");
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		ctx->flags|=BS1_RILFL_TOPEDX;
		return;
	}

	ctx->flags|=BS1_RILFL_TOPEDX;
}

void BS1_RPNIL_PushEDAX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		printf("BS1_RPNIL_PushEDAX: Warn: Possible EAX Thrashing\n");
		basm_print("push eax\n");
		basm_print("cdq\n");

		ctx->flags&=~BS1_RILFL_TOPEAX;
		ctx->flags|=BS1_RILFL_TOPEDAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		printf("BS1_RPNIL_PushEDAX: Warn: Possible EDX Thrashing\n");

		basm_print("push edx\n");
		basm_print("mov eax, edx\n");
		basm_print("cdq\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		ctx->flags|=BS1_RILFL_TOPEDAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PushEAX: Warn: Possible EDAX Thrashing\n");
		basm_print("push edx; push eax\n");
		return;
	}

	ctx->flags|=BS1_RILFL_TOPEDAX;
}

void BS1_RPNIL_PushEAX2(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		printf("BS1_RPNIL_PushEAX2: Warn: Possible EAX Thrashing\n");
		basm_print("push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PushEAX2: Warn: Possible EAX Thrashing(L)\n");
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		basm_print("push eax\n");
		return;
	}

	basm_print("push eax\n");
}

void BS1_RPNIL_PushEDX2(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		ctx->flags&=~BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		printf("BS1_RPNIL_PushEDX: Warn: Possible EDX Thrashing\n");
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PushEDX: Warn: Possible EDX Thrashing(L)\n");
		basm_print("push edx; push eax\n");
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		return;
	}

	basm_print("push edx\n");
}

void BS1_RPNIL_PushEDAX2(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		printf("BS1_RPNIL_PushEDAX2: Warn: Possible EAX Thrashing\n");
		basm_print("push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		printf("BS1_RPNIL_PushEDAX2: Warn: Possible EDX Thrashing\n");
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;

		basm_print("mov eax, edx\n");
		basm_print("cdq\n");
		basm_print("push edx\n");
		basm_print("push eax\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PushEDAX2: Warn: Possible EDAX Thrashing\n");
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		basm_print("push edx; push eax\n");
		return;
	}

	basm_print("push edx; push eax\n");
}


void BS1_RPNIL_PopECX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("mov ecx, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("mov ecx, edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PopECX: Warn: Implicit Conversion L->I\n");
		basm_print("mov ecx, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		return;
	}

	basm_print("pop ecx\n");
}

void BS1_RPNIL_PushECX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		basm_print("mov eax, ecx\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		basm_print("mov eax, ecx\n");
		ctx->flags|=BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		basm_print("mov eax, ecx\n");
		ctx->flags|=BS1_RILFL_TOPEAX;
		return;
	}

	basm_print("mov eax, ecx\n");
	ctx->flags|=BS1_RILFL_TOPEAX;
}

void BS1_RPNIL_PushECX2(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		basm_print("push ecx\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
		basm_print("push ecx\n");
		return;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		basm_print("push ecx\n");
		return;
	}

	basm_print("push ecx\n");
}

void BS1_RPNIL_FlushEAX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
	}
}

void BS1_RPNIL_FlushEDX(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		basm_print("push edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;
	}

	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		basm_print("push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;
	}

	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		basm_print("push edx; push eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
	}
}

void BS1_RPNIL_FlushECX(BS1_ILContext *ctx)
{
}

void BS1_RPNIL_FlushEBX(BS1_ILContext *ctx)
{
	if(!(ctx->flags&BS1_RILFL_USEDEBX))
	{
		basm_print("mov [ebp-4], ebx\n");
		ctx->flags|=BS1_RILFL_USEDEBX;
		return;
	}

	if(ctx->flags&BS1_RILFL_MARKEBX)
	{
		basm_print("mov [ebp-16], ebx\n");
		ctx->flags&=~BS1_RILFL_MARKEBX;
		return;
	}
}

void BS1_RPNIL_FlushESI(BS1_ILContext *ctx)
{
	if(!(ctx->flags&BS1_RILFL_USEDESI))
	{
		basm_print("mov [ebp-8], esi\n");
		ctx->flags|=BS1_RILFL_USEDESI;
		return;
	}
}

void BS1_RPNIL_FlushEDI(BS1_ILContext *ctx)
{
	if(!(ctx->flags&BS1_RILFL_USEDEDI))
	{
		basm_print("mov [ebp-12], edi\n");
		ctx->flags|=BS1_RILFL_USEDEDI;
		return;
	}
}

void BS1_RPNIL_PopEBX(BS1_ILContext *ctx)
{
	BS1_RPNIL_FlushEBX(ctx);
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{	basm_print("mov ebx, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;	return;	}
	if(ctx->flags&BS1_RILFL_TOPEDX)
	{	basm_print("mov ebx, edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;	return;	}
	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{	printf("BS1_RPNIL_PopEBX: Warn: Implicit Conversion L->I\n");
		basm_print("mov ebx, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;	return;	}
	basm_print("pop ebx\n");
}

void BS1_RPNIL_PopESI(BS1_ILContext *ctx)
{
	BS1_RPNIL_FlushESI(ctx);
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{	basm_print("mov esi, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;	return; }
	if(ctx->flags&BS1_RILFL_TOPEDX)
	{	basm_print("mov esi, edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;	return;	}
	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{	printf("BS1_RPNIL_PopESI: Warn: Implicit Conversion L->I\n");
		basm_print("mov esi, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;	return;	}
	basm_print("pop esi\n");
}

void BS1_RPNIL_PopEDI(BS1_ILContext *ctx)
{
	BS1_RPNIL_FlushEDI(ctx);
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{	basm_print("mov edi, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEAX;	return; }
	if(ctx->flags&BS1_RILFL_TOPEDX)
	{	basm_print("mov edi, edx\n");
		ctx->flags&=~BS1_RILFL_TOPEDX;	return;	}
	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{	printf("BS1_RPNIL_PopEDI: Warn: Implicit Conversion L->I\n");
		basm_print("mov edi, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;	return;	}
	basm_print("pop edi\n");
}


void BS1_RPNIL_PopEDSI(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{	basm_print("mov edi, edx; mov esi, eax\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;	return; }
	BS1_RPNIL_PopESI(ctx);
	BS1_RPNIL_PopEDI(ctx);
}

void BS1_RPNIL_PushEDSI(BS1_ILContext *ctx)
{
	BS1_RPNIL_FlushEDX(ctx);
	BS1_RPNIL_FlushEAX(ctx);
	basm_print("mov edx, edi; mov eax, esi\n");
	BS1_RPNIL_PushEDAX(ctx);
}


void BS1_RPNIL_PopInt(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
		{ ctx->flags&=~BS1_RILFL_TOPEAX; return; }
	if(ctx->flags&BS1_RILFL_TOPEDX)
		{ ctx->flags&=~BS1_RILFL_TOPEDX; return; }
	if(ctx->flags&BS1_RILFL_TOPEDAX)
	{
		printf("BS1_RPNIL_PopInt: Warn: Implicit Conversion L->I\n");
		ctx->flags&=~BS1_RILFL_TOPEDAX;
		return;
	}
	basm_print("add esp, 4\n");
}

void BS1_RPNIL_PopLong(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_TOPEAX)
	{
		printf("BS1_RPNIL_PopLong: Warn: Implicit Conversion I->L\n");
		ctx->flags&=~BS1_RILFL_TOPEAX; return;
	}
	if(ctx->flags&BS1_RILFL_TOPEDX)
	{
		printf("BS1_RPNIL_PopLong: Warn: Implicit Conversion I->L\n");
		ctx->flags&=~BS1_RILFL_TOPEDX; return;
	}
	if(ctx->flags&BS1_RILFL_TOPEDAX)
		{ ctx->flags&=~BS1_RILFL_TOPEDAX; return; }
	basm_print("add esp, 8\n");
}


void BS1_RPNIL_Enter(BS1_ILContext *ctx)
{
	basm_print("push ebp; mov ebp, esp\n");
	basm_print("sub esp, 24\n");	//ebx esi edi mark temp0/1

	ctx->flags=0;
}

void BS1_RPNIL_Return(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_USEDEBX)basm_print("mov ebx, [ebp-4]\n");
	if(ctx->flags&BS1_RILFL_USEDESI)basm_print("mov esi, [ebp-8]\n");
	if(ctx->flags&BS1_RILFL_USEDEDI)basm_print("mov edi, [ebp-12]\n");
	basm_print("mov esp, ebp; pop ebp; ret\n");
}

void BS1_RPNIL_PushMark(BS1_ILContext *ctx)
{
	int i;

	i=ctx->markstackpos++;
	ctx->markstack[i]=ctx->tstackpos;
	
	BS1_RPNIL_SyncStack(ctx);
	if(!(ctx->flags&BS1_RILFL_MARKEBX))
		BS1_RPNIL_FlushEBX(ctx);
	basm_print("push ebx; mov ebx, esp\n");
	ctx->flags|=BS1_RILFL_MARKEBX;
}

void BS1_RPNIL_PopMark(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_MARKEBX)
	{
		basm_print("mov esp, ebx; pop ebx\n");
		return;
	}

	BS1_RPNIL_FlushEBX(ctx);
	basm_print("mov esp, [ebp-16]; pop ebx\n");
	ctx->flags|=BS1_RILFL_MARKEBX;
}

void BS1_RPNIL_CacheMark(BS1_ILContext *ctx)
{
	if(ctx->flags&BS1_RILFL_MARKEBX)
		return;
	BS1_RPNIL_FlushEBX(ctx);
	basm_print("mov ebx, [ebp-16]\n");
}


int BS1_RPNIL_LoadLocalOffset(BS1_ILContext *ctx, char *name)
{
	int i, j, k;

	j=24;
	for(i=0; i<ctx->blk->nvar; i++)
	{
		k=ctx->blk->vars[i];
		switch(ctx->blk->vart[i])
		{
		case BS1_ILT_INT:
		case BS1_ILT_FLOAT:
		case BS1_ILT_POINTER:
			j+=k*4;
			j=(j+3)&(~3);
			break;
		case BS1_ILT_LONG:
		case BS1_ILT_DOUBLE:
			j+=8*k;
			j=(j+7)&(~7);
			break;
		case BS1_ILT_BYTE:
			j+=k;
			break;
		case BS1_ILT_WORD:
			j+=k*2;
			j=(j+1)&(~1);
			break;
		default: break;
		}

		if(!strcmp(ctx->blk->varn[i], name))
			return(j);
	}
	return(0);
}

int BS1_RPNIL_LoadArgOffset(BS1_ILContext *ctx, char *name)
{
	int i, j, k;

	j=2;
	for(i=0; i<ctx->blk->narg; i++)
	{
		if(!strcmp(ctx->blk->argn[i], name))
			return(j);

		j++;
		if((ctx->blk->argt[i]==BS1_ILT_LONG) ||
			(ctx->blk->argt[i]==BS1_ILT_DOUBLE))
		{
			j++;
			if(j&1)j++;
		}
	}

	return(0);
}

void BS1_RPNIL_LoadInt(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);
	BS1_RPNIL_FlushEAX(ctx);
	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i)	{ basm_print("mov eax, [ebp-%d]\n", i); return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i)	{ basm_print("mov eax, [ebp+%d]\n", i*4); return; }
	basm_print("mov eax, [%s]\n", s);
}

void BS1_RPNIL_LoadLong(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);
	BS1_RPNIL_FlushEDX(ctx);
	BS1_RPNIL_FlushEAX(ctx);

	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i)
	{	basm_print("mov eax, [ebp-%d]\n", i);
		basm_print("mov edx, [ebp-%d]\n", i-4);
		return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i)
	{	basm_print("mov eax, [ebp+%d]\n", i*4);
		basm_print("mov edx, [ebp+%d]\n", i*4+4);
		return; }

	basm_print("mov eax, [%s]\n", s);
	basm_print("mov edx, [%s+4]\n", s);
}

void BS1_RPNIL_LoadAddr(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);
	BS1_RPNIL_FlushECX(ctx);
	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i)	{ basm_print("lea ecx, [ebp-%d]\n", i); return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i)	{ basm_print("lea ecx, [ebp+%d]\n", i*4); return; }
	basm_print("lea ecx, [%s]\n", s);
}

void BS1_RPNIL_LoadFuncAddr(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);
	BS1_RPNIL_FlushECX(ctx);
	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i)	{ basm_print("mov ecx, [ebp-%d]\n", i); return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i)	{ basm_print("mov ecx, [ebp+%d]\n", i*4); return; }
	basm_print("lea ecx, [%s]\n", s);
}

void BS1_RPNIL_CallFuncAddr(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);
	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i)	{ basm_print("call [ebp-%d]\n", i); return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i)	{ basm_print("call [ebp+%d]\n", i*4); return; }
	basm_print("call %s\n", s);
}

void BS1_RPNIL_StoreInt(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);
	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i)	{ basm_print("mov [ebp-%d], eax\n", i); return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i)	{ basm_print("mov [ebp+%d], eax\n", i*4); return; }
	basm_print("mov [%s], eax\n", s);
}

void BS1_RPNIL_StoreLong(BS1_ILContext *ctx)
{
	char *s;
	int i, j, k;

	s=BS1_RPNIL_PopSymStr(ctx);

	i=BS1_RPNIL_LoadLocalOffset(ctx, s);
	if(i) { basm_print("mov [ebp-%d], eax\n", i);
		basm_print("mov [ebp-%d], edx\n", i-4);
		return; }
	i=BS1_RPNIL_LoadArgOffset(ctx, s);
	if(i) { basm_print("mov [ebp+%d], eax\n", i*4);
		basm_print("mov [ebp+%d], edx\n", i*4+4);
		return; }

	basm_print("mov [%s+0], eax\n", s);
	basm_print("mov [%s+4], edx\n", s);
}


///////////////////////////////////////

//Block 256..383, Load/Store opcodes
int BS1_RPNIL_TransOpcode256(BS1_ILContext *ctx, int op)
{
	char *s0, *s1;
	int i, j, k;

	switch(op)
	{
	case BS1_ROP_LOAD_I:
	case BS1_ROP_LOAD_P:
		BS1_RPNIL_LoadInt(ctx);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_LOAD_L:
		BS1_RPNIL_LoadLong(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_LOAD_B:
	case BS1_ROP_LOAD_C:
		BS1_RPNIL_FlushEAX(ctx);
		BS1_RPNIL_LoadAddr(ctx);
		if(op==BS1_ROP_LOAD_B)basm_print("movzx eax, [ecx]\n");
		if(op==BS1_ROP_LOAD_C)basm_print("movsx eax, [ecx]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_LOAD_W:
	case BS1_ROP_LOAD_S:
		BS1_RPNIL_FlushEAX(ctx);
		BS1_RPNIL_LoadAddr(ctx);
		if(op==BS1_ROP_LOAD_W)basm_print("movzxw eax, [ecx]\n");
		if(op==BS1_ROP_LOAD_S)basm_print("movsxw eax, [ecx]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;

	case BS1_ROP_STORE_I:
	case BS1_ROP_STORE_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_StoreInt(ctx);
		break;
	case BS1_ROP_STORE_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_StoreLong(ctx);
		break;
	case BS1_ROP_STORE_B:
	case BS1_ROP_STORE_C:
		BS1_RPNIL_LoadAddr(ctx);
		basm_print("mov [ecx], al\n");
		break;
	case BS1_ROP_STORE_W:
	case BS1_ROP_STORE_S:
		BS1_RPNIL_LoadAddr(ctx);
		basm_print("mov [ecx], ax\n");
		break;

	case BS1_ROP_LOADINDEX_I:
	case BS1_ROP_LOADINDEX_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("mov eax, [edx+ecx*4]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_LOADINDEX_L:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("shl ecx, 3\n");
		basm_print("add ecx, edx\n");
		basm_print("mov eax, [ecx]\n");
		basm_print("mov edx, [ecx+4]\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_LOADINDEX_B:
	case BS1_ROP_LOADINDEX_C:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		if(op==BS1_ROP_LOADINDEX_B)
			basm_print("movzx eax, [edx+ecx]\n");
		if(op==BS1_ROP_LOADINDEX_C)
			basm_print("movsx eax, [edx+ecx]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_LOADINDEX_W:
	case BS1_ROP_LOADINDEX_S:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		if(op==BS1_ROP_LOADINDEX_W)
			basm_print("movzxw eax, [edx+ecx*2]\n");
		if(op==BS1_ROP_LOADINDEX_S)
			basm_print("movsxw eax, [edx+ecx*2]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;

	case BS1_ROP_STOREINDEX_I:
	case BS1_ROP_STOREINDEX_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("mov [edx+ecx*4], eax\n");
		break;
	case BS1_ROP_STOREINDEX_L:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("shl ecx, 3\n");
		basm_print("add ecx, edx\n");
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("mov [ecx], eax\n");
		basm_print("mov [ecx+4], edx\n");
		break;

	case BS1_ROP_STOREINDEX_B:
	case BS1_ROP_STOREINDEX_C:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("mov [edx+ecx], al\n");
		break;
	case BS1_ROP_STOREINDEX_W:
	case BS1_ROP_STOREINDEX_S:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("mov [edx+ecx*2], ax\n");
		break;

	case BS1_ROP_LOADINDEX_IC:
	case BS1_ROP_LOADINDEX_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("mov eax, [edx+%d]\n", i*4);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_LOADINDEX_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("mov eax, [ecx+%d]\n", i*8);
		basm_print("mov edx, [ecx+%d]\n", i*8+4);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_LOADINDEX_BC:
	case BS1_ROP_LOADINDEX_CC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		if(op==BS1_ROP_LOADINDEX_BC)
			basm_print("movzx eax, [edx+%d]\n", i);
		if(op==BS1_ROP_LOADINDEX_CC)
			basm_print("movsx eax, [edx+%d]\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_LOADINDEX_WC:
	case BS1_ROP_LOADINDEX_SC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		if(op==BS1_ROP_LOADINDEX_WC)
			basm_print("movzx eax, [edx+%d]\n", i*2);
		if(op==BS1_ROP_LOADINDEX_SC)
			basm_print("movsx eax, [edx+%d]\n", i*2);
		BS1_RPNIL_PushEAX(ctx);
		break;

	case BS1_ROP_STOREINDEX_IC:
	case BS1_ROP_STOREINDEX_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("mov [edx+%d], eax\n", i*4);
		break;
	case BS1_ROP_STOREINDEX_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("mov [ecx+%d], eax\n", i*8+0);
		basm_print("mov [ecx+%d], edx\n", i*8+4);
		break;
	case BS1_ROP_STOREINDEX_BC:
	case BS1_ROP_STOREINDEX_CC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("mov [edx+%d], al\n", i);
		break;
	case BS1_ROP_STOREINDEX_WC:
	case BS1_ROP_STOREINDEX_SC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("mov [edx+%d], ax\n", i*2);
		break;

	default:
		break;
	}

	return(0);
}


///////////////////////////////////////

//Block 384..511, Conversion Opcodes
int BS1_RPNIL_TransOpcode384(BS1_ILContext *ctx, int op)
{
	char *s0, *s1;
	int i, j, k;

	switch(op)
	{
	case BS1_ROP_CONV_IL:
		BS1_RPNIL_FlushEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cdq\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_CONV_IP:
		break;

	case BS1_ROP_CONV_IB:
	case BS1_ROP_CONV_PB:
		BS1_RPNIL_PopEAX(ctx);	basm_print("and eax, 0xFF\n");
		BS1_RPNIL_PushEAX(ctx);	break;
	case BS1_ROP_CONV_IW:
	case BS1_ROP_CONV_PW:
		BS1_RPNIL_PopEAX(ctx); basm_print("and eax, 0xFFFF\n");
		BS1_RPNIL_PushEAX(ctx);	break;
	case BS1_ROP_CONV_IC:
	case BS1_ROP_CONV_PC:
		BS1_RPNIL_PopEAX(ctx);	basm_print("cbw; cwde\n");
		BS1_RPNIL_PushEAX(ctx);	break;
	case BS1_ROP_CONV_IS:
	case BS1_ROP_CONV_PS:
		BS1_RPNIL_PopEAX(ctx);	basm_print("cwde\n");
		BS1_RPNIL_PushEAX(ctx);	break;

	case BS1_ROP_CONV_LI:
	case BS1_ROP_CONV_LP:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEAX(ctx);
		break;

	case BS1_ROP_CONV_LB:
		BS1_RPNIL_PopEDAX(ctx);	basm_print("and eax, 0xFF\n");
		BS1_RPNIL_PushEAX(ctx);	break;
	case BS1_ROP_CONV_LW:
		BS1_RPNIL_PopEDAX(ctx); basm_print("and eax, 0xFFFF\n");
		BS1_RPNIL_PushEAX(ctx);	break;
	case BS1_ROP_CONV_LC:
		BS1_RPNIL_PopEDAX(ctx);	basm_print("cbw; cwde\n");
		BS1_RPNIL_PushEAX(ctx);	break;
	case BS1_ROP_CONV_LS:
		BS1_RPNIL_PopEDAX(ctx);	basm_print("cwde\n");
		BS1_RPNIL_PushEAX(ctx);	break;

	case BS1_ROP_CONV_PI:
		break;
	case BS1_ROP_CONV_PL:
	case BS1_ROP_CONV_BL:
	case BS1_ROP_CONV_WL:
		BS1_RPNIL_FlushEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
//		basm_print("cdq\n");
		basm_print("xor edx, edx\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_CONV_CL:
	case BS1_ROP_CONV_SL:
		BS1_RPNIL_FlushEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cdq\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_CONV_BI:	case BS1_ROP_CONV_BP:
	case BS1_ROP_CONV_BW:	case BS1_ROP_CONV_BC:
	case BS1_ROP_CONV_BS:
	case BS1_ROP_CONV_WI:	case BS1_ROP_CONV_WP:
	case BS1_ROP_CONV_WB:	case BS1_ROP_CONV_WC:
	case BS1_ROP_CONV_WS:
	case BS1_ROP_CONV_CI:	case BS1_ROP_CONV_CP:
	case BS1_ROP_CONV_CB:	case BS1_ROP_CONV_CW:
	case BS1_ROP_CONV_CS:
	case BS1_ROP_CONV_SI:	case BS1_ROP_CONV_SP:
	case BS1_ROP_CONV_SB:	case BS1_ROP_CONV_SW:
	case BS1_ROP_CONV_SC:
		break;

	default:
		break;
	}

	return(0);
}


///////////////////////////////////////

//Block 512..767, Arithmetic Opcodes
int BS1_RPNIL_TransOpcode512(BS1_ILContext *ctx, int op)
{
	char *s0, *s1;
	int i, j, k;

	switch(op)
	{
	case BS1_ROP_ADD_I:
	case BS1_ROP_ADD_P:
	case BS1_ROP_ADD_PI:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("add eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_ADD_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("add [esp+0], eax\n");
		basm_print("adc [esp+4], edx\n");
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_ADD_IC:
	case BS1_ROP_ADD_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("add eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_ADD_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("add eax, %d\n", i);
		basm_print("adc edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_ADD_PI_2:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("lea eax, [eax+edx*2]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_ADD_PI_4:
	case BS1_ROP_ADD_PI_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("lea eax, [eax+edx*4]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_ADD_PI_8:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("shl edx, 3; add eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_ADD_PI_16:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("shl edx, 4; add eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;

	case BS1_ROP_SUB_I:
	case BS1_ROP_SUB_P:
	case BS1_ROP_SUB_PI:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("sub eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SUB_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("sub [esp+0], eax\n");
		basm_print("sbb [esp+4], edx\n");
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_SUB_IC:
	case BS1_ROP_SUB_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("sub eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SUB_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("sub eax, %d\n", i);
		basm_print("sbb edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_SUB_PI_2:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("lea eax, [eax-edx*2]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SUB_PI_4:
	case BS1_ROP_SUB_PI_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("lea eax, [eax-edx*4]\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SUB_PI_8:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("shl edx, 3; sub eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SUB_PI_16:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("shl edx, 4; sub eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;

	case BS1_ROP_MUL_I:
	case BS1_ROP_MUL_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("imul eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;

#if 0
	case BS1_ROP_MUL_L:
		BS1_RPNIL_SyncStack(ctx);
		BS1_RPNIL_PushEDAX2(ctx);	//space for a new LL

		basm_print("mov eax, [esp+8]\n");
		basm_print("imul [esp+16]\n");
		basm_print("mov [esp+0], eax\n");
		basm_print("mov [esp+4], edx\n");

		basm_print("mov eax, [esp+8]\n");
		basm_print("imul [esp+20]\n");
		basm_print("add [esp+4], eax\n");

		basm_print("mov eax, [esp+12]\n");
		basm_print("imul [esp+16]\n");
		basm_print("add [esp+4], eax\n");

		BS1_RPNIL_PopEDAX(ctx);

		BS1_RPNIL_PopLong(ctx);
		BS1_RPNIL_PopLong(ctx);

		BS1_RPNIL_PushEDAX(ctx);
		break;
#endif

	case BS1_ROP_MUL_L:
		BS1_RPNIL_SyncStack(ctx);
		BS1_RPNIL_FlushESI(ctx);
		BS1_RPNIL_FlushEDI(ctx);
		BS1_RPNIL_FlushEBX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		BS1_RPNIL_SyncStack(ctx);

		basm_print("mov eax, [esp+0]\n");
		basm_print("mov ebx, [esp+8]\n");

		basm_print("mov ecx, eax\n");
		basm_print("imul ebx\n");
		basm_print("mov edi, edx\n");

		basm_print("mov esi, eax\n");
		basm_print("imul ecx, [esp+12]\n");
		basm_print("mov eax, [esp+4]\n");
		basm_print("add edi, ecx\n");

		basm_print("imul eax, ebx\n");
		basm_print("add edi, eax\n");

		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDSI(ctx);
		break;

	case BS1_ROP_MUL_IC:
	case BS1_ROP_MUL_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("imul eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_MUL_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("push edx\n");
		basm_print("mov ecx, %d\n", i);
		basm_print("mul ecx\n");
		basm_print("pop ecx\n");
		basm_print("mul ecx, %d\n", i);
		basm_print("add edx, ecx\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_DIV_I:
	case BS1_ROP_DIV_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("xor edx, edx; div ecx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_DIV_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		//need implement
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_DIV_IC:
	case BS1_ROP_DIV_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("mov ecx, %d\n", i);
		basm_print("xor edx, edx; div ecx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_DIV_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("mov ecx, %d\n", i);
		basm_print("div ecx; cdq\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_MOD_I:
	case BS1_ROP_MOD_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("xor edx, edx; div ecx\n");
		BS1_RPNIL_PushEDX(ctx);
		break;
	case BS1_ROP_MOD_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		//need implement
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_MOD_IC:
	case BS1_ROP_MOD_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("mov ecx, %d\n", i);
		basm_print("xor edx, edx; div ecx\n");
		BS1_RPNIL_PushEDX(ctx);
		break;
	case BS1_ROP_MOD_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("mov ecx, %d\n", i);
		basm_print("div ecx; mov eax, edx; cdq\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;


	case BS1_ROP_AND_I:
	case BS1_ROP_AND_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("and eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_AND_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("and [esp+0], eax\n");
		basm_print("and [esp+4], edx\n");
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_AND_IC:
	case BS1_ROP_AND_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("and eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_AND_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("and eax, %d\n", i);
		basm_print("and edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_OR_I:
	case BS1_ROP_OR_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("or eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_OR_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("or [esp+0], eax\n");
		basm_print("or [esp+4], edx\n");
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_OR_IC:
	case BS1_ROP_OR_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("or eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_OR_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("or eax, %d\n", i);
		basm_print("or edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_XOR_I:
	case BS1_ROP_XOR_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("or eax, edx\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_XOR_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("xor [esp+0], eax\n");
		basm_print("xor [esp+4], edx\n");
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_XOR_IC:
	case BS1_ROP_XOR_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("xor eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_XOR_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("xor eax, %d\n", i);
		basm_print("xor edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;


	case BS1_ROP_SHL_I:
	case BS1_ROP_SHL_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("shl eax, cl\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SHL_L:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		s0=BASM_GenSym();	s1=BASM_GenSym();
		basm_print("or cl, cl\n");
		basm_print("%s:\n", s0);
		basm_print("jz %s\n", s1);
		basm_print("shl eax\n");
		basm_print("rcl edx\n");
		basm_print("dec cl; jmp %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_SHL_IC:
	case BS1_ROP_SHL_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("shl eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SHL_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		if(i>=32)
		{
			basm_print("mov edx, eax; xor eax, eax\n");
			i-=32;
			if(i)basm_print("shl eax, %d\n", i);
		}else if(i>3)
		{
			BS1_RPNIL_FlushECX(ctx);
			basm_print("shl edx, %d\n", i);
			basm_print("mov ecx, eax\n");
			basm_print("shr ecx, %d\n", 32-i);
			basm_print("or edx, ecx\n");
			basm_print("shl eax, %d\n", i);
		}else
		{
			while(i--)
			{
				basm_print("shl eax\n");
				basm_print("rcl edx\n");
			}
		}
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_SHR_I:
	case BS1_ROP_SHR_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("shr eax, cl\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SHR_L:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		s0=BASM_GenSym();	s1=BASM_GenSym();
		basm_print("or cl, cl\n");
		basm_print("%s:\n", s0);
		basm_print("jz %s\n", s1);
		basm_print("shr edx\n");
		basm_print("rcr eax\n");
		basm_print("dec cl; jmp %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_SHR_IC:
	case BS1_ROP_SHR_PC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("shr eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_SHR_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		if(i>=32)
		{
			basm_print("mov eax, edx; xor edx, edx\n");
			i-=32;
			if(i)basm_print("shr eax, %d\n", i);
		}else if(i>3)
		{
			BS1_RPNIL_FlushECX(ctx);
			basm_print("shr eax, %d\n", i);
			basm_print("mov ecx, edx\n");
			basm_print("shl ecx, %d\n", 32-i);
			basm_print("or eax, ecx\n");
			basm_print("shr edx, %d\n", i);
		}else
		{
			while(i--)
			{
				basm_print("shr edx\n");
				basm_print("rcr eax\n");
			}
		}
		BS1_RPNIL_PushEDAX(ctx);
		break;


	case BS1_ROP_CMP_EQ_I:
	case BS1_ROP_CMP_EQ_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, edx\n");
		basm_print("sete al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_EQ_L:
		s0=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edi, edx\n");
		basm_print("jne %s\n", s0);
		basm_print("cmp esi, eax\n");
		basm_print("jne %s\n", s0);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;
	case BS1_ROP_CMP_EQ_IC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, %d\n", i);
		basm_print("sete al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_EQ_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		s0=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jne %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jne %s\n", s0);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_CMP_NE_I:
	case BS1_ROP_CMP_NE_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, edx\n");
		basm_print("setne al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_NE_L:
		s0=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("mov ecx, 1\n");
		basm_print("cmp edi, edx\n");
		basm_print("jne %s\n", s0);
		basm_print("cmp esi, eax\n");
		basm_print("jne %s\n", s0);
		basm_print("dec ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;
	case BS1_ROP_CMP_NE_IC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, %d\n", i);
		basm_print("setne al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_NE_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		s0=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("mov ecx, 1\n");
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jne %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jne %s\n", s0);
		basm_print("dec ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_CMP_L_I:
	case BS1_ROP_CMP_L_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, edx\n");
		basm_print("setl al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_L_L:
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edi, edx\n");
		basm_print("jg %s\n", s0);
		basm_print("jl %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("jge %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;
	case BS1_ROP_CMP_L_IC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, %d\n", i);
		basm_print("setl al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_L_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jg %s\n", s0);
		basm_print("jl %s\n", s1);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jge %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_CMP_G_I:
	case BS1_ROP_CMP_G_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, edx\n");
		basm_print("setg al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_G_L:
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edi, edx\n");
		basm_print("jg %s\n", s1);
		basm_print("jl %s\n", s0);
		basm_print("cmp esi, eax\n");
		basm_print("jle %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;
	case BS1_ROP_CMP_G_IC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, %d\n", i);
		basm_print("setg al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_G_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jg %s\n", s1);
		basm_print("jl %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jle %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;


	case BS1_ROP_CMP_LE_I:
	case BS1_ROP_CMP_LE_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, edx\n");
		basm_print("setle al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_LE_L:
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edi, edx\n");
		basm_print("jg %s\n", s0);
		basm_print("jl %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("jg %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;
	case BS1_ROP_CMP_LE_IC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, %d\n", i);
		basm_print("setle al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_LE_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jg %s\n", s0);
		basm_print("jl %s\n", s1);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jg %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_CMP_GE_I:
	case BS1_ROP_CMP_GE_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, edx\n");
		basm_print("setge al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_GE_L:
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edi, edx\n");
		basm_print("jg %s\n", s1);
		basm_print("jl %s\n", s0);
		basm_print("cmp esi, eax\n");
		basm_print("jl %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;
	case BS1_ROP_CMP_GE_IC:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopECX(ctx);
		basm_print("xor eax, eax; cmp ecx, %d\n", i);
		basm_print("setge al\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CMP_GE_LC:
		i=BS1_RPNIL_PopLitInt(ctx);
		s0=BASM_GenSym();
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_FlushECX(ctx);
		basm_print("xor ecx, ecx\n");
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jg %s\n", s1);
		basm_print("jl %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jl %s\n", s0);
		basm_print("%s:\n", s1);
		basm_print("inc ecx\n");
		basm_print("%s:\n", s0);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_INC_I:
	case BS1_ROP_INC_P:
		BS1_RPNIL_PopEAX(ctx);
		basm_print("inc eax\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_INC_L:
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("add eax, 1; adc edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_INC2_I:
	case BS1_ROP_INC2_P:
		BS1_RPNIL_PopEAX(ctx);
		basm_print("add eax, 2\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_INC2_L:
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("add eax, 2; adc edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_DEC_I:
	case BS1_ROP_DEC_P:
		BS1_RPNIL_PopEAX(ctx);
		basm_print("dec eax\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_DEC_L:
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("sub eax, 1; sbb edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;
	case BS1_ROP_DEC2_I:
	case BS1_ROP_DEC2_P:
		BS1_RPNIL_PopEAX(ctx);
		basm_print("sub eax, 2\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_DEC2_L:
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("sub eax, 2; sbb edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_NOT_I:
	case BS1_ROP_NOT_P:
		BS1_RPNIL_PopEAX(ctx);
		basm_print("not eax\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_NOT_L:
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("not eax; not edx\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_NEG_I:
	case BS1_ROP_NEG_P:
		BS1_RPNIL_PopEAX(ctx);
		basm_print("neg eax\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_NEG_L:
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("not eax; not edx\n");
		basm_print("add eax, 1; adc edx, 0\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	default:
		break;
	}

	return(0);
}


///////////////////////////////////////

//Block 896..959: Jump-Compare Ops
int BS1_RPNIL_TransOpcode896(BS1_ILContext *ctx, int op)
{
	char *s0, *s1;
	int i, j, k;

	switch(op)
	{
	case BS1_ROP_JMP_EQ_I:
	case BS1_ROP_JMP_EQ_P:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("cmp edx, eax\n");
		basm_print("je %s\n", s0);
		break;
	case BS1_ROP_JMP_EQ_L:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		basm_print("cmp edi, edx\n");
		basm_print("jne %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("je %s\n", s0);
		basm_print("%s:\n", s1);
		break;
	case BS1_ROP_JMP_EQ_IC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cmp eax, %d\n", i);
		basm_print("je %s\n", s0);
		break;
	case BS1_ROP_JMP_EQ_LC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jne %s\n", s1);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jne %s\n", s1);
		basm_print("jmp %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_JMP_NE_I:
	case BS1_ROP_JMP_NE_P:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("cmp edx, eax\n");
		basm_print("jne %s\n", s0);
		break;
	case BS1_ROP_JMP_NE_L:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		basm_print("cmp edi, edx\n");
		basm_print("jne %s\n", s0);
		basm_print("cmp esi, eax\n");
		basm_print("jne %s\n", s0);
		break;
	case BS1_ROP_JMP_NE_IC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cmp eax, %d\n", i);
		basm_print("jne %s\n", s0);
		break;
	case BS1_ROP_JMP_NE_LC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jne %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jne %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_JMP_L_I:
	case BS1_ROP_JMP_L_P:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("cmp edx, eax\n");
		basm_print("jl %s\n", s0);
		break;
	case BS1_ROP_JMP_L_L:
		s0=BASM_GenSym();
		s1=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		basm_print("cmp edi, edx\n");
		basm_print("jg %s\n", s0);
		basm_print("jl %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("jl %s\n", s1);
		basm_print("%s:\n", s0);
		break;
	case BS1_ROP_JMP_L_IC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cmp eax, %d\n", i);
		basm_print("jl %s\n", s0);
		break;
	case BS1_ROP_JMP_L_LC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jg %s\n", s1);
		basm_print("jl %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jl %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_JMP_G_I:
	case BS1_ROP_JMP_G_P:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("cmp edx, eax\n");
		basm_print("jg %s\n", s0);
		break;
	case BS1_ROP_JMP_G_L:
		s0=BASM_GenSym();
		s1=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		basm_print("cmp edi, edx\n");
		basm_print("jl %s\n", s0);
		basm_print("jg %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("jg %s\n", s1);
		basm_print("%s:\n", s0);
		break;
	case BS1_ROP_JMP_G_IC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cmp eax, %d\n", i);
		basm_print("jg %s\n", s0);
		break;
	case BS1_ROP_JMP_G_LC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jl %s\n", s1);
		basm_print("jg %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jg %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushECX(ctx);
		break;


	case BS1_ROP_JMP_LE_I:
	case BS1_ROP_JMP_LE_P:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("cmp edx, eax\n");
		basm_print("jle %s\n", s0);
		break;
	case BS1_ROP_JMP_LE_L:
		s0=BASM_GenSym();
		s1=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		basm_print("cmp edi, edx\n");
		basm_print("jg %s\n", s0);
		basm_print("jl %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("jle %s\n", s1);
		basm_print("%s:\n", s0);
		break;
	case BS1_ROP_JMP_LE_IC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cmp eax, %d\n", i);
		basm_print("jle %s\n", s0);
		break;
	case BS1_ROP_JMP_LE_LC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jg %s\n", s1);
		basm_print("jl %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jle %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_JMP_GE_I:
	case BS1_ROP_JMP_GE_P:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PopEDX(ctx);
		basm_print("cmp edx, eax\n");
		basm_print("jge %s\n", s0);
		break;
	case BS1_ROP_JMP_GE_L:
		s0=BASM_GenSym();
		s1=BS1_RPNIL_PopJmpStr(ctx);
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PopEDSI(ctx);
		basm_print("cmp edi, edx\n");
		basm_print("jl %s\n", s0);
		basm_print("jg %s\n", s1);
		basm_print("cmp esi, eax\n");
		basm_print("jge %s\n", s1);
		basm_print("%s:\n", s0);
		break;
	case BS1_ROP_JMP_GE_IC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		basm_print("cmp eax, %d\n", i);
		basm_print("jge %s\n", s0);
		break;
	case BS1_ROP_JMP_GE_LC:
		s0=BS1_RPNIL_PopJmpStr(ctx);
		i=BS1_RPNIL_PopLitInt(ctx);
		s1=BASM_GenSym();
		BS1_RPNIL_PopEDAX(ctx);
		basm_print("cmp edx, %d\n", (i<0)?-1:1);
		basm_print("jl %s\n", s1);
		basm_print("jg %s\n", s0);
		basm_print("cmp eax, %d\n", i&0xFFFFFFFF);
		basm_print("jge %s\n", s0);
		basm_print("%s:\n", s1);
		BS1_RPNIL_PushECX(ctx);
		break;

	default:
		break;
	}

	return(0);
}


///////////////////////////////////////

int BS1_RPNIL_TransOpcode(BS1_ILContext *ctx)
{
	int op;
	int i, j, k;

	j=ctx->ip-ctx->blk->body;
	for(i=0; i<ctx->blk->nlbl; i++)
		if(ctx->blk->lblo[i]==j)
	{
		basm_print("%s:\n", ctx->blk->lbln[i]);
		break;
	}

	op=*ctx->ip++;
	if(op>=192)op=((op&0x3F)<<8)|(*ctx->ip++);
	bs1_rpnil_curop=op;

	if((op>=256) && (op<384))
		{ i=BS1_RPNIL_TransOpcode256(ctx, op); return(i); }
	if((op>=384) && (op<512))
		{ i=BS1_RPNIL_TransOpcode384(ctx, op); return(i); }
	if((op>=512) && (op<768))
		{ i=BS1_RPNIL_TransOpcode512(ctx, op); return(i); }

	if((op>=896) && (op<960))
		{ i=BS1_RPNIL_TransOpcode896(ctx, op); return(i); }

	switch(op)
	{
	case BS1_ROP_NOP:
		break;

	case BS1_ROP_MARK:
		BS1_RPNIL_PushMark(ctx);
		break;

	case BS1_ROP_CALL_I:
	case BS1_ROP_CALL_P:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("call ecx\n");
		BS1_RPNIL_PopMark(ctx);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CALL_L:
		BS1_RPNIL_PopECX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("call ecx\n");
		BS1_RPNIL_PopMark(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_CALL_IS:
	case BS1_ROP_CALL_PS:
		BS1_RPNIL_SyncStack(ctx);
		BS1_RPNIL_CallFuncAddr(ctx);
		BS1_RPNIL_PopMark(ctx);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_CALL_LS:
		BS1_RPNIL_SyncStack(ctx);
		BS1_RPNIL_CallFuncAddr(ctx);
		BS1_RPNIL_PopMark(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_RET_I:
	case BS1_ROP_RET_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		BS1_RPNIL_Return(ctx);
		break;
	case BS1_ROP_RET_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		BS1_RPNIL_Return(ctx);
		break;

	case BS1_ROP_DUP_I:
	case BS1_ROP_DUP_P:
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PushEAX2(ctx);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_DUP_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_PushEDAX2(ctx);
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_EXCH_I:
	case BS1_ROP_EXCH_P:
		BS1_RPNIL_PopEDX(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_PushEDX2(ctx);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_EXCH_L:
		BS1_RPNIL_PopEDAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("xchg edx, [esp+4]; xchg eax, [esp]\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	case BS1_ROP_PUSH_NULL:
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("xor eax, eax\n");
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_PUSH_P:
		BS1_RPNIL_LoadAddr(ctx);
		BS1_RPNIL_PushECX(ctx);
		break;

	case BS1_ROP_JMP:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("jmp %s\n", ctx->blk->lbln[i]);
		break;
	case BS1_ROP_JMP_TRUE:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("and eax, eax; jnz %s\n", ctx->blk->lbln[i]);
		break;
	case BS1_ROP_JMP_FALSE:
		i=BS1_RPNIL_PopLitInt(ctx);
		BS1_RPNIL_PopEAX(ctx);
		BS1_RPNIL_SyncStack(ctx);
		basm_print("and eax, eax; jz %s\n", ctx->blk->lbln[i]);
		break;

	case BS1_ROP_PUSH_LI:
		i=BS1_RPNIL_DecSVLI(&ctx->ip);
		BS1_RPNIL_PushLitInt(ctx, i);
		break;
	case BS1_ROP_PUSH_RS:
		i=BS1_RPNIL_DecVLI(&ctx->ip);
		BS1_RPNIL_PushSymInt(ctx, i);
		break;
	case BS1_ROP_PUSH_JI:
		i=BS1_RPNIL_DecVLI(&ctx->ip);
		BS1_RPNIL_PushLitInt(ctx, i);
		break;

	case BS1_ROP_PUSH_I:
		i=BS1_RPNIL_DecSVLI(&ctx->ip);
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("mov eax, %d\n", i);
		BS1_RPNIL_PushEAX(ctx);
		break;
	case BS1_ROP_PUSH_L:
		i=BS1_RPNIL_DecSVLI(&ctx->ip);
		BS1_RPNIL_FlushEDX(ctx);
		BS1_RPNIL_FlushEAX(ctx);
		basm_print("mov eax, %d\n", i);
		basm_print("cdq\n");
		BS1_RPNIL_PushEDAX(ctx);
		break;

	}
}

BS1_ILContext *BS1_RPNIL_AllocContext()
{
	BS1_ILContext *ctx;

	ctx=malloc(sizeof(BS1_ILContext));
	memset(ctx, 0, sizeof(BS1_ILContext));

	ctx->listack=malloc(256*sizeof(int));
	ctx->lsstack=malloc(256*sizeof(int));
	ctx->markstack=malloc(256*sizeof(int));

	return(ctx);
}

void BS1_RPNIL_FreeContext(BS1_ILContext *ctx)
{
	free(ctx->listack);
	free(ctx->lsstack);
	free(ctx->markstack);
	free(ctx);
}

void *BS1_RPNIL_TransBlock(BS1_ILBlock *blk)
{
	BS1_ILContext *ctx;
	void *p;
	byte *eip;

	ctx=BS1_RPNIL_AllocContext();

	ctx->blk=blk;
	ctx->ip=blk->body;
	eip=blk->body+blk->szbody;

	BASM_BeginAssembly(blk->name);

	basm_print("\n\n%s:\n", blk->name);

	BS1_RPNIL_Enter(ctx);
	while(ctx->ip<eip)
		BS1_RPNIL_TransOpcode(ctx);

	p=BASM_EndAssembly();

	BS1_RPNIL_FreeContext(ctx);

	return(p);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int doc, pds;

int symchar(int c)
{
	if((c>='a') && (c<='z'))return(1);
	if((c>='A') && (c<='Z'))return(1);
	if((c>='0') && (c<='9'))return(1);
	if(c=='_')return(1);
	return(0);
}

int main(int argc, char *argv[])
{
	int i, j, l;
	FILE *fd;
	char *buf, *buf2, *buf3, *buf4;
	char *s, *s2, *t;
	char *cat;

	buf=malloc(16384);
	buf2=malloc(16384);
	buf3=malloc(256);
	buf4=malloc(256);

	doc=0;
	pds=0;

	for(i=1; i<argc; i++)
	{
		if(argv[i][0]=='-')
		{
			if(!strcmp(argv[i], "-doc"))
			{
				doc=1;
				cat=argv[i+1];
				i++;
				continue;
			}
			if(!strcmp(argv[i], "-pds"))
			{
				pds=1;
				cat=argv[i+1];
				i++;
				continue;
			}
			fprintf(stderr, "Unknown option '%s'\n", argv[i]);
			exit(-1);
		}

		fd=fopen(argv[i], "rt");
		printf("//%s\n", argv[i]);
		l=0;
		while(!feof(fd))
		{
			memset(buf, 0, 256);
			fgets(buf, 255, fd);
			l++;

			s=buf;
			while(*s && (*s!='\r') && (*s!='\n'))s++;
			if(*s=='\r')*s=0;
			if(*s=='\n')*s=0;

			s=buf;
			while(*s && (*s<=' '))s++;
			if(!strncmp(s, "//AH:", 5))
			{
//				fprintf(stderr, "//AH tag %s %d\n",
//					argv[i], l);
				s+=5;
				while(*s && (*s<=' '))s++;
				if(!strcmp(s, "skip"))break;
			}

			if(pds)if(!strncmp(s, "//PDSCAT:", 9))
			{
				s+=9;
				t=buf3;
				while(*s)*t++=*s++;
				*t++=0;

				cat=strdup(buf3);
			}

			if(pds)if(!strncmp(s, "//PDS:", 6))
			{
				s+=6;
				while(*s && (*s<=' '))s++;

				t=buf3;
				while(*s && strncmp(s, "::", 2))
				{
					if((s[0]=='\\') && (s[1]<=' '))
					{
						fgets(buf, 255, fd);
						s=buf;
						while(*s && (*s<=' '))s++;
						if(!strncmp(s, "//", 2))s+=2;
						continue;
					}
					if(*s=='\r')break;
					if(*s=='\n')break;
					*t++=*s++;
				}
				*t++=0;

				if(!strncmp(s, "::", 2))s+=2;

				t=buf4;
				while(*s)
				{
					if((s[0]=='\\') && (s[1]<=' '))
					{
						fgets(buf, 255, fd);
						s=buf;
						while(*s && (*s<=' '))s++;
						if(!strncmp(s, "//", 2))s+=2;
						continue;
					}
					if(*s=='\r')break;
					if(*s=='\n')break;
					*t++=*s++;
				}
				*t++=0;

				printf(
					"/*--\n"
					"Cat %s\n"
					"Text\n"
					"\t%s\n"
					"\t%s\n"
					"--*/\n",
					cat, buf3, buf4);
			}

			if(pds)continue;


			s=buf;
			if(*s<=' ')continue;
			while(symchar(*s))s++;
			while(*s && (*s<=' '))s++;
			if(!*s || (*s=='('))continue;
			while(*s=='*')s++;
			while(*s && symchar(*s))s++;
			if(*s!='(')continue;

			t=s;
			while(*s && (*s!='/'))s++;
			if(!strncmp(s, "//AH:", 5))
			{
//				fprintf(stderr, "//AH tag %s %d\n",
//					argv[i], l);
				s+=5;
				while(*s && (*s<=' '))s++;
				if(!strcmp(s, "ignore"))continue;
			}
			s=t;

			if(*s=='(')s++;
			j=1;
			while(j)
			{
				if(!*s)
				{
					memset(buf2, 0, 256);
					fgets(buf2, 255, fd);
					l++;

					t=buf2;
					while(*t && (*t<=' '))t++;

					s2=t;
					t=s;
					while(*s2 && (*s2!='\n'))*t++=*s2++;
					*t++=' ';
					*t++=0;
				}else
				{
					if(*s=='(')j++;
					if(*s==')')j--;
					s++;
				}
			}
			t=s;
			while(*s && (*s!='/'))s++;
			if(!strncmp(s, "//AH:", 5))
			{
				fprintf(stderr, "//AH tag %s %d\n",
					argv[i], l);
				s+=5;
				while(*s && (*s<=' '))s++;
				if(!strncmp(s, "ignore", 6))continue;
			}
			s=t;

			if(*s==')')s++;
			*s=0;

			if(doc)
			{
				printf(
					"/*--\n"
					"Cat %s\n"
					"Text\n"
					"\t%s;\n"
					"\t%s:%d\n"
					"--*/\n",
					cat, buf, argv[i], l);
			}else printf("%s;\n", buf);
		}
		fclose(fd);
	}
	return(0);
}
#include <stdio.h>

//unsigned char buf[1024];

int func()
{
	return(0);
}

int main()
{
//	unsigned char buf[1024];
	unsigned char *buf;

	void (*fp)();
	int *p;

	p=&func;
//	*p=-1;

	buf=malloc(64);
	buf[0]=0xC3;

	fp=buf;
	fp();

	printf("OK\n");
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <readline/readline.h>
#include <readline/history.h>

#include <time.h>

#include <bgbscr1.h>

extern int bs1_svm_opcnt;

elem BS1_LoadScriptObj(char *name, elem obj)
{
	char tb[256];
	FILE *fd;
	elem t;
	char *s, *buf;
	byte buf1[4096], *ip;
	int sz;

	BS1_SVM_Init();

	fd=fopen(name, "rb");
	if(!fd)return(BS1_MM_NULL);
	fseek(fd, 0, 2);
	sz=ftell(fd);

	buf=malloc(sz);
	fseek(fd, 0, 0);
	fread(buf, 1, sz, fd);
	fclose(fd);

#if 1
	BS1_Parse_SetLinenum("<eval-str>", buf, 1);
	s=buf;
	t=BS1_Parse_Block(&s);
	ip=BS1_DSOP_FlattenBuffer(buf1, t);

	sprintf(tb, "%s.dso", name);
	fd=fopen(tb, "wb");
	fwrite(buf1, 1, ip-buf1, fd);
	fclose(fd);
#endif

	t=BS1_SVM_EvalStringObj(buf, obj);
	free(buf);

	return(t);
}

int main(int argc, char *argv[])
{
	char buf[256];
	char *s;
	elem a, t;
	int i, it, dt;
	float dtf;

	BS1_TY_Init();
	BS1_SVM_Init();

	for(i=1; i<argc; i++)
		BS1_LoadScriptObj(argv[i], BS1_MM_NULL);

//	a=BS1_TY_Cons(BS1_TY_HashSymbol("a"),
//		BS1_TY_Cons(BS1_TY_Float(-3.225), BS1_TY_HashSymbol("c")));
//	a=BS1_ParseS_FromString("(foo (bar baz:) (alpha beta gamma delta) 3 4.0 \"yo\" : dude)");

//	BS1_TY_PrintTC(a);
//	printf("\n");

//	BS1_SVM_EvalString("(print \"tst \" (* (+ 2 3) 5) 'foo 'bar \" baz\n\")");

	BS1_GC_PrintStats();

	while(1)
	{
//		memset(buf, 0, 256);
//		fgets(buf, 255, stdin);
		s=readline("> ");

		while(*s && (*s<=' '))s++;
		if(!*s)continue;

		add_history(s);
		strcpy(buf, s);
		strcat(buf, ";;");
		free(s);

		BS1_Parse_SetLinenum("<repl>", buf, 1);

		it=clock();
		bs1_svm_opcnt=0;

		t=BS1_SVM_EvalString(buf);

//		s=buf;
//		t=BS1_Parse_BlockStatement2(&s);

		BS1_TY_PrintLN(t);

		dt=clock()-it;
		if(dt)
		{
			dtf=(dt*1000.0)/CLOCKS_PER_SEC;
			printf("eval took %gms, %g MIPS\n",
				dtf, bs1_svm_opcnt/(dtf*1000.0));
		}

		if(t==KEYSYM("quit"))
			break;

		BS1_GC_CheckRef(t);
		BS1_GC_PrintStats();
	}

//	printf("VM End\n");

	return(0);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
	int total, file, i;
	FILE *fd, *lfd;
	char buf[1024], lfb[256];
	char *s;

	if(argc<2)
	{
		fd=stdin;

		file=0;
		while(fgets(buf, 1023, fd))file++;
		printf("%d\n", file);

		return(0);
	}

	if(!strcmp(argv[1], "-l"))
	{
		lfd=NULL;
		if(!strcmp(argv[2], "-"))
			lfd=stdin;
		if(!lfd)lfd=fopen(argv[2], "rt");
		if(!lfd)
		{
			printf("%s: can't open list %s\n", argv[0], argv[2]);
			return(-1);
		}


		total=0;
		while(!feof(lfd))
		{
			memset(lfb, 0, 256);
			fgets(lfb, 255, lfd);

			s=lfb;
			while(*s)
			{
				if(*s>' ')break;
				s++;
			}
			if(!*s)continue;

			while(*s>' ')s++;
			*s=0;

//			printf("%s\n", lfb);

			file=0;
			fd=fopen(lfb, "rt");
			if(!fd)continue;

			while(fgets(buf, 1023, fd))file++;
			fclose(fd);
//			printf("%s %d\n", lfb, file);
			total+=file;
		}
		printf("total %d\n", total);

		return(0);
	}

	total=0;
	for(i=1; i<argc; i++)
	{
		file=0;
		fd=fopen(argv[i], "rt");
		if(!fd)continue;
		while(fgets(buf, 1023, fd))file++;
		fclose(fd);
		printf("%s %d\n", argv[i], file);
		total+=file;
	}
	printf("total %d\n", total);

	return(0);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

char *tstr="test string %d\n";
void (*fptr)(int x, int y);

int main(int argc, char *argv[])
{
	static byte buf[1024];
	ASM_Context *ctx;
	FILE *fd;
	int i;

	BS1_TY_Init();
	BS1_SVM_Init();

	ctx=ASM_NewContext();
	ctx->ip=buf;

	ASM_EmitLabel(ctx, "foo");

#if 0
//	ASM_OutOpRegReg(ctx, ASM_OP_MOV, ASM_EAX, ASM_EDX);
//	ASM_OutOpRegMem(ctx, ASM_OP_ADD, ASM_EAX, ASM_ESP, -16);
//	ASM_OutOpRegMem(ctx, ASM_OP_ADD, ASM_ECX, ASM_EBP, 0);

	ASM_OutOpRegMem(ctx, ASM_OP_MOV, ASM_EAX, ASM_ESP, 4);
	ASM_OutOpRegMem(ctx, ASM_OP_ADD, ASM_EAX, ASM_ESP, 8);
	ASM_OutOpReg(ctx, ASM_OP_PUSH, ASM_EAX);

	ASM_OutOpImm(ctx, ASM_OP_PUSH, (int)(tstr));

	ASM_OutOpRegImm(ctx, ASM_OP_MOV, ASM_EAX, (int)(&printf));
	ASM_OutOpReg(ctx, ASM_OP_CALL, ASM_EAX);

	ASM_OutOpReg(ctx, ASM_OP_POP, ASM_EAX);
	ASM_OutOpReg(ctx, ASM_OP_POP, ASM_EAX);

	ASM_OutOpSingle(ctx, ASM_OP_RET);

	ASM_EmitJmpLabel(ctx, "foo");

	ASM_EmitLabelPtr(ctx, "printf", &printf);

	ASM_ParseOpcodeList(ctx,
		"nop; nop; call bar; mov eax, [esp+4]; add eax, [esp+8]; "
		"push eax; mov ecx, [esp+eax*2-16]; mov ax, 0x2718; "
		"mov eax, 0xdecaf; call printf; pop eax; jcxz_b foo; bar: ret");
#endif

	ASM_EmitLabelPtr(ctx, "printf", &printf);
	ASM_EmitLabelPtr(ctx, "tstr", tstr);

#if 0
	ASM_ParseOpcodeList(ctx,
		"A16 "
		"call_w bar; mov ax, [bp+4]; add ax, [bp+6]; "
		"push ax; call_w printf; pop ax; pop ax; bar: ret; "
		"db 'foo bar baz', 13, 10");
#endif

	ASM_ParseOpcodeList(ctx,
		"nop; nop; call bar; mov eax, [esp+4]; add eax, [esp+8]; "
		"push eax; push tstr; call printf; pop eax; pop eax; "
		"bar: ret; ");

	fd=fopen("out.bin", "wb");
	i=ctx->ip-buf;
	fwrite(buf, 1, i, fd);
	fclose(fd);

	DisAsm_PrintOpcodes(buf, 0, i);

	fptr=(void (*)(int, int))buf;
	fptr(3, 4);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <time.h>

float vec_dot1(const float* a, const float* b, int len)
{
    float f;
    int i;
    f=0;
    for(i=0; i<len; i++)f+=a[i]*b[i];
    return(f);
}

float vec_dot2(const float* a, const float* b, int len)
{
    float f;
    f=0;
    while(len--)f+=a[len]*b[len];
    return(f);
}

int main()
{
	float v0[64], v1[64];
	int i, j;

	i=clock();

	for(i=0; j<10000000; j++)
		vec_dot1(v0, v1, 64);

	i=clock()-i;
	printf("%f\n", i/(float)CLOCKS_PER_SEC);


	i=clock();

	for(i=0; j<10000000; j++)
		vec_dot2(v0, v1, 64);

	i=clock()-i;
	printf("%f\n", i/(float)CLOCKS_PER_SEC);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <readline/readline.h>
#include <readline/history.h>

#include <time.h>

#include <bgbscr1.h>

extern int bs1_svm_opcnt;

elem BS1_LoadScriptObj(char *name, elem obj)
{
	char tb[256];
	FILE *fd;
	elem t;
	char *s, *buf;
	byte buf1[4096], *ip;
	int sz;

	BS1_SVM_Init();

	fd=fopen(name, "rb");
	if(!fd)return(BS1_MM_NULL);
	fseek(fd, 0, 2);
	sz=ftell(fd);

	buf=malloc(sz+1);
	fseek(fd, 0, 0);
	fread(buf, 1, sz, fd);
	fclose(fd);
	buf[sz]=0;

	BS1_RPNIL_ProcessBuffer(buf);
	t=BS1_MM_NULL;

//	BS1_CParse_SetLinenum("<eval-str>", buf, 1);
//	s=buf;
//	t=BS1_CParse_Block(&s);

//	BS1_TY_PrintLN(t);
//	BS1_S_PrintFmt(t);

//	t=BS1_SVM_EvalStringObj(buf, obj);
	free(buf);

	return(t);
}

int main(int argc, char *argv[])
{
	char buf[256];
	char *s;
	elem a, t;
	int i, it, dt;
	float dtf;

	BS1_TY_Init();
	BS1_SVM_Init();

	for(i=1; i<argc; i++)
		BS1_LoadScriptObj(argv[i], BS1_MM_NULL);

	while(1)
	{
		s=readline("> ");

		while(*s && (*s<=' '))s++;
		if(!*s)continue;

		add_history(s);
		strcpy(buf, s);
		strcat(buf, ";;");
		free(s);

		BS1_CParse_SetLinenum("<repl>", buf, 1);

		s=buf;
		t=BS1_CParse_BlockStatement2(&s);

		BS1_TY_PrintLN(t);

		if(t==KEYSYM("quit"))
			break;

		BS1_GC_CheckRef(t);
	}

	return(0);
}

/*

Struct/Union/...
(struct <name> <body>)
(union <name> <body>)

(proto <type> <def> (<def*>))

Types
(<typename> <flags> <ind>)
(<struct> <flags> <ind>)
(<union> <flags> <ind>)
...

Def Basic
(<varname> <ind> <size*>)
(<def> <ind> <size*>)

Def Expanded
(<varname> <typename|struct> <flags> <ind> <size*>)
(<def> <typename|struct> <flags> <ind> <size*>)

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>


elem bs1_cparse_structs=BS1_MM_NULL;
elem bs1_cparse_types=BS1_MM_NULL;

elem BS1_CParse_LookupStruct(char *name)
{
	elem c, t, sy;

	sy=SYM(name);

	c=bs1_cparse_structs;
	while(c!=BS1_MM_NULL)
	{
		t=CAR(c);
		if(CADR(t)==sy)
		{
			printf("BS1_CParse_LookupStruct: found %s\n", name);
			BS1_TY_PrintLN(t);
			return(t);
		}
		c=CDR(c);
	}
	printf("BS1_CParse_LookupStruct: fail find %s\n", name);
	return(BS1_MM_NULL);
}

elem BS1_CParse_LookupType(char *name)
{
	elem c, t, sy;

	sy=SYM(name);

	c=bs1_cparse_types;
	while(c!=BS1_MM_NULL)
	{
		t=CAR(c);
		if(CAR(t)==sy)
		{
			printf("BS1_CParse_LookupType: found %s\n", name);
			BS1_TY_PrintLN(t);
			return(t);
		}
		c=CDR(c);
	}
	printf("BS1_CParse_LookupType: fail find %s\n", name);
	return(BS1_MM_NULL);
}


int BS1_CParse_HandleTypedef(elem n)
{
	elem c, t;

	if(FORM_IS(n, "vars"))
	{
		c=CDR(n);
		while(BS1_CONSP(c))
		{
			bs1_cparse_types=CONS(CAR(c), bs1_cparse_types);
			c=CDR(c);
		}
		return(0);
	}
}


elem BS1_CParse_DefType(char **str)
{
	char b[256], b2[256];
	char *s, *s1, *bty;
	int i, j, ty, ty2, fl;
	elem n, n1;

	s=*str;

	bty=NULL;

	BS1_CParse_Token(s, b, &ty);
	fl=0; j=0;
	while(1)
	{
		i=0;
		if(!strcmp(b, "unsigned"))i=BS1_TYPEFL_UNSIGNED;
		if(!strcmp(b, "extern"))i=BS1_TYPEFL_EXTERN;
		if(!strcmp(b, "const"))i=BS1_TYPEFL_CONST;
		if(!strcmp(b, "static"))i=BS1_TYPEFL_STATIC;
		if(!strcmp(b, "volatile"))i=BS1_TYPEFL_VOLATILE;

		if(!strcmp(b, "final"))i=BS1_TYPEFL_CONST;
		if(!strcmp(b, "native"))i=BS1_TYPEFL_NATIVE;
		if(!strcmp(b, "public"))i=BS1_TYPEFL_PUBLIC;
		if(!strcmp(b, "private"))i=BS1_TYPEFL_PRIVATE;
		if(!strcmp(b, "protected"))i=BS1_TYPEFL_PROTECTED;
		if(!strcmp(b, "virtual"))i=BS1_TYPEFL_VIRTUAL;

		if(i)
		{
			fl|=i;
			s=BS1_CParse_Token(s, b, &ty);
			BS1_CParse_Token(s, b, &ty);
			j++;
			continue;
		}

		if(!strcmp(b, "char") || !strcmp(b, "short") ||
			!strcmp(b, "int") || !strcmp(b, "long") ||
			!strcmp(b, "float") || !strcmp(b, "double") ||
			!strcmp(b, "void"))
		{
			s=BS1_CParse_Token(s, b, &ty);

			if(!strcmp(b, "int"))
			{
				BS1_CParse_Token(s, b, &ty);
				j++;
				continue;	//short int, ...
			}
			bty=BS1_RStrDup(b);

			BS1_CParse_Token(s, b, &ty);
			j++;
			continue;
		}

		break;
	}

#if 0
	if(!strcmp(b, "char") || !strcmp(b, "short") ||
		!strcmp(b, "int") || !strcmp(b, "long") ||
		!strcmp(b, "float") || !strcmp(b, "double") ||
		!strcmp(b, "void"))
	{
		s=BS1_CParse_Token(s, b, &ty);
		n=LIST3(KEYSYM(b), FIXNUM(fl), FIXNUM(0));

		*str=s;
		return(n);
	}
#endif

	if(!strcmp(b, "struct") || !strcmp(b, "union"))
	{
		j=!strcmp(b, "struct");

		s=BS1_CParse_Token(s, b, &ty);	//struct
		s1=BS1_CParse_Token(s, b, &ty);	//name, '{', ...
		BS1_CParse_Token(s1, b2, &ty2);	//name, '{', ...

		if(ty==BS1_TOKEN_NAME)
		{
			s=BS1_CParse_Token(s, b, &ty);	//name
			n=BS1_CParse_LookupStruct(b);

			BS1_CParse_Token(s, b2, &ty2);	//'{', ...
			if(!strcmp(b2, "{"))
			{
				s=BS1_CParse_Token(s, b2, &ty2); //'{'
				n1=BS1_CParse_Block(&s);

				if(n!=BS1_MM_NULL)
				{
					BS1_TY_SetCar(CDDR(n), n1);
				}else
				{
					n=LIST3S(j?"struct":"union",
						SYM(b), n1);
					bs1_cparse_structs=CONS(n,
						bs1_cparse_structs);
				}
			}else if(n==BS1_MM_NULL)
			{
				n=LIST3S(j?"struct":"union",
					SYM(b), BS1_MM_NULL);
				bs1_cparse_structs=CONS(n,
					bs1_cparse_structs);
			}
		}else if(!strcmp(b, "{"))
		{
			s=BS1_CParse_Token(s, b, &ty); //'{'
			n1=BS1_CParse_Block(&s);
			n=LIST3S(j?"struct":"union", BS1_MM_NULL, n1);
		}

		n=LIST3(n, FIXNUM(fl), FIXNUM(0));

		*str=s;
		return(n);
	}

	n=BS1_CParse_LookupType(b);
	if(n!=BS1_MM_NULL)
	{
		s=BS1_CParse_Token(s, b, &ty);

//		n=LIST3(CAR(n), FIXNUM(fl), FIXNUM(0));
//		n=LIST3(n, FIXNUM(fl), FIXNUM(0));
		n=CDR(n);

		*str=s;
		return(n);
	}

	if(j)
	{
		if(!bty)bty="int";

//		s=BS1_CParse_Token(s, b, &ty);
		n=LIST3(KEYSYM(bty), FIXNUM(fl), FIXNUM(0));
		*str=s;
		return(n);
	}

	return(BS1_MM_NULL);
}

elem BS1_CParse_DefName(char **str)
{
	char b[256];
	char *s;
	int i, ty, fl, ind;
	elem n, n1;

	s=*str;

	BS1_CParse_Token(s, b, &ty);

	if(!strcmp(b, ";") || !strcmp(b, ","))
		return(BS1_MM_NULL);

	ind=0;
	while(1)
	{
		if(!strcmp(b, "*"))
		{
			s=BS1_CParse_Token(s, b, &ty);
			BS1_CParse_Token(s, b, &ty);
			ind++;
			continue;
		}
		break;
	}

	if(!strcmp(b, "("))
	{
		s=BS1_CParse_Token(s, b, &ty);	//(
		n1=BS1_CParse_DefName(&s);
		s=BS1_CParse_Token(s, b, &ty);	//)
		n=LIST2(n1, FIXNUM(fl));
	}else
	{
		if(ty!=BS1_TOKEN_NAME)
		{
			BS1_MSG_Error(s, "BS1_CParse_DefName: "
				"Invalid Token '%s'\n", b);
			*(int *)(-1)=-1;
		}

		s=BS1_CParse_Token(s, b, &ty);
//		n=LIST2(KEYSYM(b), FIXNUM(ind));
		n=LIST2(SYM(b), FIXNUM(ind));
	}

	BS1_CParse_Token(s, b, &ty);
	while(1)
	{
		if(!strcmp(b, "["))
		{
			s=BS1_CParse_Token(s, b, &ty);
			BS1_CParse_Token(s, b, &ty);
			if(!strcmp(b, "]"))
			{
				s=BS1_CParse_Token(s, b, &ty);
				ind++;
				continue;
			}

			n1=BS1_CParse_Expression(&s);
			s=BS1_CParse_Token(s, b, &ty);

			n=BS1_TY_NAppend(n, CONS(n1, BS1_MM_NULL));

			BS1_CParse_Token(s, b, &ty);
			continue;
		}
		break;
	}

	BS1_TY_SetCar(CDR(n), FIXNUM(ind));

	*str=s;
	return(n);
}

elem BS1_CParse_ExpandDefinition(elem tn, elem dn)
{
	elem n;
	int i;

	i=TOINT(CADDR(tn))+TOINT(CADR(dn));
	n=LIST4(CAR(dn), CAR(tn), CADR(tn), FIXNUM(i));
	n=BS1_TY_NAppend(n, CDDR(dn));
	n=BS1_TY_NAppend(n, CDDDR(tn));

	return(n);
}


elem BS1_CParse_Definition(char **str)
{
	char b[256], b2[256];
	char *s, *s2;
	int ty, ty2;
	elem n, n1, n2, n3, n4;

	s=*str;

	n=BS1_CParse_DefType(&s);
	if(n!=BS1_MM_NULL)
	{
		s2=s;
		n1=BS1_CParse_DefName(&s2);
		BS1_CParse_Token(s2, b, &ty);

		if(!n1)
		{
			*str=s;
			return(BS1_MM_NULL);
		}

		//typed function definition
		if(!strcmp(b, "("))
		{
			s=s2;

			n=BS1_CParse_ExpandDefinition(n, n1);

			s=BS1_CParse_Token(s, b, &ty);	//(
			n1=BS1_CParse_FunVarsList(&s);

			BS1_CParse_Token(s, b, &ty);
			if(!strcmp(b, ";"))
			{
				n=LIST3S("proto", n, n1);
				*str=s;
				return(n);
			}

			n2=BS1_CParse_BlockStatement2(&s);
			n=LIST4S("defun", n, n1, n2);
			*str=s;
			return(n);
		}

		n1=BS1_CParse_VarsList(&s, n);
//		n=CONS2S("vars", n, n1);
		n=CONS(SYM("vars"), n1);

		*str=s;
		return(n);
	}

	return(BS1_MM_NULL);
}


elem BS1_CParse_FunArgs(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		b[0]=0;
		BS1_CParse_Token(s, b, &ty);
		if(!*b)break;
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_CParse_Token(s, b, &ty);
			break;
		}

		n=BS1_CParse_Expression3(&s);
		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		BS1_CParse_Token(s, b, &ty);
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_CParse_Token(s, b, &ty);
			break;
		}

		if(strcmp(b, ","))
		{
			BS1_MSG_Error(s, "BS1_CParse_FunArgs: "
				"Invalid Token '%s'\n", b);
			*(int *)(-1)=-1;
		}

		s=BS1_CParse_Token(s, b, &ty);	//','
	}

	*str=s;
	return(lst);
}

elem BS1_CParse_VarsList(char **str, elem tn)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);
		if(!strcmp(b, ";"))
		{
			s=BS1_CParse_Token(s, b, &ty);
			break;
		}

		n=BS1_CParse_DefName(&s);
		n=BS1_CParse_ExpandDefinition(tn, n);

		BS1_CParse_Token(s, b, &ty);
		if(!strcmp(b, "="))
		{
			s=BS1_CParse_Token(s, b, &ty);
			n1=BS1_CParse_Expression(&s);

			n=CONS(n, CONS(n1, BS1_MM_NULL));

			BS1_CParse_Token(s, b, &ty);
		}

		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		s=BS1_CParse_Token(s, b, &ty);
		if(!strcmp(b, ";"))break;

		if(strcmp(b, ","))
		{
			BS1_MSG_Error(s, "PDSCR_CParse_VarsList: Invalid token %s "
				"in vars list\n", b);
			*str=NULL;
			return(BS1_MM_NULL);
		}
	}

	*str=s;
	return(lst);
}

elem BS1_CParse_FunVarsList(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, n2, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);
		if(!strcmp(b, ")"))
		{
			s=BS1_CParse_Token(s, b, &ty);
			break;
		}

		n1=BS1_CParse_DefType(&s);
		n2=BS1_CParse_DefName(&s);

//		n=LIST2(n1, n2);
		n=BS1_CParse_ExpandDefinition(n1, n2);

		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		BS1_CParse_Token(s, b, &ty);

		if(!strcmp(b, ")"))
		{
			s=BS1_CParse_Token(s, b, &ty);
			break;
		}

		if(strcmp(b, ","))
		{
			BS1_MSG_Error(s, "PDSCR_CParse_FunVarsList: "
				"Invalid token %s "
				"in vars list\n", b);
			*str=NULL;
			return(BS1_MM_NULL);
		}
		s=BS1_CParse_Token(s, b, &ty);
	}

	*str=s;
	return(lst);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

//Lit:		Literal values/builtin expressions
//PE:		(<expr>) <expr>[<expr>] <expr>.<name>
//IncDec:	++<name> --<name> + - ! ~ ... <name>++ <name>-- <expr>(<args>)       
//E:		<expr>**<expr>
//MD:		* / % \ &	*. /. %. \. &.
//AS:		+ - | ^		+. -. |. ^.
//SHLR:		<< >>
//RCmp:		< > <= >= == === != <=> <<== >>==
//Lop:		&&
//Lop2:		|| ^^
//TCond:	<expr>?<expr>:<expr>
//Attr:		:= :!= :< :> :<= :>= :<< :>> :<<= :>>=
//Equals:	= += -= *= /= \= %= &= |= ^= >>= <<=

elem BS1_CParse_Expression(char **str);

BS1_ParseItem *bs1_cparse_exprs=NULL;

int BS1_CParse_AddExpression(char *name, elem (*func)(char **s))
{
	BS1_ParseItem *tmp;

	tmp=malloc(sizeof(BS1_ParseItem));
	tmp->name=strdup(name);
	tmp->func=func;

	tmp->next=bs1_cparse_exprs;
	bs1_cparse_exprs=tmp;

	return(0);
}

elem BS1_CParse_ParseExpressionName(char *name, char **s)
{
	BS1_ParseItem *cur;

	cur=bs1_cparse_exprs;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}
	return(BS1_MM_NULL);
}

elem BS1_CParse_Number(char *str)
{
	long long l;
	char *s, *t;
	elem n;
	int i, sg;

	t=str;
	if((t[0]=='0') && (t[1]=='x'))
	{
		l=0; t+=2;
		while(*t)
		{
			l*=16;
			if((*t>='0') && (*t<='9'))l+=*t-'0';
			if((*t>='A') && (*t<='F'))l+=*t-'A'+10;
			if((*t>='a') && (*t<='f'))l+=*t-'a'+10;
			t++;
		}

		return(BS1_INT(l));
	}

	if(t[0]=='0')
	{
		l=0; t++;
		while(*t)
		{
			l*=8;
			if((*t>='0') && (*t<='7'))l+=*t-'0';
				else break;
			t++;
		}

		return(BS1_INT(l));
	}

	i=0; t=str;
	while(*t) { if(*t=='.')i++; if(*t=='e')i++; t++; }
	if(i)
	{
		n=FLONUM(atof(str));
		return(n);
	}

	t=str; l=0; sg=0;
	if(*t=='-') { sg=1; t++; }
	while(*t)
	{
		l*=10;
		if((*t>='0') && (*t<='9'))l+=*t-'0';
			else break;
		t++;
	}
	if(sg)l=-l;

	return(BS1_INT(l));
}

elem BS1_CParse_ExpressionLit(char **str)
{
	char b[256], b2[256];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2;
	int i;

	s=*str;

	BS1_CParse_Token(s, b, &ty);

	s=*str;

	s=BS1_CParse_Token(s, b, &ty);
	if(!s)return(BS1_MM_NULL);

	if(!strcmp(b, "{") && (ty==BS1_TOKEN_BRACE))
	{
		n1=BS1_CParse_FunArgs(&s);
		n=CONSS("list", n1);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_NAME)
	{
		n=BS1_CParse_ParseExpressionName(b, &s);
		if(n)
		{
			*str=s;
			return(n);
		}

		n=SYM(b);
		*str=s;
		return(n);
	}

	BS1_CParse_Token(s, b2, &ty2);

	if(ty==BS1_TOKEN_NUMBER)
	{
		if((b[0]=='0') && (b[1]=='x'))
		{
			i=0; t=b+2;
			while(*t)
			{
				i*=16;
				if((*t>='0') && (*t<='9'))i+=*t-'0';
				if((*t>='A') && (*t<='F'))i+=*t-'A'+10;
				if((*t>='a') && (*t<='f'))i+=*t-'a'+10;
				t++;
			}

			*str=s;
			return(FIXNUM(i));
		}

		BS1_CParse_Token(s, b2, &ty2);
		if(!strcmp(b2, "i") && (ty2==BS1_TOKEN_NAME))
		{
			s=BS1_CParse_Token(s, b2, &ty2);
			if(!strcmp(b2, "i"))n=COMPLEX_I(atof(b));

			*str=s;
			return(n);

		}

		n=BS1_CParse_Number(b);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_STRING)
	{
		BS1_CParse_Token(s, b2, &ty2);
		while(ty2==BS1_TOKEN_STRING)
		{
			s=BS1_CParse_Token(s, b2, &ty2);
			strcat(b, b2);
			BS1_CParse_Token(s, b2, &ty2);
		}

		n=STRING(b);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_CHARSTRING)
	{
		BS1_CParse_Token(s, b2, &ty2);
		while(ty2==BS1_TOKEN_CHARSTRING)
		{
			s=BS1_CParse_Token(s, b2, &ty2);
			strcat(b, b2);
			BS1_CParse_Token(s, b2, &ty2);
		}

		n=BS1_CHAR(b[0]);

		*str=s;
		return(n);
	}

	BS1_MSG_Error(s, "PDSCR_CParse_ExpressionLit: "
		"Invalid Item '%s'\n", b);
	*(int *)(-1)=-1;

	*str=NULL;
	return(BS1_MM_NULL);
}

elem BS1_CParse_ExpressionPE(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;
	int i;

	s=*str;
	BS1_CParse_Token(s, b, &ty);
	if(!strcmp(b, "(") && (ty==BS1_TOKEN_BRACE))
	{
		s=BS1_CParse_Token(s, b, &ty);	//(
//		n=BS1_CParse_Expression(&s);
//		s=BS1_CParse_Token(s, b, &ty);

		n=BS1_CParse_FunArgs(&s);
		if(CDR(n))n=CONS(SYM("begin"), n);

		*str=s;
		return(n);
	}

	n=BS1_CParse_ExpressionLit(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		if(!BS1_CParse_IsWhiteOnly(s))break;
		BS1_CParse_Token(s, b, &ty);

		if(!strcmp(b, "["))
		{
			s=BS1_CParse_Token(s, b, &ty); //[
			n1=BS1_CParse_Expression(&s);
			s=BS1_CParse_Token(s, b, &ty); //]
			n=LIST3S("getindex", n, n1);
			continue;
		}

		if(!strcmp(b, "."))
		{
			s=BS1_CParse_Token(s, b, &ty); //.
			s=BS1_CParse_Token(s, b, &ty); //name
			n=LIST3S("objref", n, SYM(b));
			continue;
		}

		if(!strcmp(b, "->"))
		{
			s=BS1_CParse_Token(s, b, &ty); //.
			s=BS1_CParse_Token(s, b, &ty); //name
			n=LIST3S("objref", n, SYM(b));
			continue;
		}

		break;
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionCast(char **str)
{
	char b[64], b2[64];
	char *s, *t, *s1;
	int ty, ty2;

	elem n, n1;

	s=*str;
	s1=BS1_CParse_Token(s, b, &ty);
	if(!strcmp(b, "("))
	{
		n=BS1_CParse_DefType(&s1);
		if(n1!=BS1_MM_NULL)
		{
			s=s1;
			s=BS1_CParse_Token(s, b, &ty);

			n1=BS1_CParse_ExpressionPE(&s);

			n=LIST3S("cast", n, n1);
			*str=s;
			return(n);
		}
	}

	n=BS1_CParse_ExpressionPE(str);

//	if(n1!=BS1_MM_NULL)
//		n=LIST2(n1, n);
	return(n);
}

elem BS1_CParse_ExpressionIncDec(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	BS1_CParse_Token(s, b, &ty);
	if(!strcmp(b, "++") && (ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionIncDec(&s);
		n=LIST2S("preinc!", n1);
		*str=s;
		return(n);
	}
	if(!strcmp(b, "--") && (ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionIncDec(&s);
		n=LIST2S("predec!", n1);
		*str=s;
		return(n);
	}

	if((!strcmp(b, "+") || !strcmp(b, "-") || !strcmp(b, "!") ||
		!strcmp(b, "~") || !strcmp(b, "&") || !strcmp(b, "*")) &&
			(ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionIncDec(&s);
		n=LIST3S("unary", SYM(b), n1);
		*str=s;
		return(n);
	}

	s=*str;
	n=BS1_CParse_ExpressionCast(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);
		if(!strcmp(b, "(") && (ty==BS1_TOKEN_BRACE))
		{
			if(FORM_IS(n, "objref"))
			{
				s=BS1_CParse_Token(s, b, &ty); //'('
				n1=BS1_CParse_FunArgs(&s);
				n=CONS3(SYM("methodcall"),
					CADR(n), CADDR(n), n1);
				continue;
			}

			s=BS1_CParse_Token(s, b, &ty); //'('
			n1=BS1_CParse_FunArgs(&s);
			if(!s)
			{
				*str=s;
				return(n);
			}

			n=CONS2(SYM("funcall"), n, n1);
			continue;
		}

		if(!strcmp(b, "++"))
		{
			s=BS1_CParse_Token(s, b, &ty);
			n=LIST2S("postinc!", n);
			continue;
		}
		if(!strcmp(b, "--"))
		{
			s=BS1_CParse_Token(s, b, &ty);
			n=LIST2S("postdec!", n);
			continue;
		}

		break;
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionMD(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionIncDec(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_CParse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;

		if(strcmp(b, "*") && strcmp(b, "/") && strcmp(b, "%") &&
			strcmp(b, "&"))
			break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionIncDec(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionAS(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionMD(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_CParse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;

		if(strcmp(b, "+") && strcmp(b, "-") &&
			strcmp(b, "|") && strcmp(b, "^"))
			break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionMD(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionSHLR(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionAS(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_CParse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;
		if(strcmp(b, "<<") && strcmp(b, ">>"))
			break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionAS(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionRCmp(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionSHLR(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, "<") && strcmp(b, ">") &&
			strcmp(b, "<=") && strcmp(b, ">=") &&
			strcmp(b, "==") && strcmp(b, "!="))
			break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionSHLR(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionLop(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionRCmp(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, "&&"))
			break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionRCmp(&s);

		if(FORM_IS(n, "and"))
		{
			n=BS1_TY_NAppend(n, LIST1(n1));
			continue;
		}

		n=LIST3S("and", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionLop2(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionLop(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, "||"))
			break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionLop(&s);

		if(FORM_IS(n, "or"))
		{
			n=BS1_TY_NAppend(n, LIST1(n1));
			continue;
		}

		n=LIST3S("or", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionTCond(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n1=BS1_CParse_ExpressionLop2(&s);
	BS1_CParse_Token(s, b, &ty);
	if(strcmp(b, "?"))
	{
		*str=s;
		return(n1);
	}

	s=BS1_CParse_Token(s, b, &ty); //?
	n2=BS1_CParse_ExpressionLop2(&s);
	s=BS1_CParse_Token(s, b, &ty); //:
	n3=BS1_CParse_ExpressionTCond(&s);
	n=LIST4S("if", n1, n2, n3);

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionEquals(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionTCond(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;

		if(strcmp(b, "=") && strcmp(b, "+=") && strcmp(b, "-=") &&
		strcmp(b, "*=") && strcmp(b, "/=")  && strcmp(b, "%=")  &&
		strcmp(b, "&=") && strcmp(b, "|=") &&
		strcmp(b, "^=") && strcmp(b, "<<=") && strcmp(b, ">>="))
			break;

		t=NULL;
		if(!strcmp(b, "+="))t="+";
		if(!strcmp(b, "-="))t="-";
		if(!strcmp(b, "*="))t="*";
		if(!strcmp(b, "/="))t="/";
		if(!strcmp(b, "%="))t="%";
		if(!strcmp(b, "&="))t="&";
		if(!strcmp(b, "|="))t="|";
		if(!strcmp(b, "^="))t="^";
		if(!strcmp(b, "<<="))t="<<";
		if(!strcmp(b, ">>="))t=">>";

		s=BS1_CParse_Token(s, b, &ty);

		if(BS1_SYMBOLP(n))
		{
			n1=BS1_CParse_ExpressionEquals(&s);
			if(t)n=LIST3S("set!", n,
					LIST4S("binary", SYM(t), n, n1));
				else n=LIST3S("set!", n, n1);
			continue;
		}

		if(FORM_IS(n, "objref") || FORM_IS(n, "getindex"))
		{
			if(FORM_IS(n, "objref"))
			{
				n1=BS1_CParse_ExpressionEquals(&s);
				if(t)n1=LIST4S("binary", SYM(t), n, n1);
				n=LIST4S("objset!", CADR(n), CADDR(n), n1);
				continue;
			}
			if(FORM_IS(n, "getindex"))
			{
				n1=BS1_CParse_ExpressionEquals(&s);
				if(t)n1=LIST4S("binary", SYM(t), n, n1);
				n=LIST4S("setindex!", CADR(n), CADDR(n), n1);
				continue;
			}
		}

		n1=BS1_CParse_ExpressionEquals(&s);
		if(t)n1=LIST3S(t, n, n1);
		n=LIST3S("setexpr!", n, n1);
		continue;
	}

	*str=s;
	return(n);
}

elem BS1_CParse_ExpressionComma(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_CParse_ExpressionEquals(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_CParse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_SEPERATOR)break;
		if(strcmp(b, ","))break;

		s=BS1_CParse_Token(s, b, &ty);
		n1=BS1_CParse_ExpressionEquals(&s);
		n=LIST3S("comma", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_CParse_Expression(char **str)
{
	return(BS1_CParse_ExpressionEquals(str));
}

elem BS1_CParse_Expression2(char **str)
{
	return(BS1_CParse_ExpressionComma(str));
}

elem BS1_CParse_Expression3(char **str)
{
	char b[64], b2[64];
	int ty, ty2;
	char *s;
	elem n;

	s=*str;
	n=BS1_CParse_ExpressionEquals(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	BS1_CParse_Token(s, b, &ty);
	if(!strcmp(b, ":"))
	{
		s=BS1_CParse_Token(s, b, &ty);
		if(BS1_SYMBOLP(n))n=KEYSYM(TOSYM(n));
			else n=LIST2S("colon", n);
	}

	*str=s;
	return(n);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

BS1_ParseItem *bs1_cparse_stmts=NULL;
BS1_ParseItem *bs1_cparse_blkstmts=NULL;

char *bs1_cparse_curfilename=NULL;

int BS1_CParse_AddStatement(char *name, elem (*func)(char **s))
{
	BS1_ParseItem *tmp;

	tmp=malloc(sizeof(BS1_ParseItem));
	tmp->name=strdup(name);
	tmp->func=func;

	tmp->next=bs1_cparse_stmts;
	bs1_cparse_stmts=tmp;

	return(0);
}

elem BS1_CParse_ParseStatementName(char *name, char **s)
{
	BS1_ParseItem *cur;

	cur=bs1_cparse_stmts;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}
	return(BS1_MM_NULL);
}

int BS1_CParse_AddBlockStatement(char *name,
	elem (*func)(char **s))
{
	BS1_ParseItem *tmp;

	tmp=malloc(sizeof(BS1_ParseItem));
	tmp->name=strdup(name);
	tmp->func=func;

	tmp->next=bs1_cparse_blkstmts;
	bs1_cparse_blkstmts=tmp;

	return(0);
}

elem BS1_CParse_ParseBlockStatementName(char *name, char **s)
{
	BS1_ParseItem *cur;

	cur=bs1_cparse_blkstmts;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}
	return(BS1_MM_NULL);
}

char *BS1_CParse_EatSemicolon(char *s)
{
	s=BS1_CParse_EatWhite(s);
	if(*s==';')s++;
	s=BS1_CParse_EatWhite(s);
	return(s);
}

elem BS1_CParse_Statement(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, n2;

	s=*str;
	s=BS1_CParse_Token(s, b, &ty);
	BS1_CParse_Token(s, b2, &ty2);
	if(!*s)
	{
		*str=s;
		return(BS1_MM_NULL);
	}

	if(ty!=BS1_TOKEN_NAME)
	{
		s=*str;
		n=BS1_CParse_Expression(&s);
		*str=s;
		return(n);
	}

	n=BS1_CParse_ParseStatementName(b, &s);
	if(n!=BS1_MM_NULL)
	{
		*str=s;
		return(n);
	}

	if(!strcmp(b, "break"))
	{
		n=LIST1S("break");
		*str=s;
		return(n);
	}

	if(!strcmp(b, "continue"))
	{
		n=LIST1S("continue");
		*str=s;
		return(n);
	}

	if(!strcmp(b, "goto"))
	{
		s=BS1_CParse_Token(s, b2, &ty2);
		n=LIST2S("goto", STRING(b2));
		*str=s;
		return(n);
	}

	if(!strcmp(b, "return"))
	{
		BS1_CParse_Token(s, b2, &ty2);
		if(b2[0]!=';')
			n1=BS1_CParse_Expression(&s);
			else n1=BS1_MM_NULL;

		n=LIST2S("return", n1);

		*str=s;
		return(n);
	}


	s=*str;
	s=BS1_CParse_EatWhite(s);
	if(!s || !*s)return(BS1_MM_NULL);

	n=BS1_CParse_Expression(&s);
	if(n!=BS1_MM_NULL)
	{
		*str=s;
		return(n);
	}

	BS1_MSG_Error(s, "PDSCR_CParse_Statement: Unrecognizable "
		"statement type\n");
	*str=NULL;
	return(BS1_MM_NULL);
}

elem BS1_CParse_BlockStatementInner(char **str)
{
	char b[256], b2[256];
	char *s, *s2;
	int ty, ty2;
	elem n, n1, n2, n3, n4;

	s=*str;

	s=BS1_CParse_Token(s, b, &ty);
	BS1_CParse_Token(s, b2, &ty2);
	if(!*s)
	{
		*str=s;
		return(BS1_MM_NULL);
	}

	if(ty==BS1_TOKEN_SEPERATOR)
	{
		*str=s;
		return(BS1_MM_NULL);
	}

	if((ty==BS1_TOKEN_NAME) && !strcmp(b2, ":"))
	{
		s=BS1_CParse_Token(s, b2, &ty2);	//:

		if(!strcmp(b, "default"))
		{
			n=LIST1S("case_default");
			*str=s;
			return(n);
		}

		n=LIST2S("label", SYM(b));

		*str=s;
		return(n);
	}

	if(!strcmp(b, "typedef"))
	{
		n=BS1_CParse_Definition(&s);
		BS1_CParse_HandleTypedef(n);

		*str=s;
		return(BS1_MM_NULL);
	}

	if(!strcmp(b, "case"))
	{
		n1=BS1_CParse_Expression(&s);
		s=BS1_CParse_Token(s, b2, &ty2);	//:
		n=LIST2S("case", n1);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "if"))
	{
		s=BS1_CParse_Token(s, b, &ty);	//(
		n1=BS1_CParse_Expression(&s);
		s=BS1_CParse_Token(s, b, &ty);	//)
		n2=BS1_CParse_BlockStatement2(&s);

		BS1_CParse_Token(s, b, &ty);
		if(strcmp(b, "else"))
		{
			n=LIST3S("if", n1, n2);
			*str=s;
			return(n);
		}

		s=BS1_CParse_Token(s, b, &ty);	//else
		n3=BS1_CParse_BlockStatement2(&s);
		n=LIST4S("if", n1, n2, n3);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "while"))
	{
		s=BS1_CParse_Token(s, b, &ty);	//'('
		n1=BS1_CParse_Expression(&s);
		s=BS1_CParse_Token(s, b, &ty);	//')'

		n2=BS1_CParse_BlockStatement2(&s);
		n=LIST3S("while", n1, n2);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "for"))
	{
		s=BS1_CParse_Token(s, b, &ty);		//(
		s2=BS1_CParse_Token(s, b, &ty);		//
		s2=BS1_CParse_Token(s2, b2, &ty);	//

		n1=BS1_CParse_Expression2(&s);
		s=BS1_CParse_EatSemicolon(s);
		n2=BS1_CParse_Expression2(&s);
		s=BS1_CParse_EatSemicolon(s);
		n3=BS1_CParse_Expression2(&s);

		s=BS1_CParse_Token(s, b, &ty);	//)
		n4=BS1_CParse_BlockStatement2(&s);

		n=LIST5S("for", n1, n2, n3, n4);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "switch"))
	{
		s=BS1_CParse_Token(s, b, &ty);	//(
		n1=BS1_CParse_Expression(&s);
		s=BS1_CParse_Token(s, b, &ty);	//)

		s=BS1_CParse_Token(s, b, &ty); //{
		n2=BS1_CParse_Block(&s);

		n=CONS2(SYM("switch"), n1, n2);

		*str=s;
		return(n);
	}

	n=BS1_CParse_ParseBlockStatementName(b, &s);
	if(n)
	{
		*str=s;
		return(n);
	}


	s=*str;

	n=BS1_CParse_Definition(&s);
	if(n!=BS1_MM_NULL)
	{
		s=BS1_CParse_EatSemicolon(s);
		*str=s;
		return(n);
	}

	n=BS1_CParse_Statement(&s);
	s=BS1_CParse_EatSemicolon(s);
	*str=s;
	return(n);
}

elem BS1_CParse_BlockStatement(char **str)
{
	char b[64];
	int ty;
	elem n, n1;
	int i;
	char *s;

	s=*str;

#if 1
	BS1_CParse_Token(s, b, &ty);
	while(!strcmp(b, "#"))
	{
		s=BS1_CParse_Token(s, b, &ty);
		while(*s && (*s!='\n'))s++;

		b[0]=0;
		BS1_CParse_Token(s, b, &ty);
	}
#endif

	n=BS1_CParse_BlockStatementInner(&s);

	*str=s;
	return(n);
}

elem BS1_CParse_Block(char **str)
{
	char b[256];
	char *s, *s1;
	int ty, ty2;
	elem n, lst;

	s=*str; s1=s;
	lst=BS1_MM_NULL;
	while(1)
	{
		BS1_CParse_Token(s, b, &ty);
		if(!*s || (*b=='}'))
		{
			s=BS1_CParse_Token(s, b, &ty);
			break;
		}

		n=BS1_CParse_BlockStatement(&s);
		if(n==BS1_MM_NULL)
		{
			if(!s || s==s1)
			{
				BS1_MSG_Error(s, "PDSCR_CParse_Block: "
					"Unknown Parse Error\n");
				break;
			}
			continue;
		}
		lst=BS1_TY_NAppend(lst, LIST1(n));
	}

	*str=s;
	return(lst);
}

elem BS1_CParse_BlockStatement2(char **str)
{
	char b[64];
	char *s;
	int ty;
	elem n;

	s=*str;

	BS1_CParse_Token(s, b, &ty);
	if(!strcmp(b, "{"))
	{
		s=BS1_CParse_Token(s, b, &ty);
		n=BS1_CParse_Block(&s);
		n=CONS(SYM("begin"), n);

		*str=s;
		return(n);
	}

	n=BS1_CParse_BlockStatement(str);
	return(n);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <stdarg.h>

#include <bgbscr1.h>


char *bs1_cparse_pbase;
char *bs1_cparse_fname;
int bs1_cparse_linenum=1;

char *bs1_cparse_pbasestack[16];
char *bs1_cparse_fnamestack[16];
int bs1_cparse_lnumstack[16];
int bs1_cparse_lnumstackpos;

int BS1_CParse_GetLinenum()
	{ return(bs1_cparse_linenum); }

char *BS1_CParse_GetFilename()
	{ return(bs1_cparse_fname); }

int BS1_CParse_CalcLinenum(char *se)
{
	char *s;
	int i;

	if(!bs1_cparse_pbase)
		return(0);

	s=bs1_cparse_pbase;
	i=bs1_cparse_linenum;
	while(s<se)
	{
		if(*s=='\n')i++;
		if((s[0]=='\r') && (s[1]!='\n'))i++;
		s++;
	}

	return(i);
}

int BS1_CParse_SetLinenum(char *fname, char *base, int num)
{
	bs1_cparse_fname=fname;
	bs1_cparse_pbase=base;
	bs1_cparse_linenum=num;
	return(num);
}

int BS1_CParse_PushLinenum()
{
	bs1_cparse_lnumstack[bs1_cparse_lnumstackpos]=
		bs1_cparse_linenum;
	bs1_cparse_pbasestack[bs1_cparse_lnumstackpos]=
		bs1_cparse_pbase;
	bs1_cparse_fnamestack[bs1_cparse_lnumstackpos]=
		bs1_cparse_fname;
	bs1_cparse_lnumstackpos++;
	return(0);
}

int BS1_CParse_PopLinenum()
{
	bs1_cparse_lnumstackpos--;
	bs1_cparse_linenum=
		bs1_cparse_lnumstack[bs1_cparse_lnumstackpos];
	bs1_cparse_pbase=
		bs1_cparse_pbasestack[bs1_cparse_lnumstackpos];
	bs1_cparse_fname=
		bs1_cparse_fnamestack[bs1_cparse_lnumstackpos];
	return(bs1_cparse_linenum);
}

char *BS1_CParse_EatWhiteOnly(char *s)
{
	while(*s && (*s<=' '))s++;
	return(s);
}

char *BS1_CParse_EatWhite(char *s)
{
	int i;

	while(*s && (*s<=' '))s++;

	if((s[0]=='/') && (s[1]=='/'))
	{
		while(*s && (*s!='\n'))s++;
		s=BS1_CParse_EatWhite(s);
		return(s);
	}
	if((s[0]=='/') && (s[1]=='*'))
	{
		s+=2;
		i=1;
		while(*s && i)
		{
			if((s[0]=='/') && (s[1]=='*'))
			{
				s+=2;
				i++;
				continue;
			}
			if((s[0]=='*') && (s[1]=='/'))
			{
				s+=2;
				i--;
				continue;
			}
			s++;
		}
		s=BS1_CParse_EatWhite(s);
		return(s);
	}

	return(s);
}

int BS1_CParse_IsWhiteOnly(char *s)
{
	while((*s==' ') || (*s=='\t'))
		s++;

	if((s[0]=='/') && (s[1]=='/'))return(0);
	if((s[0]=='/') && (s[1]=='*'))return(0);
	if((s[0]=='*') && (s[1]=='/'))return(0);

	if(*s>' ')return(1);
	if(*s==' ')return(1);
	if(*s=='\t')return(1);

	return(0);
}

int BS1_CParse_IsLineBreak(char *se)
{
	char *s, *b, *t;
	int i, j;

	s=se;
	while(*s && (*s<=' '))
	{
		if(*s=='\r')return(1);
		if(*s=='\n')return(1);
		s++;
	}
	if(!*s)return(1);

	return(0);
}


int BS1_CParse_OpChar(int c)
{
	int i;

	switch(c)
	{
	case '~':
	case '!':
	case '@':
	case '#':
	case '$':
	case '%':
	case '^':
	case '&':
	case '*':
	case '-':
	case '=':
	case '+':

	case '\\':
	case '|':

	case ':':

	case '<':
	case '>':
	case '?':
	case '/':

	case '.':
		i=1;
		break;

	default:
		i=0;
		break;
	}
	return(i);
}

char *BS1_CParse_Token(char *s, char *b, int *ty)
{
	char *t;
	int i;

	*b=0;
	s=BS1_CParse_EatWhite(s);
	if(!*s)
	{
		*ty=BS1_TOKEN_NULL;
		return(s);
	}
	t=b;

	if((*s=='_') || ((*s>='a') && (*s<='z')) || ((*s>='A') && (*s<='Z')))
	{
		while(
			(*s=='_') ||
			((*s>='a') && (*s<='z')) ||
			((*s>='A') && (*s<='Z')) ||
			((*s>='0') && (*s<='9')))
			*t++=*s++;
		*t++=0;

		*ty=BS1_TOKEN_NAME;
		return(s);
	}

	if((*s>='0') && (*s<='9'))
	{
		if((s[0]=='0') && (s[1]=='x'))
		{
			*t++=*s++;
			*t++=*s++;
			while(((*s>='0') && (*s<='9')) ||
				((*s>='A') && (*s<='F')) ||
				((*s>='a') && (*s<='f')))
			{
				*t++=*s++;
			}
			*t++=0;

			*ty=BS1_TOKEN_NUMBER;
			return(s);
		}

		if(*s=='-')*t++=*s++;
		while(((*s>='0') && (*s<='9')) || (*s=='.') || (*s=='e'))
		{
			if(*s=='e')
			{
				*t++=*s++;
				if((*s=='+') || (*s=='-'))
					*t++=*s++;
				continue;
			}
			*t++=*s++;
		}
		*t++=0;

		*ty=BS1_TOKEN_NUMBER;
		return(s);
	}

	if((*s=='"') || (*s=='\'')) /* quoted string */
	{
		if(*s=='\'')i=1;
			else i=0;
		s++;
		while(*s)
		{
			if(!i)if(*s=='"')break;
			if(i)if(*s=='\'')break;

			if(*s=='\\')
			{
				s++;
				switch(*s)
				{
				case 'n':
					*t++='\n';
					break;
				case 't':
					*t++='\t';
					break;
				case 'r':
					*t++='\r';
					break;
				case 'e':
					*t++='\x1B';
					break;
				case '\\':
					*t++='\\';
					break;
				case '"':
					*t++='"';
					break;
				case '\'':
					*t++='\'';
					break;
				default:
					break;
				}
				s++;
			}else *t++=*s++;
		}
		*t++=0;
		if(*s)s++;

		*ty=BS1_TOKEN_STRING;
		if(i)*ty=BS1_TOKEN_CHARSTRING;
		return(s);
	}

	if(!strncmp(s, "...", 3))
	{
		*t++=*s++;
		*t++=*s++;
		*t++=*s++;
		*t++=0;

		*ty=BS1_TOKEN_MISC;
		return(s);
	}

	if((*s==',') || (*s==';') || ((*s=='.') && (s[1]!='.')))
	{
		*t++=*s++;
		*t++=0;

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_SEPERATOR;
		return(s);
	}

	if(
		(*s=='{') || (*s=='}') ||
		(*s=='[') || (*s==']') ||
		(*s=='(') || (*s==')'))
	{
		*t++=*s++;
		*t++=0;

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_BRACE;
		return(s);
	}

	if(BS1_CParse_OpChar(*s))
	{
		if(
			!strncmp(s, "<<=", 3) ||
			!strncmp(s, ">>=", 3)
			)
		{
			*t++=*s++;
			*t++=*s++;
			*t++=*s++;
			*t++=0;
		}else if(
			!strncmp(s, "==", 2) ||
			!strncmp(s, "<=", 2) ||
			!strncmp(s, ">=", 2) ||
			!strncmp(s, "!=", 2) ||
			!strncmp(s, "<<", 2) ||
			!strncmp(s, ">>", 2) ||
			!strncmp(s, "&&", 2) ||
			!strncmp(s, "||", 2) ||

			!strncmp(s, "++", 2) ||
			!strncmp(s, "--", 2) ||

			!strncmp(s, "+=", 2) ||
			!strncmp(s, "-=", 2) ||
			!strncmp(s, "*=", 2) ||
			!strncmp(s, "/=", 2) ||
			!strncmp(s, "&=", 2) ||
			!strncmp(s, "|=", 2) ||
			!strncmp(s, "^=", 2) ||

			!strncmp(s, "->", 2)
			)
		{
			*t++=*s++;
			*t++=*s++;
			*t++=0;
		}else
		{
			*t++=*s++;
			*t++=0;
		}

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_OPERATOR;
		if(!strcmp(b, ":"))*ty=BS1_TOKEN_SEPERATOR;

		return(s);
	}

	BS1_MSG_Error(s, "BS1_CParse_Token: Parse Error Char '%c'\n", *s);
	*ty=BS1_TOKEN_NULL;
	return(NULL);
}
#include <bgbscr1.h>

char *bs1_pp_ibuf;
char *bs1_pp_obuf;

char *bs1_pp_def_name[4096];
char *bs1_pp_def_value[4096];
int bs1_pp_ndef;

int bs1_pp_iflvl;	//nested ifdef-level (true branches)
int bs1_pp_iflvl2;	//nested ifdef-level (false branch)

int BS1_PP_LookupDefine(char *name)
{
	int i;

	for(i=0; i<bs1_pp_ndef; i++)
		if(!strcmp(bs1_pp_def_name[i], name))
			return(i);
	return(-1);
}

char *BS1_PP_EmitString(char *t, char *s)
{
	*t++='\"';

	while(*s)
	{
		if((*s<=' ') || (*s>='~'))
		{
			switch(*s)
			{
			case '\r': *t++='\\'; *t++='r'; break;
			case '\n': *t++='\\'; *t++='n'; break;
			case '\t': *t++='\\'; *t++='t'; break;
			case '\x1B': *t++='\\'; *t++='e'; break;
			default: sprintf(t, "\\x%02X", *s); t+=4; break;
			}
			s++;
			continue;
		}

		if(*s=='\"')*t++='\\';
		if(*s=='\'')*t++='\\';
		if(*s=='\\')*t++='\\';
		*t++=*s++;
	}

	*t++='\"';
}

void BS1_PP_Trigraphs(char *str)
{
	char *s, *t;

	s=str; t=str;
	while(*s)
	{
		if((s[0]=='?') && (s[1]=='?'))
		{
			if(s[2]=='=') { *t++='#'; s+=3; continue; }
			if(s[2]==')') { *t++=']'; s+=3; continue; }
			if(s[2]=='!') { *t++='|'; s+=3; continue; }
			if(s[2]=='(') { *t++='['; s+=3; continue; }
			if(s[2]==''') { *t++='^'; s+=3; continue; }
			if(s[2]=='>') { *t++='}'; s+=3; continue; }
			if(s[2]=='/') { *t++='\\'; s+=3; continue; }
			if(s[2]=='<') { *t++='{'; s+=3; continue; }
			if(s[2]=='-') { *t++='~'; s+=3; continue; }
		}
		*t++=*s++;
		continue;
	}
	*t++=0;
}


void BS1_PP_Directive2(char *str)
{
	char b[256], b2[256];
	char *s, *t;
	int i;

	s=str;
	s++;

	s=BS1_CParse_Token(s, b, &ty);
	BS1_CParse_Token(s, b2, &ty2);

	if(!strcmp(b, "if"))		{ bs1_pp_iflvl2++; return; }
	if(!strcmp(b, "ifdef"))		{ bs1_pp_iflvl2++; return; }
	if(!strcmp(b, "ifndef"))	{ bs1_pp_iflvl2++; return; }
	if(!strcmp(b, "endif"))		{ bs1_pp_iflvl2--; return; }

	if(!strcmp(b, "else"))
	{
		if(bs1_pp_iflvl2==1)
		{
			bs1_pp_iflvl2--;
			bs1_pp_iflvl++;
			return;
		}
	}
}

void BS1_PP_Directive(char *str)
{
	char b[256], b2[256];
	char *s, *t, *s1;
	int i, j;

	if(bs1_pp_iflvl2)
	{
		BS1_PP_Directive2(str);
		return;
	}

	s=str;
	s++;

	s=BS1_CParse_Token(s, b, &ty);
	s1=BS1_CParse_Token(s, b2, &ty2);

	if(!strcmp(b, "define"))
	{
		if(*s1!='(')
		{
			i=BS1_PP_LookupDefine(b2);
			if(i<0)i=bs1_pp_ndef++;

			while(*s1 && (*s1<=' '))s1++;
			bs1_pp_def_name[i]=strdup(b2);
			bs1_pp_def_value[i]=strdup(s1);

			return;
		}

		printf("BS1_PP_Directive: Incomplete, no macros\n");
		return;
	}

	if(!strcmp(b, "endif"))
	{
		bs1_pp_iflvl--;
		return;
	}

	if(!strcmp(b, "else"))
	{
		bs1_pp_iflvl--;
		bs1_pp_iflvl2++;
		return;
	}

	if(!strcmp(b, "ifdef"))
	{
		i=BS1_PP_LookupDefine(b2);
		if(i<0)bs1_pp_iflvl2++;
			else bs1_pp_iflvl++;
		return;
	}
	if(!strcmp(b, "ifndef"))
	{
		i=BS1_PP_LookupDefine(b2);
		if(i<0)bs1_pp_iflvl++;
			else bs1_pp_iflvl2++;
		return;
	}

	if(!strcmp(b, "undef"))
	{
		i=BS1_PP_LookupDefine(b2);
		if(i<0)return;

		for(j=i; j<bs1_pp_ndef; j++)
		{
			bs1_pp_def_name[j]=bs1_pp_def_name[j+1];
			bs1_pp_def_value[j]=bs1_pp_def_value[j+1];
		}
		bs1_pp_ndef--;
		return;
	}

	printf("BS1_PP_Directive: Unsupported preproc directive %s\n", b);
}

int BS1_PP_Line(char *str)
{
	static char lbuf[4096];
	char b[256], b2[256];
	char *s, *t;
	int i, ty, ty2, ni;

	if(bs1_pp_iflvl2)return;

	ni=0;
	s=str; t=lbuf;
	while(*s)
	{
		s=BS1_CParse_Token(s, b, &ty);
		BS1_CParse_Token(s, b2, &ty2);

		if(ty==BS1_TOKEN_NAME)
		{
			i=BS1_PP_LookupDefine(b);
			if(i<0)
			{
				sprintf(t, "%s ", b);
				t+=strlen(t);
				continue;
			}

			ni++;
			sprintf(t, "%s ", bs1_pp_def_value[i]);
			t+=strlen(t);
			continue;
		}

		if(ty==BS1_TOKEN_STRING)
		{
			t=BS1_PP_EmitString(t, b);
			continue;
		}

		sprintf(t, "%s", b);
		t+=strlen(t);
	}
	*t=0;

	strcpy(str, lbuf);
	return(ni);
}

char *BS1_PP_ParseLine(char *s, char *b)
{
	char *t;

	t=b;
	while(*s && (*s!='\n') && (*s!='\r'))
	{
		if((s[0]=='/') && (s[1]=='/'))
		{
			while(*s && (*s!='\n') && (*s!='\r'))
				s++;
			break;
		}

		if((s[0]=='/') && (s[1]=='*'))
		{
			s+=2;
			while(*s && (*s!='\n') && (*s!='\r'))
			{
				if((s[0]=='*') && (s[1]=='/'))
				{
					s+=2;
					break;
				}
				s++;
			}
			*t++=' ';
			continue;
		}

		if((*s=='\\') && ((s[1]=='\r') || (s[1]=='\n')))
		{
			s++;
			while(*s<=' ')s++;
			*t++=' ';
			continue;
		}
		*t++=*s++;
	}
	*t++=0;
	if(*s=='\r')s++;
	if(*s=='\n')s++;

	return(s);
}

void BS1_PP_Buffer(char *ibuf)
{
	static char b[4096];
	char *s, *t;
	int i;

	s=ibuf;
	while(*s)
	{
		s=BS1_PP_ParseLine(s, b);

		if(!b[0])
		{
			*bs1_pp_obuf++='\n';
			*bs1_pp_obuf=0;
			continue;
		}

		BS1_PP_Trigraphs(b);

		if(b[0]=='#')
		{
			BS1_PP_Directive(b);
			continue;
		}

		i=1;
		while(i)i=BS1_PP_Line(b);

		sprintf(bs1_pp_obuf, "%s\n", b);
		bs1_pp_obuf+=strlen(bs1_pp_obuf);
	}
}


int BS1_PP_Filter(char *ibuf, char *obuf)
{
	bs1_pp_ibuf=ibuf;
	bs1_pp_obuf=obuf;
	bs1_pp_ndef=0;
}

/*
Prototype Objects
 */

static elem bs1_sobj_stack[256];
static int bs1_sobj_stackpos=0;

elem BS1_SObj_New()
{
	BS1_Object *tmp;
	elem t;

	t=BS1_MM_AllocObj(BS1_TYH_OBJECT, sizeof(BS1_Object));
	tmp=BS1_TY_GetObjData(t);

	tmp->lkey=BS1_MM_NULL;
	tmp->lval=BS1_MM_NULL;
	tmp->dkey=BS1_MM_NULL;
	tmp->dval=BS1_MM_NULL;
	tmp->nkey=0;

	return(t);
}

elem BS1_SObj_GetHash(elem ka, elem va, elem slot)
{
	elem t;
	int i, j, k, sz;

	if(slot==BS1_MM_NULL)
		return(BS1_MM_NULL);

	sz=BS1_TY_GetArrayLen(ka);
	i=BS1_TY_GetSymbolIndex(slot);
	if(i<0)i=slot^(slot>>8)^(slot>>16);
	i*=65521;

	for(k=0; k<16; k++)
	{
		j=(i>>16)%sz;

		t=BS1_TY_GetArrayElem(ka, j);
		if(t==slot)
		{
			t=BS1_TY_GetArrayElem(va, j);
			return(t);
		}
		if(t==BS1_MM_NULL)return(BS1_MM_NULL);
		i*=65521;
	}
	return(BS1_MM_NULL);
}

elem BS1_SObj_GetSlot(elem obj, elem slot)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;
	int i;

	for(i=(bs1_sobj_stackpos-1); i>=0; i--)
		if(bs1_sobj_stack[i]==obj)
			return(BS1_MM_NULL);

	if(bs1_sobj_stackpos>=255)return(BS1_MM_NULL);
	bs1_sobj_stack[bs1_sobj_stackpos++]=obj;
	

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
				return(CAR(cv));
			ck=CDR(ck); cv=CDR(cv);
		}

		bs1_sobj_stackpos--;
		return(BS1_MM_NULL);
	}

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			bs1_sobj_stackpos--;
			return(CAR(cv));
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	ck=tmp->dkey; cv=tmp->dval;
	while(ck)
	{
		t=BS1_SObj_GetSlot(CAR(cv), slot);
		if(t!=BS1_MM_NULL)
		{
			bs1_sobj_stackpos--;
			return(t);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	bs1_sobj_stackpos--;
	return(BS1_MM_NULL);
}

int BS1_SObj_SetSlotR(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	int i;

	for(i=(bs1_sobj_stackpos-1); i>=0; i--)
		if(bs1_sobj_stack[i]==obj)
			return(BS1_MM_NULL);

	if(bs1_sobj_stackpos>=255)return(BS1_MM_NULL);
	bs1_sobj_stack[bs1_sobj_stackpos++]=obj;


	tmp=BS1_TY_GetObjData(obj);

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			BS1_TY_SetCar(cv, val);
			bs1_sobj_stackpos--;
			return(0);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	ck=tmp->dkey; cv=tmp->dval;
	while(ck)
	{
		i=BS1_SObj_SetSlotR(CAR(cv), slot, val);
		if(!i)
		{
			bs1_sobj_stackpos--;
			return(0);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	bs1_sobj_stackpos--;
	return(-1);
}

elem BS1_SObj_SetSlot(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	char *s;
	int i;

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')return(BS1_SObj_BindSlot(obj, slot, val));
	i=BS1_SObj_SetSlotR(obj, slot, val);
	if(!i)return(BS1_MM_NULL);

	SET(tmp->lkey, CONS(slot, tmp->lkey));
	SET(tmp->lval, CONS(val, tmp->lval));
	tmp->nkey++;
	return(BS1_MM_NULL);
}

elem BS1_SObj_BindSlot(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
			{
				BS1_TY_SetCar(cv, val);
				return(BS1_MM_NULL);
			}
			ck=CDR(ck); cv=CDR(cv);
		}

		SET(tmp->dkey, CONS(slot, tmp->dkey));
		SET(tmp->dval, CONS(val, tmp->dval));
		return(BS1_MM_NULL);
	}

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			BS1_TY_SetCar(cv, val);
			return(BS1_MM_NULL);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	SET(tmp->lkey, CONS(slot, tmp->lkey));
	SET(tmp->lval, CONS(val, tmp->lval));
	tmp->nkey++;
	return(BS1_MM_NULL);
}

static void bs1_sobj_mark(elem obj)
{
	BS1_Object *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->lkey);
	BS1_GC_MarkRef(tmp->lval);
	BS1_GC_MarkRef(tmp->dkey);
	BS1_GC_MarkRef(tmp->dval);
}

static void bs1_sobj_destroy(elem obj)
{
	BS1_Object *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->lkey);
	BS1_GC_DecRef(tmp->lval);
	BS1_GC_DecRef(tmp->dkey);
	BS1_GC_DecRef(tmp->dval);
}

int BS1_SObj_Init()
{
	BS1_TY_SetMarkFunc(BS1_TYH_OBJECT, &bs1_sobj_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_OBJECT, &bs1_sobj_destroy);
}#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <bgbscr1.h>

extern char *bs1_ops_strs[];
extern char *bs1_ops_args[];

elem bs1_svm_toplevel;
int bs1_svm_opcnt;

static void bs1_sblk_mark(elem obj)
{
	BS1_SVMBlock *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->args);
	BS1_GC_MarkRef(tmp->exps);
	BS1_GC_MarkRef(tmp->lit);
}

static void bs1_sblk_destroy(elem obj)
{
	BS1_SVMBlock *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->args);
	BS1_GC_DecRef(tmp->exps);
	BS1_GC_DecRef(tmp->lit);
	free(tmp->body);
}

static void bs1_sfun_mark(elem obj)
{
	BS1_SVMLambda *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->lkey);
	BS1_GC_MarkRef(tmp->lval);
	BS1_GC_MarkRef(BS1_MM_GetPtrElem(tmp->blk));
}

static void bs1_sfun_destroy(elem obj)
{
	BS1_SVMLambda *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->lkey);
	BS1_GC_DecRef(tmp->lval);
	BS1_GC_DecRef(BS1_MM_GetPtrElem(tmp->blk));
}

static void bs1_sctx_mark(elem obj)
{
	BS1_SVMState *tmp;
	int i;

	tmp=BS1_TY_GetObjData(obj);

	BS1_GC_MarkRef(tmp->self);
	BS1_GC_MarkRef(tmp->lit);
	BS1_GC_MarkRef(tmp->func);

	BS1_GC_MarkRef(tmp->klenv);
	BS1_GC_MarkRef(tmp->vlenv);
	BS1_GC_MarkRef(tmp->kdenv);
	BS1_GC_MarkRef(tmp->vdenv);

	for(i=0; i<tmp->stackpos; i++)
		BS1_GC_MarkRef(tmp->stack[i]);

	for(i=0; i<tmp->flowstackpos; i++)
	{
		BS1_GC_MarkRef(tmp->flowstack[i]->self);
		BS1_GC_MarkRef(tmp->flowstack[i]->lit);
		BS1_GC_MarkRef(tmp->flowstack[i]->func);
		BS1_GC_MarkRef(tmp->flowstack[i]->klenv);
		BS1_GC_MarkRef(tmp->flowstack[i]->vlenv);
		BS1_GC_MarkRef(tmp->flowstack[i]->kdenv);
		BS1_GC_MarkRef(tmp->flowstack[i]->vdenv);
	}
}

static void bs1_sctx_destroy(elem obj)
{
	BS1_SVMState *tmp;
	int i;

	tmp=BS1_TY_GetObjData(obj);

#ifdef BS1_FRAMEREFS
	BS1_GC_DecRef(tmp->self);
	BS1_GC_DecRef(tmp->lit);
	BS1_GC_DecRef(tmp->func);

	BS1_GC_DecRef(tmp->klenv);
	BS1_GC_DecRef(tmp->vlenv);
	BS1_GC_DecRef(tmp->kdenv);
	BS1_GC_DecRef(tmp->vdenv);
#endif

	for(i=0; i<tmp->stackpos; i++)
		BS1_GC_DecRef(tmp->stack[i]);

#ifdef BS1_FRAMEREFS
	for(i=0; i<256; i++)
	{
		if(!tmp->flowstack[i])break;
		BS1_GC_DecRef(tmp->flowstack[i]->self);
		BS1_GC_DecRef(tmp->flowstack[i]->lit);
		BS1_GC_DecRef(tmp->flowstack[i]->func);
		BS1_GC_DecRef(tmp->flowstack[i]->klenv);
		BS1_GC_DecRef(tmp->flowstack[i]->vlenv);
		BS1_GC_DecRef(tmp->flowstack[i]->kdenv);
		BS1_GC_DecRef(tmp->flowstack[i]->vdenv);
	}
#endif

	free(tmp->stack);
	free(tmp->markstack);

	for(i=0; i<256; i++)
	{
		if(!tmp->flowstack[i])break;
		free(tmp->flowstack[i]);
	}
}

int BS1_SVM_Init()
{
	static int init=0;

	if(init)return(0);
	init=1;

	BS1_TY_Init();

	BS1_GC_AddRoot(&bs1_svm_toplevel);

	BS1_SObj_Init();
	SET(bs1_svm_toplevel, BS1_SObj_New());
	BS1_Builtins_Init();

	BS1_TY_SetMarkFunc(BS1_TYH_SVMBLK, &bs1_sblk_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_SVMBLK, &bs1_sblk_destroy);
	BS1_TY_SetMarkFunc(BS1_TYH_SVMLAMBDA, &bs1_sfun_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_SVMLAMBDA, &bs1_sfun_destroy);
	BS1_TY_SetMarkFunc(BS1_TYH_SVMCTX, &bs1_sctx_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_SVMCTX, &bs1_sctx_destroy);
}

void BS1_SVM_AddBuiltin(char *name, char *desc,
	elem (*fcn)(BS1_SVMState *ctx, elem args), int nargs)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=name; t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			t++;
			s=t;
		}
	}

	tmp=BS1_MM_AllocObj(BS1_TYH_SVMBUILTIN, sizeof(BS1_SVMBuiltin));
	bfcn=BS1_TY_GetObjData(tmp);

	bfcn->name=strdup(s);
	bfcn->desc=strdup(desc);
	bfcn->fcn=fcn;
	bfcn->nargs=nargs;

	BS1_SObj_BindSlot(obj, SYM(s), tmp);
//	BS1_SObj_BindSlot(bs1_svm_toplevel, SYM(name), tmp);
}

void BS1_SVM_AddBuiltin2(char *name, char *desc,
	elem (*fcn)(BS1_SVMState *ctx, elem args), int nargs)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
			{
				tmp=BS1_SObj_New();
				BS1_SObj_BindSlot(obj, SYM(s), tmp);
			}

			obj=tmp; s=t;
		}
	}

	tmp=BS1_MM_AllocObj(BS1_TYH_SVMBUILTIN, sizeof(BS1_SVMBuiltin));
	bfcn=BS1_TY_GetObjData(tmp);

//	bfcn->name=name;
//	bfcn->desc=desc;
	bfcn->name=strdup(s);
	bfcn->desc=strdup(desc);
	bfcn->fcn=fcn;
	bfcn->nargs=nargs;

	BS1_SObj_BindSlot(obj, SYM(s), tmp);
//	BS1_SObj_BindSlot(bs1_svm_toplevel, SYM(name), tmp);
}

void BS1_SVM_AddBinding(char *name, elem val)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=name; t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			t++;
			s=t;
		}
	}

	BS1_SObj_BindSlot(obj, SYM(s), val);
}

void BS1_SVM_AddBinding2(char *name, elem val)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
			{
				tmp=BS1_SObj_New();
				BS1_SObj_BindSlot(obj, SYM(s), tmp);
			}

			obj=tmp; s=t;
		}
	}

	BS1_SObj_BindSlot(obj, SYM(s), val);
}


elem BS1_SVM_GetTop(char *name)
{
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;
	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
				return(BS1_MM_NULL);
			obj=tmp; s=t;
		}
	}

	tmp=BS1_SObj_GetSlot(obj, SYM(s));
	return(tmp);
}

void BS1_SVM_SetTop(char *name, elem val)
{
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;
	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
			{
				tmp=BS1_SObj_New();
				BS1_SObj_BindSlot(obj, SYM(s), tmp);
			}

			obj=tmp; s=t;
		}
	}

	BS1_SObj_BindSlot(obj, SYM(s), val);
}


elem BS1_SVM_NewState()
{
	elem tmp;
	BS1_SVMState *ctx;

	tmp=BS1_MM_AllocObj(BS1_TYH_SVMCTX, sizeof(BS1_SVMState));
	ctx=BS1_TY_GetObjData(tmp);

	ctx->stack=malloc(4096*sizeof(elem));
	ctx->markstack=malloc(256*sizeof(int));

	memset(ctx->stack, 0, 4096*sizeof(elem));
	memset(ctx->markstack, 0, 256*sizeof(int));

	ctx->flowstack=malloc(256*sizeof(BS1_SVMFrame *));
	memset(ctx->flowstack, 0, 256*sizeof(BS1_SVMFrame *));

	return(tmp);
}


void BS1_SVM_Push(BS1_SVMState *ctx, elem val)
{
	BS1_GC_IncRef(val);
	ctx->stack[ctx->stackpos++]=val;
}

elem BS1_SVM_Pop(BS1_SVMState *ctx)
{
	elem t;

	ctx->stackpos--;
	t=ctx->stack[ctx->stackpos];
	BS1_GC_SafeDecRef(t);
	return(t);
}

void BS1_SVM_PushF(BS1_SVMState *ctx, elem val)
{
	ctx->stack[ctx->stackpos++]=val;
}

elem BS1_SVM_PopF(BS1_SVMState *ctx)
{
	ctx->stackpos--;
	return(ctx->stack[ctx->stackpos]);
}

void BS1_SVM_PopDestroy(BS1_SVMState *ctx)
{
	elem t;

	ctx->stackpos--;
	t=ctx->stack[ctx->stackpos];
	BS1_GC_DecRef(t);
}

int BS1_SVM_PopBool(BS1_SVMState *ctx)
{
	elem t;
	int i;

	ctx->stackpos--;
	t=ctx->stack[ctx->stackpos];

	if(t==BS1_MM_FALSE)return(0);
	if(t==BS1_MM_NULL)return(0);
	if(t==BS1_MM_TRUE)return(1);
	if(t==BS1_MM_FIXNUM_0)return(0);
	BS1_GC_DecRef(t);
	return(1);

#if 0
	switch(t)
	{
	case BS1_MM_NULL: i=0; break;
	case BS1_MM_FIXNUM_0: i=0; break;
	case BS1_MM_FALSE: i=0; break;
	case BS1_MM_TRUE: i=1; break;
	default:
		i=1;
		BS1_GC_DecRef(t);
		break;
	}
	return(i);
#endif
}

void BS1_SVM_PushList(BS1_SVMState *ctx, elem l)
{
	elem c;

	ctx->markstack[ctx->markstackpos++]=ctx->stackpos;

	c=l;
	while(BS1_CONSP(l))
	{
		BS1_SVM_Push(ctx, CAR(l));
		l=CDR(l);
	}
}

elem BS1_SVM_PopList(BS1_SVMState *ctx)
{
	elem t, l;
	int i;

	i=ctx->markstack[ctx->markstackpos-1];
	l=BS1_MM_NULL;
	while(ctx->stackpos>i)
	{
		t=BS1_SVM_Pop(ctx);
		l=CONS(t, l);
	}

	ctx->markstackpos--;
	return(l);
}

elem BS1_SVM_PopList2(BS1_SVMState *ctx)
{
	elem t, l;
	int i;

	i=ctx->markstack[ctx->markstackpos-1];
	l=BS1_SVM_Pop(ctx);
	while(ctx->stackpos>i)
	{
		t=BS1_SVM_Pop(ctx);
		l=CONS(t, l);
	}

	ctx->markstackpos--;
	return(l);
}

void BS1_SVM_PopMark(BS1_SVMState *ctx)
{
	int i;

	ctx->markstackpos--;
	i=ctx->markstack[ctx->markstackpos];
	while(ctx->stackpos>i)
		BS1_SVM_PopDestroy(ctx);
}

void BS1_SVM_ShiftMark(BS1_SVMState *ctx)
{
	int i, j, k;

	ctx->markstackpos--;
	k=ctx->markstack[ctx->markstackpos];

	i=k;
	j=ctx->markstack[ctx->markstackpos-1];
	while(i<ctx->stackpos)
	{
		BS1_GC_DecRef(ctx->stack[j]);
		ctx->stack[j++]=ctx->stack[i++];
	}
	ctx->stackpos=j;
	while(j<k)BS1_GC_DecRef(ctx->stack[j++]);
}


elem BS1_SVM_Lookup(BS1_SVMState *ctx, elem key)
{
	elem ck, cv, t;
	int i, j;

	if(ctx->klenv && !ctx->vlenv)
	{
		ck=ctx->klenv; i=0;
		while(ck)
		{
			if(CARF(ck)==key)
			{
				t=ctx->stack[ctx->eargs-i-1];
				return(t);
			}
			i++; ck=CDRF(ck);
		}

		t=BS1_SObj_GetSlot(ctx->self, key);
		return(t);
	}

	ck=ctx->klenv; cv=ctx->vlenv;
	while(ck)
	{
		if(CARF(ck)==key)return(CARF(cv));
		ck=CDRF(ck); cv=CDRF(cv);
	}

#if 0
	ck=ctx->kdenv;
	cv=ctx->vdenv;
	while(ck)
	{
		if(CARF(ck)==key)return(CARF(cv));
		ck=CDRF(ck); cv=CDRF(cv);
	}
#endif

	t=BS1_SObj_GetSlot(ctx->self, key);

//	printf("obj get %s %08X\n", TOSYM(key), t);

	return(t);
}

void BS1_SVM_Assign(BS1_SVMState *ctx, elem key, elem val)
{
	elem ck, cv, t;
	int i;

	if(ctx->klenv && !ctx->vlenv)
	{
		ck=ctx->klenv; i=0;
		while(ck)
		{
			if(CARF(ck)==key)
			{
				ctx->stack[ctx->eargs-i-1]=val;
				return;
			}
			i++; ck=CDRF(ck);
		}

		BS1_SObj_SetSlot(ctx->self, key, val);
		return;
	}

	ck=ctx->klenv;
	cv=ctx->vlenv;
	while(ck)
	{
		if(CARF(ck)==key)
		{
			BS1_TY_SetCar(cv, val);
			return;
		}
		ck=CDRF(ck); cv=CDRF(cv);
	}

#if 0
	ck=ctx->kdenv;
	cv=ctx->vdenv;
	while(ck)
	{
		if(CAR(ck)==key)
		{
			BS1_TY_SetCar(cv, val);
			return;
		}
		ck=CDR(ck); cv=CDR(cv);
	}
#endif

	BS1_SObj_SetSlot(ctx->self, key, val);
}

elem BS1_SVM_LookupIdx(BS1_SVMState *ctx, int idx)
{
	elem c, t;
	int i;

	if(!ctx->vlenv)
	{
		t=ctx->stack[ctx->eargs-idx-1];
		return(t);
	}

	c=ctx->vlenv; i=idx;
	while(i--)c=CDRF(c);
	return(CARF(c));
}

void BS1_SVM_AssignIdx(BS1_SVMState *ctx, int idx, elem val)
{
	elem c, t;
	int i;

	if(!ctx->vlenv)
	{
		SET(ctx->stack[ctx->eargs-idx-1], val);
		return;
	}

	c=ctx->vlenv; i=idx;
	while(i--)c=CDRF(c);
	BS1_TY_SetCar(c, val);
}

void BS1_SVM_AssignIdxF(BS1_SVMState *ctx, int idx, elem val)
{
	elem c, t;
	int i;

	if(ctx->klenv && !ctx->vlenv)
	{
		ctx->stack[ctx->eargs-idx-1]=val;
		return;
	}

	c=ctx->vlenv; i=idx;
	while(i--)c=CDRF(c);
//	CARF(c)=val;
	BS1_TY_SetCar2(c, val);
}

void BS1_SVM_Bind(BS1_SVMState *ctx, elem key, elem val)
{
//	printf("bind %s %08X\n", TOSYM(key), val);

	BS1_SObj_BindSlot(ctx->self, key, val);
}

void BS1_SVM_LexBind(BS1_SVMState *ctx, elem key, elem val)
{
	int i;

	if(ctx->klenv && !ctx->vlenv)
	{
		i=ctx->stackpos++;
		while(i>ctx->eargs)
		{
			ctx->stack[i]=ctx->stack[i-1];
			i--;
		}

		i=ctx->eargs++;
		SET(ctx->stack[i], val);
		SET(ctx->klenv, CONS(key, ctx->klenv));
		return;
	}

	SET(ctx->klenv, CONS(key, ctx->klenv));
	SET(ctx->vlenv, CONS(val, ctx->vlenv));
}

void BS1_SVM_DynBind(BS1_SVMState *ctx, elem key, elem val)
{
//	SET(ctx->kdenv, CONS(key, ctx->kdenv));
//	SET(ctx->vdenv, CONS(val, ctx->vdenv));
}

elem BS1_SVM_LoadIndex(BS1_SVMState *ctx, elem obj, elem key)
{
	elem c, t;
	int i;

	if(BS1_ARRAYP(obj))
	{
		i=BS1_TY_GetInt(key);
		t=BS1_TY_GetArrayElem(obj, i);
		return(t);
	}

	if(BS1_TY_GetType(obj)==BS1_TYH_OBJECT)
	{
		t=BS1_SObj_GetSlot(obj, key);
		return(t);
	}

	if(BS1_CONSP(obj))
	{
		c=obj; i=TOINT(key);
		while(BS1_CONSP(c) && i)
			{ i--; c=CDR(c); }
		if(BS1_CONSP(c))return(CAR(c));

		return(BS1_MM_NULL);
	}

	if(BS1_FVECTORP(obj))
	{
		t=FLONUM(BS1_TYVec_GetVecVal(obj, TOINT(key)));
		return(t);
	}

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_GetSlot(obj, key);
		return(t);
	}

	t=BS1_TY_LoadIndex(obj, key);
	return(t);

//	return(BS1_MM_NULL);
}

void BS1_SVM_StoreIndex(BS1_SVMState *ctx, elem obj, elem key, elem val)
{
	elem c;
	int i;

	if(BS1_ARRAYP(obj))
	{
		i=BS1_TY_GetInt(key);
		BS1_TY_SetArrayElem(obj, i, val);
		return;
	}

	if(BS1_TY_GetType(obj)==BS1_TYH_OBJECT)
	{
		BS1_SObj_SetSlot(obj, key, val);
		return;
	}

	if(BS1_CONSP(obj))
	{
		c=obj; i=TOINT(key);
		while(BS1_CONSP(c) && i)
			{ i--; c=CDR(c); }
		if(BS1_CONSP(c))BS1_TY_SetCar(c, val);

		return;
	}

	if(BS1_FVECTORP(obj))
	{
		BS1_TYVec_SetVecVal(obj, TOINT(key), TOFLOAT(val));
		return;
	}

	if(BS1_HANDLEP(obj))
	{
		BS1_TYHDL_SetSlot(obj, key, val);
		return;
	}

	BS1_TY_StoreIndex(obj, key, val);
}

elem BS1_SVM_Unary(BS1_SVMState *ctx, int i, elem obj)
{
	elem t;
	t=BS1_Opr_Unary(i, obj);
	BS1_GC_CheckRef(obj);
	return(t);
}

elem BS1_SVM_Binary(BS1_SVMState *ctx, int i, elem tl, elem tr)
{
	elem t;
	t=BS1_Opr_Binary(i, tl, tr);
	BS1_GC_CheckRef(tl);
	BS1_GC_CheckRef(tr);
	return(t);
}

#if 0
void BS1_SVM_PushFrame(BS1_SVMState *ctx)
{
	BS1_SVMFrame *frm;
	int i;

	i=ctx->flowstackpos++;
	if(i<0)return;

	frm=ctx->flowstack[i];
	if(!frm)
	{
		frm=malloc(sizeof(BS1_SVMFrame));
		memset(frm, 0, sizeof(BS1_SVMFrame));
		ctx->flowstack[i]=frm;
	}

	SET(frm->self, ctx->self);
	SET(frm->lit, ctx->lit);
	SET(frm->func, ctx->func);
	SET(frm->klenv, ctx->klenv);
	SET(frm->vlenv, ctx->vlenv);
//	SET(frm->kdenv, ctx->kdenv);
//	SET(frm->vdenv, ctx->vdenv);

	frm->ip=ctx->ip;

	frm->iv[0]=ctx->args;
	frm->iv[1]=ctx->eargs;

#ifdef BS1_JIT
	frm->thunk=ctx->thunk;
#endif
}

void BS1_SVM_PopFrame(BS1_SVMState *ctx)
{
	BS1_SVMFrame *frm;
	int i;

	ctx->flowstackpos--;
	i=ctx->flowstackpos;

	if(i<0)
	{
		CLEAR(ctx->self);	CLEAR(ctx->lit);
		CLEAR(ctx->func);
		CLEAR(ctx->klenv);	CLEAR(ctx->vlenv);
//		CLEAR(ctx->kdenv);	CLEAR(ctx->vdenv);
		return;
	}

	frm=ctx->flowstack[i];
	SET(ctx->self, frm->self);
	SET(ctx->lit, frm->lit);
	SET(ctx->func, frm->func);
	SET(ctx->klenv, frm->klenv);
	SET(ctx->vlenv, frm->vlenv);
//	SET(ctx->kdenv, frm->kdenv);
//	SET(ctx->vdenv, frm->vdenv);

	ctx->ip=frm->ip;
	ctx->args=frm->iv[0];
	ctx->eargs=frm->iv[1];

#ifdef BS1_JIT
	ctx->thunk=frm->thunk;
#endif


#if 0
	//in the name of proper ref counts
	CLEAR(frm->self);
	CLEAR(frm->lit);
	CLEAR(frm->func);
	CLEAR(frm->klenv);
	CLEAR(frm->vlenv);
//	CLEAR(frm->kdenv);
//	CLEAR(frm->vdenv);
	frm->ip=NULL;
#endif
}
#endif


#if 1
void BS1_SVM_PushFrame(BS1_SVMState *ctx)
{
	BS1_SVMFrame *frm;
	int i;

	i=ctx->flowstackpos++;
	if(i<0)return;

	frm=ctx->flowstack[i];
	if(!frm)
	{
		frm=malloc(sizeof(BS1_SVMFrame));
		memset(frm, 0, sizeof(BS1_SVMFrame));
		ctx->flowstack[i]=frm;
	}

	frm->self=ctx->self;
	frm->lit=ctx->lit;
	frm->func=ctx->func;
	frm->klenv=ctx->klenv;
	frm->vlenv=ctx->vlenv;

	ctx->self=BS1_MM_NULL;
	ctx->lit=BS1_MM_NULL;
	ctx->func=BS1_MM_NULL;
	ctx->klenv=BS1_MM_NULL;
	ctx->vlenv=BS1_MM_NULL;

	frm->ip=ctx->ip;

	frm->iv[0]=ctx->args;
	frm->iv[1]=ctx->eargs;

#ifdef BS1_JIT
	frm->thunk=ctx->thunk;
#endif
}

void BS1_SVM_PopFrame(BS1_SVMState *ctx)
{
	BS1_SVMFrame *frm;
	int i;

	ctx->flowstackpos--;
	i=ctx->flowstackpos;

#ifdef BS1_FRAMEREFS
	CLEAR(ctx->self);	CLEAR(ctx->lit);
	CLEAR(ctx->func);
	CLEAR(ctx->klenv);	CLEAR(ctx->vlenv);
//	CLEAR(ctx->kdenv);	CLEAR(ctx->vdenv);
#endif

	if(i<0)return;

	frm=ctx->flowstack[i];
	ctx->self=frm->self;
	ctx->lit=frm->lit;
	ctx->func=frm->func;
	ctx->klenv=frm->klenv;
	ctx->vlenv=frm->vlenv;

	ctx->ip=frm->ip;
	ctx->args=frm->iv[0];
	ctx->eargs=frm->iv[1];

#ifdef BS1_JIT
	ctx->thunk=frm->thunk;
#endif

}
#endif


void BS1_SVM_BindArgs(BS1_SVMState *ctx, elem kl, elem vl)
{
	elem kc, vc;

	if((kl==BS1_MM_NULL) && (vl==BS1_MM_NULL))
		return;

//	kc=kl; vc=vl; kl=BS1_MM_NULL; vl=BS1_MM_NULL;
//	while(BS1_CONSP(kc) && BS1_CONSP(vc))
//		{ kl=kc; vl=vc; kc=CDR(kc); vc=CDR(vc); }

	kc=kl; vc=vl;
	while(BS1_CONSP(kc) && BS1_CONSP(vc))
	{
		if(BS1_CONSP(CAR(kc)))
		{
			SET(ctx->klenv, CONS(CADAR(kc), ctx->klenv));
			SET(ctx->vlenv, CONS(CAR(vc), ctx->vlenv));
			kc=CDR(kc); vc=CDR(vc);
			continue;
		}

		if(!BS1_SYMBOLP(CAR(kc)))
		{
			kc=CDR(kc); vc=CDR(vc);
			continue;
		}

		SET(ctx->klenv, CONS(CAR(kc), ctx->klenv));
		SET(ctx->vlenv, CONS(CAR(vc), ctx->vlenv));
		kc=CDR(kc); vc=CDR(vc);
	}

	if(BS1_SYMBOLP(kc))
	{
		SET(ctx->klenv, CONS(kc, ctx->klenv));
		SET(ctx->vlenv, CONS(vc, ctx->vlenv));
	}
}

void BS1_SVM_CallObj(BS1_SVMState *ctx, elem obj, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	BS1_SVMBuiltin *bfcn;
	elem t, u, l, x;

//	printf("call %s\n", BS1_TY_GetTypeName(f));

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		blk=BS1_TY_GetObjData(f);

#ifdef BS1_BLKSTKARGS
		if(blk->fargs)
		{
			BS1_SVM_PushFrame(ctx);

#ifdef BS1_FRAMEREFS
			SET(ctx->self, obj);
			SET(ctx->lit, blk->lit);
			SET(ctx->func, f);
			SET(ctx->klenv, blk->fargs);
			SET(ctx->vlenv, BS1_MM_NULL);
#else
			ctx->self=obj;
			ctx->lit=blk->lit;
			ctx->func=f;
			ctx->klenv=blk->fargs;
			ctx->vlenv=BS1_MM_NULL;
#endif

			ctx->ip=blk->body;
			ctx->args=ctx->markstack[ctx->markstackpos-1];
			ctx->eargs=ctx->stackpos;

#ifdef BS1_JIT
			ctx->thunk=blk->thunk;
#endif
			return;
		}
#endif

		l=BS1_SVM_PopList(ctx);
		BS1_SVM_PushFrame(ctx);

#ifdef BS1_FRAMEREFS
		SET(ctx->self, obj);
		SET(ctx->lit, blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, BS1_MM_NULL);
		SET(ctx->vlenv, BS1_MM_NULL);
#else
		ctx->self=obj;
		ctx->lit=blk->lit;
		ctx->func=f;
		ctx->klenv=BS1_MM_NULL;
		ctx->vlenv=BS1_MM_NULL;
#endif

#ifdef BS1_JIT
		ctx->thunk=blk->thunk;
#endif
		ctx->ip=blk->body;
		BS1_SVM_BindArgs(ctx, blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMLAMBDA)
	{
		l=BS1_SVM_PopList(ctx);
		BS1_SVM_PushFrame(ctx);

		lmb=BS1_TY_GetObjData(f);

#ifdef BS1_FRAMEREFS
		SET(ctx->self, obj);
		SET(ctx->lit, lmb->blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, lmb->lkey);
		SET(ctx->vlenv, lmb->lval);
#else
		ctx->self=obj;
		ctx->lit=lmb->blk->lit;
		ctx->func=f;
		ctx->klenv=lmb->lkey;
		ctx->vlenv=lmb->lval;
#endif

#ifdef BS1_JIT
		ctx->thunk=lmb->blk->thunk;
#endif

		ctx->ip=lmb->blk->body;
		BS1_SVM_BindArgs(ctx, lmb->blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBUILTIN)
	{
		l=BS1_SVM_PopList(ctx);
		bfcn=BS1_TY_GetObjData(f);

//		printf("Builtin %s\n", bfcn->name);

		u=BS1_MM_NULL; x=BS1_MM_NULL;
		SET(u, ctx->self);
		SET(x, ctx->func);
		SET(ctx->self, obj);
		SET(ctx->func, f);

		t=bfcn->fcn(ctx, l);
		SET(ctx->self, u);
		SET(ctx->func, x);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_HANDLEP(f))
	{
		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_Call(f, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	l=BS1_SVM_PopList(ctx);
	t=BS1_TY_Call(obj, f, l);
	BS1_SVM_Push(ctx, t);
	BS1_GC_CheckRef(l);
	return;
}

void BS1_SVM_TailCallObj(BS1_SVMState *ctx, elem obj, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	BS1_SVMBuiltin *bfcn;
	elem t, l, x;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		blk=BS1_TY_GetObjData(f);

#ifdef BS1_BLKSTKARGS
		if(blk->fargs)
		{
			BS1_SVM_PushFrame(ctx);

#ifdef BS1_FRAMEREFS
			SET(ctx->self, obj);
			SET(ctx->lit, blk->lit);
			SET(ctx->func, f);
			SET(ctx->klenv, blk->fargs);
			SET(ctx->vlenv, BS1_MM_NULL);
#else
			ctx->self=obj;
			ctx->lit=blk->lit;
			ctx->func=f;
			ctx->klenv=blk->fargs;
			ctx->vlenv=BS1_MM_NULL;
#endif

			ctx->ip=blk->body;
			ctx->args=ctx->markstack[ctx->markstackpos-1];
			ctx->eargs=ctx->stackpos;
#ifdef BS1_JIT
			ctx->thunk=blk->thunk;
#endif
			return;
		}
#endif

		l=BS1_SVM_PopList(ctx);

#ifdef BS1_FRAMEREFS
		SET(ctx->self, obj);
		SET(ctx->lit, blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, BS1_MM_NULL);
		SET(ctx->vlenv, BS1_MM_NULL);
#else
		ctx->self=obj;
		ctx->lit=blk->lit;
		ctx->func=f;
		ctx->klenv=BS1_MM_NULL;
		ctx->vlenv=BS1_MM_NULL;
#endif

		ctx->ip=blk->body;
#ifdef BS1_JIT
		ctx->thunk=blk->thunk;
#endif
		BS1_SVM_BindArgs(ctx, blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMLAMBDA)
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		lmb=BS1_TY_GetObjData(f);

#ifdef BS1_FRAMEREFS
		SET(ctx->self, obj);
		SET(ctx->lit, lmb->blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, lmb->lkey);
		SET(ctx->vlenv, lmb->lval);
#else
		ctx->self=obj;
		ctx->lit=lmb->blk->lit;
		ctx->func=f;
		ctx->klenv=lmb->lkey;
		ctx->vlenv=lmb->lval;
#endif

		ctx->ip=lmb->blk->body;
#ifdef BS1_JIT
		ctx->thunk=lmb->blk->thunk;
#endif
		BS1_SVM_BindArgs(ctx, lmb->blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBUILTIN)
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		bfcn=BS1_TY_GetObjData(f);

		x=BS1_MM_NULL;
		SET(x, ctx->func);

		SET(ctx->self, obj);
		SET(ctx->func, f);
		t=bfcn->fcn(ctx, l);
		SET(ctx->func, x);

		BS1_SVM_PopFrame(ctx);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_HANDLEP(f))
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_Call(f, l);
		BS1_SVM_PopFrame(ctx);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	if(ctx->klenv && !ctx->vlenv)
		BS1_SVM_ShiftMark(ctx);
	l=BS1_SVM_PopList(ctx);
	t=BS1_TY_Call(obj, f, l);
	BS1_SVM_Push(ctx, t);
	BS1_GC_CheckRef(l);
	return;
}

void BS1_SVM_MethodCall(BS1_SVMState *ctx, elem obj, elem key)
{
	elem f, t, l;

	if(BS1_HANDLEP(obj))
	{
		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_CallMethod(obj, key, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	if(BS1_TY_HasMethodCall(obj))
	{
		l=BS1_SVM_PopList(ctx);
		t=BS1_TY_MethodCall(obj, key, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	f=BS1_SVM_LoadIndex(ctx, obj, key);
	BS1_SVM_CallObj(ctx, obj, f);
}

void BS1_SVM_MethodTailCall(BS1_SVMState *ctx, elem obj, elem key)
{
	elem f, t, l;

	if(BS1_HANDLEP(obj))
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_CallMethod(obj, key, l);
		BS1_SVM_PopFrame(ctx);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	if(BS1_TY_HasMethodCall(obj))
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		t=BS1_TY_MethodCall(obj, key, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	f=BS1_SVM_LoadIndex(ctx, obj, key);
	BS1_SVM_TailCallObj(ctx, obj, f);
}

elem BS1_SVM_Close(BS1_SVMState *ctx, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	elem t;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		blk=BS1_TY_GetObjData(f);
		BS1_GC_IncRef(f);

		t=BS1_MM_AllocObj(BS1_TYH_SVMLAMBDA, sizeof(BS1_SVMLambda));
		lmb=BS1_TY_GetObjData(t);
		SET(lmb->lkey, ctx->klenv);
		SET(lmb->lval, ctx->vlenv);
		lmb->blk=blk;
		return(t);
	}

	return(f);
}

elem BS1_SVM_Cast(BS1_SVMState *ctx, elem ty, elem t)
{
	if(ty==KEYSYM("int"))
	{
		if(BS1_FIXNUMP(t))return(t);
		if(BS1_FLONUMP(t))return(FIXNUM(TOFLOAT(t)));
		return(BS1_MM_NULL);
	}

	if(ty==KEYSYM("float"))
	{
		if(BS1_FIXNUMP(t))return(FLONUM(TOINT(t)));
		if(BS1_FLONUMP(t))return(t);
		return(BS1_MM_NULL);
	}

	return(t);
}

elem BS1_SVM_ReadID(BS1_SVMState *ctx)
{
	elem t;
	int i;

	i=*ctx->ip++;
	if(i&128)i=((i&127)<<8)|(*ctx->ip++);
	t=BS1_TY_GetArrayElem2(ctx->lit, i);
	return(t);
}

int BS1_SVM_ReadIDX(BS1_SVMState *ctx)
{
	int i;
	i=*ctx->ip++;
	if(i&128)i=((i&127)<<8)|(*ctx->ip++);
	return(i);
}

int BS1_SVM_DumpOpcode(BS1_SVMState *ctx)
{
	char *bops[]={"add", "sub", "mul", "div", "mod", "and", "or",
		"xor", "shl", "shr", "eq", "eqv", "neq", "neqv", "l",
		"g", "le", "ge"};

	elem t;
	byte *ip, *ip1;
	char *s;
	int i, j, k;

	ip=ctx->ip;

	i=*ip++;
	if(i>=192)
	{
		i=(i-192)*256+(*ip++);
		printf("%08X %02X%02X ", ctx->ip,
			ctx->ip[0], ctx->ip[1]);
	}else
	{
		printf("%08X %02X ", ctx->ip, i);
	}

	k=0; s=bs1_ops_args[i]; ip1=ip;
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T') || (*s=='N'))
			{ j=*ip1++; k++; if(j&128)k++; s++; continue; }
		if(*s=='A') { ip1+=2; k+=2; s++; continue; }

		if(*s=='C') { ip1++; k++; s++; continue; }
		if(*s=='B') { ip1++; k++; s++; continue; }
		if(*s=='W') { ip1++; k+=2; s++; continue; }
		if(*s=='H') { ip1++; k+=2; s++; continue; }

		if(*s=='u') { ip1++; k++; s++; continue; }
		if(*s=='b') { ip1++; k++; s++; continue; }

		s++;
	}

	ip1=ip;
	for(j=0; j<k; j++)printf("%02X", *ip1++);

	if(i<192)printf("  ");
	for(; j<4; j++)printf("  ");

	printf(" %s ", bs1_ops_strs[i]);

	s=bs1_ops_args[i];
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T'))
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			t=BS1_TY_GetArrayElem2(ctx->lit, i);
			BS1_TY_Print(t);
			printf(" ");
			s++;
			continue;
		}
		if(*s=='N')
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			printf("%d ", i);
			s++;
			continue;
		}
		if(*s=='A')
		{
			i=*ip++; i|=(*ip++)<<8;
			printf("%08X ", ip+i);
			s++;
			continue;
		}
		if(*s=='C') { i=(signed char)(*ip++); printf("%d ", i);
			s++; continue; }
		if(*s=='B') { i=*ip++; printf("%d ", i); s++; continue; }
		if(*s=='W') { i=*ip++; i|=(*ip++)<<8; printf("%d ", i);
			s++; continue; }
		if(*s=='H') { i=*ip++; i|=(*ip++)<<8; printf("%g ", i/100.0);
			s++; continue; }

		if(*s=='b') { i=*ip++; printf("%s ", bops[i]); s++; continue; }
		s++;
	}

	printf("\n");
}

void BS1_SVM_StepJmpBool(BS1_SVMState *ctx, int j)
{
	int i;

	i=*ctx->ip++;
	i|=(*ctx->ip++)<<8;
	i=((signed short)i);
	if(j)ctx->ip+=i;
}

int BS1_SVM_StepC1(BS1_SVMState *ctx)
{
	elem t, u, v;
	int i, j;

	i=256+(*ctx->ip++);
	switch(i)
	{
	case BS1_SOP_JMP_L_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_L_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<TOFLOAT(v));
		break;
	case BS1_SOP_JMP_G_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>TOFLOAT(v));
		break;
	case BS1_SOP_JMP_LE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<=TOFLOAT(v));
		break;
	case BS1_SOP_JMP_GE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>=TOFLOAT(v));
		break;

	case BS1_SOP_JMP_E_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
//		u=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
//		v=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
		BS1_SVM_StepJmpBool(ctx, u==v);
		break;
	case BS1_SOP_JMP_NE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u!=v);
		break;
	case BS1_SOP_JMP_L_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_E_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;

	case BS1_SOP_JMP_E_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;
	default:
		break;
	}
}

int BS1_SVM_Step(BS1_SVMState *ctx)
{
	elem t, u, v;
	int i, j, k, rs;

//	printf("%d ", *ctx->ip);
//	BS1_SVM_DumpOpcode(ctx);

	i=*ctx->ip++;
	if(i>=192)i=(i-192)*256+(*ctx->ip++);

	rs=0;
//	switch(*ctx->ip++)
	switch(i)
	{
	case BS1_SOP_NOP:
		break;
	case BS1_SOP_BLOCK:
		rs=1;
		break;
	case BS1_SOP_DBGMARK:
		break;
	case BS1_SOP_CGENAST:
		break;

	case BS1_SOP_PUSH:
		t=BS1_SVM_ReadID(ctx);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_POP:
		BS1_SVM_PopDestroy(ctx);
		break;
	case BS1_SOP_LOAD:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_STORE:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_Assign(ctx, t, u);
		break;
	case BS1_SOP_BIND:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_Bind(ctx, t, u);
		break;
	case BS1_SOP_DYNBIND:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_DynBind(ctx, t, u);
		break;
	case BS1_SOP_LEXBIND:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_LexBind(ctx, t, u);
		break;

	case BS1_SOP_LOADINDEX:
		u=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, u);
		BS1_SVM_Push(ctx, v);
		break;
	case BS1_SOP_STOREINDEX:
		v=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, u, v);
		break;
	case BS1_SOP_LOADINDEX_S:
		u=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, u);
		BS1_SVM_Push(ctx, v);
		break;
	case BS1_SOP_STOREINDEX_S:
		u=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, u, v);
		break;

	case BS1_SOP_LOADINDEX_I:
		u=FIXNUM(*ctx->ip++);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, u);
		BS1_SVM_Push(ctx, v);
		break;
	case BS1_SOP_STOREINDEX_I:
		u=FIXNUM(*ctx->ip++);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, u, v);
		break;

	case BS1_SOP_LOADINDEX_0:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_0);
		BS1_SVM_Push(ctx, v); break;
	case BS1_SOP_LOADINDEX_1:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_1);
		BS1_SVM_Push(ctx, v); break;
	case BS1_SOP_LOADINDEX_2:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_2);
		BS1_SVM_Push(ctx, v); break;
	case BS1_SOP_LOADINDEX_3:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_3);
		BS1_SVM_Push(ctx, v); break;

	case BS1_SOP_STOREINDEX_0:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_0, u); break;
	case BS1_SOP_STOREINDEX_1:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_1, u); break;
	case BS1_SOP_STOREINDEX_2:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_2, u); break;
	case BS1_SOP_STOREINDEX_3:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_3, u); break;

	case BS1_SOP_PUSHSELF:
		BS1_SVM_PushF(ctx, ctx->self);
		break;
	case BS1_SOP_PUSH_NULL:
		BS1_SVM_PushF(ctx, BS1_MM_NULL);
		break;
	case BS1_SOP_PUSH_TRUE:
		BS1_SVM_PushF(ctx, BS1_MM_TRUE);
		break;
	case BS1_SOP_PUSH_FALSE:
		BS1_SVM_PushF(ctx, BS1_MM_FALSE);
		break;
	case BS1_SOP_PUSH_SV:
		i=(signed char)(*ctx->ip++);
		BS1_SVM_PushF(ctx, FIXNUM(i));
		break;
	case BS1_SOP_PUSH_SV_P:
		i=*ctx->ip++;
		BS1_SVM_PushF(ctx, FIXNUM(i));
		break;
	case BS1_SOP_PUSH_SV_N:
		i=*ctx->ip++;
		BS1_SVM_PushF(ctx, FIXNUM(-i));
		break;
	case BS1_SOP_PUSH_SV_F:
		i=*ctx->ip++;
		i+=(*ctx->ip++)<<8;
		BS1_SVM_PushF(ctx, FLONUM(((short)i)/100.0));
		break;
	case BS1_SOP_PUSH_0: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_0); break;
	case BS1_SOP_PUSH_1: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_1); break;
	case BS1_SOP_PUSH_2: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_2); break;
	case BS1_SOP_PUSH_3: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_3); break;
	case BS1_SOP_PUSH_4: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_4); break;
	case BS1_SOP_PUSH_5: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_5); break;
	case BS1_SOP_PUSH_6: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_6); break;
	case BS1_SOP_PUSH_7: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_7); break;
	case BS1_SOP_PUSH_CF: BS1_SVM_Push(ctx, ctx->func); break;

	case BS1_SOP_LLOAD:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_LSTORE:
		i=*ctx->ip++;
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_AssignIdx(ctx, i, t);
		break;
	case BS1_SOP_LLOAD_F:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_PushF(ctx, t);
		break;
	case BS1_SOP_LSTORE_F:
		i=*ctx->ip++;
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_AssignIdxF(ctx, i, t);
		break;
	case BS1_SOP_LLOAD_F2:
		i=*ctx->ip++;
		t=ctx->stack[ctx->eargs-i-1];
		ctx->stack[ctx->stackpos++]=t;
		break;
	case BS1_SOP_LSTORE_F2:
		i=*ctx->ip++;
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->eargs-i-1]=t;
		break;

	case BS1_SOP_LINC_FN:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_AssignIdxF(ctx, i, t+4);
		break;
	case BS1_SOP_LDEC_FN:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_AssignIdxF(ctx, i, t-4);
		break;
	case BS1_SOP_LINC_FN2:
		i=*ctx->ip++;
		ctx->stack[ctx->eargs-i-1]+=4;
		break;
	case BS1_SOP_LDEC_FN2:
		i=*ctx->ip++;
		ctx->stack[ctx->eargs-i-1]-=4;
		break;

	case BS1_SOP_CLEARENV: break;
	case BS1_SOP_BINDPATTERN: break;
	case BS1_SOP_LOADMINDEX: break;
	case BS1_SOP_STOREMINDEX: break;

	case BS1_SOP_TRYLOAD:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_Push(ctx, t);
		break;

	case BS1_SOP_CAST:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Cast(ctx, t, u);
		BS1_SVM_Push(ctx, u);
		break;

	case BS1_SOP_MARK:
		ctx->markstack[ctx->markstackpos++]=ctx->stackpos;
		break;

	case BS1_SOP_CALL:
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_CallObj(ctx, ctx->self, t);
		break;
	case BS1_SOP_TAILCALL:
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_TailCallObj(ctx, ctx->self, t);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;
	case BS1_SOP_CALL_S:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_CallObj(ctx, ctx->self, t);
		break;
	case BS1_SOP_TAILCALL_S:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_TailCallObj(ctx, ctx->self, t);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;

	case BS1_SOP_METHODCALL:
		t=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodCall(ctx, u, t);
		break;
	case BS1_SOP_METHODTAILCALL:
		t=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodTailCall(ctx, u, t);
		break;
	case BS1_SOP_METHODCALL_S:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodCall(ctx, u, t);
		break;
	case BS1_SOP_METHODTAILCALL_S:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodTailCall(ctx, u, t);
		break;

	case BS1_SOP_RET:
#ifdef BS1_BLKSTKARGS
		if(ctx->klenv && !ctx->vlenv)
		{
			t=BS1_SVM_PopF(ctx);
			BS1_SVM_PopMark(ctx);
//			ctx->args=ctx->markstack[ctx->markstackpos-1];
//			ctx->eargs=ctx->stackpos;
			BS1_SVM_PushF(ctx, t);
		}
#endif

		BS1_SVM_PopFrame(ctx);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;

	case BS1_SOP_CALL_CF:
		BS1_SVM_CallObj(ctx, ctx->self, ctx->func);
		break;
	case BS1_SOP_TAILCALL_CF:
		BS1_SVM_TailCallObj(ctx, ctx->self, ctx->func);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;

	case BS1_SOP_CAR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CAR(t)); break;
	case BS1_SOP_CDR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CDR(t)); break;
	case BS1_SOP_CAAR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CAAR(t)); break;
	case BS1_SOP_CDAR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CDAR(t)); break;
	case BS1_SOP_CADR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CADR(t)); break;
	case BS1_SOP_CDDR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CDDR(t)); break;

	case BS1_SOP_CLOSE:
		t=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Close(ctx, t);
		BS1_SVM_Push(ctx, t);
		break;

	case BS1_SOP_DUP:
//		t=BS1_SVM_PopF(ctx);
//		BS1_SVM_PushF(ctx, t);
//		BS1_SVM_Push(ctx, t);
		BS1_SVM_Push(ctx, ctx->stack[ctx->stackpos-1]);
		break;
	case BS1_SOP_DUP_F:
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_PushF(ctx, t);
		BS1_SVM_PushF(ctx, t);
		break;
	case BS1_SOP_EXCH:
		u=BS1_SVM_PopF(ctx);
		v=BS1_SVM_PopF(ctx);
		BS1_SVM_PushF(ctx, u);
		BS1_SVM_PushF(ctx, v);
		break;
	case BS1_SOP_INDEX:
		i=BS1_SVM_ReadIDX(ctx);
		t=ctx->stack[ctx->stackpos-(i+1)];
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_RINDEX:
		i=BS1_SVM_ReadIDX(ctx);
		j=ctx->markstack[ctx->markstackpos-1];
		t=ctx->stack[i+j];
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_SETINDEX:
		t=BS1_SVM_Pop(ctx);
		i=BS1_SVM_ReadIDX(ctx);
		ctx->stack[ctx->stackpos-(i+1)]=t;
		break;
	case BS1_SOP_SETRINDEX:
		t=BS1_SVM_Pop(ctx);
		i=BS1_SVM_ReadIDX(ctx);
		j=ctx->markstack[ctx->markstackpos-1];
		ctx->stack[i+j]=t;
		break;

	case BS1_SOP_DUP_R:
		i=*ctx->ip++;
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_Push(ctx, t);
		SET(ctx->reg[i], t);
		break;
	case BS1_SOP_DUP_RF:
		i=*ctx->ip++;
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_PushF(ctx, t);
		ctx->reg[i]=t;
		break;
	case BS1_SOP_PUSH_R:
		i=*ctx->ip++;
		BS1_SVM_Push(ctx, ctx->reg[i]);
		break;
	case BS1_SOP_PUSH_RF:
		i=*ctx->ip++;
		BS1_SVM_PushF(ctx, ctx->reg[i]);
		break;
	case BS1_SOP_POP_R:
		i=*ctx->ip++;
		t=BS1_SVM_PopF(ctx);
		ctx->reg[i]=t;
		break;

	case BS1_SOP_UNARYOP:
		i=*ctx->ip++;
		t=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Unary(ctx, i, t);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_BINARYOP:
		i=*ctx->ip++;
		v=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Binary(ctx, i, u, v);
		BS1_SVM_Push(ctx, t);
		break;

	case BS1_SOP_JMP:
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		ctx->ip+=i;
		break;
	case BS1_SOP_JMP_TRUE:
//		j=BS1_TY_GetBool(BS1_SVM_Pop(ctx));
		j=BS1_SVM_PopBool(ctx);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(j)ctx->ip+=i;
		break;
	case BS1_SOP_JMP_FALSE:
//		j=BS1_TY_GetBool(BS1_SVM_Pop(ctx));
		j=BS1_SVM_PopBool(ctx);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(!j)ctx->ip+=i;
		break;

	case BS1_SOP_JMP_COND_U:
		j=*ctx->ip++;
		j=BS1_Opr_CondUnary(j, BS1_SVM_Pop(ctx));
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(j)ctx->ip+=i;
		break;
	case BS1_SOP_JMP_COND_B:
		v=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		j=*ctx->ip++;
		j=BS1_Opr_CondBinary(j, u, v);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(j)ctx->ip+=i;
		break;

	case BS1_SOP_LIST:
		t=BS1_SVM_PopList2(ctx);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_DICT:
		t=BS1_SVM_PopList(ctx);
		u=BS1_SObj_New();
		v=t;
		while(BS1_CONSP(v))
		{
			BS1_SObj_BindSlot(u, CAR(v), CADR(v));
			v=CDDR(v);
		}
		BS1_GC_CheckRef(t);
		BS1_SVM_Push(ctx, u);
		break;
	case BS1_SOP_VECTOR:
		t=BS1_SVM_PopList(ctx);
		u=BS1_TYVec_List2FVec(t);
		BS1_SVM_Push(ctx, u);
		BS1_GC_CheckRef(t);
		break;
	case BS1_SOP_COMPLEX_I:
		t=BS1_SVM_Pop(ctx);
		t=BS1_COMPLEX_I(TOFLOAT(t));
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_MATRIX:
		t=BS1_SVM_PopList(ctx);
		u=BS1_TYMat_List2FMat(t);
		BS1_SVM_Push(ctx, u);
		BS1_GC_CheckRef(t);
		break;


	case BS1_SOP_INC_FN: ctx->stack[ctx->stackpos-1]+=4; break;
	case BS1_SOP_DEC_FN: ctx->stack[ctx->stackpos-1]-=4; break;
	case BS1_SOP_INC2_FN: ctx->stack[ctx->stackpos-1]+=8; break;
	case BS1_SOP_DEC2_FN: ctx->stack[ctx->stackpos-1]-=8; break;

	case BS1_SOP_ADD_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]+=t&(~3);
		break;
	case BS1_SOP_SUB_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]-=t&(~3);
		break;
	case BS1_SOP_MUL_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)*TOINT(v));
		break;
	case BS1_SOP_DIV_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)/TOINT(v));
		break;
	case BS1_SOP_IDIV_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)/TOINT(v));
		break;
	case BS1_SOP_MOD_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)%TOINT(v));
		break;
	case BS1_SOP_AND_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]&=t;
		break;
	case BS1_SOP_OR_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]|=t;
		break;
	case BS1_SOP_XOR_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]^=t&(~3);
		break;
	case BS1_SOP_CMP_L_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)<((int)v));
		break;
	case BS1_SOP_CMP_G_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)>((int)v));
		break;
	case BS1_SOP_CMP_LE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)<=((int)v));
		break;
	case BS1_SOP_CMP_GE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)>=((int)v));
		break;
	case BS1_SOP_CMP_E_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(u==v);
		break;
	case BS1_SOP_CMP_NE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(u!=v);
		break;

	case BS1_SOP_ADD_FN_C:
		i=*ctx->ip++;
		ctx->stack[ctx->stackpos-1]+=i<<2;
		break;
	case BS1_SOP_SUB_FN_C:
		i=*ctx->ip++;
		ctx->stack[ctx->stackpos-1]-=i<<2;
		break;
	case BS1_SOP_MUL_FN_C:
		i=*ctx->ip++;
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=((t&(~3))*i)|BS1_MM_FIXNUM;
		break;

	case BS1_SOP_SHL_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)<<TOINT(v));
		break;
	case BS1_SOP_SHR_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)>>TOINT(v));
		break;
	case BS1_SOP_EXP_FN:
		i=TOINT(ctx->stack[--ctx->stackpos]);
		j=TOINT(ctx->stack[ctx->stackpos-1]);
		k=1; while(i--)k*=j;
		ctx->stack[ctx->stackpos-1]=FIXNUM(k);
		break;

	case BS1_SOP_SHL_FN_C:
		i=*ctx->ip++;
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=((t>>2)<<(i+2))|BS1_MM_FIXNUM;
		break;
	case BS1_SOP_SHR_FN_C:
		i=*ctx->ip++;
		j=TOINT(ctx->stack[ctx->stackpos-1]);
		ctx->stack[ctx->stackpos-1]=((j>>i)<<2)|BS1_MM_FIXNUM;
		break;
	case BS1_SOP_EXP_FN_C:
		i=*ctx->ip++;
		j=TOINT(ctx->stack[ctx->stackpos-1]);
		k=1; while(i--)k*=j;
		ctx->stack[ctx->stackpos-1]=FIXNUM(k);
		break;

	case BS1_SOP_CONV_FN2FL:
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOINT(t));
		break;
	case BS1_SOP_CONV_FL2FN:
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(((int)TOFLOAT(t)));
		break;

	case BS1_SOP_ADD_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)+TOFLOAT(v));
		break;
	case BS1_SOP_SUB_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)-TOFLOAT(v));
		break;
	case BS1_SOP_MUL_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)*TOFLOAT(v));
		break;
	case BS1_SOP_DIV_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)/TOFLOAT(v));
		break;
	case BS1_SOP_CMP_L_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)<TOFLOAT(v));
		break;
	case BS1_SOP_CMP_G_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)>TOFLOAT(v));
		break;
	case BS1_SOP_CMP_LE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)<=TOFLOAT(v));
		break;
	case BS1_SOP_CMP_GE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)>=TOFLOAT(v));
		break;
	case BS1_SOP_CMP_E_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)==TOFLOAT(v));
		break;
	case BS1_SOP_CMP_NE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)!=TOFLOAT(v));
		break;
	case BS1_SOP_NEG_FL:
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(-TOFLOAT(t));
		break;

	case BS1_SOP_JMP_E_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u==v);
		break;
	case BS1_SOP_JMP_NE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u!=v);
		break;
	case BS1_SOP_JMP_E_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)==TOFLOAT(v));
		break;
	case BS1_SOP_JMP_NE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)!=TOFLOAT(v));
		break;

	case 0xC1:
		BS1_SVM_StepC1(ctx);
		break;

#if 1
	case BS1_SOP_JMP_L_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_L_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<TOFLOAT(v));
		break;
	case BS1_SOP_JMP_G_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>TOFLOAT(v));
		break;
	case BS1_SOP_JMP_LE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<=TOFLOAT(v));
		break;
	case BS1_SOP_JMP_GE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>=TOFLOAT(v));
		break;

	case BS1_SOP_JMP_E_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
//		u=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
//		v=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
		BS1_SVM_StepJmpBool(ctx, u==v);
		break;
	case BS1_SOP_JMP_NE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u!=v);
		break;
	case BS1_SOP_JMP_L_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_E_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;

	case BS1_SOP_JMP_E_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;


	case BS1_SOP_JMP_E_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t==u);
		break;
	case BS1_SOP_JMP_NE_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t!=u);
		break;
	case BS1_SOP_JMP_L_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<u);
		break;
	case BS1_SOP_JMP_G_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>u);
		break;
	case BS1_SOP_JMP_LE_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<=u);
		break;
	case BS1_SOP_JMP_GE_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>=u);
		break;

	case BS1_SOP_JMP_E_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t==u);
		break;
	case BS1_SOP_JMP_NE_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t!=u);
		break;
	case BS1_SOP_JMP_L_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<u);
		break;
	case BS1_SOP_JMP_G_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>u);
		break;
	case BS1_SOP_JMP_LE_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<=u);
		break;
	case BS1_SOP_JMP_GE_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>=u);
		break;
#endif

	default:
		break;
	}

	return(rs);
}

int BS1_SVM_Run(elem ct)
{
	BS1_SVMState *ctx;
	int rs, i, j, t;

	ctx=BS1_TY_GetObjData(ct);
	rs=0;

//	t=clock();
	i=0;
	while(!rs)
	{
#ifdef BS1_JIT
		if(ctx->thunk)
		{
			rs=ctx->thunk(ctx);
			continue;
		}
#endif

//		printf("%p %p\n", ctx, ctx->ip);
		i++;
		rs=BS1_SVM_Step(ctx);
	}

//	j=clock()-t;
//	if(j)printf("MIPS %g\n", (i/(j/(float)CLOCKS_PER_SEC))/1000000.0);

	bs1_svm_opcnt+=i;

	return(rs);
}

elem BS1_SVM_EvalExprsObj(elem exp, elem obj)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l, f;
	int i;

	cctx=malloc(sizeof(BS1_SVMCState));
	memset(cctx, 0, sizeof(BS1_SVMCState));

	cctx->lvl=-1;
	f=BS1_SComp_CompileBlock(cctx, BS1_MM_NULL, BS1_MM_NULL, exp);

	free(cctx);

	ct=BS1_SVM_NewState();
	ctx=BS1_TY_GetObjData(ct);
	ctx->flowstackpos=-1;

	BS1_SVM_PushList(ctx, BS1_MM_NULL);
	BS1_SVM_CallObj(ctx, obj, f);
	i=BS1_SVM_Run(ct);
	t=BS1_SVM_Pop(ctx);

	BS1_GC_CheckRef(f);
	BS1_GC_CheckRef(ct);

	return(t);
}

elem BS1_SVM_EvalStringS(char *str)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	elem t, ct, l;
	int i;

	l=BS1_ParseS_MultiFromString(str);
	t=BS1_SVM_EvalExprsObj(l, bs1_svm_toplevel);
	BS1_GC_CheckRef(l);

	return(t);
}

elem BS1_SVM_EvalString(char *str)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l;
	int i;

	s=str;
	l=BS1_Parse_Block(&s);
	BS1_TY_PrintLN(l);

	t=BS1_SVM_EvalExprsObj(l, bs1_svm_toplevel);
	BS1_GC_CheckRef(l);

	return(t);
}

elem BS1_SVM_EvalStringObj(char *str, elem obj)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l;
	int i;

	if(obj==BS1_MM_NULL)
		obj=bs1_svm_toplevel;

	BS1_Parse_SetLinenum("<eval-str>", str, 1);

	s=str;
	l=BS1_Parse_Block(&s);
//	BS1_TY_PrintLN(l);

	t=BS1_SVM_EvalExprsObj(l, obj);
	BS1_GC_CheckRef(l);

	return(t);
}

elem BS1_SVM_CallFuncObj(elem obj, elem fcn, elem args)
{
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l, f;
	int i;

	if(obj==BS1_MM_NULL)
		obj=bs1_svm_toplevel;

	if(BS1_SYMBOLP(fcn))
	{
		fcn=BS1_SObj_GetSlot(obj, fcn);
		if(fcn==BS1_MM_NULL)
			return(BS1_MM_NULL);
	}

//	printf("call ");
//	BS1_TY_PrintLN(CONS(fcn, args));

	ct=BS1_SVM_NewState();
	ctx=BS1_TY_GetObjData(ct);
	ctx->flowstackpos=-1;

	BS1_SVM_PushList(ctx, args);
	BS1_SVM_CallObj(ctx, obj, fcn);
	i=BS1_SVM_Run(ct);
	t=BS1_SVM_Pop(ctx);

	BS1_GC_CheckRef(ct);

	return(t);
}
/*
Prototype Objects
 */

#include <bgbscr1.h>

static elem bs1_sobj_stack[256];
static int bs1_sobj_stackpos=0;


//lookup hash

static elem bs1_sobj_findobj;
static elem bs1_sobj_findvar;

static elem bs1_sobj_srchash[4096];
static elem bs1_sobj_dsthash[4096];
static elem bs1_sobj_varhash[4096];
static elem bs1_sobj_valhash[4096];


#if 1
elem BS1_SObj_FlushHash()
{
	int i;
	for(i=0; i<4096; i++)
		bs1_sobj_varhash[i]=BS1_MM_NULL;
	return(BS1_MM_NULL);
}

elem BS1_SObj_FlushHashSlot(elem slot)
{
	int i;
	for(i=0; i<4096; i++)
		if(bs1_sobj_varhash[i]==slot)
			bs1_sobj_varhash[i]=BS1_MM_NULL;
	return(BS1_MM_NULL);
}

elem BS1_SObj_GetHash(elem obj, elem slot)
{
	int i;

	i=(((obj^slot)*251+slot)>>8)&0xFFF;
	if((bs1_sobj_srchash[i]==obj) && (bs1_sobj_varhash[i]==slot))
		return(bs1_sobj_valhash[i]);
	return(BS1_MM_NULL);
}

elem BS1_SObj_SetHash(elem sobj, elem dobj, elem slot, elem val)
{
	int i;

	i=(((sobj^slot)*251+slot)>>8)&0xFFF;
	bs1_sobj_srchash[i]=sobj;
	bs1_sobj_dsthash[i]=dobj;
	bs1_sobj_varhash[i]=slot;
	bs1_sobj_valhash[i]=val;
	return(BS1_MM_NULL);
}

#else

elem BS1_SObj_FlushHash()
	{ return(BS1_MM_NULL); }
elem BS1_SObj_FlushHashSlot(elem slot)
	{ return(BS1_MM_NULL); }
elem BS1_SObj_GetHash(elem obj, elem slot)
	{ return(BS1_MM_UNDEF); }
elem BS1_SObj_SetHash(elem sobj, elem dobj, elem slot, elem val)
	{ return(BS1_MM_NULL); }

#endif


elem BS1_SObj_New()
{
	BS1_Object *tmp;
	elem t;

	t=BS1_MM_AllocObj(BS1_TYH_OBJECT, sizeof(BS1_Object));
	tmp=BS1_TY_GetObjData(t);

	tmp->lkey=BS1_MM_NULL;
	tmp->lval=BS1_MM_NULL;
	tmp->dkey=BS1_MM_NULL;
	tmp->dval=BS1_MM_NULL;
	tmp->nkey=0;

	return(t);
}

elem BS1_SObj_GetSlotR(elem obj, elem slot)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;
	int i;

	t=BS1_SObj_GetHash(obj, slot);
	if(t!=BS1_MM_NULL)return(CAR(t));
	bs1_sobj_findobj=BS1_MM_NULL;
	bs1_sobj_findvar=BS1_MM_NULL;

	for(i=(bs1_sobj_stackpos-1); i>=0; i--)
		if(bs1_sobj_stack[i]==obj)
			return(BS1_MM_NULL);

	if(bs1_sobj_stackpos>=255)return(BS1_MM_NULL);
	bs1_sobj_stack[bs1_sobj_stackpos++]=obj;

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_GetSlot(obj, slot);
		BS1_SObj_SetHash(obj, bs1_sobj_findobj, slot, t);
		bs1_sobj_stackpos--;
		return(t);
	}

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
			{
				bs1_sobj_stackpos--;
				return(CAR(cv));
			}
			ck=CDR(ck); cv=CDR(cv);
		}

		bs1_sobj_stackpos--;
		return(BS1_MM_NULL);
	}

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			bs1_sobj_stackpos--;

			bs1_sobj_findobj=obj;
			bs1_sobj_findvar=cv;
			BS1_SObj_SetHash(obj, obj, slot, cv);
			return(CAR(cv));
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	ck=tmp->dkey; cv=tmp->dval;
	while(ck)
	{
		t=BS1_SObj_GetSlot(CAR(cv), slot);
		if(t!=BS1_MM_NULL)
		{
			BS1_SObj_SetHash(obj, bs1_sobj_findobj,
				slot, bs1_sobj_findvar);
			bs1_sobj_stackpos--;
			return(t);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	bs1_sobj_stackpos--;
	return(BS1_MM_NULL);
}

elem BS1_SObj_GetSlot(elem obj, elem slot)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;
	int i;

	bs1_sobj_stackpos=0;
	t=BS1_SObj_GetSlotR(obj, slot);
	return(t);
}

int BS1_SObj_SetSlotR(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	int i;

	bs1_sobj_findobj=BS1_MM_NULL;
	bs1_sobj_findvar=BS1_MM_NULL;

	for(i=(bs1_sobj_stackpos-1); i>=0; i--)
		if(bs1_sobj_stack[i]==obj)
			return(-1);

	if(bs1_sobj_stackpos>=255)return(-1);
	bs1_sobj_stack[bs1_sobj_stackpos++]=obj;

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_SetSlot(obj, slot, val);
		bs1_sobj_stackpos--;
		return(t);
	}


	tmp=BS1_TY_GetObjData(obj);

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			bs1_sobj_findobj=obj;
			bs1_sobj_findvar=cv;
			BS1_SObj_SetHash(obj, obj, slot, cv);

			BS1_TY_SetCar(cv, val);
			bs1_sobj_stackpos--;
			return(0);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	ck=tmp->dkey; cv=tmp->dval;
	while(ck)
	{
		i=BS1_SObj_SetSlotR(CAR(cv), slot, val);
		if(!i)
		{
			BS1_SObj_SetHash(obj, bs1_sobj_findobj,
				slot, bs1_sobj_findvar);
			bs1_sobj_stackpos--;
			return(0);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	bs1_sobj_stackpos--;
	return(-1);
}

elem BS1_SObj_SetSlot(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;
	int i;

	t=BS1_SObj_GetHash(obj, slot);
	if(t!=BS1_MM_NULL)
	{
		BS1_TY_SetCar(t, val);
		return(BS1_MM_NULL);
	}

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_SetSlot(obj, slot, val);
		return(t);
	}

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		BS1_SObj_FlushHash();

		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
			{
				BS1_TY_SetCar(cv, val);
				return(BS1_MM_NULL);
			}
			ck=CDR(ck); cv=CDR(cv);
		}

		SET(tmp->dkey, CONS(slot, tmp->dkey));
		SET(tmp->dval, CONS(val, tmp->dval));
		return(BS1_MM_NULL);
	}

	i=BS1_SObj_SetSlotR(obj, slot, val);
	if(!i)return(BS1_MM_NULL);

	BS1_SObj_FlushHashSlot(slot);
	SET(tmp->lkey, CONS(slot, tmp->lkey));
	SET(tmp->lval, CONS(val, tmp->lval));
	tmp->nkey++;
	return(BS1_MM_NULL);
}

elem BS1_SObj_BindSlot(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_SetSlot(obj, slot, val);
		return(t);
	}

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
			{
				BS1_TY_SetCar(cv, val);
				return(BS1_MM_NULL);
			}
			ck=CDR(ck); cv=CDR(cv);
		}

		SET(tmp->dkey, CONS(slot, tmp->dkey));
		SET(tmp->dval, CONS(val, tmp->dval));
		return(BS1_MM_NULL);
	}

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			BS1_TY_SetCar(cv, val);
			return(BS1_MM_NULL);
		}
		ck=CDR(ck); cv=CDR(cv);
	}


	SET(tmp->lkey, CONS(slot, tmp->lkey));
	SET(tmp->lval, CONS(val, tmp->lval));
	tmp->nkey++;
	return(BS1_MM_NULL);
}


static void bs1_sobj_mark(elem obj)
{
	BS1_Object *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->lkey);
	BS1_GC_MarkRef(tmp->lval);
	BS1_GC_MarkRef(tmp->dkey);
	BS1_GC_MarkRef(tmp->dval);
}

static void bs1_sobj_destroy(elem obj)
{
	BS1_Object *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->lkey);
	BS1_GC_DecRef(tmp->lval);
	BS1_GC_DecRef(tmp->dkey);
	BS1_GC_DecRef(tmp->dval);
}

int BS1_SObj_Init()
{
	BS1_TY_SetMarkFunc(BS1_TYH_OBJECT, &bs1_sobj_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_OBJECT, &bs1_sobj_destroy);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>


BS1_DSOPCtx *BS1_DSOP_MakeContext(byte *buf)
{
	BS1_DSOPCtx *ctx;
	int i;

	ctx=malloc(sizeof(BS1_DSOPCtx));
	memset(ctx, 0, sizeof(BS1_DSOPCtx));

	ctx->varr=malloc(256*sizeof(elem));
	ctx->stack=malloc(4096*sizeof(elem));
	ctx->mstack=malloc(256*sizeof(int));
	ctx->stackpos=0;
	ctx->mstackpos=0;

	for(i=0; i<256; i++)ctx->varr[i]=BS1_MM_NULL;
	for(i=0; i<4096; i++)ctx->stack[i]=BS1_MM_NULL;
	for(i=0; i<256; i++)ctx->mstack[i]=0;

	ctx->ip=buf;
	return(ctx);
}

void BS1_DSOP_ClearContext(BS1_DSOPCtx *ctx)
{
	int i;

	for(i=0; i<256; i++)BS1_CLEAR(ctx->varr[i]);
	for(i=0; i<4096; i++)BS1_CLEAR(ctx->stack[i]);
	ctx->stackpos=0;
	ctx->mstackpos=0;
}

void BS1_DSOP_FreeContext(BS1_DSOPCtx *ctx)
{
	int i;

	for(i=0; i<256; i++)BS1_CLEAR(ctx->varr[i]);
	for(i=0; i<4096; i++)BS1_CLEAR(ctx->stack[i]);

	free(ctx->varr);
	free(ctx->stack);
	free(ctx->mstack);
	free(ctx);
}

byte *BS1_DSOP_EncodeVLI(byte *ip, int i)
{
	if(i>=(1<<28))*ip++=((i>>28)&127)|128;
	if(i>=(1<<21))*ip++=((i>>21)&127)|128;
	if(i>=(1<<14))*ip++=((i>>14)&127)|128;
	if(i>=(1<<7))*ip++=((i>>7)&127)|128;
	*ip++=i&127;
	return(ip);
}

byte *BS1_DSOP_EncodeSVLI(byte *ip, int i)
{
	if(i<0)i=((-i)<<1)|1;
		else i<<=1;
	ip=BS1_DSOP_EncodeVLI(ip, i);
	return(ip);
}

int BS1_DSOP_DecodeVLI(BS1_DSOPCtx *ctx)
{
	int i, j;

	i=*ctx->ip++; j=i&0x7F;
	while(i&0x80)
	{
		i=*ctx->ip++;
		j=(j<<7)|(i&0x7F);
	}
	return(j);
}

int BS1_DSOP_DecodeSVLI(BS1_DSOPCtx *ctx)
{
	int i;
	i=BS1_DSOP_DecodeVLI(ctx);
	return((i&1)?(-(i>>1)):(i>>1));
}

void BS1_DSOP_EncodeString(BS1_DSOPCtx *ctx, char *str)
{
	char *s;
	s=str;
	while(*s)*ctx->ip++=*s++;
	*ctx->ip++=0;
}

int BS1_DSOP_IndexLit(BS1_DSOPCtx *ctx, elem l)
{
	int i;

	for(i=0; i<256; i++)
		if(BS1_EQVP(ctx->varr[i], l))
			return(i);
	return(-1);
}

int BS1_DSOP_FlattenBlock(BS1_DSOPCtx *ctx, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	BS1_SVMBuiltin *bfcn;
	byte *s;
	elem t, l;
	int i, j;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		blk=BS1_TY_GetObjData(f);

		BS1_DSOP_Flatten(ctx, blk->type);
		BS1_DSOP_Flatten(ctx, blk->name);
		BS1_DSOP_Flatten(ctx, blk->args);
		BS1_DSOP_Flatten(ctx, blk->exps);

		BS1_DSOP_Flatten(ctx, blk->lit);

		i=blk->szbody; s=blk->body;
		*ctx->ip++=BS1_DSOP_BYTEARRAY;
		ctx->ip=BS1_DSOP_EncodeVLI(ctx->ip, i);
		for(j=0; j<i; j++)*ctx->ip++=*s++;

		*ctx->ip++=BS1_DSOP_BLOCK;

		return(0);
	}
	return(-1);
}

int BS1_DSOP_FlattenExpr(BS1_DSOPCtx *ctx, elem l)
{
	byte *ap, *bp;
	elem *p;
	elem c, t;
	char *s;
	int i, j;

	if(BS1_FIXNUMP(l))
	{
		*ctx->ip++=BS1_DSOP_FIXNUM;
		ctx->ip=BS1_DSOP_EncodeSVLI(ctx->ip, TOINT(l));
		return(0);
	}
	if(BS1_FLONUMP(l))
	{
		*ctx->ip++=BS1_DSOP_FLONUM_F;
		*ctx->ip++=(l>>24)&0xFF;
		*ctx->ip++=(l>>18)&0xFF;
		*ctx->ip++=(l>>8)&0xFF;
		*ctx->ip++=(l&0xFC)&0xFF;
		return(0);
	}

	if(BS1_STRINGP(l))
	{
		*ctx->ip++=BS1_DSOP_STRING;
		BS1_DSOP_EncodeString(ctx, TOSTRING(l));
		return(0);
	}
	if(BS1_SYMBOLP(l))
	{
		s=TOSYM(l);
		i=strlen(s);

		if((i>0) && (i<9))
		{
			*ctx->ip++=BS1_DSOP_SYMBOL_1+(i-1);
			while(i--)*ctx->ip++=*s++;
			return(0);
		}

		*ctx->ip++=BS1_DSOP_SYMBOL;
		BS1_DSOP_EncodeString(ctx, s);
		return(0);
	}
	if(BS1_KEYWORDP(l))
	{
		s=TOSYM(l);
		i=strlen(s);

		if((i>0) && (i<9))
		{
			*ctx->ip++=BS1_DSOP_KEYWORD_1+(i-1);
			while(i--)*ctx->ip++=*s++;
			return(0);
		}

		*ctx->ip++=BS1_DSOP_KEYWORD;
		BS1_DSOP_EncodeString(ctx, s);
		return(0);
	}

	if(BS1_CONSP(l))
	{
		if(!BS1_CONSP(CDR(l)) && (CDR(l)!=BS1_MM_NULL))
		{
			BS1_DSOP_Flatten(ctx, CAR(l));
			BS1_DSOP_Flatten(ctx, CDR(l));
			*ctx->ip++=BS1_DSOP_CONS;
			return(0);
		}

#if 1
		i=BS1_TY_GetListLen(l);
		if((i>0) && (i<9))
		{
			c=l;
			while(BS1_CONSP(c))
			{
				BS1_DSOP_Flatten(ctx, CAR(c));
				c=CDR(c);
			}

			*ctx->ip++=BS1_DSOP_LIST_1+(i-1);
			return(0);
		}
#endif

		*ctx->ip++=BS1_DSOP_MARK;
		c=l;
		while(BS1_CONSP(c))
		{
			BS1_DSOP_Flatten(ctx, CAR(c));
			c=CDR(c);
		}

		if(c!=BS1_MM_NULL)
		{
			BS1_DSOP_Flatten(ctx, c);
			*ctx->ip++=BS1_DSOP_LIST2;
			return(0);
		}

		*ctx->ip++=BS1_DSOP_LIST;
		return(0);
	}

	if(BS1_ARRAYP(l))
	{
		i=BS1_MM_GetObjSize(l)/sizeof(elem);
		p=BS1_TY_GetObjData(l);

		*ctx->ip++=BS1_DSOP_MARK;
		for(j=0; j<i; j++)BS1_DSOP_Flatten(ctx, p[j]);
		*ctx->ip++=BS1_DSOP_ARRAY;
		return(0);
	}


	if(BS1_TY_GetType(l)==BS1_TYH_SVMBLK)
	{
		i=BS1_DSOP_FlattenBlock(ctx, l);
		return(i);
	}

	if(BS1_TY_GetType(l)==BS1_TYH_BYTEARRAY)
	{
		i=BS1_MM_GetObjSize(l);
		ap=BS1_TY_GetObjData(l);

		*ctx->ip++=BS1_DSOP_BYTEARRAY;
		ctx->ip=BS1_DSOP_EncodeVLI(ctx->ip, i);
		for(j=0; j<i; j++)*ctx->ip++=*ap++;
		return(0);
	}

	*ctx->ip++=BS1_DSOP_NULL;
	printf("BS1_DSOP_FlattenExpr: Unhandled Type %s\n",
		BS1_TY_GetTypeName(l));
	return(-1);
}

int BS1_DSOP_Flatten(BS1_DSOPCtx *ctx, elem l)
{
	elem c, t;
	int i, j;

	i=-1;
	i=BS1_DSOP_IndexLit(ctx, l);
	if(i>=0)
	{
		if(i<64)
		{
			*ctx->ip++=BS1_DSOP_PUSH_I0+i;
		}else
		{
			*ctx->ip++=BS1_DSOP_PUSH_I;
			ctx->ip=BS1_DSOP_EncodeVLI(ctx->ip, i);
		}

		for(j=i; j>0; j--)SET(ctx->varr[j], ctx->varr[j-1]);
		SET(ctx->varr[0], l);
		return(0);
	}

	i=BS1_DSOP_FlattenExpr(ctx, l);
	for(j=255; j>0; j--)SET(ctx->varr[j], ctx->varr[j-1]);
	SET(ctx->varr[0], l);
	return(i);

}


elem BS1_DSOP_Pop(BS1_DSOPCtx *ctx)
{
	ctx->stackpos--;
	return(ctx->stack[ctx->stackpos]);
}

void BS1_DSOP_Push(BS1_DSOPCtx *ctx, elem l)
{
	int i;
	ctx->stack[ctx->stackpos++]=l;

	for(i=255; i>0; i--)SET(ctx->varr[i], ctx->varr[i-1]);
	SET(ctx->varr[0], l);
}

void BS1_DSOP_MoveFront(BS1_DSOPCtx *ctx, int i)
{
	elem l;
	int j;

	l=ctx->varr[i];
	for(j=i; j>0; j--)SET(ctx->varr[j], ctx->varr[j-1]);
	SET(ctx->varr[0], l);
}

int BS1_DSOP_UnFlattenOp(BS1_DSOPCtx *ctx)
{
	char buf[16];
	byte *s;
	elem t, u, v;
	int i, j, k;

	if(ctx->stackpos<0)
	{
		printf("BS1_DSOP_UnFlattenOp: stack underflow\n");
		return(-1);
	}
	if(ctx->mstackpos<0)
	{
		printf("BS1_DSOP_UnFlattenOp: mark stack underflow\n");
		return(-1);
	}

	printf("%08X %d\n", ctx->ip, *ctx->ip);

	i=*ctx->ip++;

	switch(i)
	{
	case BS1_DSOP_FIXNUM:
		j=BS1_DSOP_DecodeSVLI(ctx);
		BS1_DSOP_Push(ctx, FIXNUM(j));
		break;
	case BS1_DSOP_FLONUM_H:
		j=(signed short)((ctx->ip[0]<<8)|ctx->ip[1]);
		ctx->ip+=2;
		BS1_DSOP_Push(ctx, FLONUM(j/100.0));
		break;
	case BS1_DSOP_FLONUM_F:
		t=(ctx->ip[0]<<24)|(ctx->ip[1]<<16)|(ctx->ip[2]<<8)|ctx->ip[3];
		ctx->ip+=4;
		BS1_DSOP_Push(ctx, (t&(~3))|BS1_MM_FLONUM);
		break;

	case BS1_DSOP_STRING:
		t=STRING(ctx->ip);
		ctx->ip+=strlen(ctx->ip)+1;
		BS1_DSOP_Push(ctx, t);
		break;
	case BS1_DSOP_SYMBOL:
		t=SYM(ctx->ip);
		ctx->ip+=strlen(ctx->ip)+1;
		BS1_DSOP_Push(ctx, t);
		break;
	case BS1_DSOP_KEYWORD:
		t=KEYSYM(ctx->ip);
		ctx->ip+=strlen(ctx->ip)+1;
		BS1_DSOP_Push(ctx, t);
		break;
	case BS1_DSOP_CHAR:
		i=BS1_DSOP_DecodeVLI(ctx);
		BS1_DSOP_Push(ctx, FIXNUM(i));
		break;

	case BS1_DSOP_CONS:
		v=BS1_DSOP_Pop(ctx);
		u=BS1_DSOP_Pop(ctx);
		BS1_DSOP_Push(ctx, CONS(u, v));
		break;
	case BS1_DSOP_LIST:
		i=ctx->mstack[--ctx->mstackpos];
		u=BS1_MM_NULL;
		while(ctx->stackpos>i)
		{
			t=BS1_DSOP_Pop(ctx);
			u=CONS(t, u);
		}
		BS1_DSOP_Push(ctx, u);
		break;
	case BS1_DSOP_LIST2:
		i=ctx->mstack[--ctx->mstackpos];
		u=BS1_DSOP_Pop(ctx);
		while(ctx->stackpos>i)
		{
			t=BS1_DSOP_Pop(ctx);
			u=CONS(t, u);
		}
		BS1_DSOP_Push(ctx, u);
		break;
	case BS1_DSOP_ARRAY:
		i=ctx->mstack[--ctx->mstackpos];
		u=BS1_MM_NULL;
		while(ctx->stackpos>i)
		{
			t=BS1_DSOP_Pop(ctx);
			u=CONS(t, u);
		}
		t=BS1_TY_ListToArray(u);
		BS1_DSOP_Push(ctx, t);
		break;
	case BS1_DSOP_BYTEARRAY:
		i=BS1_DSOP_DecodeVLI(ctx);
		t=BS1_MM_AllocObj(BS1_TYH_BYTEARRAY, i);
		s=BS1_TY_GetObjData(t);
		for(j=0; j<i; j++)*s++=*ctx->ip++;
		BS1_DSOP_Push(ctx, t);
		break;

	case BS1_DSOP_NULL:
		BS1_DSOP_Push(ctx, BS1_MM_NULL);
		break;
	case BS1_DSOP_TRUE:
		BS1_DSOP_Push(ctx, BS1_MM_TRUE);
		break;
	case BS1_DSOP_FALSE:
		BS1_DSOP_Push(ctx, BS1_MM_FALSE);
		break;

	case BS1_DSOP_MARK:
		ctx->mstack[ctx->mstackpos++]=ctx->stackpos;
		break;
	case BS1_DSOP_DUP:
		SET(ctx->stack[ctx->stackpos], ctx->stack[ctx->stackpos-1]);
		ctx->stackpos++;
		break;
	case BS1_DSOP_PUSH_I:
		i=BS1_DSOP_DecodeVLI(ctx);
		BS1_DSOP_MoveFront(ctx, i);
		ctx->stack[ctx->stackpos++]=ctx->varr[0];
		break;

	default:
		if((i>=BS1_DSOP_SYMBOL_1) && (i<(BS1_DSOP_SYMBOL_1+8)))
		{
			i-=BS1_DSOP_SYMBOL_1-1; s=buf;
			while(i--)*s++=*ctx->ip++; *s++=0;
			BS1_DSOP_Push(ctx, SYM(buf));
			break;
		}
		if((i>=BS1_DSOP_KEYWORD_1) && (i<(BS1_DSOP_KEYWORD_1+8)))
		{
			i-=BS1_DSOP_KEYWORD_1-1; s=buf;
			while(i--)*s++=*ctx->ip++; *s++=0;
			BS1_DSOP_Push(ctx, KEYSYM(buf));
			break;
		}
		if((i>=BS1_DSOP_LIST_1) && (i<(BS1_DSOP_LIST_1+8)))
		{
			i-=BS1_DSOP_LIST_1-1;
			u=BS1_MM_NULL;
			while(i--)
			{
				t=BS1_DSOP_Pop(ctx);
				u=CONS(t, u);
			}
			BS1_DSOP_Push(ctx, u);
			break;
		}

		if((i>=BS1_DSOP_PUSH_I0) && (i<192))
		{
			i-=BS1_DSOP_PUSH_I0;
			BS1_DSOP_MoveFront(ctx, i);
			ctx->stack[ctx->stackpos++]=ctx->varr[0];
			break;
		}
		break;
	}
}


byte *BS1_DSOP_FlattenBuffer(byte *buf, elem l)
{
	BS1_DSOPCtx *ctx;
	byte *ip, *ipe;
	elem n;
	int i;

	ctx=BS1_DSOP_MakeContext(buf);
	BS1_DSOP_Flatten(ctx, l);
	ipe=ctx->ip;

#if 1
	i=ipe-buf;
	BS1_DSOP_ClearContext(ctx);
	ctx->ip=buf;

	while(ctx->ip<ipe)
	{
		i=BS1_DSOP_UnFlattenOp(ctx);
		if(i<0)
		{
			BS1_DSOP_FreeContext(ctx);
			return(ipe);
		}
	}
	n=BS1_DSOP_Pop(ctx);
	BS1_TY_PrintLN(n);

	printf("%s\n", BS1_EQVP(n, l)?"PASS":"FAIL");
#endif

	BS1_DSOP_FreeContext(ctx);
	return(ipe);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>

static int bs1_scomp_seq=1;


int BS1_SComp_CompileSwitch(BS1_SVMCState *ctx, elem l)
{
	char **cl, *s;
	byte *ip;
	int i, j, ncl;
	elem c, t, u, v;

	cl=BS1_MM_RAlloc(4096*sizeof(char *));

	ncl=0; c=CDDR(l);
	while(BS1_CONSP(c))
	{
		if(FORM_IS(CAR(c), "case") ||
			FORM_IS(CAR(c), "case_default"))
		{
			cl[ncl++]=BS1_SComp_GenSym();
			c=CDR(c);
			continue;
		}
		c=CDR(c);
	}

	BS1_SComp_CompileExpr(ctx, CADR(l));

	i=0; c=CDDR(l);
	while(BS1_CONSP(c))
	{
		if(FORM_IS(CAR(c), "case"))
		{
			*ctx->ip++=BS1_SOP_DUP;
			BS1_SComp_CompileExpr(ctx, CADAR(c));

//			*ctx->ip++=BS1_SOP_BINARYOP;
//			*ctx->ip++=BS1_OPR_EQV;
//			BS1_SComp_CompileJmpTrue(ctx, cl[i++]);

			BS1_SComp_CompileJmpCond(ctx, BS1_OPR_EQV, cl[i++]);
			c=CDR(c);
			continue;
		}

		if(FORM_IS(CAR(c), "case_default"))
		{
			BS1_SComp_CompileJmp(ctx, cl[i++]);
			c=CDR(c);
			continue;
		}
		c=CDR(c);
	}


	s=BS1_SComp_GenSym();
	ctx->breakstack[ctx->breakstackpos++]=s;
	BS1_SComp_CompileBreak(ctx);

	i=0; c=CDDR(l);
	while(BS1_CONSP(c))
	{
		if(FORM_IS(CAR(c), "case") ||
			FORM_IS(CAR(c), "case_default"))
		{
			BS1_SComp_EmitLabel(ctx, cl[i++], ctx->ip);
			c=CDR(c);
			continue;
		}

		BS1_SComp_CompileStatement(ctx, CAR(c));
		c=CDR(c);
	}

	BS1_SComp_EmitLabel(ctx, s, ctx->ip);
	*ctx->ip++=BS1_SOP_POP;

	ctx->breakstackpos--;
	return;
}

void BS1_SComp_CompileStatement(BS1_SVMCState *ctx, elem l)
{
	byte *ip0, *ip1;
	elem c, ct, cv, t, n, u, v, n1;
	char *s, *s1, *s2;
	int i, j, k;

	l=BS1_SComp_ReduceExpr(ctx, l);

	//references/literals are useless in statement position
	if(!BS1_CONSP(l))
	{
		if(l==BS1_MM_NULL)return;	//empty statement

		printf("useless expression in statement position\n");
		return;
	}

	if(CAR(l)==SYM("module"))
	{
		ctx->mname=CADR(l);
		return;
	}

	if(CAR(l)==SYM("import"))
	{
		SET(ctx->mimps, CONS(CADR(l), ctx->mimps));
		return;
	}

	if(CAR(l)==SYM("switch"))
	{
		BS1_SComp_CompileSwitch(ctx, l);
		return;
	}

	if(CAR(l)==SYM("goto"))
	{
		*ctx->ip++=BS1_SOP_JMP;
		*ctx->ip++=0;
		*ctx->ip++=0;
		BS1_SComp_EmitGoto(ctx,
			BS1_TY_GetSymbol(CADR(l)), ctx->ip);
		return;
	}

	if(CAR(l)==SYM("label"))
	{
		BS1_SComp_EmitLabel(ctx,
			BS1_TY_GetSymbol(CADR(l)), ctx->ip);
		return;
	}

	if(CAR(l)==SYM("continue"))
	{
		s=ctx->contstack[ctx->contstackpos-1];

		*ctx->ip++=BS1_SOP_JMP;
		*ctx->ip++=0;
		*ctx->ip++=0;
		BS1_SComp_EmitGoto(ctx, s, ctx->ip);
		return;
	}

	if(CAR(l)==SYM("break"))
	{
		s=ctx->breakstack[ctx->breakstackpos-1];
		*ctx->ip++=BS1_SOP_JMP;
		*ctx->ip++=0;
		*ctx->ip++=0;
		BS1_SComp_EmitGoto(ctx, s, ctx->ip);
		return;
	}

	if(CAR(l)==SYM("return"))
	{
		BS1_SComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_RET;
		return;
	}

	if(CAR(l)==SYM("set!"))
	{
		t=CADR(l);
		c=ctx->lenv; ct=ctx->tenv; cv=ctx->venv;
		i=0; j=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==t)break;
			c=CDR(c); ct=CDR(ct); cv=CDR(cv);
			j++;
		}
		if(BS1_CONSP(c) && i)ctx->cap++;

		if(BS1_CONSP(c))
		{
			t=BS1_SComp_InferExpr(ctx, CADDR(l));
			n=CAR(ct);

			if((n!=BS1_MM_NULL) && (t==BS1_MM_NULL))
			{
				i=BS1_SComp_IndexLit(ctx, n);
				*ctx->ip++=BS1_SOP_CAST;
				BS1_SComp_EncIDX(ctx, i);
				t=n;
			}

			if((n!=BS1_MM_NULL) && (t!=n))
			{
				printf("warn: inferencer violation\n");
				BS1_TY_SetCar(ct, BS1_MM_NULL);
			}

			BS1_TY_SetCar(cv, BS1_MM_NULL);

			if((t==KEYSYM("int")) || (t==KEYSYM("float")))
			{
				BS1_SComp_CompileExpr(ctx, CADDR(l));
				*ctx->ip++=BS1_SOP_LSTORE_F;
				*ctx->ip++=j;
				return;
			}

			BS1_SComp_CompileExpr(ctx, CADDR(l));
			*ctx->ip++=BS1_SOP_LSTORE;
			*ctx->ip++=j;
			return;
		}


		BS1_SComp_CompileExpr(ctx, CADDR(l));
		i=BS1_SComp_IndexLit(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_STORE;
		BS1_SComp_EncIDX(ctx, i);

		return;
	}

	if((CAR(l)==SYM("setindex!")) || (CAR(l)==SYM("vector-set!")))
	{
		BS1_SComp_CompileExpr(ctx, CADDDR(l));
		BS1_SComp_CompileExpr(ctx, CADDR(l));
		BS1_SComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_STOREINDEX;
		return;
	}

	if(FORM_IS(l, "preinc!") || FORM_IS(l, "predec!") ||
		FORM_IS(l, "postinc!") || FORM_IS(l, "postdec!"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		u=BS1_SComp_InferExpr(ctx, t);

		if(FORM_IS(l, "preinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;
		if(FORM_IS(l, "postinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;

		if(BS1_SYMBOLP(t) && (u==KEYSYM("int")))
		{
			c=ctx->lenv;
			k=0; j=0;
			while(BS1_CONSP(c))
			{
				if(c==ctx->llenv)k=1;
				if(CAR(c)==t)break;
				c=CDR(c); j++;
			}

			if(BS1_CONSP(c))
			{
				if(k)ctx->cap++;
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_LINC_FN;
					else *ctx->ip++=BS1_SOP_LDEC_FN;
				*ctx->ip++=j;
				return;
			}
		}

		if(BS1_SYMBOLP(t))
		{
			BS1_SComp_CompileExpr(ctx, t);

			if(u==KEYSYM("int"))
			{
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_DEC_FN;
			}else
			{
				*ctx->ip++=BS1_SOP_UNARYOP;
				*ctx->ip++=i;
			}

			BS1_SComp_CompileAssign(ctx, t);
			return;
		}

		return;
	}

	if(CAR(l)==SYM("define"))
	{
		if(!BS1_CONSP(CADR(l)))
		{
			BS1_SComp_CompileExpr(ctx, CADDR(l));
			i=BS1_SComp_IndexLit(ctx, CADR(l));
			if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
				else *ctx->ip++=BS1_SOP_BIND;
			BS1_SComp_EncIDX(ctx, i);
			return;
		}

		if(!ctx->lvl && !ctx->olvl)
		{
			t=BS1_SComp_CompileBlock(ctx, CAADR(l), CDADR(l), CDDR(l));

			i=BS1_SComp_IndexLit(ctx, t);
			*ctx->ip++=BS1_SOP_PUSH;
			BS1_SComp_EncIDX(ctx, i);

			SET(ctx->mfcns, CONS(t, ctx->mfcns));

			i=BS1_SComp_IndexLit(ctx, CAADR(l));
			*ctx->ip++=BS1_SOP_BIND;
			BS1_SComp_EncIDX(ctx, i);

			return;
		}

		t=CONS(SYM("lambda"), CONS(CDADR(l), CDDR(l)));
		BS1_SComp_CompileExpr(ctx, t);
		i=BS1_SComp_IndexLit(ctx, CAADR(l));
		if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
			else *ctx->ip++=BS1_SOP_BIND;
		BS1_SComp_EncIDX(ctx, i);

		return;
	}

#if 0
	if(CAR(l)==SYM("defvar"))
	{
		if(!BS1_CONSP(CADR(l)))
		{
			BS1_SComp_CompileExpr(ctx, CADDR(l));
			i=BS1_SComp_IndexLit(ctx, CADR(l));
			*ctx->ip++=BS1_SOP_DYNBIND;
			BS1_SComp_EncIDX(ctx, i);
			return;
		}

		t=CONS(SYM("lambda"), CONS(CDADR(l), CDDR(l)));
		BS1_SComp_CompileExpr(ctx, t);
		i=BS1_SComp_IndexLit(ctx, CAADR(l));
		*ctx->ip++=BS1_SOP_DYNBIND;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}
#endif

	if(CAR(l)==SYM("vars"))
	{
		c=CADDR(l);
		t=CADR(l);

		while(BS1_CONSP(c))
		{
			n=CAR(c);
			v=BS1_MM_NULL;

			if(BS1_CONSP(n))
			{
				v=CADR(n);
				n=CAR(n);
			}

			BS1_SComp_CompileExpr(ctx, v);
			i=BS1_SComp_IndexLit(ctx, n);
			if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
				else *ctx->ip++=BS1_SOP_BIND;
			BS1_SComp_EncIDX(ctx, i);

			if(ctx->lvl)
			{
				n1=BS1_MM_NULL;
				if(!BS1_SComp_IsExpr(v))n1=v;

				SET(ctx->lenv, CONS(n, ctx->lenv));
				SET(ctx->tenv, CONS(t, ctx->tenv));
				SET(ctx->venv, CONS(n1, ctx->venv));
			}else if(!ctx->olvl)
			{
				n1=BS1_MM_NULL;
				if(!BS1_SComp_IsExpr(v))n1=v;

				SET(ctx->mlenv, CONS(n, ctx->mlenv));
				SET(ctx->mtenv, CONS(t, ctx->mtenv));
				SET(ctx->mvenv, CONS(n1, ctx->mvenv));
			}

			c=CDR(c);
		}
		return;
	}

	if(CAR(l)==SYM("defun"))
	{
		if(!ctx->lvl && !ctx->olvl)
		{
			t=BS1_SComp_CompileBlock(ctx,
				LIST2(CADR(l), CADDR(l)),
				CADDDR(l), CDDDDR(l));

			i=BS1_SComp_IndexLit(ctx, t);
			*ctx->ip++=BS1_SOP_PUSH;
			BS1_SComp_EncIDX(ctx, i);

			SET(ctx->mfcns, CONS(t, ctx->mfcns));

			i=BS1_SComp_IndexLit(ctx, CADDR(l));
			*ctx->ip++=BS1_SOP_BIND;
			BS1_SComp_EncIDX(ctx, i);

			return;
		}


//		t=CONS2S("lambda", CADDDR(l), CDDDDR(l));

		t=CONS3S("rlambda", LIST2(CADR(l), CADDR(l)),
			CADDDR(l), CDDDDR(l));

		BS1_TY_PrintLN(t);

		BS1_SComp_CompileExpr(ctx, t);
		i=BS1_SComp_IndexLit(ctx, CADDR(l));
		if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
			else *ctx->ip++=BS1_SOP_BIND;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==1)
		{
			BS1_SComp_CompileStatement(ctx, CADDR(l));
			return;
		}
		if(i==0)
		{
			if(BS1_CONSP(CDDDR(l)))
				BS1_SComp_CompileStatement(ctx, CADDDR(l));
			return;
		}

#if 0
		BS1_SComp_CompileExpr(ctx, t);

		*ctx->ip++=BS1_SOP_JMP_FALSE;
		*ctx->ip++=0;
		*ctx->ip++=0;
		ip0=ctx->ip;
#endif

		BS1_SComp_CompileJCF(ctx, t);
		ip0=ctx->ip;


		BS1_SComp_CompileStatement(ctx, CADDR(l));

		if(BS1_CONSP(CDDDR(l)))
		{
			*ctx->ip++=BS1_SOP_JMP;
			*ctx->ip++=0;
			*ctx->ip++=0;
			ip1=ctx->ip;

			i=ctx->ip-ip0;
			*(ip0-2)=i&0xFF;
			*(ip0-1)=(i>>8)&0xFF;

			BS1_SComp_CompileStatement(ctx, CADDDR(l));
			ip0=ip1;
		}
		i=ctx->ip-ip0;
		*(ip0-2)=i&0xFF;
		*(ip0-1)=(i>>8)&0xFF;
		return;
	}

	if(CAR(l)==SYM("begin"))
	{
		c=CDR(l);
		while(BS1_CONSP(c))
		{
			BS1_SComp_CompileStatement(ctx, CAR(c));
			c=CDR(c);
		}
		return;
	}

	if(CAR(l)==SYM("for"))
	{
		s1=BS1_SComp_GenSym();
		s2=BS1_SComp_GenSym();

		ctx->contstack[ctx->contstackpos++]=s1;
		ctx->breakstack[ctx->breakstackpos++]=s2;

		BS1_SComp_CompileStatement(ctx, CADR(l));

		BS1_SComp_EmitLabel(ctx, s1, ctx->ip);

//		BS1_SComp_CompileExpr(ctx, CADDR(l));
//		BS1_SComp_CompileBreakFalse(ctx);

		BS1_SComp_CompileJCF(ctx, CADDR(l));
		BS1_SComp_EmitGoto(ctx, s2, ctx->ip);

		BS1_SComp_CompileStatement(ctx, CADDDDR(l));

		BS1_SComp_CompileStatement(ctx, CADDDR(l));
		BS1_SComp_CompileContinue(ctx);

		BS1_SComp_EmitLabel(ctx, s2, ctx->ip);

		ctx->contstackpos--;
		ctx->breakstackpos--;
		return;
	}

	if(CAR(l)==SYM("while"))
	{
		s1=BS1_SComp_GenSym();
		s2=BS1_SComp_GenSym();

		ctx->contstack[ctx->contstackpos++]=s1;
		ctx->breakstack[ctx->breakstackpos++]=s2;

		BS1_SComp_EmitLabel(ctx, s1, ctx->ip);

		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);

		if(i==0)return;

		if(i==1)
		{
			BS1_SComp_CompileStatement(ctx, CADDR(l));
			BS1_SComp_CompileContinue(ctx);

			BS1_SComp_EmitLabel(ctx, s2, ctx->ip);

			ctx->contstackpos--;
			ctx->breakstackpos--;
			return;
		}

//		BS1_SComp_CompileExpr(ctx, t);
//		BS1_SComp_CompileBreakFalse(ctx);

		BS1_SComp_CompileJCF(ctx, t);
		BS1_SComp_EmitGoto(ctx, s2, ctx->ip);

		BS1_SComp_CompileStatement(ctx, CADDR(l));

		BS1_SComp_CompileContinue(ctx);
		BS1_SComp_EmitLabel(ctx, s2, ctx->ip);

		ctx->contstackpos--;
		ctx->breakstackpos--;
		return;
	}


	if(CAR(l)==SYM("do_while"))
	{
		s1=BS1_SComp_GenSym();
		s2=BS1_SComp_GenSym();
		ctx->contstack[ctx->contstackpos++]=s1;
		ctx->breakstack[ctx->breakstackpos++]=s2;

		BS1_SComp_EmitLabel(ctx, s1, ctx->ip);

		BS1_SComp_CompileStatement(ctx, CADDR(l));

		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==0)return;

		if(i==1)
		{
			BS1_SComp_CompileContinue(ctx);
			BS1_SComp_EmitLabel(ctx, s2, ctx->ip);
			ctx->contstackpos--;
			ctx->breakstackpos--;
			return;
		}

//		BS1_SComp_CompileExpr(ctx, t);
//		BS1_SComp_CompileContinueTrue(ctx);

		BS1_SComp_CompileJCT(ctx, t);
		BS1_SComp_EmitGoto(ctx, s1, ctx->ip);

		BS1_SComp_EmitLabel(ctx, s2, ctx->ip);

		ctx->contstackpos--;
		ctx->breakstackpos--;
		return;
	}


	BS1_SComp_CompileExpr(ctx, l);
	*ctx->ip++=BS1_SOP_POP;
}

extern char *bs1_ops_strs[];
extern char *bs1_ops_args[];

byte *BS1_SComp_NextOpcode(byte *ip)
{
	char *s;
	int i, j, k;

	i=*ip++;
	if(i>=192)i=(i-192)*256+(*ip++);

	s=bs1_ops_args[i];
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T') || (*s=='N'))
			{ j=*ip++; if(j&128)ip++; s++; continue; }
		if(*s=='A') { ip+=2; s++; continue; }

		if(*s=='C') { ip++; s++; continue; }
		if(*s=='B') { ip++; s++; continue; }
		if(*s=='W') { ip++; s++; continue; }
		if(*s=='H') { ip++; s++; continue; }

		if(*s=='u') { ip++; s++; continue; }
		if(*s=='b') { ip++; s++; continue; }

		s++;
	}

	return(ip);
}

byte *BS1_SComp_DumpOpcode(byte *ip, elem lit)
{
	char *uops[]={"neg", "not", "lnot"};
	char *bops[]={"add", "sub", "mul", "div", "mod", "and", "or",
		"xor", "shl", "shr", "eq", "eqv", "neq", "neqv", "l",
		"g", "le", "ge"};

	elem t;
	byte *oip, *ip1;
	char *s;
	int i, j, k;

	oip=ip;
	i=*ip++;
	if(i>=192)
	{
		i=(i-192)*256+(*ip++);
		printf("%08X %02X%02X ", oip, oip[0], oip[1]);
	}else
	{
		printf("%08X %02X ", oip, i);
	}

	k=0; s=bs1_ops_args[i]; ip1=ip;
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T') || (*s=='N'))
			{ j=*ip1++; k++; if(j&128)k++; s++; continue; }
		if(*s=='A') { ip1+=2; k+=2; s++; continue; }

		if(*s=='C') { ip1++; k++; s++; continue; }
		if(*s=='B') { ip1++; k++; s++; continue; }
		if(*s=='W') { ip1++; k+=2; s++; continue; }
		if(*s=='H') { ip1++; k+=2; s++; continue; }

		if(*s=='u') { ip1++; k++; s++; continue; }
		if(*s=='b') { ip1++; k++; s++; continue; }

		s++;
	}

	ip1=ip;
	for(j=0; j<k; j++)printf("%02X", *ip1++);

	if(i<192)printf("  ");
	for(; j<4; j++)printf("  ");

	printf(" %s ", bs1_ops_strs[i]);

	s=bs1_ops_args[i];
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T'))
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			t=BS1_TY_GetArrayElem2(lit, i);
			BS1_TY_Print(t);
			printf(" ");
			s++;
			continue;
		}
		if(*s=='N')
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			printf("%d ", i);
			s++;
			continue;
		}
		if(*s=='A')
		{
			i=*ip++; i|=(*ip++)<<8;
			printf("%08X ", ip+i);
			s++;
			continue;
		}
		if(*s=='C') { i=(signed char)(*ip++); printf("%d ", i);
			s++; continue; }
		if(*s=='B') { i=*ip++; printf("%d ", i); s++; continue; }
		if(*s=='W') { i=*ip++; i|=(*ip++)<<8; printf("%d ", i);
			s++; continue; }
		if(*s=='H') { i=*ip++; i|=(*ip++)<<8; printf("%g ", i/100.0);
			s++; continue; }

		if(*s=='u') { i=*ip++; printf("%s ", uops[i]); s++; continue; }
		if(*s=='b') { i=*ip++; printf("%s ", bops[i]); s++; continue; }
		s++;
	}

	printf("\n");

	return(ip);
}

elem BS1_SComp_CompileBlock(BS1_SVMCState *lctx,
	elem name, elem args, elem body)
{
	BS1_SVMBlock *blk;
	BS1_SVMCState *ctx;

	char **gname, **lname;
	byte **gdest, **ldest;
	char **cname, **bname;

	elem *lit;
	byte *ip, *cip, *ipe;

	elem fargs, blkn;
	elem c, t, u;
	int i, j, k;

	ctx=malloc(sizeof(BS1_SVMCState));
	memset(ctx, 0, sizeof(BS1_SVMCState));

	gname=malloc(4096*sizeof(char *));
	gdest=malloc(4096*sizeof(byte *));
	lname=malloc(256*sizeof(char *));
	ldest=malloc(256*sizeof(byte *));

	cname=malloc(16*sizeof(char *));
	bname=malloc(16*sizeof(char *));

	ctx->goto_name=gname;
	ctx->goto_dest=gdest;
	ctx->lbl_name=lname;
	ctx->lbl_dest=ldest;

	ctx->contstack=cname;
	ctx->breakstack=bname;

	SET(ctx->lenv, lctx->lenv);
	SET(ctx->llenv, ctx->lenv);
	SET(ctx->tenv, lctx->tenv);
	SET(ctx->ltenv, ctx->tenv);
	SET(ctx->venv, lctx->venv);
	SET(ctx->lvenv, ctx->venv);

	if(BS1_CONSP(name))
	{
		ctx->cf_n=CADR(name);
		ctx->cf_ty=CAR(name);
	}else ctx->cf_n=name;
	blkn=ctx->cf_n;

	c=args; u=BS1_MM_NULL;
	while(BS1_CONSP(c))
	{
		t=CAR(c);
		if(BS1_CONSP(t))
		{
			SET(ctx->lenv, CONS(CADR(t), ctx->lenv));
			SET(ctx->tenv, CONS(CAR(t), ctx->tenv));
			SET(ctx->venv, CONS(BS1_MM_NULL, ctx->venv));
			u=CONS(CADR(t), u);
		}else
		{
			SET(ctx->lenv, CONS(CAR(c), ctx->lenv));
			SET(ctx->tenv, CONS(BS1_MM_NULL, ctx->tenv));
			SET(ctx->venv, CONS(BS1_MM_NULL, ctx->venv));
			u=CONS(t, u);
		}
		c=CDR(c);
	}

	if(c!=BS1_MM_NULL)
	{
		ctx->lenv=CONS(c, ctx->lenv);
		fargs=BS1_MM_NULL;
		ctx->i_cap=1;
	}else
	{
		fargs=BS1_TY_NReverse(u);
		ctx->i_cap=BS1_SComp_GuessCloseBlock(ctx, body);
	}

	body=BS1_SComp_ReverseStepBlock(ctx, body);

	lit=malloc(4096*sizeof(elem));
	memset(lit, 0, 4096*sizeof(elem));
	ip=malloc(65536);

	ctx->lvl=lctx->lvl+1;
	ctx->lit=lit;
	ctx->ip=ip;

	if(BS1_CONSP(body))
	{
		c=body;
		while(BS1_CONSP(c))
		{
			if(BS1_CONSP(CDR(c)))
			{
				t=BS1_SComp_ReverseStepBlock(ctx, CDR(c));
				BS1_SComp_CompileStatement(ctx, CAR(c));
				c=t;
				continue;
			}else
			{
				BS1_SComp_CompileExprTail(ctx, CAR(c));
				break;
			}
		}

		*ctx->ip++=BS1_SOP_RET;
	}else
	{
		*ctx->ip++=BS1_SOP_PUSH_NULL;
		*ctx->ip++=BS1_SOP_RET;
	}

//	printf("gotos %d, labels %d\n", ctx->n_goto, ctx->n_lbl);

	if(ctx->cap)fargs=BS1_MM_NULL;

	//resolve gotos
	for(i=0; i<ctx->n_goto; i++)
	{
		for(j=0; j<ctx->n_lbl; j++)
			if(!strcmp(lname[j], gname[i]))
		{
			k=ldest[j]-gdest[i];
//			printf("res goto %s %s, %08X->%08X (%d)\n",
//				gname[i], lname[j], gdest[i], ldest[j], k);

			*(gdest[i]-2)=k&0xFF;
			*(gdest[i]-1)=(k>>8)&0xFF;
			break;
		}

		if(j>=ctx->n_lbl)
			printf("missing label %s\n", gname[i]);
	}


	t=BS1_MM_AllocObj(BS1_TYH_SVMBLK, sizeof(BS1_SVMBlock));
	blk=BS1_TY_GetObjData(t);

	SET(blk->name, blkn);
	SET(blk->args, args);
	SET(blk->fargs, fargs);
	SET(blk->exps, body);

	for(i=0; lit[i]; i++);
	u=BS1_TY_NewArrayFromArray(lit, i);
	SET(blk->lit, u);

	blk->szbody=ctx->ip-ip;
	blk->body=malloc(blk->szbody);
	memcpy(blk->body, ip, blk->szbody);

	lctx->cap=lctx->cap||ctx->cap;

	CLEAR(ctx->lenv);
	CLEAR(ctx->llenv);

	for(i=0; i<ctx->n_goto; i++)free(gname[i]);
	for(i=0; i<ctx->n_lbl; i++)free(lname[i]);
	free(gname);
	free(gdest);
	free(lname);
	free(ldest);

	free(cname);
	free(bname);

	free(lit);
	free(ip);
	free(ctx);

	if(fargs)
	{
		ip=blk->body;
		ipe=blk->body+blk->szbody;

		while(ip<ipe)
		{
			if(*ip==BS1_SOP_LLOAD_F)*ip=BS1_SOP_LLOAD_F2;
			if(*ip==BS1_SOP_LSTORE_F)*ip=BS1_SOP_LSTORE_F2;
			if(*ip==BS1_SOP_LINC_FN)*ip=BS1_SOP_LINC_FN2;
			if(*ip==BS1_SOP_LDEC_FN)*ip=BS1_SOP_LDEC_FN2;
			ip=BS1_SComp_NextOpcode(ip);
		}
	}

#if 1
	printf("BLK %s, SA %s\n", TOSTRING(blkn), fargs?"Yes":"No");

	ip=blk->body;
	ipe=blk->body+blk->szbody;

	while(ip<ipe)
	{
		ip=BS1_SComp_DumpOpcode(ip, blk->lit);
	}

	printf("\n");
#endif

//	BS1_JIT_CompileBlock(t);

	return(t);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>


int BS1_SComp_BoolExpr(BS1_SVMCState *ctx, elem l)
{
	if(l==BS1_MM_FALSE)return(0);
	if(l==BS1_MM_NULL)return(0);
	if(l==BS1_MM_FIXNUM)return(0);
	if(l==BS1_MM_FLONUM)return(0);

	if(l==BS1_MM_TRUE)return(1);
	if(BS1_FIXNUMP(l))return(1);
	if(BS1_FLONUMP(l))return(1);
	return(-1);
}

int BS1_SComp_IsExpr(elem l)
{
	if(BS1_CONSP(l))return(1);
	if(BS1_SYMBOLP(l))return(1);
	return(0);
}

elem BS1_SComp_ReduceForm(BS1_SVMCState *ctx, elem l)
{
	elem c, t, x;
	int i, j;

	if(CAR(l)==SYM("unary"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		if(CADR(l)==SYM("!"))
		{
			if(CAR(t)==SYM("=="))return(CONSS("!=", CDR(t)));
			if(CAR(t)==SYM("!="))return(CONSS("==", CDR(t)));
			if(CAR(t)==SYM("==="))return(CONSS("!==", CDR(t)));
			if(CAR(t)==SYM("!=="))return(CONSS("===", CDR(t)));

			if(CAR(t)==SYM("<"))return(CONSS(">=", CDR(t)));
			if(CAR(t)==SYM(">"))return(CONSS("<=", CDR(t)));
			if(CAR(t)==SYM("<="))return(CONSS(">", CDR(t)));
			if(CAR(t)==SYM(">="))return(CONSS("<", CDR(t)));
		}

		if(CADR(l)==SYM("+"))i=BS1_OPR_POS;
		if(CADR(l)==SYM("-"))i=BS1_OPR_NEG;
		if(CADR(l)==SYM("~"))i=BS1_OPR_NOT;
		if(CADR(l)==SYM("!"))i=BS1_OPR_LNOT;
		if(CADR(l)==SYM("*"))i=BS1_OPR_UMUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_UDIV;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_UIDIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_UMOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_UAND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_UOR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_UXOR;
		if(CADR(l)==SYM("&&"))i=BS1_OPR_ULAND;
		if(CADR(l)==SYM("||"))i=BS1_OPR_ULOR;
		if(CADR(l)==SYM("^^"))i=BS1_OPR_ULXOR;

		l=BS1_Opr_Unary(i, t);
		return(l);
	}

#if 0
	if((CAR(l)==SYM("+")) || (CAR(l)==SYM("-")) ||
		(CAR(l)==SYM("*")) || (CAR(l)==SYM("/")) ||
		(CAR(l)==SYM("%")) || (CAR(l)==SYM("&")) ||
		(CAR(l)==SYM("|")) || (CAR(l)==SYM("^")) ||
		(CAR(l)==SYM("**")) || (CAR(l)==SYM("\\")))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		if(CAR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CAR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CAR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CAR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CAR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CAR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CAR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CAR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CAR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CAR(l)==SYM("**"))i=BS1_OPR_EXP;

		x=t; c=CDDR(l);
		while(BS1_CONSP(c))
		{
			t=BS1_SComp_ReduceExpr(ctx, CAR(c));
			if(BS1_SComp_IsExpr(t))return(l);

			x=BS1_Opr_Binary(i, x, t);

			c=CDR(c);
		}
		return(x);
	}

	if((CAR(l)==SYM("<<")) || (CAR(l)==SYM(">>")) ||
		(CAR(l)==SYM("==")) || (CAR(l)==SYM("===")) ||
		(CAR(l)==SYM("!=")) || (CAR(l)==SYM("!==")) ||
		(CAR(l)==SYM("<")) || (CAR(l)==SYM(">")) ||
		(CAR(l)==SYM("<=")) || (CAR(l)==SYM(">=")))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		x=BS1_SComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_SComp_IsExpr(x))return(l);


		if(CAR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CAR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CAR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CAR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CAR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CAR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CAR(l)==SYM("<"))i=BS1_OPR_L;
		if(CAR(l)==SYM(">"))i=BS1_OPR_G;
		if(CAR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CAR(l)==SYM(">="))i=BS1_OPR_GE;

		l=BS1_Opr_Binary(i, t, x);
		return(l);
	}
#endif

	if(FORM_IS(l, "binary"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		x=BS1_SComp_ReduceExpr(ctx, CADDDR(l));
		if(BS1_SComp_IsExpr(x))return(l);


		if(CADR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CADR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CADR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CADR(l)==SYM("**"))i=BS1_OPR_EXP;

		if(CADR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CADR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CADR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CADR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CADR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CADR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CADR(l)==SYM("<"))i=BS1_OPR_L;
		if(CADR(l)==SYM(">"))i=BS1_OPR_G;
		if(CADR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CADR(l)==SYM(">="))i=BS1_OPR_GE;

		if((CADR(l)==SYM("/")) && BS1_FIXNUMP(t) && BS1_FIXNUMP(x))
			return(BS1_TY_Rational(TOINT(t), TOINT(x)));

		l=BS1_Opr_Binary(i, t, x);
		return(l);
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==1)
		{
			l=BS1_SComp_ReduceExpr(ctx, CADDR(l));
			return(l);
		}
		if(i==0)
		{
			t=BS1_MM_NULL;
			if(BS1_CONSP(CDDDR(l)))
				t=BS1_SComp_ReduceExpr(ctx, CADDDR(l));
			return(t);
		}
		return(l);
	}

	if(CAR(l)==SYM("begin"))
	{
//		if((CDDR(l)==BS1_MM_NULL) &&
//			(FORM_IS(CADR(l), "unary") ||
//			FORM_IS(CADR(l), "binary")))

		if(CDDR(l)==BS1_MM_NULL)
		{
			t=BS1_SComp_ReduceExpr(ctx, CADR(l));
			return(t);
		}

		return(l);
	}

	return(l);
}

elem BS1_SComp_ReduceExpr(BS1_SVMCState *ctx, elem l)
{
	elem t, cn, cv, ct;
	if(BS1_CONSP(l))
	{
		t=BS1_SComp_ReduceForm(ctx, l);
		return(t);
	}

	if(BS1_SYMBOLP(l))
	{
		if(l==SYM("I"))return(BS1_COMPLEX_I(1));
		if(l==SYM("PI"))return(FLONUM(M_PI));
		if(l==SYM("E"))return(FLONUM(M_E));

		cn=ctx->lenv;
		ct=ctx->tenv;
		cv=ctx->venv;

		if(ctx->cap)return(l);

		while(BS1_CONSP(cn) && (cn!=ctx->lenv))
		{
			if((CAR(cn)==l) && (CAR(cv)!=BS1_MM_NULL))
				return(CAR(cv));

			cn=CDR(cn);
			ct=CDR(ct);
			cv=CDR(cv);
		}
	}
	return(l);
}


elem BS1_SComp_InferTypeBase(elem l)
{
	char b[64];
	char *s, *t;

	if(!BS1_KEYWORDP(l))
		return(BS1_MM_NULL);

	s=TOSYM(l); t=b;
	while(*s && (*s!='$'))*t++=*s++;
	*t++=0;

	return(KEYSYM(b));
}

int BS1_SComp_InferIsIntP(elem t)
{
	if(t==KEYSYM("byte"))return(1);
	if(t==KEYSYM("sbyte"))return(1);
	if(t==KEYSYM("short"))return(1);
	if(t==KEYSYM("ushort"))return(1);
	if(t==KEYSYM("int"))return(1);
	if(t==KEYSYM("uint"))return(1);
	return(0);
}

int BS1_SComp_InferIsLongP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("long"))return(1);
	if(t==KEYSYM("ulong"))return(1);
	return(0);
}

int BS1_SComp_InferIsFloatP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("float"))return(1);
	return(0);
}

int BS1_SComp_InferIsDoubleP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("float"))return(1);
	if(t==KEYSYM("double"))return(1);
	return(0);
}

int BS1_SComp_InferIsNumP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(BS1_SComp_InferIsLongP(t))return(1);
	if(BS1_SComp_InferIsFloatP(t))return(1);
	if(BS1_SComp_InferIsDoubleP(t))return(1);
	return(0);
}

elem BS1_SComp_InferIsInt(elem t)
{
	if(BS1_SComp_InferIsIntP(t))
		return(KEYSYM("int"));
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferIsLong(elem t)
{
	if(BS1_SComp_InferIsIntP(t))
		return(KEYSYM("int"));
	if(BS1_SComp_InferIsLongP(t))
		return(KEYSYM("long"));
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferIsNum(elem t)
{
	if(BS1_SComp_InferIsIntP(t))
		return(KEYSYM("int"));
	if(BS1_SComp_InferIsLongP(t))
		return(KEYSYM("long"));
	if(BS1_SComp_InferIsFloatP(t))
		return(KEYSYM("float"));
	if(BS1_SComp_InferIsDoubleP(t))
		return(KEYSYM("double"));
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferForm(BS1_SVMCState *ctx, elem l)
{
	elem c, t, x, n;
	int i;

	if(CAR(l)==SYM("cast"))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		return(CADR(l));
	}

	if((CAR(l)==SYM("unary")) && (CADR(l)==SYM("!")))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		return(KEYSYM("bool"));
	}

	if((CAR(l)==SYM("unary")) && (CADR(l)==SYM("~")))
	{
		t=BS1_SComp_InferExpr(ctx, CADR(l));
		return(BS1_SComp_InferIsLong(t));
	}

//	if((CAR(l)==SYM("-")) && !BS1_CONSP(CDDR(l)))
//	{
//		t=BS1_SComp_InferExpr(ctx, CADR(l));
//		return(BS1_SComp_InferIsNum(t));
//	}

	if(FORM_IS(l, "binary") && CADR(l)==SYM("/"))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		x=BS1_SComp_InferExpr(ctx, CADDDR(l));

		i=BS1_SComp_InferIsNumP(t) &&
			BS1_SComp_InferIsNumP(x);
		if(!i)return(BS1_MM_NULL);

		n=KEYSYM("float");
		if(t==KEYSYM("double"))n=t;
		if(x==KEYSYM("double"))n=x;
		return(n);
	}

	if(FORM_IS(l, "binary") && (CADR(l)==SYM("\\")))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		x=BS1_SComp_InferExpr(ctx, CADDDR(l));

		return(KEYSYM("int"));
	}

//	if((CAR(l)==SYM("+")) || (CAR(l)==SYM("-")) ||
//		(CAR(l)==SYM("*")) ||
//		(CAR(l)==SYM("%")) || (CAR(l)==SYM("&")) ||
//		(CAR(l)==SYM("|")) || (CAR(l)==SYM("^")))

	if(FORM_IS(l, "binary") && (
		(CADR(l)==SYM("+")) || (CADR(l)==SYM("-")) ||
		(CADR(l)==SYM("*")) || (CADR(l)==SYM("%")) ||
		(CADR(l)==SYM("&")) || (CADR(l)==SYM("|")) ||
		(CADR(l)==SYM("^"))))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));

		x=t; c=CDDDR(l);
		while(BS1_CONSP(c))
		{
			t=BS1_SComp_InferExpr(ctx, CAR(c));
			if(t!=x)return(BS1_MM_NULL);
			c=CDR(c);
		}
		return(x);
	}

	if(FORM_IS(l, "binary") &&
		((CADR(l)==SYM("<<")) || (CADR(l)==SYM(">>"))))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		x=BS1_SComp_InferExpr(ctx, CADDDR(l));

		i=BS1_SComp_InferIsIntP(t) &&
			BS1_SComp_InferIsIntP(x);
		if(i)return(t);
		return(BS1_MM_NULL);
	}

//	if((CAR(l)==SYM("==")) || (CAR(l)==SYM("===")) ||
//		(CAR(l)==SYM("!=")) || (CAR(l)==SYM("!==")) ||
//		(CAR(l)==SYM("<")) || (CAR(l)==SYM(">")) ||
//		(CAR(l)==SYM("<=")) || (CAR(l)==SYM(">=")))

	if(FORM_IS(l, "binary") && (
		(CADR(l)==SYM("==")) || (CADR(l)==SYM("===")) ||
		(CADR(l)==SYM("!=")) || (CADR(l)==SYM("!==")) ||
		(CADR(l)==SYM("<"))  || (CADR(l)==SYM(">")) ||
		(CADR(l)==SYM("<=")) || (CADR(l)==SYM(">="))))
	{
		return(KEYSYM("bool"));
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==1)
		{
			t=BS1_SComp_InferExpr(ctx, CADDR(l));
			return(t);
		}
		if(i==0)
		{
			t=BS1_MM_NULL;
			if(BS1_CONSP(CDDDR(l)))
				t=BS1_SComp_InferExpr(ctx, CADDDR(l));
			return(t);
		}

		x=BS1_MM_NULL;
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		if(BS1_CONSP(CDDDR(l)))
			x=BS1_SComp_InferExpr(ctx, CADDDR(l));
		if(t!=x)return(BS1_MM_NULL);
		return(t);
	}

	if(CAR(l)==SYM("funcall"))
	{
#if 0
		printf("Infer Func: ");
		BS1_TY_Print(CADR(l));
		printf("=");
		BS1_TY_Print(ctx->cf_n);
		printf("\n");
#endif

		ctx->i_cx_p=0;
		if(CADR(l)==ctx->cf_n)
		{
			t=BS1_SComp_InferTypeBase(ctx->cf_ty);
			return(t);
//			return(ctx->cf_ty);
		}
		return(BS1_MM_NULL);
	}

	ctx->i_cx_p=0;
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferExpr(BS1_SVMCState *ctx, elem l)
{
	elem t, cn, cv, ct;

	l=BS1_SComp_ReduceExpr(ctx, l);

//	printf("Infer Reduce: ");
//	BS1_TY_PrintLN(l);

	if(BS1_CONSP(l))
	{
		t=BS1_SComp_InferForm(ctx, l);
		return(t);
	}

	if(BS1_SYMBOLP(l))
	{
		if(l==SYM("I"))return(KEYSYM("complex"));
		if(l==SYM("PI"))return(KEYSYM("float"));
		if(l==SYM("E"))return(KEYSYM("float"));

		cn=ctx->lenv;
		ct=ctx->tenv;
		cv=ctx->venv;

		while(BS1_CONSP(cn))
		{
			if(CAR(cn)==l)
			{
				t=BS1_SComp_InferTypeBase(CAR(ct));
				return(t);
			}
			cn=CDR(cn);
			ct=CDR(ct);
			cv=CDR(cv);
		}

		return(BS1_MM_NULL);
	}

	if(l==BS1_MM_NULL)return(KEYSYM("null"));
	if(l==BS1_MM_TRUE)return(KEYSYM("bool"));
	if(l==BS1_MM_FALSE)return(KEYSYM("bool"));

	if(BS1_FIXNUMP(l))return(KEYSYM("int"));
	if(BS1_FLONUMP(l))return(KEYSYM("float"));
	if(BS1_CHARP(l))return(KEYSYM("char"));

	if(BS1_STRINGP(l))return(KEYSYM("string"));
	if(BS1_KEYWORDP(l))return(KEYSYM("keyword"));

	if(BS1_ARRAYP(l))return(KEYSYM("array"));
	if(BS1_FVECTORP(l))return(KEYSYM("vector"));

	return(BS1_MM_NULL);
}

elem BS1_SComp_InferExprClean(BS1_SVMCState *ctx, elem l, int *cp)
{
	elem t;

	ctx->i_cx_p=1;
	t=BS1_SComp_InferExpr(ctx, l);
	*cp=ctx->i_cx_p;

	return(t);
}


int BS1_SComp_GuessCloseForm(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	if(FORM_IS(l, "lambda"))return(1);
	if(FORM_IS(l, "rlambda"))return(1);
	if(FORM_IS(l, "defun"))return(1);
	if(FORM_IS(l, "define") && BS1_CONSP(CADR(l)))
		return(1);

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		i=i||BS1_SComp_GuessCloseExpr(ctx, CAR(c));
		c=CDR(c);
	}
	return(i);
}

int BS1_SComp_GuessCloseExpr(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	if(BS1_CONSP(l))
		return(BS1_SComp_GuessCloseForm(ctx, l));

	if(BS1_SYMBOLP(l))
	{
		c=ctx->lenv; i=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==l)break;
			c=CDR(c);
		}

		if(BS1_CONSP(c))return(i);
		return(0);
	}

	return(0);
}

int BS1_SComp_GuessCloseBlock(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		i=i||BS1_SComp_GuessCloseExpr(ctx, CAR(c));
		c=CDR(c);
	}
	return(i);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>

static int bs1_scomp_seq=1;

int BS1_SComp_IndexLit(BS1_SVMCState *ctx, elem l)
{
	int i;

	for(i=0; ctx->lit[i]; i++)
		if(BS1_Opr_IsEqual(ctx->lit[i], l))
			return(i);
	ctx->lit[i]=l;
	return(i);
}

int BS1_SComp_IndexLit2(BS1_SVMCState *ctx, elem l)
{
	int i;

	for(i=0; ctx->lit[i]; i++)
		if(ctx->lit[i]==l)
			return(i);
	ctx->lit[i]=l;
	return(i);
}

void BS1_SComp_EncIDX(BS1_SVMCState *ctx, int i)
{
	if(i<127)
	{
		*ctx->ip++=i;
		return;
	}

	*ctx->ip++=(i>>8)|128;
	*ctx->ip++=i&255;
}

void BS1_SComp_EmitGoto(BS1_SVMCState *ctx, char *name, byte *ip)
{
	ctx->goto_name[ctx->n_goto]=strdup(name);
	ctx->goto_dest[ctx->n_goto]=ip;
	ctx->n_goto++;
}

void BS1_SComp_EmitLabel(BS1_SVMCState *ctx, char *name, byte *ip)
{
	ctx->lbl_name[ctx->n_lbl]=strdup(name);
	ctx->lbl_dest[ctx->n_lbl]=ip;
	ctx->n_lbl++;
}

char *BS1_SComp_GenSym()
{
	char buf[32];

	sprintf(buf, "gs$%d", bs1_scomp_seq++);
	return(BS1_RStrDup(buf));
}

int BS1_SComp_RegIdx(elem t)
{
	char *s;

	if(!BS1_SYMBOLP(t))return(-1);
	s=BS1_TOSYM(t);
	if(s[0]!='$')return(-1);
	if((s[1]<'0') || (s[1]>'9'))return(-1);
	return(atoi(s+1));
}

void BS1_SComp_CompileBreak(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->breakstack[ctx->breakstackpos-1];
	*ctx->ip++=BS1_SOP_JMP;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileContinue(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->contstack[ctx->contstackpos-1];
	*ctx->ip++=BS1_SOP_JMP;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileBreakFalse(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->breakstack[ctx->breakstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_FALSE;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileBreakTrue(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->breakstack[ctx->breakstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_TRUE;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileContinueFalse(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->contstack[ctx->contstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_FALSE;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileContinueTrue(BS1_SVMCState *ctx)
{
	char *s;

	s=ctx->contstack[ctx->contstackpos-1];
	*ctx->ip++=BS1_SOP_JMP_TRUE;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}


void BS1_SComp_CompileJmp(BS1_SVMCState *ctx, char *s)
{
	*ctx->ip++=BS1_SOP_JMP;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileJmpFalse(BS1_SVMCState *ctx, char *s)
{
	*ctx->ip++=BS1_SOP_JMP_FALSE;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileJmpTrue(BS1_SVMCState *ctx, char *s)
{
	*ctx->ip++=BS1_SOP_JMP_TRUE;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileJmpCond(BS1_SVMCState *ctx, int i, char *s)
{
	*ctx->ip++=BS1_SOP_JMP_COND_B;
	*ctx->ip++=i;
	*ctx->ip++=0;
	*ctx->ip++=0;
	BS1_SComp_EmitGoto(ctx, s, ctx->ip);
}

void BS1_SComp_CompileJCO(BS1_SVMCState *ctx, int op, elem ln, elem rn)
{
	elem lt, rt;
	elem t0, t1;
	int i, j, k;

	ln=BS1_SComp_ReduceExpr(ctx, ln);
	rn=BS1_SComp_ReduceExpr(ctx, rn);
	lt=BS1_SComp_InferExpr(ctx, ln);
	rt=BS1_SComp_InferExpr(ctx, rn);


	if(BS1_FIXNUMP(ln) || BS1_FLONUMP(ln))
	{
		switch(op)
		{
			case BS1_OPR_L: op=BS1_OPR_G; break;
			case BS1_OPR_G: i=BS1_OPR_L; break;
			case BS1_OPR_LE: i=BS1_OPR_GE; break;
			case BS1_OPR_GE: i=BS1_OPR_LE; break;
			default: break;
		}

		t0=ln; t1=lt;
		ln=rn; lt=rt;
		rn=t0; rt=t1;
	}

#if 1
	j=BS1_SComp_CheckLexical(ctx, ln);
	k=BS1_SComp_CheckLexical(ctx, rn);

	if((lt==rt) && (lt==KEYSYM("int")) && (j>=0) && (k>=0) &&
		!ctx->i_cap)
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_LFN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_LFN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_LFN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_LFN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_LFN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_LFN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_LFN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_LFN; break;
			default: break;
		}

		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=j;
		*ctx->ip++=k;
		*ctx->ip++=0;
		*ctx->ip++=0;
		return;
	}

	if((lt==KEYSYM("int")) && (j>=0) && (rn==BS1_MM_FIXNUM_0) &&
		!ctx->i_cap)
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_LZFN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_LZFN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_LZFN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_LZFN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_LZFN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_LZFN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_LZFN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_LZFN; break;
			default: break;
		}

		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=j;
		*ctx->ip++=0;
		*ctx->ip++=0;
		return;
	}

	if((lt==KEYSYM("int")) && (j>=0) && BS1_FIXNUMP(rn) &&
		(TOINT(rn)>-128) && (TOINT(rn)<128) &&
		!ctx->i_cap)
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_LFNC; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_LFNC; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_LFNC; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_LFNC; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_LFNC; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_LFNC; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_LFNC; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_LFNC; break;
			default: break;
		}

		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=j;
		*ctx->ip++=TOINT(rn);
		*ctx->ip++=0;
		*ctx->ip++=0;
		return;
	}
#endif

	if((lt==KEYSYM("int")) && (rn==BS1_MM_FIXNUM_0))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_ZFN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_ZFN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_ZFN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_ZFN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_ZFN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_ZFN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_ZFN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_ZFN; break;
			default: break;
		}
		BS1_SComp_CompileExpr(ctx, ln);
		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=0; *ctx->ip++=0;
		return;
	}

	if((lt==KEYSYM("int")) && BS1_FIXNUMP(rn) &&
		(TOINT(rn)>-128) && (TOINT(rn)<128))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_FNC; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_FNC; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_FNC; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_FNC; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_FNC; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_FNC; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_FNC; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_FNC; break;
			default: break;
		}
		BS1_SComp_CompileExpr(ctx, ln);
		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=TOINT(rn);
		*ctx->ip++=0; *ctx->ip++=0;
		return;
	}

	if((lt==rt) && (lt==KEYSYM("int")))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_FN; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_FN; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_FN; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_FN; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_FN; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_FN; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_FN; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_FN; break;
			default: break;
		}

		BS1_SComp_CompileExpr(ctx, ln);
		BS1_SComp_CompileExpr(ctx, rn);
		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=0; *ctx->ip++=0;
		return;
	}

	if(((lt==KEYSYM("int")) || (lt==KEYSYM("float"))) &&
		((rt==KEYSYM("int")) || (rt==KEYSYM("float"))))
	{
		switch(op)
		{
			case BS1_OPR_EQV: i=BS1_SOP_JMP_E_FL; break;
			case BS1_OPR_NEQV: i=BS1_SOP_JMP_NE_FL; break;
			case BS1_OPR_EQ: i=BS1_SOP_JMP_E_FL; break;
			case BS1_OPR_NEQ: i=BS1_SOP_JMP_NE_FL; break;
			case BS1_OPR_L: i=BS1_SOP_JMP_L_FL; break;
			case BS1_OPR_G: i=BS1_SOP_JMP_G_FL; break;
			case BS1_OPR_LE: i=BS1_SOP_JMP_LE_FL; break;
			case BS1_OPR_GE: i=BS1_SOP_JMP_GE_FL; break;
			default: break;
		}

		BS1_SComp_CompileExpr(ctx, ln);
		if(lt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;
		BS1_SComp_CompileExpr(ctx, rn);
		if(rt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;

		BS1_SComp_EmitOp(ctx, i);
		*ctx->ip++=0; *ctx->ip++=0;
		return;
	}

	BS1_SComp_CompileExpr(ctx, ln);
	BS1_SComp_CompileExpr(ctx, rn);
	*ctx->ip++=BS1_SOP_JMP_COND_B;
	*ctx->ip++=op;
	*ctx->ip++=0; *ctx->ip++=0;
}

void BS1_SComp_CompileJCT(BS1_SVMCState *ctx, elem l)
{
	elem t;
	int i;

	l=BS1_SComp_ReduceExpr(ctx, l);
	t=BS1_SComp_InferExpr(ctx, l);

	if(FORM_IS(l, "unary") && (CADR(l)==SYM("!")))
	{
		BS1_SComp_CompileJCF(ctx, CADDR(l));
		return;
	}

	i=-1;
	if(FORM_IS_BINARY(l, "=="))i=BS1_OPR_EQV;
	if(FORM_IS_BINARY(l, "!="))i=BS1_OPR_NEQV;
	if(FORM_IS_BINARY(l, "==="))i=BS1_OPR_EQ;
	if(FORM_IS_BINARY(l, "!=="))i=BS1_OPR_NEQ;
	if(FORM_IS_BINARY(l, "<"))i=BS1_OPR_L;
	if(FORM_IS_BINARY(l, ">"))i=BS1_OPR_G;
	if(FORM_IS_BINARY(l, "<="))i=BS1_OPR_LE;
	if(FORM_IS_BINARY(l, ">="))i=BS1_OPR_GE;

	if(i<0)
	{
		i=BS1_SComp_CheckLexical(ctx, l);
		if((t==KEYSYM("int")) && (i>=0) && !ctx->i_cap)
		{
			BS1_SComp_EmitOp(ctx, BS1_SOP_JMP_NE_LZFN);
			*ctx->ip++=i;
			*ctx->ip++=0; *ctx->ip++=0;
			return;
		}

		if(t==KEYSYM("int"))
		{
			BS1_SComp_CompileExpr(ctx, l);
			BS1_SComp_EmitOp(ctx, BS1_SOP_JMP_NE_ZFN);
			*ctx->ip++=0; *ctx->ip++=0;
			return;
		}

		BS1_SComp_CompileExpr(ctx, l);
		*ctx->ip++=BS1_SOP_JMP_TRUE;
		*ctx->ip++=0;
		*ctx->ip++=0;
		return;
	}

	BS1_SComp_CompileJCO(ctx, i, CADDR(l), CADDDR(l));
}

void BS1_SComp_CompileJCF(BS1_SVMCState *ctx, elem l)
{
	elem t;
	int i;

	l=BS1_SComp_ReduceExpr(ctx, l);
	t=BS1_SComp_InferExpr(ctx, l);

	if(FORM_IS(l, "unary") && (CADR(l)==SYM("!")))
	{
		BS1_SComp_CompileJCT(ctx, CADDR(l));
		return;
	}

	i=-1;
	if(FORM_IS_BINARY(l, "=="))i=BS1_OPR_NEQV;
	if(FORM_IS_BINARY(l, "!="))i=BS1_OPR_EQV;
	if(FORM_IS_BINARY(l, "==="))i=BS1_OPR_NEQ;
	if(FORM_IS_BINARY(l, "!=="))i=BS1_OPR_EQ;
	if(FORM_IS_BINARY(l, "<"))i=BS1_OPR_GE;
	if(FORM_IS_BINARY(l, ">"))i=BS1_OPR_LE;
	if(FORM_IS_BINARY(l, "<="))i=BS1_OPR_G;
	if(FORM_IS_BINARY(l, ">="))i=BS1_OPR_L;

	if(i<0)
	{
		i=BS1_SComp_CheckLexical(ctx, l);
		if((t==KEYSYM("int")) && (i>=0) && !ctx->i_cap)
		{
			BS1_SComp_EmitOp(ctx, BS1_SOP_JMP_E_LZFN);
			*ctx->ip++=i;
			*ctx->ip++=0; *ctx->ip++=0;
			return;
		}

		if(t==KEYSYM("int"))
		{
			BS1_SComp_CompileExpr(ctx, l);
			BS1_SComp_EmitOp(ctx, BS1_SOP_JMP_E_ZFN);
			*ctx->ip++=0; *ctx->ip++=0;
			return;
		}

		BS1_SComp_CompileExpr(ctx, l);
		*ctx->ip++=BS1_SOP_JMP_FALSE;
		*ctx->ip++=0;
		*ctx->ip++=0;
		return;
	}

	BS1_SComp_CompileJCO(ctx, i, CADDR(l), CADDDR(l));
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>


int BS1_SComp_CompileBinary(BS1_SVMCState *ctx, elem l)
{
	elem ln, rn, lt, rt;
	elem t0, t1;
	int lc, rc;

	int i, j, k;

	ln=BS1_SComp_ReduceExpr(ctx, CADR(l));
	rn=BS1_SComp_ReduceExpr(ctx, CADDR(l));

	lt=BS1_SComp_InferExprClean(ctx, ln, &lc);
	rt=BS1_SComp_InferExprClean(ctx, rn, &rc);

#if 0
	printf("Infer L: ");
	BS1_TY_Print(ln);
	printf(" ");
	BS1_TY_Print(lt);
	printf(" %s\n", lc?"clean":"dirty");

	printf("Infer R: ");
	BS1_TY_Print(rn);
	printf(" ");
	BS1_TY_Print(rt);
	printf(" %s\n", rc?"clean":"dirty");
#endif

	if(lt==BS1_MM_NULL)return(0);
	if(rt==BS1_MM_NULL)return(0);

	if((lt==rt) && (lt==KEYSYM("int")))
	{
		i=-1;

		if(CAR(l)==SYM("+"))i=BS1_SOP_ADD_FN;
		if(CAR(l)==SYM("-"))i=BS1_SOP_SUB_FN;
		if(CAR(l)==SYM("*"))i=BS1_SOP_MUL_FN;
		if(CAR(l)==SYM("/"))i=BS1_SOP_DIV_FN;
		if(CAR(l)==SYM("\\"))i=BS1_SOP_IDIV_FN;
		if(CAR(l)==SYM("%"))i=BS1_SOP_MOD_FN;
		if(CAR(l)==SYM("&"))i=BS1_SOP_AND_FN;
		if(CAR(l)==SYM("|"))i=BS1_SOP_OR_FN;
		if(CAR(l)==SYM("^"))i=BS1_SOP_XOR_FN;

		if(CAR(l)==SYM("<<"))i=BS1_SOP_SHL_FN;
		if(CAR(l)==SYM(">>"))i=BS1_SOP_SHR_FN;
		if(CAR(l)==SYM("**"))i=BS1_SOP_EXP_FN;

		if(CAR(l)==SYM("<"))i=BS1_SOP_CMP_L_FN;
		if(CAR(l)==SYM(">"))i=BS1_SOP_CMP_G_FN;
		if(CAR(l)==SYM("<="))i=BS1_SOP_CMP_LE_FN;
		if(CAR(l)==SYM(">="))i=BS1_SOP_CMP_GE_FN;
		if(CAR(l)==SYM("=="))i=BS1_SOP_CMP_E_FN;
		if(CAR(l)==SYM("!="))i=BS1_SOP_CMP_NE_FN;
		if(CAR(l)==SYM("==="))i=BS1_SOP_CMP_E_FN;
		if(CAR(l)==SYM("!=="))i=BS1_SOP_CMP_NE_FN;

		if(i<0)return(0);

		if(((i==BS1_SOP_ADD_FN) || (i==BS1_SOP_SUB_FN)) &&
			(BS1_FIXNUMP(ln) || BS1_FIXNUMP(rn)))
		{
			if(BS1_FIXNUMP(ln)) { t0=rn; t1=ln; }
				else { t0=ln; t1=rn; }

			j=TOINT(t1);
			if(!j)
			{
				BS1_SComp_CompileExpr(ctx, t0);
				return(1);
			}

			k=1;
			if(i==BS1_SOP_SUB_FN)
			{
				j=-j;

				//handle case of sides flipped
				if(BS1_FIXNUMP(ln))k=0;
			}

			if(k && (j>0) && (j<256))
			{
				BS1_SComp_CompileExpr(ctx, t0);
				if(j<3)
				{
					if(j==1)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_INC2_FN;
					return(1);
				}

				*ctx->ip++=BS1_SOP_ADD_FN_C;
				*ctx->ip++=j;
				return(1);
			}
			if(k && (j<0) && (j>-256))
			{
				BS1_SComp_CompileExpr(ctx, t0);
				if(j>-3)
				{
					if(j==-1)*ctx->ip++=BS1_SOP_DEC_FN;
					else *ctx->ip++=BS1_SOP_DEC2_FN;
					return(1);
				}

				*ctx->ip++=BS1_SOP_SUB_FN_C;
				*ctx->ip++=-j;
				return(1);
			}
		}

		if((i==BS1_SOP_MUL_FN) &&
			(BS1_FIXNUMP(ln) || BS1_FIXNUMP(rn)))
		{
			if(BS1_FIXNUMP(ln)) { t0=rn; t1=ln; }
				else { t0=ln; t1=rn; }

			j=TOINT(t1);
			if(!j)
			{
				*ctx->ip++=BS1_SOP_PUSH_0;
				return(1);
			}

			k=0;
			if(j<0) { j=-j; k=1; }

			if(j<256)
			{
				BS1_SComp_CompileExpr(ctx, t0);
				*ctx->ip++=BS1_SOP_MUL_FN_C;
				*ctx->ip++=j;
				if(k)*ctx->ip++=BS1_SOP_NEG_FN;
				return(1);
			}
		}

#if 0
		if((i==BS1_SOP_EXP_FN) && BS1_FIXNUMP(rn))
		{
			j=TOINT(rn);
			if(!j)
			{
				*ctx->ip++=BS1_SOP_PUSH_1;
				return(1);
			}

			if((j>0) && (j<=8))
			{
				BS1_SComp_CompileExpr(ctx, ln);
				for(k=1; k<j; k++)
					*ctx->ip++=BS1_SOP_DUP_F;
				for(k=1; k<j; k++)
					*ctx->ip++=BS1_SOP_MUL_FN;
				return(1);
			}
		}
#endif

		if(((i==BS1_SOP_SHL_FN) || (i==BS1_SOP_SHR_FN) ||
			(i==BS1_SOP_EXP_FN)) && BS1_FIXNUMP(rn))
		{
			j=TOINT(rn);
			if(!j && ((i==BS1_SOP_SHL_FN) || (i==BS1_SOP_SHR_FN)))
			{
				BS1_SComp_CompileExpr(ctx, ln);
				return(1);
			}
			if(!j && (i==BS1_SOP_EXP_FN))
			{
				*ctx->ip++=BS1_SOP_PUSH_1;
				return(1);
			}

			if((j>0) && (j<256))
			{
				if(i==BS1_SOP_SHL_FN)i=BS1_SOP_SHL_FN_C;
				if(i==BS1_SOP_SHR_FN)i=BS1_SOP_SHR_FN_C;
				if(i==BS1_SOP_EXP_FN)i=BS1_SOP_EXP_FN_C;

				BS1_SComp_CompileExpr(ctx, ln);
				*ctx->ip++=i;
				*ctx->ip++=j;
				return(1);
			}
		}

		if(lc && rc && EQUALP(ln, rn))
		{
			BS1_SComp_CompileExpr(ctx, ln);
			*ctx->ip++=BS1_SOP_DUP_F;
			*ctx->ip++=i;
			return(1);
		}

		BS1_SComp_CompileExpr(ctx, ln);
		BS1_SComp_CompileExpr(ctx, rn);
		*ctx->ip++=i;

		return(1);
	}

	i=0; j=0;
	if(lt==KEYSYM("int"))i=1;
	if(lt==KEYSYM("float"))i=1;
	if(rt==KEYSYM("int"))j=1;
	if(rt==KEYSYM("float"))j=1;

	if(i && j)
	{
		i=-1;

		if(CAR(l)==SYM("+"))i=BS1_SOP_ADD_FL;
		if(CAR(l)==SYM("-"))i=BS1_SOP_SUB_FL;
		if(CAR(l)==SYM("*"))i=BS1_SOP_MUL_FL;
		if(CAR(l)==SYM("/"))i=BS1_SOP_DIV_FL;

		if(CAR(l)==SYM("<"))i=BS1_SOP_CMP_L_FL;
		if(CAR(l)==SYM(">"))i=BS1_SOP_CMP_G_FL;
		if(CAR(l)==SYM("<="))i=BS1_SOP_CMP_LE_FL;
		if(CAR(l)==SYM(">="))i=BS1_SOP_CMP_GE_FL;
		if(CAR(l)==SYM("=="))i=BS1_SOP_CMP_E_FL;
		if(CAR(l)==SYM("!="))i=BS1_SOP_CMP_NE_FL;

		if(i<0)return(0);

		if(lc && rc && EQUALP(ln, rn))
		{
			BS1_SComp_CompileExpr(ctx, ln);
			*ctx->ip++=BS1_SOP_DUP_F;
			*ctx->ip++=i;
		}


		BS1_SComp_CompileExpr(ctx, ln);
		if(lt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;

		BS1_SComp_CompileExpr(ctx, rn);
		if(rt==KEYSYM("int"))*ctx->ip++=BS1_SOP_CONV_FN2FL;

		*ctx->ip++=i;

		return(1);
	}

	return(0);
}

int BS1_SComp_CompileSpecial(BS1_SVMCState *ctx, elem l)
{
	elem c, t, u, v;
	char *s0, *s1, *s2, *s3;
	int i, j;

	if(CAR(l)==SYM("infer"))
	{
		t=BS1_SComp_InferExpr(ctx, CADR(l));
		i=BS1_SComp_IndexLit(ctx, t);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
		return(1);
	}


	s0=TOSYM(CAR(l));
	s1=s0+(strlen(s0)-1);

	i=0;
	if((*s0=='c') && (*s1=='r'))
	{
		s2=s0+1;
		while((s2<s1) && ((*s2=='a') || (*s2=='d')))
			s2++;
		if(s2==s1)i=1;
	}

	if(!i)return(0);

	BS1_SComp_CompileExpr(ctx, CADR(l));

	s0++; s2=s1-1;
	while((s2-1)>=s0)
	{
		if(!strncmp(s2-1, "aa", 2))*ctx->ip++=BS1_SOP_CAAR;
		if(!strncmp(s2-1, "da", 2))*ctx->ip++=BS1_SOP_CDAR;
		if(!strncmp(s2-1, "ad", 2))*ctx->ip++=BS1_SOP_CADR;
		if(!strncmp(s2-1, "dd", 2))*ctx->ip++=BS1_SOP_CDDR;
		s2-=2;
	}
	while(s2>=s0)
	{
		if(*s2=='a')*ctx->ip++=BS1_SOP_CAR;
			else *ctx->ip++=BS1_SOP_CDR;
		s2--;
	}

	return(1);
}

void BS1_SComp_EmitOp(BS1_SVMCState *ctx, elem i)
{
	if(i>=192)
	{
		*ctx->ip++=(i>>8)+192;
		*ctx->ip++=i&0xFF;
	}else *ctx->ip++=i;
}

int BS1_SComp_CheckLexical(BS1_SVMCState *ctx, elem l)
{
	elem c, t;
	int i;

	if(!BS1_SYMBOLP(l))return(-1);

	c=ctx->lenv; i=0;
	while(BS1_CONSP(c))
	{
		if(CAR(c)==l)break;
		c=CDR(c);
		i++;
	}

	if(BS1_CONSP(c))return(i);
	return(-1);
}


void BS1_SComp_CompileAssign(BS1_SVMCState *ctx, elem l)
{
	elem c, ct, cv, t;
	int i, j;

	i=BS1_SComp_RegIdx(l);
	if(i>=0)
	{
		*ctx->ip++=BS1_SOP_POP_R;
		*ctx->ip++=i;
		return;
	}

	c=ctx->lenv; ct=ctx->tenv; cv=ctx->venv;
	i=0; j=0;
	while(BS1_CONSP(c))
	{
		if(c==ctx->llenv)i=1;
		if(CAR(c)==l)break;
		c=CDR(c); ct=CDR(ct); cv=CDR(cv);
		j++;
	}
	if(BS1_CONSP(c) && i)ctx->cap++;

	if(BS1_CONSP(c))
	{
		t=CAR(ct);
		BS1_TY_SetCar(cv, BS1_MM_NULL);

		if(t!=BS1_MM_NULL)
		{
			i=BS1_SComp_IndexLit(ctx, t);
			*ctx->ip++=BS1_SOP_CAST;
			BS1_SComp_EncIDX(ctx, i);
		}

		if((t==KEYSYM("int")) || (t==KEYSYM("float")))
		{
			*ctx->ip++=BS1_SOP_LSTORE_F;
			*ctx->ip++=j;
			return;
		}

		*ctx->ip++=BS1_SOP_LSTORE;
		*ctx->ip++=j;
		return;
	}

	i=BS1_SComp_IndexLit(ctx, l);
	*ctx->ip++=BS1_SOP_STORE;
	BS1_SComp_EncIDX(ctx, i);
}

void BS1_SComp_CompileForm(BS1_SVMCState *ctx, elem l)
{
	byte *ips[64];
	byte *ip0, *ip1, *ip2;
	elem c, d, t, u, v;
	int i, j;

	if(BS1_KEYWORDP(CAR(l)))
	{
		BS1_SComp_CompileExpr(ctx, CADR(l));
		i=BS1_SComp_IndexLit(ctx, CAR(l));
		*ctx->ip++=BS1_SOP_CAST;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("goto"))
	{
		if(!ctx->tail)
		{
			printf("invalid use of goto\n");
			return;
		}

		*ctx->ip++=BS1_SOP_JMP;
		*ctx->ip++=0;
		*ctx->ip++=0;
		BS1_SComp_EmitGoto(ctx,
			BS1_TY_GetSymbol(CADR(l)), ctx->ip);
		return;
	}

	if(CAR(l)==SYM("label"))
	{
		if(!ctx->tail)
		{
			printf("invalid use of label\n");
			return;
		}

		BS1_SComp_EmitLabel(ctx,
			BS1_TY_GetSymbol(CADR(l)), ctx->ip);
		*ctx->ip++=BS1_SOP_PUSH_NULL;
		return;
	}

	if(	(CAR(l)==SYM("for")) || (CAR(l)==SYM("while")) ||
		(CAR(l)==SYM("for_in")) || (CAR(l)==SYM("do_while")))
	{
		BS1_SComp_CompileStatement(ctx, l);
		*ctx->ip++=BS1_SOP_PUSH_NULL;
		return;
	}


	if(CAR(l)==SYM("quote"))
	{
		i=BS1_SComp_IndexLit(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("return"))
	{
		BS1_SComp_CompileExpr(ctx, CADR(l));
		if(!ctx->tail)
			*ctx->ip++=BS1_SOP_RET;
		return;
	}

	if(CAR(l)==SYM("set!"))
	{
		BS1_SComp_CompileExpr(ctx, CADDR(l));

		i=BS1_SComp_RegIdx(CADR(l));
		if(i>=0)
		{
			*ctx->ip++=BS1_SOP_DUP_R;
			*ctx->ip++=i;
			return;
		}

		*ctx->ip++=BS1_SOP_DUP;
		BS1_SComp_CompileAssign(ctx, CADR(l));
		return;
	}

	if((CAR(l)==SYM("setindex!")) || (CAR(l)==SYM("vector-set!")))
	{
		t=CADDDR(l);
		u=BS1_SComp_InferExpr(ctx, t);
		BS1_SComp_CompileExpr(ctx, t);
		if((u==KEYSYM("int")) || (u==KEYSYM("float")))
				*ctx->ip++=BS1_SOP_DUP_F;
			else *ctx->ip++=BS1_SOP_DUP;

		if(BS1_FIXNUMP(CADDR(l)))
		{
			i=TOINT(CADDR(l));
			if((i>=0) && (i<4))
			{
				BS1_SComp_CompileExpr(ctx, CADR(l));
				*ctx->ip++=BS1_SOP_STOREINDEX_0+i;
				return;
			}
			if((i>=0) && (i<255))
			{
				BS1_SComp_CompileExpr(ctx, CADR(l));
				*ctx->ip++=BS1_SOP_STOREINDEX_I;
				*ctx->ip++=i;
				return;
			}
		}

//		BS1_SComp_CompileExpr(ctx, CADDDR(l));
//		*ctx->ip++=BS1_SOP_DUP;
		BS1_SComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_EXCH;
		BS1_SComp_CompileExpr(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_EXCH;
		*ctx->ip++=BS1_SOP_STOREINDEX;
		return;
	}

	if((CAR(l)==SYM("getindex")) || (CAR(l)==SYM("vector-ref")))
	{
		if(BS1_FIXNUMP(CADDR(l)))
		{
			i=TOINT(CADDR(l));
			if((i>=0) && (i<4))
			{
				BS1_SComp_CompileExpr(ctx, CADR(l));
				*ctx->ip++=BS1_SOP_LOADINDEX_0+i;
				return;
			}
			if((i>=0) && (i<255))
			{
				BS1_SComp_CompileExpr(ctx, CADR(l));
				*ctx->ip++=BS1_SOP_LOADINDEX_I;
				*ctx->ip++=i;
				return;
			}
		}

		BS1_SComp_CompileExpr(ctx, CADR(l));
		BS1_SComp_CompileExpr(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_LOADINDEX;
		return;
	}

	if(CAR(l)==SYM("objref"))
	{
		BS1_SComp_CompileExpr(ctx, CADR(l));
//		i=BS1_SComp_IndexLit(ctx, CADDR(l));
//		*ctx->ip++=BS1_SOP_PUSH;
//		BS1_SComp_EncIDX(ctx, i);
//		*ctx->ip++=BS1_SOP_LOADINDEX;

		i=BS1_SComp_IndexLit(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_LOADINDEX_S;
		*ctx->ip++=i;

		return;
	}

	if(CAR(l)==SYM("objset!"))
	{
//		BS1_SComp_CompileExpr(ctx, CADDDR(l));
//		*ctx->ip++=BS1_SOP_DUP;
//
//		BS1_SComp_CompileExpr(ctx, CADR(l));
//		*ctx->ip++=BS1_SOP_EXCH;
//
//		i=BS1_SComp_IndexLit(ctx, CADDR(l));
//		*ctx->ip++=BS1_SOP_PUSH;
//		BS1_SComp_EncIDX(ctx, i);
//		*ctx->ip++=BS1_SOP_EXCH;
//		*ctx->ip++=BS1_SOP_STOREINDEX;

		t=CADDDR(l);
		u=BS1_SComp_InferExpr(ctx, t);
		BS1_SComp_CompileExpr(ctx, t);
		if((u==KEYSYM("int")) || (u==KEYSYM("float")))
				*ctx->ip++=BS1_SOP_DUP_F;
			else *ctx->ip++=BS1_SOP_DUP;

		BS1_SComp_CompileExpr(ctx, CADR(l));
		i=BS1_SComp_IndexLit(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_STOREINDEX_S;
		*ctx->ip++=i;

		return;
	}

	if(FORM_IS(l, "preinc!") || FORM_IS(l, "predec!"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		u=BS1_SComp_InferExpr(ctx, t);
		if(FORM_IS(l, "preinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;

		if(BS1_SYMBOLP(t))
		{
			BS1_SComp_CompileExpr(ctx, t);

			if(u==KEYSYM("int"))
			{
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_DEC_FN;
				*ctx->ip++=BS1_SOP_DUP_F;
			}else
			{
				*ctx->ip++=BS1_SOP_UNARYOP;
				*ctx->ip++=i;
				*ctx->ip++=BS1_SOP_DUP;
			}

//			i=BS1_SComp_IndexLit(ctx, t);
//			*ctx->ip++=BS1_SOP_STORE;
//			BS1_SComp_EncIDX(ctx, i);
			BS1_SComp_CompileAssign(ctx, t);
			return;
		}

		return;
	}

	if(FORM_IS(l, "postinc!") || FORM_IS(l, "postdec!"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		u=BS1_SComp_InferExpr(ctx, t);
		if(FORM_IS(l, "postinc!"))i=BS1_OPR_INC;
			else i=BS1_OPR_DEC;

		if(BS1_SYMBOLP(t))
		{
			BS1_SComp_CompileExpr(ctx, t);

			if(u==KEYSYM("int"))
			{
				*ctx->ip++=BS1_SOP_DUP_F;
				if(i==BS1_OPR_INC)*ctx->ip++=BS1_SOP_INC_FN;
					else *ctx->ip++=BS1_SOP_DEC_FN;
			}else
			{
				*ctx->ip++=BS1_SOP_DUP;
				*ctx->ip++=BS1_SOP_UNARYOP;
				*ctx->ip++=i;
			}

//			i=BS1_SComp_IndexLit(ctx, t);
//			*ctx->ip++=BS1_SOP_STORE;
//			BS1_SComp_EncIDX(ctx, i);
			BS1_SComp_CompileAssign(ctx, t);
			return;
		}

		return;
	}


	if(CAR(l)==SYM("if"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==1)
		{
			BS1_SComp_CompileExpr(ctx, CADDR(l));
			return;
		}
		if(i==0)
		{
			if(BS1_CONSP(CDDDR(l)))
				BS1_SComp_CompileExpr(ctx, CADDDR(l));
			return;
		}

#if 0
		if(FORM_IS(t, "unary") && (CADR(t)==SYM("!")))
		{
			BS1_SComp_CompileExpr(ctx, CADDR(t));
			*ctx->ip++=BS1_SOP_JMP_TRUE;
			*ctx->ip++=0;
			*ctx->ip++=0;
			ip0=ctx->ip;
		}else
		{
			BS1_SComp_CompileExpr(ctx, t);
			*ctx->ip++=BS1_SOP_JMP_FALSE;
			*ctx->ip++=0;
			*ctx->ip++=0;
			ip0=ctx->ip;
		}
#endif

		BS1_SComp_CompileJCF(ctx, t);
		ip0=ctx->ip;

		BS1_SComp_CompileExprT(ctx, CADDR(l));

		if(ctx->tail)
		{
			if(!FORM_IS(CADDR(l), "funcall"))
				*ctx->ip++=BS1_SOP_RET;
		}else
		{
			*ctx->ip++=BS1_SOP_JMP;
			*ctx->ip++=0;
			*ctx->ip++=0;
			ip1=ctx->ip;
		}

		i=ctx->ip-ip0;
		*(ip0-2)=i&0xFF;
		*(ip0-1)=(i>>8)&0xFF;

		if(BS1_CONSP(CDDDR(l)))
			BS1_SComp_CompileExprT(ctx, CADDDR(l));
			else *ctx->ip++=BS1_SOP_PUSH_NULL;

		if(!ctx->tail)
		{
			i=ctx->ip-ip1;
			*(ip1-2)=i&0xFF;
			*(ip1-1)=(i>>8)&0xFF;
		}

		return;
	}

	if(CAR(l)==SYM("begin"))
	{
		c=CDR(l);
		while(1)
		{
			if(BS1_CONSP(CDR(c)))
			{
				BS1_SComp_CompileStatement(ctx, CAR(c));
				c=CDR(c);
				continue;
			}

			BS1_SComp_CompileExprT(ctx, CAR(c));
			break;
		}

		return;
	}

	if((CAR(l)==SYM("and")) || (CAR(l)==SYM("or")))
	{
		if(CAR(l)==SYM("and"))j=BS1_SOP_JMP_FALSE;
		if(CAR(l)==SYM("or"))j=BS1_SOP_JMP_TRUE;

		i=0; c=CDR(l);
		while(1)
		{
			if(BS1_CONSP(CDR(c)))
			{
				BS1_SComp_CompileExpr(ctx, CAR(c));
				*ctx->ip++=BS1_SOP_DUP;

				*ctx->ip++=j;
				*ctx->ip++=0;
				*ctx->ip++=0;
				ips[i++]=ctx->ip;

				*ctx->ip++=BS1_SOP_POP;

				c=CDR(c);
				continue;
			}

			BS1_SComp_CompileExprT(ctx, CAR(c));

			while(i>0)
			{
				i--;
				j=ctx->ip-ips[i];
				*(ips[i]-2)=j&0xFF;
				*(ips[i]-1)=(j>>8)&0xFF;
			}

			break;
		}

		return;
	}

	if(CAR(l)==SYM("define"))
	{
		if(!BS1_CONSP(CADR(l)))
		{
			BS1_SComp_CompileExpr(ctx, CADDR(l));
			*ctx->ip++=BS1_SOP_DUP;
			i=BS1_SComp_IndexLit(ctx, CADR(l));
			if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
				else *ctx->ip++=BS1_SOP_BIND;
			BS1_SComp_EncIDX(ctx, i);
			return;
		}

		t=CONS(SYM("lambda"), CONS(CDADR(l), CDDR(l)));
		BS1_SComp_CompileExpr(ctx, t);
		*ctx->ip++=BS1_SOP_DUP;
		i=BS1_SComp_IndexLit(ctx, CAADR(l));
		if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
			else *ctx->ip++=BS1_SOP_BIND;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("defun"))
	{
//		t=CONS2S("lambda", CADDDR(l), CDDDDR(l));
		t=CONS3S("rlambda", LIST2(CADR(l), CADDR(l)),
			CADDDR(l), CDDDDR(l));

//		BS1_TY_PrintLN(t);

		BS1_SComp_CompileExpr(ctx, t);
		*ctx->ip++=BS1_SOP_DUP;

		i=BS1_SComp_IndexLit(ctx, CADDR(l));
		if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
			else *ctx->ip++=BS1_SOP_BIND;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("defvar"))
	{
		if(!BS1_CONSP(CADR(l)))
		{
			BS1_SComp_CompileExpr(ctx, CADDR(l));
			*ctx->ip++=BS1_SOP_DUP;
			i=BS1_SComp_IndexLit(ctx, CADR(l));
			*ctx->ip++=BS1_SOP_DYNBIND;
			BS1_SComp_EncIDX(ctx, i);
			return;
		}

		t=CONS(SYM("lambda"), CONS(CDADR(l), CDDR(l)));
		BS1_SComp_CompileExpr(ctx, t);
		*ctx->ip++=BS1_SOP_DUP;
		i=BS1_SComp_IndexLit(ctx, CAADR(l));
		*ctx->ip++=BS1_SOP_DYNBIND;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(CAR(l)==SYM("vars"))
	{
		c=CADDR(l);

		while(BS1_CONSP(c))
		{
			if(BS1_CONSP(CAR(c)))
			{
				BS1_SComp_CompileExpr(ctx, CADAR(c));
				i=BS1_SComp_IndexLit(ctx, CAAR(c));
				if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
					else *ctx->ip++=BS1_SOP_BIND;
				BS1_SComp_EncIDX(ctx, i);
			}else
			{
				*ctx->ip++=BS1_SOP_PUSH_NULL;
				i=BS1_SComp_IndexLit(ctx, CAR(c));
				if(ctx->lvl)*ctx->ip++=BS1_SOP_LEXBIND;
					else *ctx->ip++=BS1_SOP_BIND;
				BS1_SComp_EncIDX(ctx, i);
			}

			c=CDR(c);
		}
		*ctx->ip++=BS1_SOP_PUSH_NULL;
		return;
	}

	if(CAR(l)==SYM("lambda"))
	{
		j=ctx->cap;
		ctx->cap=0;

		t=BS1_SComp_CompileBlock(ctx, BS1_MM_NULL, CADR(l), CDDR(l));

		i=BS1_SComp_IndexLit(ctx, t);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);

		if(ctx->cap)*ctx->ip++=BS1_SOP_CLOSE;
		ctx->cap=ctx->cap||j;

		return;
	}

	if(CAR(l)==SYM("rlambda"))
	{
		j=ctx->cap;
		ctx->cap=0;

		t=BS1_SComp_CompileBlock(ctx, CADR(l), CADDR(l), CDDDR(l));

		i=BS1_SComp_IndexLit(ctx, t);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);

		if(ctx->cap)*ctx->ip++=BS1_SOP_CLOSE;
		ctx->cap=ctx->cap||j;

		return;
	}

	if(CAR(l)==SYM("attr"))
	{
		BS1_SComp_CompileExpr(ctx, CADDR(l));
		i=BS1_SComp_IndexLit(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
		*ctx->ip++=BS1_SOP_ATTR;
	}

	if(CAR(l)==SYM("dict"))
	{
		*ctx->ip++=BS1_SOP_MARK;

		i=BS1_SComp_IndexLit(ctx, SYM("_parent"));
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
		*ctx->ip++=BS1_SOP_PUSHSELF;

		j=ctx->lvl;
		ctx->lvl=0;
		ctx->olvl++;

		c=CDR(l);
		while(BS1_CONSP(c))
		{
			t=CAR(c);

			if(FORM_IS(t, "attr") || FORM_IS(t, "set!"))
			{
				i=BS1_SComp_IndexLit(ctx, CADR(t));
				*ctx->ip++=BS1_SOP_PUSH;
				BS1_SComp_EncIDX(ctx, i);
				BS1_SComp_CompileExpr(ctx, CADDR(t));
			}

			if(FORM_IS(t, "define"))
			{
				i=BS1_SComp_IndexLit(ctx, CAADR(t));
				*ctx->ip++=BS1_SOP_PUSH;
				BS1_SComp_EncIDX(ctx, i);
				u=CONS2(SYM("lambda"), 
					CDADR(t), CDDR(t));
				BS1_SComp_CompileExpr(ctx, u);
			}

			c=CDR(c);
		}
		*ctx->ip++=BS1_SOP_DICT;

		ctx->olvl--;
		ctx->lvl=j;
		return;
	}

	if((CAR(l)==SYM("list")) || (CAR(l)==SYM("array")) ||
		(CAR(l)==SYM("vector")))
	{
		*ctx->ip++=BS1_SOP_MARK;
		c=CDR(l);
		while(BS1_CONSP(c))
		{
			BS1_SComp_CompileExpr(ctx, CAR(c));
			c=CDR(c);
		}
		if(CAR(l)==SYM("list"))
		{
			BS1_SComp_CompileExpr(ctx, c);
			*ctx->ip++=BS1_SOP_LIST;
		}
		if(CAR(l)==SYM("array"))*ctx->ip++=BS1_SOP_ARRAY;
		if(CAR(l)==SYM("vector"))*ctx->ip++=BS1_SOP_VECTOR;
		return;
	}

	if(CAR(l)==SYM("matrix"))
	{
		*ctx->ip++=BS1_SOP_MARK;
		c=CDR(l);
		while(BS1_CONSP(c))
		{
			if(BS1_CONSP(CAR(c)))
			{
				*ctx->ip++=BS1_SOP_MARK;
				d=CAR(c);
				while(BS1_CONSP(d))
				{
					BS1_SComp_CompileExpr(ctx, CAR(d));
					d=CDR(d);
				}
				*ctx->ip++=BS1_SOP_VECTOR;
			}else BS1_SComp_CompileExpr(ctx, CAR(c));
			c=CDR(c);
		}

		*ctx->ip++=BS1_SOP_MATRIX;
		return;
	}

	if(CAR(l)==SYM("unary"))
	{
		BS1_SComp_CompileExpr(ctx, CADDR(l));

		i=-1;
		if(CADR(l)==SYM("+"))i=BS1_OPR_POS;
		if(CADR(l)==SYM("-"))i=BS1_OPR_NEG;
		if(CADR(l)==SYM("~"))i=BS1_OPR_NOT;
		if(CADR(l)==SYM("!"))i=BS1_OPR_LNOT;
		if(CADR(l)==SYM("*"))i=BS1_OPR_UMUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_UDIV;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_UIDIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_UMOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_UAND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_UOR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_UXOR;
		if(CADR(l)==SYM("&&"))i=BS1_OPR_ULAND;
		if(CADR(l)==SYM("||"))i=BS1_OPR_ULOR;
		if(CADR(l)==SYM("^^"))i=BS1_OPR_ULXOR;

		*ctx->ip++=BS1_SOP_UNARYOP;
		*ctx->ip++=i;
		return;
	}

#if 0
	if((CAR(l)==SYM("+")) || (CAR(l)==SYM("-")) ||
		(CAR(l)==SYM("*")) || (CAR(l)==SYM("/")) ||
		(CAR(l)==SYM("%")) || (CAR(l)==SYM("&")) ||
		(CAR(l)==SYM("|")) || (CAR(l)==SYM("^")) ||
		(CAR(l)==SYM("\\")) || (CAR(l)==SYM("**")) ||
		(CAR(l)==SYM("+.")) || (CAR(l)==SYM("-.")) ||
		(CAR(l)==SYM("*.")) || (CAR(l)==SYM("/.")) ||
		(CAR(l)==SYM("%.")) || (CAR(l)==SYM("&.")) ||
		(CAR(l)==SYM("|.")) || (CAR(l)==SYM("^.")) ||
		(CAR(l)==SYM("\\.")))
	{
		if(CDDDR(l)==BS1_MM_NULL)
		{
			i=BS1_SComp_CompileBinary(ctx, l);
			if(i)return;
		}

		BS1_SComp_CompileExpr(ctx, CADR(l));

		if(CAR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CAR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CAR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CAR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CAR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CAR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CAR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CAR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CAR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CAR(l)==SYM("**"))i=BS1_OPR_EXP;

		if(CAR(l)==SYM("+."))i=BS1_OPR_DADD;
		if(CAR(l)==SYM("-."))i=BS1_OPR_DSUB;
		if(CAR(l)==SYM("*."))i=BS1_OPR_DMUL;
		if(CAR(l)==SYM("/."))i=BS1_OPR_DDIV;
		if(CAR(l)==SYM("\\."))i=BS1_OPR_DIDIV;
		if(CAR(l)==SYM("%."))i=BS1_OPR_DMOD;
		if(CAR(l)==SYM("&."))i=BS1_OPR_DAND;
		if(CAR(l)==SYM("|."))i=BS1_OPR_DOR;
		if(CAR(l)==SYM("^."))i=BS1_OPR_DXOR;

		c=CDDR(l);
		while(BS1_CONSP(c))
		{
			BS1_SComp_CompileExpr(ctx, CAR(c));
			*ctx->ip++=BS1_SOP_BINARYOP;
			*ctx->ip++=i;
			c=CDR(c);
		}
		return;
	}

	if((CAR(l)==SYM("<<")) || (CAR(l)==SYM(">>")) ||
		(CAR(l)==SYM("==")) || (CAR(l)==SYM("===")) ||
		(CAR(l)==SYM("!=")) || (CAR(l)==SYM("!==")) ||
		(CAR(l)==SYM("<")) || (CAR(l)==SYM(">")) ||
		(CAR(l)==SYM("<=")) || (CAR(l)==SYM(">=")))
	{
		i=BS1_SComp_CompileBinary(ctx, l);
		if(i)return;

		BS1_SComp_CompileExpr(ctx, CADR(l));
		BS1_SComp_CompileExpr(ctx, CADDR(l));

		if(CAR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CAR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CAR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CAR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CAR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CAR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CAR(l)==SYM("<"))i=BS1_OPR_L;
		if(CAR(l)==SYM(">"))i=BS1_OPR_G;
		if(CAR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CAR(l)==SYM(">="))i=BS1_OPR_GE;

		*ctx->ip++=BS1_SOP_BINARYOP;
		*ctx->ip++=i;
		return;
	}
#endif

	if(FORM_IS(l, "binary"))
	{
		i=BS1_SComp_CompileBinary(ctx, CDR(l));
		if(i)return;

		BS1_SComp_CompileExpr(ctx, CADDR(l));
		BS1_SComp_CompileExpr(ctx, CADDDR(l));

		i=-1;
		if(CADR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CADR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CADR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CADR(l)==SYM("**"))i=BS1_OPR_EXP;

		if(CADR(l)==SYM("+."))i=BS1_OPR_DADD;
		if(CADR(l)==SYM("-."))i=BS1_OPR_DSUB;
		if(CADR(l)==SYM("*."))i=BS1_OPR_DMUL;
		if(CADR(l)==SYM("/."))i=BS1_OPR_DDIV;
		if(CADR(l)==SYM("\\."))i=BS1_OPR_DIDIV;
		if(CADR(l)==SYM("%."))i=BS1_OPR_DMOD;
		if(CADR(l)==SYM("&."))i=BS1_OPR_DAND;
		if(CADR(l)==SYM("|."))i=BS1_OPR_DOR;
		if(CADR(l)==SYM("^."))i=BS1_OPR_DXOR;

		if(CADR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CADR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CADR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CADR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CADR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CADR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CADR(l)==SYM("<"))i=BS1_OPR_L;
		if(CADR(l)==SYM(">"))i=BS1_OPR_G;
		if(CADR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CADR(l)==SYM(">="))i=BS1_OPR_GE;

		*ctx->ip++=BS1_SOP_BINARYOP;
		*ctx->ip++=i;
		return;
	}

	if(CAR(l)==SYM("funcall"))
	{
		if(BS1_SYMBOLP(CADR(l)))
		{
			i=BS1_SComp_CompileSpecial(ctx, CDR(l));
			if(i>0)return;
		}

		*ctx->ip++=BS1_SOP_MARK;
		c=CDDR(l);
		while(BS1_CONSP(c))
		{
			BS1_SComp_CompileExpr(ctx, CAR(c));
			c=CDR(c);
		}

		if(CADR(l)==ctx->cf_n)
		{
			if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL_CF;
				else *ctx->ip++=BS1_SOP_CALL_CF;
			return;
		}

		if(BS1_SYMBOLP(CADR(l)))
		{
			i=BS1_SComp_IndexLit(ctx, CADR(l));
			if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL_S;
				else *ctx->ip++=BS1_SOP_CALL_S;
			BS1_SComp_EncIDX(ctx, i);
			return;
		}

		BS1_SComp_CompileExpr(ctx, CADR(l));
		if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL;
			else *ctx->ip++=BS1_SOP_CALL;
		return;
	}

	if(CAR(l)==SYM("methodcall"))
	{
		*ctx->ip++=BS1_SOP_MARK;
		c=CDDDR(l);
		while(BS1_CONSP(c))
		{
			BS1_SComp_CompileExpr(ctx, CAR(c));
			c=CDR(c);
		}

		BS1_SComp_CompileExpr(ctx, CADR(l));

		i=BS1_SComp_IndexLit(ctx, CADDR(l));
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);

		if(ctx->tail)*ctx->ip++=BS1_SOP_METHODTAILCALL;
			else *ctx->ip++=BS1_SOP_METHODCALL;
		return;
	}

	if(CAR(l)==SYM("complex"))
	{
		BS1_SComp_CompileExpr(ctx, CADR(l));
		*ctx->ip++=BS1_SOP_COMPLEX_I;
		return;
	}

	printf("unhandled expr %s\n", BS1_TY_GetSymbol(CAR(l)));
	*ctx->ip++=BS1_SOP_PUSH_NULL;

#if 0
	*ctx->ip++=BS1_SOP_MARK;
	c=CDR(l);
	while(BS1_CONSP(c))
	{
		BS1_SComp_CompileExpr(ctx, CAR(c));
		c=CDR(c);
	}
	BS1_SComp_CompileExpr(ctx, CAR(l));
	if(ctx->tail)*ctx->ip++=BS1_SOP_TAILCALL;
		else *ctx->ip++=BS1_SOP_CALL;
#endif
}

void BS1_SComp_CompileExprT(BS1_SVMCState *ctx, elem l)
{
	float f;
	elem t, c, ct, cv;
	int i, j;

	l=BS1_SComp_ReduceExpr(ctx, l);

	if(BS1_CONSP(l))
	{
		BS1_SComp_CompileForm(ctx, l);
		return;
	}

	if(BS1_SYMBOLP(l))
	{
		i=BS1_SComp_RegIdx(l);
		if(i>=0)
		{
			*ctx->ip++=BS1_SOP_PUSH_R;
			*ctx->ip++=i;
			return;
		}

		//take note of any captured variables
		c=ctx->lenv; ct=ctx->tenv; cv=ctx->venv; i=0; j=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==l)break;
			c=CDR(c); ct=CDR(ct); cv=CDR(cv);
			j++;
		}
		if(BS1_CONSP(c) && i)ctx->cap++;

		if(!BS1_CONSP(c))
		{
			if((l==SYM("self")) || (l==SYM("this")))
				{ *ctx->ip++=BS1_SOP_PUSHSELF; return; }
			if(l==SYM("true"))
				{ *ctx->ip++=BS1_SOP_PUSH_TRUE; return; }
			if(l==SYM("false"))
				{ *ctx->ip++=BS1_SOP_PUSH_FALSE; return; }
			if(l==SYM("null"))
				{ *ctx->ip++=BS1_SOP_PUSH_NULL; return; }
		}

		if((l==ctx->cf_n) && (!BS1_CONSP(c) || i))
			{ *ctx->ip++=BS1_SOP_PUSH_CF; return; }

#if 0
		if(BS1_CONSP(c) && i)printf("CCAP: %s\n",
			BS1_TY_GetSymbol(l));
		if(BS1_CONSP(c) && !i)printf("LOC: %s\n",
			BS1_TY_GetSymbol(l));
		if(!BS1_CONSP(c))printf("OBJ: %s\n",
			BS1_TY_GetSymbol(l));
#endif

		if(BS1_CONSP(c))
		{
			t=CAR(ct);
			if((t==KEYSYM("int")) || (t==KEYSYM("float")))
			{
				*ctx->ip++=BS1_SOP_LLOAD_F;
				*ctx->ip++=j;
				return;
			}

			*ctx->ip++=BS1_SOP_LLOAD;
			*ctx->ip++=j;
			return;
		}

		i=BS1_SComp_IndexLit(ctx, l);
		*ctx->ip++=BS1_SOP_LOAD;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}

	if(l==BS1_MM_NULL)
		{ *ctx->ip++=BS1_SOP_PUSH_NULL; }
	else if(l==BS1_MM_TRUE)
		{ *ctx->ip++=BS1_SOP_PUSH_TRUE; }
	else if(l==BS1_MM_FALSE)
		{ *ctx->ip++=BS1_SOP_PUSH_FALSE; }
	else if(l==BS1_MM_FIXNUM) { *ctx->ip++=BS1_SOP_PUSH_0; }
	else if(l==BS1_MM_FIXNUM_1) { *ctx->ip++=BS1_SOP_PUSH_1; }
	else if(l==BS1_MM_FIXNUM_2) { *ctx->ip++=BS1_SOP_PUSH_2; }
	else if(l==BS1_MM_FIXNUM_3) { *ctx->ip++=BS1_SOP_PUSH_3; }
	else if(l==BS1_MM_FIXNUM_4) { *ctx->ip++=BS1_SOP_PUSH_4; }
	else if(l==BS1_MM_FIXNUM_5) { *ctx->ip++=BS1_SOP_PUSH_5; }
	else if(l==BS1_MM_FIXNUM_6) { *ctx->ip++=BS1_SOP_PUSH_6; }
	else if(l==BS1_MM_FIXNUM_7) { *ctx->ip++=BS1_SOP_PUSH_7; }
	else if(BS1_FIXNUMP(l))
	{
		i=BS1_TOINT(l);
/*
		if((i>=-127) && (i<=127))
		{
			*ctx->ip++=BS1_SOP_PUSH_SV;
			*ctx->ip++=i&0xFF;
			return;
		}
*/
		if((i>=0) && (i<=255))
		{
			*ctx->ip++=BS1_SOP_PUSH_SV_P;
			*ctx->ip++=i;
			return;
		}
		if((i<=0) && (i>=-255))
		{
			*ctx->ip++=BS1_SOP_PUSH_SV_N;
			*ctx->ip++=-i;
			return;
		}

		i=BS1_SComp_IndexLit2(ctx, l);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}else if(BS1_FLONUMP(l))
	{
		f=BS1_TOFLOAT(l);
		i=(int)(rint(f*100));
//		printf("%f %f %f\n", f, i/100.0, f-(i/100.0));
		if((-32768<=i) && (i<=32767) && ( (f==(i/100.0)) ||
			((fabs(f-(i/100.0))<=0.0001) && ((i>100) || (i<-100))) ))
		{
			*ctx->ip++=BS1_SOP_PUSH_SV_F;
			*ctx->ip++=i&0xFF;
			*ctx->ip++=(i>>8)&0xFF;
			return;
		}

		i=BS1_SComp_IndexLit2(ctx, l);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
		return;
	}else
	{
		i=BS1_SComp_IndexLit(ctx, l);
		*ctx->ip++=BS1_SOP_PUSH;
		BS1_SComp_EncIDX(ctx, i);
	}
}

void BS1_SComp_CompileExpr(BS1_SVMCState *ctx, elem l)
{
	int i;

	i=ctx->tail;
	ctx->tail=0;
	BS1_SComp_CompileExprT(ctx, l);
	ctx->tail=i;
}

void BS1_SComp_CompileExprTail(BS1_SVMCState *ctx, elem l)
{
	int i;

	i=ctx->tail;
	ctx->tail=1;
	BS1_SComp_CompileExprT(ctx, l);
	ctx->tail=i;
}
/* Autogenerated source */

char *bs1_ops_strs[]={
"nop", "block", "dbgmark", "cgenast", "", "", "", "", "", "", "", 
"", "", "", "", "", "push", "pop", "load", "store", "bind", "dynbind", 
"lexbind", "loadindex", "storeindex", "pushself", "clearenv", "bindpattern", 
"loadmindex", "storemindex", "tryload", "", "mark", "call", "tailcall", 
"ret", "pushenv", "popenv", "enter", "exit", "methodcall", "begincc", 
"beginobj", "close", "methodtailcall", "flink", "frame", "close2", 
"dup", "exch", "index", "rindex", "setindex", "setrindex", "", "", 
"", "", "", "", "", "", "", "", "unaryop", "binaryop", "push_null", 
"push_true", "push_false", "push_sv", "push_0", "push_1", "push_2", 
"push_3", "push_4", "push_5", "push_6", "push_7", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "throw", "begintry", 
"endtry", "catch", "", "", "jmp", "jmp_true", "jmp_false", "", "", 
"", "", "", "", "", "array", "dict", "attr", "object", "vector", 
"terminal", "complex", "matrix", "list", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", ""};

char *bs1_ops_args[]={
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", ""};

/*
Reverse Preprocessing Step
Process and rebuild parse trees in reverse order for reasons of building a
forwards context (and possible rebuilding of future statements).
*/

#include <bgbscr1.h>

elem BS1_SComp_ReverseStepStmt(BS1_SVMCState *ctx, elem l)
{
	return(l);
}

elem BS1_SComp_ReverseStepBlock(BS1_SVMCState *ctx, elem l)
{
	elem t, r;
	if(!BS1_CONSP(l))return(l);
	r=BS1_SComp_ReverseStepBlock(ctx, CDR(l));
	t=BS1_SComp_ReverseStepStmt(ctx, CAR(l));

	if((t==CAR(l)) && (r==CDR(l)))
		return(l);

	t=CONS(t, r);
	BS1_GC_CheckRef(l);
	return(t);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>


int BS1_SComp_BoolExpr(BS1_SVMCState *ctx, elem l)
{
	if(l==BS1_MM_FALSE)return(0);
	if(l==BS1_MM_NULL)return(0);
	if(l==BS1_MM_FIXNUM)return(0);
	if(l==BS1_MM_FLONUM)return(0);

	if(l==BS1_MM_TRUE)return(1);
	if(BS1_FIXNUMP(l))return(1);
	if(BS1_FLONUMP(l))return(1);
	return(-1);
}

int BS1_SComp_IsExpr(elem l)
{
	if(BS1_CONSP(l))return(1);
	if(BS1_SYMBOLP(l))return(1);
	return(0);
}

elem BS1_SComp_ReduceForm(BS1_SVMCState *ctx, elem l)
{
	elem c, t, x;
	int i, j;

	if(CAR(l)==SYM("unary"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		if(CADR(l)==SYM("!"))
		{
			if(CAR(t)==SYM("=="))return(CONSS("!=", CDR(t)));
			if(CAR(t)==SYM("!="))return(CONSS("==", CDR(t)));
			if(CAR(t)==SYM("==="))return(CONSS("!==", CDR(t)));
			if(CAR(t)==SYM("!=="))return(CONSS("===", CDR(t)));

			if(CAR(t)==SYM("<"))return(CONSS(">=", CDR(t)));
			if(CAR(t)==SYM(">"))return(CONSS("<=", CDR(t)));
			if(CAR(t)==SYM("<="))return(CONSS(">", CDR(t)));
			if(CAR(t)==SYM(">="))return(CONSS("<", CDR(t)));
		}

		if(CADR(l)==SYM("+"))i=BS1_OPR_POS;
		if(CADR(l)==SYM("-"))i=BS1_OPR_NEG;
		if(CADR(l)==SYM("~"))i=BS1_OPR_NOT;
		if(CADR(l)==SYM("!"))i=BS1_OPR_LNOT;
		if(CADR(l)==SYM("*"))i=BS1_OPR_UMUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_UDIV;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_UIDIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_UMOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_UAND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_UOR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_UXOR;
		if(CADR(l)==SYM("&&"))i=BS1_OPR_ULAND;
		if(CADR(l)==SYM("||"))i=BS1_OPR_ULOR;
		if(CADR(l)==SYM("^^"))i=BS1_OPR_ULXOR;

		l=BS1_Opr_Unary(i, t);
		return(l);
	}

#if 0
	if((CAR(l)==SYM("+")) || (CAR(l)==SYM("-")) ||
		(CAR(l)==SYM("*")) || (CAR(l)==SYM("/")) ||
		(CAR(l)==SYM("%")) || (CAR(l)==SYM("&")) ||
		(CAR(l)==SYM("|")) || (CAR(l)==SYM("^")) ||
		(CAR(l)==SYM("**")) || (CAR(l)==SYM("\\")))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		if(CAR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CAR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CAR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CAR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CAR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CAR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CAR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CAR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CAR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CAR(l)==SYM("**"))i=BS1_OPR_EXP;

		x=t; c=CDDR(l);
		while(BS1_CONSP(c))
		{
			t=BS1_SComp_ReduceExpr(ctx, CAR(c));
			if(BS1_SComp_IsExpr(t))return(l);

			x=BS1_Opr_Binary(i, x, t);

			c=CDR(c);
		}
		return(x);
	}

	if((CAR(l)==SYM("<<")) || (CAR(l)==SYM(">>")) ||
		(CAR(l)==SYM("==")) || (CAR(l)==SYM("===")) ||
		(CAR(l)==SYM("!=")) || (CAR(l)==SYM("!==")) ||
		(CAR(l)==SYM("<")) || (CAR(l)==SYM(">")) ||
		(CAR(l)==SYM("<=")) || (CAR(l)==SYM(">=")))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		x=BS1_SComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_SComp_IsExpr(x))return(l);


		if(CAR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CAR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CAR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CAR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CAR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CAR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CAR(l)==SYM("<"))i=BS1_OPR_L;
		if(CAR(l)==SYM(">"))i=BS1_OPR_G;
		if(CAR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CAR(l)==SYM(">="))i=BS1_OPR_GE;

		l=BS1_Opr_Binary(i, t, x);
		return(l);
	}
#endif

	if(FORM_IS(l, "binary"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADDR(l));
		if(BS1_SComp_IsExpr(t))return(l);

		x=BS1_SComp_ReduceExpr(ctx, CADDDR(l));
		if(BS1_SComp_IsExpr(x))return(l);


		if(CADR(l)==SYM("+"))i=BS1_OPR_ADD;
		if(CADR(l)==SYM("-"))i=BS1_OPR_SUB;
		if(CADR(l)==SYM("*"))i=BS1_OPR_MUL;
		if(CADR(l)==SYM("/"))i=BS1_OPR_DIV;
		if(CADR(l)==SYM("%"))i=BS1_OPR_MOD;
		if(CADR(l)==SYM("&"))i=BS1_OPR_AND;
		if(CADR(l)==SYM("|"))i=BS1_OPR_OR;
		if(CADR(l)==SYM("^"))i=BS1_OPR_XOR;
		if(CADR(l)==SYM("\\"))i=BS1_OPR_IDIV;
		if(CADR(l)==SYM("**"))i=BS1_OPR_EXP;

		if(CADR(l)==SYM("<<"))i=BS1_OPR_SHL;
		if(CADR(l)==SYM(">>"))i=BS1_OPR_SHR;
		if(CADR(l)==SYM("=="))i=BS1_OPR_EQV;
		if(CADR(l)==SYM("!="))i=BS1_OPR_NEQV;
		if(CADR(l)==SYM("==="))i=BS1_OPR_EQ;
		if(CADR(l)==SYM("!=="))i=BS1_OPR_NEQ;
		if(CADR(l)==SYM("<"))i=BS1_OPR_L;
		if(CADR(l)==SYM(">"))i=BS1_OPR_G;
		if(CADR(l)==SYM("<="))i=BS1_OPR_LE;
		if(CADR(l)==SYM(">="))i=BS1_OPR_GE;

		if((CADR(l)==SYM("/")) && BS1_FIXNUMP(t) && BS1_FIXNUMP(x))
			return(BS1_TY_Rational(TOINT(t), TOINT(x)));

		l=BS1_Opr_Binary(i, t, x);
		return(l);
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==1)
		{
			l=BS1_SComp_ReduceExpr(ctx, CADDR(l));
			return(l);
		}
		if(i==0)
		{
			t=BS1_MM_NULL;
			if(BS1_CONSP(CDDDR(l)))
				t=BS1_SComp_ReduceExpr(ctx, CADDDR(l));
			return(t);
		}
		return(l);
	}

	if(CAR(l)==SYM("begin"))
	{
//		if((CDDR(l)==BS1_MM_NULL) &&
//			(FORM_IS(CADR(l), "unary") ||
//			FORM_IS(CADR(l), "binary")))

		if(CDDR(l)==BS1_MM_NULL)
		{
			t=BS1_SComp_ReduceExpr(ctx, CADR(l));
			return(t);
		}

		return(l);
	}

	return(l);
}

elem BS1_SComp_ReduceExpr(BS1_SVMCState *ctx, elem l)
{
	elem t, cn, cv, ct;
	if(BS1_CONSP(l))
	{
		t=BS1_SComp_ReduceForm(ctx, l);
		return(t);
	}

	if(BS1_SYMBOLP(l))
	{
		if(l==SYM("I"))return(BS1_COMPLEX_I(1));
		if(l==SYM("PI"))return(FLONUM(M_PI));
		if(l==SYM("E"))return(FLONUM(M_E));

		cn=ctx->lenv;
		ct=ctx->tenv;
		cv=ctx->venv;

		if(ctx->cap)return(l);

		while(BS1_CONSP(cn) && (cn!=ctx->lenv))
		{
			if((CAR(cn)==l) && (CAR(cv)!=BS1_MM_NULL))
				return(CAR(cv));

			cn=CDR(cn);
			ct=CDR(ct);
			cv=CDR(cv);
		}
	}
	return(l);
}


elem BS1_SComp_InferTypeBase(elem l)
{
	char b[64];
	char *s, *t;

	if(!BS1_KEYWORDP(l))
		return(BS1_MM_NULL);

	s=TOSYM(l); t=b;
	while(*s && (*s!='$'))*t++=*s++;
	*t++=0;

	return(KEYSYM(b));
}

int BS1_SComp_InferIsIntP(elem t)
{
	if(t==KEYSYM("byte"))return(1);
	if(t==KEYSYM("sbyte"))return(1);
	if(t==KEYSYM("short"))return(1);
	if(t==KEYSYM("ushort"))return(1);
	if(t==KEYSYM("int"))return(1);
	if(t==KEYSYM("uint"))return(1);
	return(0);
}

int BS1_SComp_InferIsLongP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("long"))return(1);
	if(t==KEYSYM("ulong"))return(1);
	return(0);
}

int BS1_SComp_InferIsFloatP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("float"))return(1);
	return(0);
}

int BS1_SComp_InferIsDoubleP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(t==KEYSYM("float"))return(1);
	if(t==KEYSYM("double"))return(1);
	return(0);
}

int BS1_SComp_InferIsNumP(elem t)
{
	if(BS1_SComp_InferIsIntP(t))return(1);
	if(BS1_SComp_InferIsLongP(t))return(1);
	if(BS1_SComp_InferIsFloatP(t))return(1);
	if(BS1_SComp_InferIsDoubleP(t))return(1);
	return(0);
}

elem BS1_SComp_InferIsInt(elem t)
{
	if(BS1_SComp_InferIsIntP(t))
		return(KEYSYM("int"));
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferIsLong(elem t)
{
	if(BS1_SComp_InferIsIntP(t))
		return(KEYSYM("int"));
	if(BS1_SComp_InferIsLongP(t))
		return(KEYSYM("long"));
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferIsNum(elem t)
{
	if(BS1_SComp_InferIsIntP(t))
		return(KEYSYM("int"));
	if(BS1_SComp_InferIsLongP(t))
		return(KEYSYM("long"));
	if(BS1_SComp_InferIsFloatP(t))
		return(KEYSYM("float"));
	if(BS1_SComp_InferIsDoubleP(t))
		return(KEYSYM("double"));
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferForm(BS1_SVMCState *ctx, elem l)
{
	elem c, t, x, n;
	int i;

	if(CAR(l)==SYM("cast"))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		return(CADR(l));
	}

	if((CAR(l)==SYM("unary")) && (CADR(l)==SYM("!")))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		return(KEYSYM("bool"));
	}

	if((CAR(l)==SYM("unary")) && (CADR(l)==SYM("~")))
	{
		t=BS1_SComp_InferExpr(ctx, CADR(l));
		return(BS1_SComp_InferIsLong(t));
	}

//	if((CAR(l)==SYM("-")) && !BS1_CONSP(CDDR(l)))
//	{
//		t=BS1_SComp_InferExpr(ctx, CADR(l));
//		return(BS1_SComp_InferIsNum(t));
//	}

	if(FORM_IS(l, "binary") && CADR(l)==SYM("/"))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		x=BS1_SComp_InferExpr(ctx, CADDDR(l));

		i=BS1_SComp_InferIsNumP(t) &&
			BS1_SComp_InferIsNumP(x);
		if(!i)return(BS1_MM_NULL);

		n=KEYSYM("float");
		if(t==KEYSYM("double"))n=t;
		if(x==KEYSYM("double"))n=x;
		return(n);
	}

	if(FORM_IS(l, "binary") && (CADR(l)==SYM("\\")))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		x=BS1_SComp_InferExpr(ctx, CADDDR(l));

		return(KEYSYM("int"));
	}

//	if((CAR(l)==SYM("+")) || (CAR(l)==SYM("-")) ||
//		(CAR(l)==SYM("*")) ||
//		(CAR(l)==SYM("%")) || (CAR(l)==SYM("&")) ||
//		(CAR(l)==SYM("|")) || (CAR(l)==SYM("^")))

	if(FORM_IS(l, "binary") && (
		(CADR(l)==SYM("+")) || (CADR(l)==SYM("-")) ||
		(CADR(l)==SYM("*")) || (CADR(l)==SYM("%")) ||
		(CADR(l)==SYM("&")) || (CADR(l)==SYM("|")) ||
		(CADR(l)==SYM("^"))))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));

		x=t; c=CDDDR(l);
		while(BS1_CONSP(c))
		{
			t=BS1_SComp_InferExpr(ctx, CAR(c));
			if(t!=x)return(BS1_MM_NULL);
			c=CDR(c);
		}
		return(x);
	}

	if(FORM_IS(l, "binary") &&
		((CADR(l)==SYM("<<")) || (CADR(l)==SYM(">>"))))
	{
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		x=BS1_SComp_InferExpr(ctx, CADDDR(l));

		i=BS1_SComp_InferIsIntP(t) &&
			BS1_SComp_InferIsIntP(x);
		if(i)return(t);
		return(BS1_MM_NULL);
	}

//	if((CAR(l)==SYM("==")) || (CAR(l)==SYM("===")) ||
//		(CAR(l)==SYM("!=")) || (CAR(l)==SYM("!==")) ||
//		(CAR(l)==SYM("<")) || (CAR(l)==SYM(">")) ||
//		(CAR(l)==SYM("<=")) || (CAR(l)==SYM(">=")))

	if(FORM_IS(l, "binary") && (
		(CADR(l)==SYM("==")) || (CADR(l)==SYM("===")) ||
		(CADR(l)==SYM("!=")) || (CADR(l)==SYM("!==")) ||
		(CADR(l)==SYM("<"))  || (CADR(l)==SYM(">")) ||
		(CADR(l)==SYM("<=")) || (CADR(l)==SYM(">="))))
	{
		return(KEYSYM("bool"));
	}

	if(CAR(l)==SYM("if"))
	{
		t=BS1_SComp_ReduceExpr(ctx, CADR(l));
		i=BS1_SComp_BoolExpr(ctx, t);
		if(i==1)
		{
			t=BS1_SComp_InferExpr(ctx, CADDR(l));
			return(t);
		}
		if(i==0)
		{
			t=BS1_MM_NULL;
			if(BS1_CONSP(CDDDR(l)))
				t=BS1_SComp_InferExpr(ctx, CADDDR(l));
			return(t);
		}

		x=BS1_MM_NULL;
		t=BS1_SComp_InferExpr(ctx, CADDR(l));
		if(BS1_CONSP(CDDDR(l)))
			x=BS1_SComp_InferExpr(ctx, CADDDR(l));
		if(t!=x)return(BS1_MM_NULL);
		return(t);
	}

	if(CAR(l)==SYM("funcall"))
	{
#if 0
		printf("Infer Func: ");
		BS1_TY_Print(CADR(l));
		printf("=");
		BS1_TY_Print(ctx->cf_n);
		printf("\n");
#endif

		ctx->i_cx_p=0;
		if(CADR(l)==ctx->cf_n)
		{
			t=BS1_SComp_InferTypeBase(ctx->cf_ty);
			return(t);
//			return(ctx->cf_ty);
		}
		return(BS1_MM_NULL);
	}

	ctx->i_cx_p=0;
	return(BS1_MM_NULL);
}

elem BS1_SComp_InferExpr(BS1_SVMCState *ctx, elem l)
{
	elem t, cn, cv, ct;

	l=BS1_SComp_ReduceExpr(ctx, l);

//	printf("Infer Reduce: ");
//	BS1_TY_PrintLN(l);

	if(BS1_CONSP(l))
	{
		t=BS1_SComp_InferForm(ctx, l);
		return(t);
	}

	if(BS1_SYMBOLP(l))
	{
		if(l==SYM("I"))return(KEYSYM("complex"));
		if(l==SYM("PI"))return(KEYSYM("float"));
		if(l==SYM("E"))return(KEYSYM("float"));

		cn=ctx->lenv;
		ct=ctx->tenv;
		cv=ctx->venv;

		while(BS1_CONSP(cn))
		{
			if(CAR(cn)==l)
			{
				t=BS1_SComp_InferTypeBase(CAR(ct));
				return(t);
			}
			cn=CDR(cn);
			ct=CDR(ct);
			cv=CDR(cv);
		}

		return(BS1_MM_NULL);
	}

	if(l==BS1_MM_NULL)return(KEYSYM("null"));
	if(l==BS1_MM_TRUE)return(KEYSYM("bool"));
	if(l==BS1_MM_FALSE)return(KEYSYM("bool"));

	if(BS1_FIXNUMP(l))return(KEYSYM("int"));
	if(BS1_FLONUMP(l))return(KEYSYM("float"));
	if(BS1_CHARP(l))return(KEYSYM("char"));

	if(BS1_STRINGP(l))return(KEYSYM("string"));
	if(BS1_KEYWORDP(l))return(KEYSYM("keyword"));

	if(BS1_ARRAYP(l))return(KEYSYM("array"));
	if(BS1_FVECTORP(l))return(KEYSYM("vector"));

	return(BS1_MM_NULL);
}

elem BS1_SComp_InferExprClean(BS1_SVMCState *ctx, elem l, int *cp)
{
	elem t;

	ctx->i_cx_p=1;
	t=BS1_SComp_InferExpr(ctx, l);
	*cp=ctx->i_cx_p;

	return(t);
}


int BS1_SComp_GuessCloseForm(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	if(FORM_IS(l, "lambda"))return(1);
	if(FORM_IS(l, "rlambda"))return(1);
	if(FORM_IS(l, "defun"))return(1);
	if(FORM_IS(l, "define") && BS1_CONSP(CADR(l)))
		return(1);

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		i=i||BS1_SComp_GuessCloseExpr(ctx, CAR(c));
		c=CDR(c);
	}
	return(i);
}

int BS1_SComp_GuessCloseExpr(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	if(BS1_CONSP(l))
		return(BS1_SComp_GuessCloseForm(ctx, l));

	if(BS1_SYMBOLP(l))
	{
		c=ctx->lenv; i=0;
		while(BS1_CONSP(c))
		{
			if(c==ctx->llenv)i=1;
			if(CAR(c)==l)break;
			c=CDR(c);
		}

		if(BS1_CONSP(c))return(i);
		return(0);
	}

	return(0);
}

int BS1_SComp_GuessCloseBlock(BS1_SVMCState *ctx, elem l)
{
	elem c;
	int i;

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		i=i||BS1_SComp_GuessCloseExpr(ctx, CAR(c));
		c=CDR(c);
	}
	return(i);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

elem bs1_func_print(BS1_SVMState *ctx, elem args)
{
	elem c;

	c=args;
	while(BS1_CONSP(c))
	{
		if(BS1_STRINGP(CAR(c)))
			printf("%s", BS1_TY_GetString(CAR(c)));
		if(BS1_SYMBOLP(CAR(c)))
			printf("%s", BS1_TY_GetSymbol(CAR(c)));
		if(BS1_KEYWORDP(CAR(c)))
			printf("%s", BS1_TY_GetSymbol(CAR(c)));
		if(BS1_FIXNUMP(CAR(c)))printf("%d", TOINT(CAR(c)));
		if(BS1_FLONUMP(CAR(c)))printf("%g", TOFLOAT(CAR(c)));
		if(BS1_CHARP(CAR(c)))printf("%c", TOINT(CAR(c)));

		if(BS1_CONSP(CAR(c)))BS1_TY_Print(CAR(c));

		c=CDR(c);
	}

	return(BS1_MM_NULL);
}

elem bs1_func_println(BS1_SVMState *ctx, elem args)
{
	elem t;

	t=bs1_func_print(ctx, args);
	printf("\n");
	return(t);
}

elem bs1_func_load(BS1_SVMState *ctx, elem args)
{
	FILE *fd;
	elem t0, t1, t2;
	char *s, *buf;
	int sz;

	if(!BS1_CONSP(args))
		return(BS1_MM_NULL);

	t0=CAR(args); t1=ctx->self;
	if(BS1_CONSP(CDR(args)))
		t1=CADR(args);

	s=TOSTRING(t0);
	if(!s)return(BS1_MM_NULL);
	fd=fopen(s, "rb");
	if(!fd)return(BS1_MM_NULL);
	fseek(fd, 0, 2);
	sz=ftell(fd);

	buf=malloc(sz);
	fseek(fd, 0, 0);
	fread(buf, 1, sz, fd);
	fclose(fd);

	t2=BS1_SVM_EvalStringObj(buf, t1);
	free(buf);

	return(t2);
}

elem bs1_func_eval(BS1_SVMState *ctx, elem args)
{
	FILE *fd;
	elem t0, t1, t2;
	char *s, *buf;
	int sz;

	if(!BS1_CONSP(args))
		return(BS1_MM_NULL);

	t0=CAR(args); t1=ctx->self;
	if(BS1_CONSP(CDR(args)))
		t1=CADR(args);

	if(BS1_STRINGP(t0))
	{
		s=TOSTRING(t0);
		t2=BS1_SVM_EvalStringObj(s, t1);
	}else
	{
		t2=BS1_SVM_EvalExprsObj(LIST1(t0), t1);
	}
	return(t2);
}

elem bs1_func_car(BS1_SVMState *ctx, elem args) { return(CAR(CAR(args))); }
elem bs1_func_cdr(BS1_SVMState *ctx, elem args)	{ return(CDR(CAR(args))); }

elem bs1_func_caar(BS1_SVMState *ctx, elem args) { return(CAAR(CAR(args))); }
elem bs1_func_cdar(BS1_SVMState *ctx, elem args) { return(CDAR(CAR(args))); }
elem bs1_func_cadr(BS1_SVMState *ctx, elem args) { return(CADR(CAR(args))); }
elem bs1_func_cddr(BS1_SVMState *ctx, elem args) { return(CDDR(CAR(args))); }

elem bs1_func_caaar(BS1_SVMState *ctx, elem args) { return(CAAAR(CAR(args))); }
elem bs1_func_cdaar(BS1_SVMState *ctx, elem args) { return(CDAAR(CAR(args))); }
elem bs1_func_cadar(BS1_SVMState *ctx, elem args) { return(CADAR(CAR(args))); }
elem bs1_func_cddar(BS1_SVMState *ctx, elem args) { return(CDDAR(CAR(args))); }
elem bs1_func_caadr(BS1_SVMState *ctx, elem args) { return(CAADR(CAR(args))); }
elem bs1_func_cdadr(BS1_SVMState *ctx, elem args) { return(CDADR(CAR(args))); }
elem bs1_func_caddr(BS1_SVMState *ctx, elem args) { return(CADDR(CAR(args))); }
elem bs1_func_cdddr(BS1_SVMState *ctx, elem args) { return(CDDDR(CAR(args))); }

int BS1_Builtins_Init()
{
	BS1_SVM_AddBuiltin("print", "", &bs1_func_print, -1);
	BS1_SVM_AddBuiltin("println", "", &bs1_func_println, -1);
	BS1_SVM_AddBuiltin("load", "", &bs1_func_load, -2);
	BS1_SVM_AddBuiltin("eval", "", &bs1_func_eval, -2);

	BS1_SVM_AddBuiltin("car", "", &bs1_func_car, 1);
	BS1_SVM_AddBuiltin("cdr", "", &bs1_func_cdr, 1);
	BS1_SVM_AddBuiltin("caar", "", &bs1_func_caar, 1);
	BS1_SVM_AddBuiltin("cdar", "", &bs1_func_cdar, 1);
	BS1_SVM_AddBuiltin("cadr", "", &bs1_func_cadr, 1);
	BS1_SVM_AddBuiltin("cddr", "", &bs1_func_cddr, 1);
	BS1_SVM_AddBuiltin("caaar", "", &bs1_func_caaar, 1);
	BS1_SVM_AddBuiltin("cdaar", "", &bs1_func_cdaar, 1);
	BS1_SVM_AddBuiltin("cadar", "", &bs1_func_cadar, 1);
	BS1_SVM_AddBuiltin("cddar", "", &bs1_func_cddar, 1);
	BS1_SVM_AddBuiltin("caadr", "", &bs1_func_caadr, 1);
	BS1_SVM_AddBuiltin("cdadr", "", &bs1_func_cdadr, 1);
	BS1_SVM_AddBuiltin("caddr", "", &bs1_func_caddr, 1);
	BS1_SVM_AddBuiltin("cdddr", "", &bs1_func_cdddr, 1);

	BS1_BuiltinMath_Init();

	return(0);
}
/*
Prototype Objects
 */

#include <bgbscr1.h>

static elem bs1_sobj_stack[256];
static int bs1_sobj_stackpos=0;


elem BS1_SObj_New()
{
	BS1_Object *tmp;
	elem t;

	t=BS1_MM_AllocObj(BS1_TYH_OBJECT, sizeof(BS1_Object));
	tmp=BS1_TY_GetObjData(t);

	tmp->lkey=BS1_MM_NULL;
	tmp->lval=BS1_MM_NULL;
	tmp->dkey=BS1_MM_NULL;
	tmp->dval=BS1_MM_NULL;
	tmp->nkey=0;

	return(t);
}

elem BS1_SObj_GetSlot(elem obj, elem slot)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;
	int i;

	for(i=(bs1_sobj_stackpos-1); i>=0; i--)
		if(bs1_sobj_stack[i]==obj)
			return(BS1_MM_NULL);

	if(bs1_sobj_stackpos>=255)return(BS1_MM_NULL);
	bs1_sobj_stack[bs1_sobj_stackpos++]=obj;

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_GetSlot(obj, slot);
		return(t);
	}

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
			{
				bs1_sobj_findobj=obj;
				return(CAR(cv));
			}
			ck=CDR(ck); cv=CDR(cv);
		}

		bs1_sobj_stackpos--;
		return(BS1_MM_NULL);
	}

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			bs1_sobj_stackpos--;
			return(CAR(cv));
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	ck=tmp->dkey; cv=tmp->dval;
	while(ck)
	{
		t=BS1_SObj_GetSlot(CAR(cv), slot);
		if(t!=BS1_MM_NULL)
		{
			bs1_sobj_stackpos--;
			return(t);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	bs1_sobj_stackpos--;
	return(BS1_MM_NULL);
}

int BS1_SObj_SetSlotR(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	int i;

	for(i=(bs1_sobj_stackpos-1); i>=0; i--)
		if(bs1_sobj_stack[i]==obj)
			return(BS1_MM_NULL);

	if(bs1_sobj_stackpos>=255)return(BS1_MM_NULL);
	bs1_sobj_stack[bs1_sobj_stackpos++]=obj;

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_SetSlot(obj, slot, val);
		return(t);
	}


	tmp=BS1_TY_GetObjData(obj);

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			BS1_TY_SetCar(cv, val);
			bs1_sobj_stackpos--;
			return(0);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	ck=tmp->dkey; cv=tmp->dval;
	while(ck)
	{
		i=BS1_SObj_SetSlotR(CAR(cv), slot, val);
		if(!i)
		{
			bs1_sobj_stackpos--;
			return(0);
		}
		ck=CDR(ck); cv=CDR(cv);
	}

	bs1_sobj_stackpos--;
	return(-1);
}

elem BS1_SObj_SetSlot(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	char *s;
	elem t;
	int i;

	t=BS1_SObj_GetHashDst(obj, slot);
	if(t!=BS1_MM_UNDEF)
	{
		BS1_SObj_SetSlotR(t, slot, val);
		return(BS1_MM_NULL);
	}

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_SetSlot(obj, slot, val);
		return(t);
	}

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		t=BS1_SObj_BindSlot(obj, slot, val);
		return(t);
	}

	i=BS1_SObj_SetSlotR(obj, slot, val);
	if(!i)return(BS1_MM_NULL);

	SET(tmp->lkey, CONS(slot, tmp->lkey));
	SET(tmp->lval, CONS(val, tmp->lval));
	tmp->nkey++;
	return(BS1_MM_NULL);
}

elem BS1_SObj_BindSlot(elem obj, elem slot, elem val)
{
	BS1_Object *tmp;
	elem ck, cv, t;
	char *s;

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_SetSlot(obj, slot, val);
		return(t);
	}

	tmp=BS1_TY_GetObjData(obj);
	s=BS1_TY_GetSymbol(slot);

	if(*s=='_')
	{
		ck=tmp->dkey; cv=tmp->dval;
		while(ck)
		{
			if(CAR(ck)==slot)
			{
				BS1_TY_SetCar(cv, val);
				return(BS1_MM_NULL);
			}
			ck=CDR(ck); cv=CDR(cv);
		}

		SET(tmp->dkey, CONS(slot, tmp->dkey));
		SET(tmp->dval, CONS(val, tmp->dval));
		return(BS1_MM_NULL);
	}

	ck=tmp->lkey; cv=tmp->lval;
	while(ck)
	{
		if(CAR(ck)==slot)
		{
			BS1_TY_SetCar(cv, val);
			return(BS1_MM_NULL);
		}
		ck=CDR(ck); cv=CDR(cv);
	}


	SET(tmp->lkey, CONS(slot, tmp->lkey));
	SET(tmp->lval, CONS(val, tmp->lval));
	tmp->nkey++;
	return(BS1_MM_NULL);
}

static void bs1_sobj_mark(elem obj)
{
	BS1_Object *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->lkey);
	BS1_GC_MarkRef(tmp->lval);
	BS1_GC_MarkRef(tmp->dkey);
	BS1_GC_MarkRef(tmp->dval);
}

static void bs1_sobj_destroy(elem obj)
{
	BS1_Object *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->lkey);
	BS1_GC_DecRef(tmp->lval);
	BS1_GC_DecRef(tmp->dkey);
	BS1_GC_DecRef(tmp->dval);
}

int BS1_SObj_Init()
{
	BS1_TY_SetMarkFunc(BS1_TYH_OBJECT, &bs1_sobj_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_OBJECT, &bs1_sobj_destroy);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <bgbscr1.h>

extern char *bs1_ops_strs[];
extern char *bs1_ops_args[];

elem bs1_svm_toplevel;
int bs1_svm_opcnt;

static void bs1_sblk_mark(elem obj)
{
	BS1_SVMBlock *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->args);
	BS1_GC_MarkRef(tmp->exps);
	BS1_GC_MarkRef(tmp->lit);
}

static void bs1_sblk_destroy(elem obj)
{
	BS1_SVMBlock *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->args);
	BS1_GC_DecRef(tmp->exps);
	BS1_GC_DecRef(tmp->lit);
	free(tmp->body);
}

static void bs1_sfun_mark(elem obj)
{
	BS1_SVMLambda *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_MarkRef(tmp->lkey);
	BS1_GC_MarkRef(tmp->lval);
	BS1_GC_MarkRef(BS1_MM_GetPtrElem(tmp->blk));
}

static void bs1_sfun_destroy(elem obj)
{
	BS1_SVMLambda *tmp;
	tmp=BS1_TY_GetObjData(obj);
	BS1_GC_DecRef(tmp->lkey);
	BS1_GC_DecRef(tmp->lval);
	BS1_GC_DecRef(BS1_MM_GetPtrElem(tmp->blk));
}

static void bs1_sctx_mark(elem obj)
{
	BS1_SVMState *tmp;
	int i;

	tmp=BS1_TY_GetObjData(obj);

	BS1_GC_MarkRef(tmp->self);
	BS1_GC_MarkRef(tmp->lit);
	BS1_GC_MarkRef(tmp->func);

	BS1_GC_MarkRef(tmp->klenv);
	BS1_GC_MarkRef(tmp->vlenv);
	BS1_GC_MarkRef(tmp->kdenv);
	BS1_GC_MarkRef(tmp->vdenv);

	for(i=0; i<tmp->stackpos; i++)
		BS1_GC_MarkRef(tmp->stack[i]);

	for(i=0; i<tmp->flowstackpos; i++)
	{
		BS1_GC_MarkRef(tmp->flowstack_self[i]);
		BS1_GC_MarkRef(tmp->flowstack_lit[i]);
		BS1_GC_MarkRef(tmp->flowstack_func[i]);
		BS1_GC_MarkRef(tmp->flowstack_klenv[i]);
		BS1_GC_MarkRef(tmp->flowstack_vlenv[i]);
		BS1_GC_MarkRef(tmp->flowstack_kdenv[i]);
		BS1_GC_MarkRef(tmp->flowstack_vdenv[i]);
	}
}

static void bs1_sctx_destroy(elem obj)
{
	BS1_SVMState *tmp;
	int i;

	tmp=BS1_TY_GetObjData(obj);

	BS1_GC_DecRef(tmp->self);
	BS1_GC_DecRef(tmp->lit);
	BS1_GC_DecRef(tmp->func);

	BS1_GC_DecRef(tmp->klenv);
	BS1_GC_DecRef(tmp->vlenv);
	BS1_GC_DecRef(tmp->kdenv);
	BS1_GC_DecRef(tmp->vdenv);

	for(i=0; i<tmp->stackpos; i++)
		BS1_GC_DecRef(tmp->stack[i]);

	for(i=0; i<tmp->flowstackpos; i++)
	{
		BS1_GC_DecRef(tmp->flowstack_self[i]);
		BS1_GC_DecRef(tmp->flowstack_lit[i]);
		BS1_GC_DecRef(tmp->flowstack_func[i]);
		BS1_GC_DecRef(tmp->flowstack_klenv[i]);
		BS1_GC_DecRef(tmp->flowstack_vlenv[i]);
		BS1_GC_DecRef(tmp->flowstack_kdenv[i]);
		BS1_GC_DecRef(tmp->flowstack_vdenv[i]);
	}

	free(tmp->stack);
	free(tmp->markstack);

	free(tmp->flowstack_self);
	free(tmp->flowstack_lit);
	free(tmp->flowstack_func);
	free(tmp->flowstack_klenv);
	free(tmp->flowstack_vlenv);
	free(tmp->flowstack_kdenv);
	free(tmp->flowstack_vdenv);

	free(tmp->flowstack_ip);
	free(tmp->flowstack_int);

#ifdef BS1_JIT
	free(tmp->flowstack_thunk);
#endif
}

int BS1_SVM_Init()
{
	static int init=0;

	if(init)return(0);
	init=1;

	BS1_TY_Init();

	BS1_GC_AddRoot(&bs1_svm_toplevel);

	BS1_SObj_Init();
	SET(bs1_svm_toplevel, BS1_SObj_New());
	BS1_Builtins_Init();

	BS1_TY_SetMarkFunc(BS1_TYH_SVMBLK, &bs1_sblk_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_SVMBLK, &bs1_sblk_destroy);
	BS1_TY_SetMarkFunc(BS1_TYH_SVMLAMBDA, &bs1_sfun_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_SVMLAMBDA, &bs1_sfun_destroy);
	BS1_TY_SetMarkFunc(BS1_TYH_SVMCTX, &bs1_sctx_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_SVMCTX, &bs1_sctx_destroy);
}

void BS1_SVM_AddBuiltin(char *name, char *desc,
	elem (*fcn)(BS1_SVMState *ctx, elem args), int nargs)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=name; t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			t++;
			s=t;
		}
	}

	tmp=BS1_MM_AllocObj(BS1_TYH_SVMBUILTIN, sizeof(BS1_SVMBuiltin));
	bfcn=BS1_TY_GetObjData(tmp);

	bfcn->name=strdup(s);
	bfcn->desc=strdup(desc);
	bfcn->fcn=fcn;
	bfcn->nargs=nargs;

	BS1_SObj_BindSlot(obj, SYM(s), tmp);
//	BS1_SObj_BindSlot(bs1_svm_toplevel, SYM(name), tmp);
}

void BS1_SVM_AddBuiltin2(char *name, char *desc,
	elem (*fcn)(BS1_SVMState *ctx, elem args), int nargs)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
			{
				tmp=BS1_SObj_New();
				BS1_SObj_BindSlot(obj, SYM(s), tmp);
			}

			obj=tmp; s=t;
		}
	}

	tmp=BS1_MM_AllocObj(BS1_TYH_SVMBUILTIN, sizeof(BS1_SVMBuiltin));
	bfcn=BS1_TY_GetObjData(tmp);

//	bfcn->name=name;
//	bfcn->desc=desc;
	bfcn->name=strdup(s);
	bfcn->desc=strdup(desc);
	bfcn->fcn=fcn;
	bfcn->nargs=nargs;

	BS1_SObj_BindSlot(obj, SYM(s), tmp);
//	BS1_SObj_BindSlot(bs1_svm_toplevel, SYM(name), tmp);
}

void BS1_SVM_AddBinding(char *name, elem val)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=name; t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			t++;
			s=t;
		}
	}

	BS1_SObj_BindSlot(obj, SYM(s), val);
}

void BS1_SVM_AddBinding2(char *name, elem val)
{
	BS1_SVMBuiltin *bfcn;
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;

	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
			{
				tmp=BS1_SObj_New();
				BS1_SObj_BindSlot(obj, SYM(s), tmp);
			}

			obj=tmp; s=t;
		}
	}

	BS1_SObj_BindSlot(obj, SYM(s), val);
}


elem BS1_SVM_GetTop(char *name)
{
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;
	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
				return(BS1_MM_NULL);
			obj=tmp; s=t;
		}
	}

	tmp=BS1_SObj_GetSlot(obj, SYM(s));
	return(tmp);
}

void BS1_SVM_SetTop(char *name, elem val)
{
	elem tmp, obj;
	char *s, *t;

	obj=bs1_svm_toplevel;
	s=BS1_RStrDup(name); t=s;
	while(*t)
	{
		while(*t && (*t!='.'))t++;
		if(*t=='.')
		{
			*t++=0;

			tmp=BS1_SObj_GetSlot(obj, SYM(s));
			if(tmp==BS1_MM_NULL)
			{
				tmp=BS1_SObj_New();
				BS1_SObj_BindSlot(obj, SYM(s), tmp);
			}

			obj=tmp; s=t;
		}
	}

	BS1_SObj_BindSlot(obj, SYM(s), val);
}


elem BS1_SVM_NewState()
{
	elem tmp;
	BS1_SVMState *ctx;

	tmp=BS1_MM_AllocObj(BS1_TYH_SVMCTX, sizeof(BS1_SVMState));
	ctx=BS1_TY_GetObjData(tmp);

	ctx->stack=malloc(4096*sizeof(elem));
	ctx->markstack=malloc(256*sizeof(int));

	ctx->flowstack_self=malloc(256*sizeof(elem));
	ctx->flowstack_lit=malloc(256*sizeof(elem));
	ctx->flowstack_func=malloc(256*sizeof(elem));
	ctx->flowstack_klenv=malloc(256*sizeof(elem));
	ctx->flowstack_vlenv=malloc(256*sizeof(elem));
	ctx->flowstack_kdenv=malloc(256*sizeof(elem));
	ctx->flowstack_vdenv=malloc(256*sizeof(elem));

	memset(ctx->stack, 0, 4096*sizeof(elem));
	memset(ctx->markstack, 0, 256*sizeof(int));

	memset(ctx->flowstack_self, 0, 256*sizeof(elem));
	memset(ctx->flowstack_lit, 0, 256*sizeof(elem));
	memset(ctx->flowstack_func, 0, 256*sizeof(elem));
	memset(ctx->flowstack_klenv, 0, 256*sizeof(elem));
	memset(ctx->flowstack_vlenv, 0, 256*sizeof(elem));
	memset(ctx->flowstack_kdenv, 0, 256*sizeof(elem));
	memset(ctx->flowstack_vdenv, 0, 256*sizeof(elem));

	ctx->flowstack_ip=malloc(256*sizeof(byte *));
	ctx->flowstack_int=malloc(256*4*sizeof(int));

#ifdef BS1_JIT
	ctx->flowstack_thunk=malloc(256*sizeof(int (*)(BS1_SVMState *ctx)));
#endif

	return(tmp);
}


void BS1_SVM_Push(BS1_SVMState *ctx, elem val)
{
	BS1_GC_IncRef(val);
	ctx->stack[ctx->stackpos++]=val;
}

elem BS1_SVM_Pop(BS1_SVMState *ctx)
{
	elem t;

	ctx->stackpos--;
	t=ctx->stack[ctx->stackpos];
	BS1_GC_SafeDecRef(t);
	return(t);
}

void BS1_SVM_PushF(BS1_SVMState *ctx, elem val)
{
	ctx->stack[ctx->stackpos++]=val;
}

elem BS1_SVM_PopF(BS1_SVMState *ctx)
{
	ctx->stackpos--;
	return(ctx->stack[ctx->stackpos]);
}

void BS1_SVM_PopDestroy(BS1_SVMState *ctx)
{
	elem t;

	ctx->stackpos--;
	t=ctx->stack[ctx->stackpos];
	BS1_GC_DecRef(t);
}

int BS1_SVM_PopBool(BS1_SVMState *ctx)
{
	elem t;
	int i;

	ctx->stackpos--;
	t=ctx->stack[ctx->stackpos];

	if(t==BS1_MM_FALSE)return(0);
	if(t==BS1_MM_NULL)return(0);
	if(t==BS1_MM_TRUE)return(1);
	if(t==BS1_MM_FIXNUM_0)return(0);
	BS1_GC_DecRef(t);
	return(1);

#if 0
	switch(t)
	{
	case BS1_MM_NULL: i=0; break;
	case BS1_MM_FIXNUM_0: i=0; break;
	case BS1_MM_FALSE: i=0; break;
	case BS1_MM_TRUE: i=1; break;
	default:
		i=1;
		BS1_GC_DecRef(t);
		break;
	}
	return(i);
#endif
}

void BS1_SVM_PushList(BS1_SVMState *ctx, elem l)
{
	elem c;

	ctx->markstack[ctx->markstackpos++]=ctx->stackpos;

	c=l;
	while(BS1_CONSP(l))
	{
		BS1_SVM_Push(ctx, CAR(l));
		l=CDR(l);
	}
}

elem BS1_SVM_PopList(BS1_SVMState *ctx)
{
	elem t, l;
	int i;

	i=ctx->markstack[ctx->markstackpos-1];
	l=BS1_MM_NULL;
	while(ctx->stackpos>i)
	{
		t=BS1_SVM_Pop(ctx);
		l=CONS(t, l);
	}

	ctx->markstackpos--;
	return(l);
}

elem BS1_SVM_PopList2(BS1_SVMState *ctx)
{
	elem t, l;
	int i;

	i=ctx->markstack[ctx->markstackpos-1];
	l=BS1_SVM_Pop(ctx);
	while(ctx->stackpos>i)
	{
		t=BS1_SVM_Pop(ctx);
		l=CONS(t, l);
	}

	ctx->markstackpos--;
	return(l);
}

void BS1_SVM_PopMark(BS1_SVMState *ctx)
{
	int i;

	ctx->markstackpos--;
	i=ctx->markstack[ctx->markstackpos];
	while(ctx->stackpos>i)
		BS1_SVM_PopDestroy(ctx);
}

void BS1_SVM_ShiftMark(BS1_SVMState *ctx)
{
	int i, j, k;

	ctx->markstackpos--;
	k=ctx->markstack[ctx->markstackpos];

	i=k;
	j=ctx->markstack[ctx->markstackpos-1];
	while(i<ctx->stackpos)
	{
		BS1_GC_DecRef(ctx->stack[j]);
		ctx->stack[j++]=ctx->stack[i++];
	}
	ctx->stackpos=j;
	while(j<k)BS1_GC_DecRef(ctx->stack[j++]);
}


elem BS1_SVM_Lookup(BS1_SVMState *ctx, elem key)
{
	elem ck, cv, t;
	int i, j;

	if(ctx->klenv && !ctx->vlenv)
	{
		ck=ctx->klenv; i=0;
		while(ck)
		{
			if(CARF(ck)==key)
			{
				t=ctx->stack[ctx->eargs-i-1];
				return(t);
			}
			i++; ck=CDRF(ck);
		}

		t=BS1_SObj_GetSlot(ctx->self, key);
		return(t);
	}

	ck=ctx->klenv; cv=ctx->vlenv;
	while(ck)
	{
		if(CARF(ck)==key)return(CARF(cv));
		ck=CDRF(ck); cv=CDRF(cv);
	}

#if 0
	ck=ctx->kdenv;
	cv=ctx->vdenv;
	while(ck)
	{
		if(CARF(ck)==key)return(CARF(cv));
		ck=CDRF(ck); cv=CDRF(cv);
	}
#endif

	t=BS1_SObj_GetSlot(ctx->self, key);

//	printf("obj get %s %08X\n", TOSYM(key), t);

	return(t);
}

void BS1_SVM_Assign(BS1_SVMState *ctx, elem key, elem val)
{
	elem ck, cv, t;
	int i;

	if(ctx->klenv && !ctx->vlenv)
	{
		ck=ctx->klenv; i=0;
		while(ck)
		{
			if(CARF(ck)==key)
			{
				ctx->stack[ctx->eargs-i-1]=val;
				return;
			}
			i++; ck=CDRF(ck);
		}

		BS1_SObj_SetSlot(ctx->self, key, val);
		return;
	}

	ck=ctx->klenv;
	cv=ctx->vlenv;
	while(ck)
	{
		if(CARF(ck)==key)
		{
			BS1_TY_SetCar(cv, val);
			return;
		}
		ck=CDRF(ck); cv=CDRF(cv);
	}

#if 0
	ck=ctx->kdenv;
	cv=ctx->vdenv;
	while(ck)
	{
		if(CAR(ck)==key)
		{
			BS1_TY_SetCar(cv, val);
			return;
		}
		ck=CDR(ck); cv=CDR(cv);
	}
#endif

	BS1_SObj_SetSlot(ctx->self, key, val);
}

elem BS1_SVM_LookupIdx(BS1_SVMState *ctx, int idx)
{
	elem c, t;
	int i;

	if(!ctx->vlenv)
	{
		t=ctx->stack[ctx->eargs-idx-1];
		return(t);
	}

	c=ctx->vlenv; i=idx;
	while(i--)c=CDRF(c);
	return(CARF(c));
}

void BS1_SVM_AssignIdx(BS1_SVMState *ctx, int idx, elem val)
{
	elem c, t;
	int i;

	if(!ctx->vlenv)
	{
		SET(ctx->stack[ctx->eargs-idx-1], val);
		return;
	}

	c=ctx->vlenv; i=idx;
	while(i--)c=CDRF(c);
	BS1_TY_SetCar(c, val);
}

void BS1_SVM_AssignIdxF(BS1_SVMState *ctx, int idx, elem val)
{
	elem c, t;
	int i;

	if(ctx->klenv && !ctx->vlenv)
	{
		ctx->stack[ctx->eargs-idx-1]=val;
		return;
	}

	c=ctx->vlenv; i=idx;
	while(i--)c=CDRF(c);
//	CARF(c)=val;
	BS1_TY_SetCar2(c, val);
}

void BS1_SVM_Bind(BS1_SVMState *ctx, elem key, elem val)
{
//	printf("bind %s %08X\n", TOSYM(key), val);

	BS1_SObj_BindSlot(ctx->self, key, val);
}

void BS1_SVM_LexBind(BS1_SVMState *ctx, elem key, elem val)
{
	int i;

	if(ctx->klenv && !ctx->vlenv)
	{
		i=ctx->stackpos++;
		while(i>ctx->eargs)
		{
			ctx->stack[i]=ctx->stack[i-1];
			i--;
		}

		i=ctx->eargs++;
		SET(ctx->stack[i], val);
		SET(ctx->klenv, CONS(key, ctx->klenv));
		return;
	}

	SET(ctx->klenv, CONS(key, ctx->klenv));
	SET(ctx->vlenv, CONS(val, ctx->vlenv));
}

void BS1_SVM_DynBind(BS1_SVMState *ctx, elem key, elem val)
{
//	SET(ctx->kdenv, CONS(key, ctx->kdenv));
//	SET(ctx->vdenv, CONS(val, ctx->vdenv));
}

elem BS1_SVM_LoadIndex(BS1_SVMState *ctx, elem obj, elem key)
{
	elem c, t;
	int i;

	if(BS1_ARRAYP(obj))
	{
		i=BS1_TY_GetInt(key);
		t=BS1_TY_GetArrayElem(obj, i);
		return(t);
	}

	if(BS1_TY_GetType(obj)==BS1_TYH_OBJECT)
	{
		t=BS1_SObj_GetSlot(obj, key);
		return(t);
	}

	if(BS1_CONSP(obj))
	{
		c=obj; i=TOINT(key);
		while(BS1_CONSP(c) && i)
			{ i--; c=CDR(c); }
		if(BS1_CONSP(c))return(CAR(c));

		return(BS1_MM_NULL);
	}

	if(BS1_FVECTORP(obj))
	{
		t=FLONUM(BS1_TYVec_GetVecVal(obj, TOINT(key)));
		return(t);
	}

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_GetSlot(obj, key);
		return(t);
	}

	t=BS1_TY_LoadIndex(obj, key);
	return(t);

//	return(BS1_MM_NULL);
}

void BS1_SVM_StoreIndex(BS1_SVMState *ctx, elem obj, elem key, elem val)
{
	elem c;
	int i;

	if(BS1_ARRAYP(obj))
	{
		i=BS1_TY_GetInt(key);
		BS1_TY_SetArrayElem(obj, i, val);
		return;
	}

	if(BS1_TY_GetType(obj)==BS1_TYH_OBJECT)
	{
		BS1_SObj_SetSlot(obj, key, val);
		return;
	}

	if(BS1_CONSP(obj))
	{
		c=obj; i=TOINT(key);
		while(BS1_CONSP(c) && i)
			{ i--; c=CDR(c); }
		if(BS1_CONSP(c))BS1_TY_SetCar(c, val);

		return;
	}

	if(BS1_FVECTORP(obj))
	{
		BS1_TYVec_SetVecVal(obj, TOINT(key), TOFLOAT(val));
		return;
	}

	if(BS1_HANDLEP(obj))
	{
		BS1_TYHDL_SetSlot(obj, key, val);
		return;
	}

	BS1_TY_StoreIndex(obj, key, val);
}

elem BS1_SVM_Unary(BS1_SVMState *ctx, int i, elem obj)
{
	elem t;
	t=BS1_Opr_Unary(i, obj);
	BS1_GC_CheckRef(obj);
	return(t);
}

elem BS1_SVM_Binary(BS1_SVMState *ctx, int i, elem tl, elem tr)
{
	elem t;
	t=BS1_Opr_Binary(i, tl, tr);
	BS1_GC_CheckRef(tl);
	BS1_GC_CheckRef(tr);
	return(t);
}

void BS1_SVM_PushFrame(BS1_SVMState *ctx)
{
	int i;

	i=ctx->flowstackpos++;
	if(i<0)return;

	SET(ctx->flowstack_self[i], ctx->self);
	SET(ctx->flowstack_lit[i], ctx->lit);
	SET(ctx->flowstack_func[i], ctx->func);
	SET(ctx->flowstack_klenv[i], ctx->klenv);
	SET(ctx->flowstack_vlenv[i], ctx->vlenv);
//	SET(ctx->flowstack_kdenv[i], ctx->kdenv);
//	SET(ctx->flowstack_vdenv[i], ctx->vdenv);

	ctx->flowstack_ip[i]=ctx->ip;

	ctx->flowstack_int[i*4+0]=ctx->args;
	ctx->flowstack_int[i*4+1]=ctx->eargs;

#ifdef BS1_JIT
	ctx->flowstack_thunk[i]=ctx->thunk;
#endif
}

void BS1_SVM_PopFrame(BS1_SVMState *ctx)
{
	int i;

	ctx->flowstackpos--;
	i=ctx->flowstackpos;

	if(i<0)
	{
		CLEAR(ctx->self);	CLEAR(ctx->lit);
		CLEAR(ctx->func);
		CLEAR(ctx->klenv);	CLEAR(ctx->vlenv);
//		CLEAR(ctx->kdenv);	CLEAR(ctx->vdenv);
		return;
	}

	SET(ctx->self, ctx->flowstack_self[i]);
	SET(ctx->lit, ctx->flowstack_lit[i]);
	SET(ctx->func, ctx->flowstack_func[i]);
	SET(ctx->klenv, ctx->flowstack_klenv[i]);
	SET(ctx->vlenv, ctx->flowstack_vlenv[i]);
//	SET(ctx->kdenv, ctx->flowstack_kdenv[i]);
//	SET(ctx->vdenv, ctx->flowstack_vdenv[i]);

	ctx->ip=ctx->flowstack_ip[i];
	ctx->args=ctx->flowstack_int[i*4+0];
	ctx->eargs=ctx->flowstack_int[i*4+1];

#ifdef BS1_JIT
	ctx->thunk=ctx->flowstack_thunk[i];
#endif


#if 0
	//in the name of proper ref counts
	CLEAR(ctx->flowstack_self[i]);
	CLEAR(ctx->flowstack_lit[i]);
	CLEAR(ctx->flowstack_func[i]);
	CLEAR(ctx->flowstack_klenv[i]);
	CLEAR(ctx->flowstack_vlenv[i]);
//	CLEAR(ctx->flowstack_kdenv[i]);
//	CLEAR(ctx->flowstack_vdenv[i]);
	ctx->flowstack_ip[i]=NULL;
#endif
}

void BS1_SVM_BindArgs(BS1_SVMState *ctx, elem kl, elem vl)
{
	elem kc, vc;

	if((kl==BS1_MM_NULL) && (vl==BS1_MM_NULL))
		return;

//	kc=kl; vc=vl; kl=BS1_MM_NULL; vl=BS1_MM_NULL;
//	while(BS1_CONSP(kc) && BS1_CONSP(vc))
//		{ kl=kc; vl=vc; kc=CDR(kc); vc=CDR(vc); }

	kc=kl; vc=vl;
	while(BS1_CONSP(kc) && BS1_CONSP(vc))
	{
		if(BS1_CONSP(CAR(kc)))
		{
			SET(ctx->klenv, CONS(CADAR(kc), ctx->klenv));
			SET(ctx->vlenv, CONS(CAR(vc), ctx->vlenv));
			kc=CDR(kc); vc=CDR(vc);
			continue;
		}

		if(!BS1_SYMBOLP(CAR(kc)))
		{
			kc=CDR(kc); vc=CDR(vc);
			continue;
		}

		SET(ctx->klenv, CONS(CAR(kc), ctx->klenv));
		SET(ctx->vlenv, CONS(CAR(vc), ctx->vlenv));
		kc=CDR(kc); vc=CDR(vc);
	}

	if(BS1_SYMBOLP(kc))
	{
		SET(ctx->klenv, CONS(kc, ctx->klenv));
		SET(ctx->vlenv, CONS(vc, ctx->vlenv));
	}
}

void BS1_SVM_CallObj(BS1_SVMState *ctx, elem obj, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	BS1_SVMBuiltin *bfcn;
	elem t, u, l, x;

//	printf("call %s\n", BS1_TY_GetTypeName(f));

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		blk=BS1_TY_GetObjData(f);

#ifdef BS1_BLKSTKARGS
		if(blk->fargs)
		{
			BS1_SVM_PushFrame(ctx);
			SET(ctx->self, obj);
			SET(ctx->lit, blk->lit);
			SET(ctx->func, f);
			SET(ctx->klenv, blk->fargs);
			SET(ctx->vlenv, BS1_MM_NULL);
			ctx->ip=blk->body;
#ifdef BS1_JIT
			ctx->thunk=blk->thunk;
#endif
			ctx->args=ctx->markstack[ctx->markstackpos-1];
			ctx->eargs=ctx->stackpos;
			return;
		}
#endif

		l=BS1_SVM_PopList(ctx);
		BS1_SVM_PushFrame(ctx);

		SET(ctx->self, obj);
		SET(ctx->lit, blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, BS1_MM_NULL);
		SET(ctx->vlenv, BS1_MM_NULL);

#ifdef BS1_JIT
		ctx->thunk=blk->thunk;
#endif
		ctx->ip=blk->body;
		BS1_SVM_BindArgs(ctx, blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMLAMBDA)
	{
		l=BS1_SVM_PopList(ctx);
		BS1_SVM_PushFrame(ctx);

		lmb=BS1_TY_GetObjData(f);
		SET(ctx->self, obj);
		SET(ctx->lit, lmb->blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, lmb->lkey);
		SET(ctx->vlenv, lmb->lval);

#ifdef BS1_JIT
		ctx->thunk=lmb->blk->thunk;
#endif

		ctx->ip=lmb->blk->body;
		BS1_SVM_BindArgs(ctx, lmb->blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBUILTIN)
	{
		l=BS1_SVM_PopList(ctx);
		bfcn=BS1_TY_GetObjData(f);

//		printf("Builtin %s\n", bfcn->name);

		u=BS1_MM_NULL; x=BS1_MM_NULL;
		SET(u, ctx->self);
		SET(x, ctx->func);
		SET(ctx->self, obj);
		SET(ctx->func, f);

		t=bfcn->fcn(ctx, l);
		SET(ctx->self, u);
		SET(ctx->func, x);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_HANDLEP(f))
	{
		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_Call(f, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	l=BS1_SVM_PopList(ctx);
	t=BS1_TY_Call(obj, f, l);
	BS1_SVM_Push(ctx, t);
	BS1_GC_CheckRef(l);
	return;
}

void BS1_SVM_TailCallObj(BS1_SVMState *ctx, elem obj, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	BS1_SVMBuiltin *bfcn;
	elem t, l, x;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		blk=BS1_TY_GetObjData(f);

#ifdef BS1_BLKSTKARGS
		if(blk->fargs)
		{
			BS1_SVM_PushFrame(ctx);
			SET(ctx->self, obj);
			SET(ctx->lit, blk->lit);
			SET(ctx->func, f);
			SET(ctx->klenv, blk->fargs);
			SET(ctx->vlenv, BS1_MM_NULL);
			ctx->ip=blk->body;
#ifdef BS1_JIT
			ctx->thunk=blk->thunk;
#endif
			ctx->args=ctx->markstack[ctx->markstackpos-1];
			ctx->eargs=ctx->stackpos;
			return;
		}
#endif

		l=BS1_SVM_PopList(ctx);
		SET(ctx->self, obj);
		SET(ctx->lit, blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, BS1_MM_NULL);
		SET(ctx->vlenv, BS1_MM_NULL);
		ctx->ip=blk->body;
#ifdef BS1_JIT
		ctx->thunk=blk->thunk;
#endif
		BS1_SVM_BindArgs(ctx, blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMLAMBDA)
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		lmb=BS1_TY_GetObjData(f);
		SET(ctx->self, obj);
		SET(ctx->lit, lmb->blk->lit);
		SET(ctx->func, f);
		SET(ctx->klenv, lmb->lkey);
		SET(ctx->vlenv, lmb->lval);
		ctx->ip=lmb->blk->body;
#ifdef BS1_JIT
		ctx->thunk=lmb->blk->thunk;
#endif
		BS1_SVM_BindArgs(ctx, lmb->blk->args, l);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBUILTIN)
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		bfcn=BS1_TY_GetObjData(f);

		x=BS1_MM_NULL;
		SET(x, ctx->func);

		SET(ctx->self, obj);
		SET(ctx->func, f);
		t=bfcn->fcn(ctx, l);
		SET(ctx->func, x);

		BS1_SVM_PopFrame(ctx);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);

		return;
	}

	if(BS1_HANDLEP(f))
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_Call(f, l);
		BS1_SVM_PopFrame(ctx);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	if(ctx->klenv && !ctx->vlenv)
		BS1_SVM_ShiftMark(ctx);
	l=BS1_SVM_PopList(ctx);
	t=BS1_TY_Call(obj, f, l);
	BS1_SVM_Push(ctx, t);
	BS1_GC_CheckRef(l);
	return;
}

void BS1_SVM_MethodCall(BS1_SVMState *ctx, elem obj, elem key)
{
	elem f, t, l;

	if(BS1_HANDLEP(obj))
	{
		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_CallMethod(obj, key, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	if(BS1_TY_HasMethodCall(obj))
	{
		l=BS1_SVM_PopList(ctx);
		t=BS1_TY_MethodCall(obj, key, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	f=BS1_SVM_LoadIndex(ctx, obj, key);
	BS1_SVM_CallObj(ctx, obj, f);
}

void BS1_SVM_MethodTailCall(BS1_SVMState *ctx, elem obj, elem key)
{
	elem f, t, l;

	if(BS1_HANDLEP(obj))
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		t=BS1_TYHDL_CallMethod(obj, key, l);
		BS1_SVM_PopFrame(ctx);

		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	if(BS1_TY_HasMethodCall(obj))
	{
		if(ctx->klenv && !ctx->vlenv)
			BS1_SVM_ShiftMark(ctx);

		l=BS1_SVM_PopList(ctx);
		t=BS1_TY_MethodCall(obj, key, l);
		BS1_SVM_Push(ctx, t);
		BS1_GC_CheckRef(l);
		return;
	}

	f=BS1_SVM_LoadIndex(ctx, obj, key);
	BS1_SVM_TailCallObj(ctx, obj, f);
}

elem BS1_SVM_Close(BS1_SVMState *ctx, elem f)
{
	BS1_SVMBlock *blk;
	BS1_SVMLambda *lmb;
	elem t;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMBLK)
	{
		blk=BS1_TY_GetObjData(f);
		BS1_GC_IncRef(f);

		t=BS1_MM_AllocObj(BS1_TYH_SVMLAMBDA, sizeof(BS1_SVMLambda));
		lmb=BS1_TY_GetObjData(t);
		SET(lmb->lkey, ctx->klenv);
		SET(lmb->lval, ctx->vlenv);
		lmb->blk=blk;
		return(t);
	}

	return(f);
}

elem BS1_SVM_Cast(BS1_SVMState *ctx, elem ty, elem t)
{
	if(ty==KEYSYM("int"))
	{
		if(BS1_FIXNUMP(t))return(t);
		if(BS1_FLONUMP(t))return(FIXNUM(TOFLOAT(t)));
		return(BS1_MM_NULL);
	}

	if(ty==KEYSYM("float"))
	{
		if(BS1_FIXNUMP(t))return(FLONUM(TOINT(t)));
		if(BS1_FLONUMP(t))return(t);
		return(BS1_MM_NULL);
	}

	return(t);
}

elem BS1_SVM_ReadID(BS1_SVMState *ctx)
{
	elem t;
	int i;

	i=*ctx->ip++;
	if(i&128)i=((i&127)<<8)|(*ctx->ip++);
	t=BS1_TY_GetArrayElem2(ctx->lit, i);
	return(t);
}

int BS1_SVM_ReadIDX(BS1_SVMState *ctx)
{
	int i;
	i=*ctx->ip++;
	if(i&128)i=((i&127)<<8)|(*ctx->ip++);
	return(i);
}

int BS1_SVM_DumpOpcode(BS1_SVMState *ctx)
{
	char *bops[]={"add", "sub", "mul", "div", "mod", "and", "or",
		"xor", "shl", "shr", "eq", "eqv", "neq", "neqv", "l",
		"g", "le", "ge"};

	elem t;
	byte *ip, *ip1;
	char *s;
	int i, j, k;

	ip=ctx->ip;

	i=*ip++;
	if(i>=192)
	{
		i=(i-192)*256+(*ip++);
		printf("%08X %02X%02X ", ctx->ip,
			ctx->ip[0], ctx->ip[1]);
	}else
	{
		printf("%08X %02X ", ctx->ip, i);
	}

	k=0; s=bs1_ops_args[i]; ip1=ip;
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T') || (*s=='N'))
			{ j=*ip1++; k++; if(j&128)k++; s++; continue; }
		if(*s=='A') { ip1+=2; k+=2; s++; continue; }

		if(*s=='C') { ip1++; k++; s++; continue; }
		if(*s=='B') { ip1++; k++; s++; continue; }
		if(*s=='W') { ip1++; k+=2; s++; continue; }
		if(*s=='H') { ip1++; k+=2; s++; continue; }

		if(*s=='u') { ip1++; k++; s++; continue; }
		if(*s=='b') { ip1++; k++; s++; continue; }

		s++;
	}

	ip1=ip;
	for(j=0; j<k; j++)printf("%02X", *ip1++);

	if(i<192)printf("  ");
	for(; j<4; j++)printf("  ");

	printf(" %s ", bs1_ops_strs[i]);

	s=bs1_ops_args[i];
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T'))
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			t=BS1_TY_GetArrayElem2(ctx->lit, i);
			BS1_TY_Print(t);
			printf(" ");
			s++;
			continue;
		}
		if(*s=='N')
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			printf("%d ", i);
			s++;
			continue;
		}
		if(*s=='A')
		{
			i=*ip++; i|=(*ip++)<<8;
			printf("%08X ", ip+i);
			s++;
			continue;
		}
		if(*s=='C') { i=(signed char)(*ip++); printf("%d ", i);
			s++; continue; }
		if(*s=='B') { i=*ip++; printf("%d ", i); s++; continue; }
		if(*s=='W') { i=*ip++; i|=(*ip++)<<8; printf("%d ", i);
			s++; continue; }
		if(*s=='H') { i=*ip++; i|=(*ip++)<<8; printf("%g ", i/100.0);
			s++; continue; }

		if(*s=='b') { i=*ip++; printf("%s ", bops[i]); s++; continue; }
		s++;
	}

	printf("\n");
}

void BS1_SVM_StepJmpBool(BS1_SVMState *ctx, int j)
{
	int i;

	i=*ctx->ip++;
	i|=(*ctx->ip++)<<8;
	i=((signed short)i);
	if(j)ctx->ip+=i;
}

int BS1_SVM_StepC1(BS1_SVMState *ctx)
{
	elem t, u, v;
	int i, j;

	i=256+(*ctx->ip++);
	switch(i)
	{
	case BS1_SOP_JMP_L_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_L_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<TOFLOAT(v));
		break;
	case BS1_SOP_JMP_G_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>TOFLOAT(v));
		break;
	case BS1_SOP_JMP_LE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<=TOFLOAT(v));
		break;
	case BS1_SOP_JMP_GE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>=TOFLOAT(v));
		break;

	case BS1_SOP_JMP_E_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
//		u=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
//		v=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
		BS1_SVM_StepJmpBool(ctx, u==v);
		break;
	case BS1_SOP_JMP_NE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u!=v);
		break;
	case BS1_SOP_JMP_L_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_E_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;

	case BS1_SOP_JMP_E_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;
	default:
		break;
	}
}

int BS1_SVM_Step(BS1_SVMState *ctx)
{
	elem t, u, v;
	int i, j, k, rs;

//	printf("%d ", *ctx->ip);
//	BS1_SVM_DumpOpcode(ctx);

	i=*ctx->ip++;
	if(i>=192)i=(i-192)*256+(*ctx->ip++);

	rs=0;
//	switch(*ctx->ip++)
	switch(i)
	{
	case BS1_SOP_NOP:
		break;
	case BS1_SOP_BLOCK:
		rs=1;
		break;
	case BS1_SOP_DBGMARK:
		break;
	case BS1_SOP_CGENAST:
		break;

	case BS1_SOP_PUSH:
		t=BS1_SVM_ReadID(ctx);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_POP:
		BS1_SVM_PopDestroy(ctx);
		break;
	case BS1_SOP_LOAD:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_STORE:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_Assign(ctx, t, u);
		break;
	case BS1_SOP_BIND:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_Bind(ctx, t, u);
		break;
	case BS1_SOP_DYNBIND:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_DynBind(ctx, t, u);
		break;
	case BS1_SOP_LEXBIND:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_LexBind(ctx, t, u);
		break;

	case BS1_SOP_LOADINDEX:
		u=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, u);
		BS1_SVM_Push(ctx, v);
		break;
	case BS1_SOP_STOREINDEX:
		v=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, u, v);
		break;
	case BS1_SOP_LOADINDEX_S:
		u=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, u);
		BS1_SVM_Push(ctx, v);
		break;
	case BS1_SOP_STOREINDEX_S:
		u=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, u, v);
		break;

	case BS1_SOP_LOADINDEX_I:
		u=FIXNUM(*ctx->ip++);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, u);
		BS1_SVM_Push(ctx, v);
		break;
	case BS1_SOP_STOREINDEX_I:
		u=FIXNUM(*ctx->ip++);
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, u, v);
		break;

	case BS1_SOP_LOADINDEX_0:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_0);
		BS1_SVM_Push(ctx, v); break;
	case BS1_SOP_LOADINDEX_1:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_1);
		BS1_SVM_Push(ctx, v); break;
	case BS1_SOP_LOADINDEX_2:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_2);
		BS1_SVM_Push(ctx, v); break;
	case BS1_SOP_LOADINDEX_3:
		t=BS1_SVM_Pop(ctx);
		v=BS1_SVM_LoadIndex(ctx, t, BS1_MM_FIXNUM_3);
		BS1_SVM_Push(ctx, v); break;

	case BS1_SOP_STOREINDEX_0:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_0, u); break;
	case BS1_SOP_STOREINDEX_1:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_1, u); break;
	case BS1_SOP_STOREINDEX_2:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_2, u); break;
	case BS1_SOP_STOREINDEX_3:
		t=BS1_SVM_Pop(ctx); u=BS1_SVM_Pop(ctx);
		BS1_SVM_StoreIndex(ctx, t, BS1_MM_FIXNUM_3, u); break;

	case BS1_SOP_PUSHSELF:
		BS1_SVM_PushF(ctx, ctx->self);
		break;
	case BS1_SOP_PUSH_NULL:
		BS1_SVM_PushF(ctx, BS1_MM_NULL);
		break;
	case BS1_SOP_PUSH_TRUE:
		BS1_SVM_PushF(ctx, BS1_MM_TRUE);
		break;
	case BS1_SOP_PUSH_FALSE:
		BS1_SVM_PushF(ctx, BS1_MM_FALSE);
		break;
	case BS1_SOP_PUSH_SV:
		i=(signed char)(*ctx->ip++);
		BS1_SVM_PushF(ctx, FIXNUM(i));
		break;
	case BS1_SOP_PUSH_SV_P:
		i=*ctx->ip++;
		BS1_SVM_PushF(ctx, FIXNUM(i));
		break;
	case BS1_SOP_PUSH_SV_N:
		i=*ctx->ip++;
		BS1_SVM_PushF(ctx, FIXNUM(-i));
		break;
	case BS1_SOP_PUSH_SV_F:
		i=*ctx->ip++;
		i+=(*ctx->ip++)<<8;
		BS1_SVM_PushF(ctx, FLONUM(((short)i)/100.0));
		break;
	case BS1_SOP_PUSH_0: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_0); break;
	case BS1_SOP_PUSH_1: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_1); break;
	case BS1_SOP_PUSH_2: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_2); break;
	case BS1_SOP_PUSH_3: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_3); break;
	case BS1_SOP_PUSH_4: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_4); break;
	case BS1_SOP_PUSH_5: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_5); break;
	case BS1_SOP_PUSH_6: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_6); break;
	case BS1_SOP_PUSH_7: BS1_SVM_PushF(ctx, BS1_MM_FIXNUM_7); break;
	case BS1_SOP_PUSH_CF: BS1_SVM_Push(ctx, ctx->func); break;

	case BS1_SOP_LLOAD:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_LSTORE:
		i=*ctx->ip++;
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_AssignIdx(ctx, i, t);
		break;
	case BS1_SOP_LLOAD_F:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_PushF(ctx, t);
		break;
	case BS1_SOP_LSTORE_F:
		i=*ctx->ip++;
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_AssignIdxF(ctx, i, t);
		break;
	case BS1_SOP_LLOAD_F2:
		i=*ctx->ip++;
		t=ctx->stack[ctx->eargs-i-1];
		ctx->stack[ctx->stackpos++]=t;
		break;
	case BS1_SOP_LSTORE_F2:
		i=*ctx->ip++;
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->eargs-i-1]=t;
		break;

	case BS1_SOP_LINC_FN:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_AssignIdxF(ctx, i, t+4);
		break;
	case BS1_SOP_LDEC_FN:
		i=*ctx->ip++;
		t=BS1_SVM_LookupIdx(ctx, i);
		BS1_SVM_AssignIdxF(ctx, i, t-4);
		break;
	case BS1_SOP_LINC_FN2:
		i=*ctx->ip++;
		ctx->stack[ctx->eargs-i-1]+=4;
		break;
	case BS1_SOP_LDEC_FN2:
		i=*ctx->ip++;
		ctx->stack[ctx->eargs-i-1]-=4;
		break;

	case BS1_SOP_CLEARENV: break;
	case BS1_SOP_BINDPATTERN: break;
	case BS1_SOP_LOADMINDEX: break;
	case BS1_SOP_STOREMINDEX: break;

	case BS1_SOP_TRYLOAD:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_Push(ctx, t);
		break;

	case BS1_SOP_CAST:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Cast(ctx, t, u);
		BS1_SVM_Push(ctx, u);
		break;

	case BS1_SOP_MARK:
		ctx->markstack[ctx->markstackpos++]=ctx->stackpos;
		break;

	case BS1_SOP_CALL:
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_CallObj(ctx, ctx->self, t);
		break;
	case BS1_SOP_TAILCALL:
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_TailCallObj(ctx, ctx->self, t);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;
	case BS1_SOP_CALL_S:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_CallObj(ctx, ctx->self, t);
		break;
	case BS1_SOP_TAILCALL_S:
		t=BS1_SVM_ReadID(ctx);
		t=BS1_SVM_Lookup(ctx, t);
		BS1_SVM_TailCallObj(ctx, ctx->self, t);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;

	case BS1_SOP_METHODCALL:
		t=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodCall(ctx, u, t);
		break;
	case BS1_SOP_METHODTAILCALL:
		t=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodTailCall(ctx, u, t);
		break;
	case BS1_SOP_METHODCALL_S:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodCall(ctx, u, t);
		break;
	case BS1_SOP_METHODTAILCALL_S:
		t=BS1_SVM_ReadID(ctx);
		u=BS1_SVM_Pop(ctx);
		BS1_SVM_MethodTailCall(ctx, u, t);
		break;

	case BS1_SOP_RET:
#ifdef BS1_BLKSTKARGS
		if(ctx->klenv && !ctx->vlenv)
		{
			t=BS1_SVM_PopF(ctx);
			BS1_SVM_PopMark(ctx);
//			ctx->args=ctx->markstack[ctx->markstackpos-1];
//			ctx->eargs=ctx->stackpos;
			BS1_SVM_PushF(ctx, t);
		}
#endif

		BS1_SVM_PopFrame(ctx);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;

	case BS1_SOP_CALL_CF:
		BS1_SVM_CallObj(ctx, ctx->self, ctx->func);
		break;
	case BS1_SOP_TAILCALL_CF:
		BS1_SVM_TailCallObj(ctx, ctx->self, ctx->func);
		if(ctx->flowstackpos<0)
		{
			rs=2;
			break;
		}
		break;

	case BS1_SOP_CAR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CAR(t)); break;
	case BS1_SOP_CDR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CDR(t)); break;
	case BS1_SOP_CAAR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CAAR(t)); break;
	case BS1_SOP_CDAR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CDAR(t)); break;
	case BS1_SOP_CADR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CADR(t)); break;
	case BS1_SOP_CDDR:
		t=BS1_SVM_Pop(ctx); BS1_SVM_Push(ctx, CDDR(t)); break;

	case BS1_SOP_CLOSE:
		t=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Close(ctx, t);
		BS1_SVM_Push(ctx, t);
		break;

	case BS1_SOP_DUP:
//		t=BS1_SVM_PopF(ctx);
//		BS1_SVM_PushF(ctx, t);
//		BS1_SVM_Push(ctx, t);
		BS1_SVM_Push(ctx, ctx->stack[ctx->stackpos-1]);
		break;
	case BS1_SOP_DUP_F:
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_PushF(ctx, t);
		BS1_SVM_PushF(ctx, t);
		break;
	case BS1_SOP_EXCH:
		u=BS1_SVM_PopF(ctx);
		v=BS1_SVM_PopF(ctx);
		BS1_SVM_PushF(ctx, u);
		BS1_SVM_PushF(ctx, v);
		break;
	case BS1_SOP_INDEX:
		i=BS1_SVM_ReadIDX(ctx);
		t=ctx->stack[ctx->stackpos-(i+1)];
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_RINDEX:
		i=BS1_SVM_ReadIDX(ctx);
		j=ctx->markstack[ctx->markstackpos-1];
		t=ctx->stack[i+j];
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_SETINDEX:
		t=BS1_SVM_Pop(ctx);
		i=BS1_SVM_ReadIDX(ctx);
		ctx->stack[ctx->stackpos-(i+1)]=t;
		break;
	case BS1_SOP_SETRINDEX:
		t=BS1_SVM_Pop(ctx);
		i=BS1_SVM_ReadIDX(ctx);
		j=ctx->markstack[ctx->markstackpos-1];
		ctx->stack[i+j]=t;
		break;

	case BS1_SOP_DUP_R:
		i=*ctx->ip++;
		t=BS1_SVM_Pop(ctx);
		BS1_SVM_Push(ctx, t);
		SET(ctx->reg[i], t);
		break;
	case BS1_SOP_DUP_RF:
		i=*ctx->ip++;
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_PushF(ctx, t);
		ctx->reg[i]=t;
		break;
	case BS1_SOP_PUSH_R:
		i=*ctx->ip++;
		BS1_SVM_Push(ctx, ctx->reg[i]);
		break;
	case BS1_SOP_PUSH_RF:
		i=*ctx->ip++;
		BS1_SVM_PushF(ctx, ctx->reg[i]);
		break;
	case BS1_SOP_POP_R:
		i=*ctx->ip++;
		t=BS1_SVM_PopF(ctx);
		ctx->reg[i]=t;
		break;

	case BS1_SOP_UNARYOP:
		i=*ctx->ip++;
		t=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Unary(ctx, i, t);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_BINARYOP:
		i=*ctx->ip++;
		v=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		t=BS1_SVM_Binary(ctx, i, u, v);
		BS1_SVM_Push(ctx, t);
		break;

	case BS1_SOP_JMP:
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		ctx->ip+=i;
		break;
	case BS1_SOP_JMP_TRUE:
//		j=BS1_TY_GetBool(BS1_SVM_Pop(ctx));
		j=BS1_SVM_PopBool(ctx);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(j)ctx->ip+=i;
		break;
	case BS1_SOP_JMP_FALSE:
//		j=BS1_TY_GetBool(BS1_SVM_Pop(ctx));
		j=BS1_SVM_PopBool(ctx);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(!j)ctx->ip+=i;
		break;

	case BS1_SOP_JMP_COND_U:
		j=*ctx->ip++;
		j=BS1_Opr_CondUnary(j, BS1_SVM_Pop(ctx));
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(j)ctx->ip+=i;
		break;
	case BS1_SOP_JMP_COND_B:
		v=BS1_SVM_Pop(ctx);
		u=BS1_SVM_Pop(ctx);
		j=*ctx->ip++;
		j=BS1_Opr_CondBinary(j, u, v);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		if(j)ctx->ip+=i;
		break;

	case BS1_SOP_LIST:
		t=BS1_SVM_PopList2(ctx);
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_DICT:
		t=BS1_SVM_PopList(ctx);
		u=BS1_SObj_New();
		v=t;
		while(BS1_CONSP(v))
		{
			BS1_SObj_BindSlot(u, CAR(v), CADR(v));
			v=CDDR(v);
		}
		BS1_GC_CheckRef(t);
		BS1_SVM_Push(ctx, u);
		break;
	case BS1_SOP_VECTOR:
		t=BS1_SVM_PopList(ctx);
		u=BS1_TYVec_List2FVec(t);
		BS1_SVM_Push(ctx, u);
		BS1_GC_CheckRef(t);
		break;
	case BS1_SOP_COMPLEX_I:
		t=BS1_SVM_Pop(ctx);
		t=BS1_COMPLEX_I(TOFLOAT(t));
		BS1_SVM_Push(ctx, t);
		break;
	case BS1_SOP_MATRIX:
		t=BS1_SVM_PopList(ctx);
		u=BS1_TYMat_List2FMat(t);
		BS1_SVM_Push(ctx, u);
		BS1_GC_CheckRef(t);
		break;


	case BS1_SOP_INC_FN: ctx->stack[ctx->stackpos-1]+=4; break;
	case BS1_SOP_DEC_FN: ctx->stack[ctx->stackpos-1]-=4; break;
	case BS1_SOP_INC2_FN: ctx->stack[ctx->stackpos-1]+=8; break;
	case BS1_SOP_DEC2_FN: ctx->stack[ctx->stackpos-1]-=8; break;

	case BS1_SOP_ADD_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]+=t&(~3);
		break;
	case BS1_SOP_SUB_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]-=t&(~3);
		break;
	case BS1_SOP_MUL_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)*TOINT(v));
		break;
	case BS1_SOP_DIV_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)/TOINT(v));
		break;
	case BS1_SOP_IDIV_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)/TOINT(v));
		break;
	case BS1_SOP_MOD_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)%TOINT(v));
		break;
	case BS1_SOP_AND_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]&=t;
		break;
	case BS1_SOP_OR_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]|=t;
		break;
	case BS1_SOP_XOR_FN:
		t=ctx->stack[--ctx->stackpos];
		ctx->stack[ctx->stackpos-1]^=t&(~3);
		break;
	case BS1_SOP_CMP_L_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)<((int)v));
		break;
	case BS1_SOP_CMP_G_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)>((int)v));
		break;
	case BS1_SOP_CMP_LE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)<=((int)v));
		break;
	case BS1_SOP_CMP_GE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(((int)u)>=((int)v));
		break;
	case BS1_SOP_CMP_E_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(u==v);
		break;
	case BS1_SOP_CMP_NE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(u!=v);
		break;

	case BS1_SOP_ADD_FN_C:
		i=*ctx->ip++;
		ctx->stack[ctx->stackpos-1]+=i<<2;
		break;
	case BS1_SOP_SUB_FN_C:
		i=*ctx->ip++;
		ctx->stack[ctx->stackpos-1]-=i<<2;
		break;
	case BS1_SOP_MUL_FN_C:
		i=*ctx->ip++;
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=((t&(~3))*i)|BS1_MM_FIXNUM;
		break;

	case BS1_SOP_SHL_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)<<TOINT(v));
		break;
	case BS1_SOP_SHR_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(TOINT(u)>>TOINT(v));
		break;
	case BS1_SOP_EXP_FN:
		i=TOINT(ctx->stack[--ctx->stackpos]);
		j=TOINT(ctx->stack[ctx->stackpos-1]);
		k=1; while(i--)k*=j;
		ctx->stack[ctx->stackpos-1]=FIXNUM(k);
		break;

	case BS1_SOP_SHL_FN_C:
		i=*ctx->ip++;
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=((t>>2)<<(i+2))|BS1_MM_FIXNUM;
		break;
	case BS1_SOP_SHR_FN_C:
		i=*ctx->ip++;
		j=TOINT(ctx->stack[ctx->stackpos-1]);
		ctx->stack[ctx->stackpos-1]=((j>>i)<<2)|BS1_MM_FIXNUM;
		break;
	case BS1_SOP_EXP_FN_C:
		i=*ctx->ip++;
		j=TOINT(ctx->stack[ctx->stackpos-1]);
		k=1; while(i--)k*=j;
		ctx->stack[ctx->stackpos-1]=FIXNUM(k);
		break;

	case BS1_SOP_CONV_FN2FL:
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOINT(t));
		break;
	case BS1_SOP_CONV_FL2FN:
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FIXNUM(((int)TOFLOAT(t)));
		break;

	case BS1_SOP_ADD_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)+TOFLOAT(v));
		break;
	case BS1_SOP_SUB_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)-TOFLOAT(v));
		break;
	case BS1_SOP_MUL_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)*TOFLOAT(v));
		break;
	case BS1_SOP_DIV_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(TOFLOAT(u)/TOFLOAT(v));
		break;
	case BS1_SOP_CMP_L_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)<TOFLOAT(v));
		break;
	case BS1_SOP_CMP_G_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)>TOFLOAT(v));
		break;
	case BS1_SOP_CMP_LE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)<=TOFLOAT(v));
		break;
	case BS1_SOP_CMP_GE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)>=TOFLOAT(v));
		break;
	case BS1_SOP_CMP_E_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)==TOFLOAT(v));
		break;
	case BS1_SOP_CMP_NE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=BS1_BOOL(TOFLOAT(u)!=TOFLOAT(v));
		break;
	case BS1_SOP_NEG_FL:
		t=ctx->stack[ctx->stackpos-1];
		ctx->stack[ctx->stackpos-1]=FLONUM(-TOFLOAT(t));
		break;

	case BS1_SOP_JMP_E_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u==v);
		break;
	case BS1_SOP_JMP_NE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u!=v);
		break;
	case BS1_SOP_JMP_E_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)==TOFLOAT(v));
		break;
	case BS1_SOP_JMP_NE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)!=TOFLOAT(v));
		break;

	case 0xC1:
		BS1_SVM_StepC1(ctx);
		break;

#if 1
	case BS1_SOP_JMP_L_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_FN:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_L_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<TOFLOAT(v));
		break;
	case BS1_SOP_JMP_G_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>TOFLOAT(v));
		break;
	case BS1_SOP_JMP_LE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)<=TOFLOAT(v));
		break;
	case BS1_SOP_JMP_GE_FL:
		v=ctx->stack[--ctx->stackpos];
		u=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, TOFLOAT(u)>=TOFLOAT(v));
		break;

	case BS1_SOP_JMP_E_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
//		u=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
//		v=BS1_SVM_LookupIdx(ctx, *ctx->ip++);
		BS1_SVM_StepJmpBool(ctx, u==v);
		break;
	case BS1_SOP_JMP_NE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u!=v);
		break;
	case BS1_SOP_JMP_L_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<v);
		break;
	case BS1_SOP_JMP_G_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>v);
		break;
	case BS1_SOP_JMP_LE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u<=v);
		break;
	case BS1_SOP_JMP_GE_LFN:
		u=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		v=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, u>=v);
		break;

	case BS1_SOP_JMP_E_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_ZFN:
		t=ctx->stack[--ctx->stackpos];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;

	case BS1_SOP_JMP_E_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t==BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_NE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t!=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_L_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_G_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_LE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t<=BS1_MM_FIXNUM_0);
		break;
	case BS1_SOP_JMP_GE_LZFN:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		BS1_SVM_StepJmpBool(ctx, t>=BS1_MM_FIXNUM_0);
		break;


	case BS1_SOP_JMP_E_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t==u);
		break;
	case BS1_SOP_JMP_NE_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t!=u);
		break;
	case BS1_SOP_JMP_L_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<u);
		break;
	case BS1_SOP_JMP_G_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>u);
		break;
	case BS1_SOP_JMP_LE_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<=u);
		break;
	case BS1_SOP_JMP_GE_FNC:
		t=ctx->stack[--ctx->stackpos];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>=u);
		break;

	case BS1_SOP_JMP_E_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t==u);
		break;
	case BS1_SOP_JMP_NE_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t!=u);
		break;
	case BS1_SOP_JMP_L_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<u);
		break;
	case BS1_SOP_JMP_G_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>u);
		break;
	case BS1_SOP_JMP_LE_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t<=u);
		break;
	case BS1_SOP_JMP_GE_LFNC:
		t=ctx->stack[ctx->eargs-(*ctx->ip++)-1];
		u=FIXNUM((signed char)(*ctx->ip++));
		BS1_SVM_StepJmpBool(ctx, t>=u);
		break;
#endif

	default:
		break;
	}

	return(rs);
}

int BS1_SVM_Run(elem ct)
{
	BS1_SVMState *ctx;
	int rs, i, j, t;

	ctx=BS1_TY_GetObjData(ct);
	rs=0;

//	t=clock();
	i=0;
	while(!rs)
	{
#ifdef BS1_JIT
		if(ctx->thunk)
		{
			rs=ctx->thunk(ctx);
			continue;
		}
#endif

//		printf("%p %p\n", ctx, ctx->ip);
		i++;
		rs=BS1_SVM_Step(ctx);
	}

//	j=clock()-t;
//	if(j)printf("MIPS %g\n", (i/(j/(float)CLOCKS_PER_SEC))/1000000.0);

	bs1_svm_opcnt+=i;

	return(rs);
}

elem BS1_SVM_EvalExprsObj(elem exp, elem obj)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l, f;
	int i;

	cctx=malloc(sizeof(BS1_SVMCState));
	memset(cctx, 0, sizeof(BS1_SVMCState));

	cctx->lvl=-1;
	f=BS1_SComp_CompileBlock(cctx, BS1_MM_NULL, BS1_MM_NULL, exp);

	free(cctx);

	ct=BS1_SVM_NewState();
	ctx=BS1_TY_GetObjData(ct);
	ctx->flowstackpos=-1;

	BS1_SVM_PushList(ctx, BS1_MM_NULL);
	BS1_SVM_CallObj(ctx, obj, f);
	i=BS1_SVM_Run(ct);
	t=BS1_SVM_Pop(ctx);

	BS1_GC_CheckRef(f);
	BS1_GC_CheckRef(ct);

	return(t);
}

elem BS1_SVM_EvalStringS(char *str)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	elem t, ct, l;
	int i;

	l=BS1_ParseS_MultiFromString(str);
	t=BS1_SVM_EvalExprsObj(l, bs1_svm_toplevel);
	BS1_GC_CheckRef(l);

	return(t);
}

elem BS1_SVM_EvalString(char *str)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l;
	int i;

	s=str;
	l=BS1_Parse_Block(&s);
	BS1_TY_PrintLN(l);

	t=BS1_SVM_EvalExprsObj(l, bs1_svm_toplevel);
	BS1_GC_CheckRef(l);

	return(t);
}

elem BS1_SVM_EvalStringObj(char *str, elem obj)
{
	BS1_SVMCState *cctx;
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l;
	int i;

	if(obj==BS1_MM_NULL)
		obj=bs1_svm_toplevel;

	BS1_Parse_SetLinenum("<eval-str>", str, 1);

	s=str;
	l=BS1_Parse_Block(&s);
//	BS1_TY_PrintLN(l);

	t=BS1_SVM_EvalExprsObj(l, obj);
	BS1_GC_CheckRef(l);

	return(t);
}

elem BS1_SVM_CallFuncObj(elem obj, elem fcn, elem args)
{
	BS1_SVMState *ctx;
	char *s;
	elem t, ct, l, f;
	int i;

	if(obj==BS1_MM_NULL)
		obj=bs1_svm_toplevel;

	if(BS1_SYMBOLP(fcn))
	{
		fcn=BS1_SObj_GetSlot(obj, fcn);
		if(fcn==BS1_MM_NULL)
			return(BS1_MM_NULL);
	}

//	printf("call ");
//	BS1_TY_PrintLN(CONS(fcn, args));

	ct=BS1_SVM_NewState();
	ctx=BS1_TY_GetObjData(ct);
	ctx->flowstackpos=-1;

	BS1_SVM_PushList(ctx, args);
	BS1_SVM_CallObj(ctx, obj, fcn);
	i=BS1_SVM_Run(ct);
	t=BS1_SVM_Pop(ctx);

	BS1_GC_CheckRef(ct);

	return(t);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>


elem BS1_Parse_FunArgs(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		b[0]=0;
		BS1_Parse_Token(s, b, &ty);
		if(!*b)break;
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		n=BS1_Parse_Expression3(&s);
		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		BS1_Parse_Token(s, b, &ty);
//		if((*b==')') || (*b==']') || (*b=='}'))break;
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if(!strcmp(b, ";"))
		{
			s=BS1_Parse_Token(s, b, &ty);

			n=BS1_Parse_Expression3(&s);
			lst=BS1_TY_NAppend(lst, n);
			continue;
		}

#if 0
		if(strcmp(b, ","))
		{
			BS1_MSG_Error(s, "BS1_Parse_FunArgs: "
				"Invalid Token '%s'\n", b);
			*(int *)(-1)=-1;
		}
#endif

		if(!strcmp(b, ","))
		{
			s=BS1_Parse_Token(s, b, &ty);
			continue;
		}
	}

	*str=s;
	return(lst);
}

elem BS1_Parse_FunArgs2(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		b[0]=0;
		BS1_Parse_Token(s, b, &ty);
		if(!*b)break;
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		n=BS1_Parse_Expression3(&s);
		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		BS1_Parse_Token(s, b, &ty);

		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if(!strcmp(b, ",") || !strcmp(b, ";"))
		{
			s=BS1_Parse_Token(s, b, &ty);
			continue;
		}
	}

	*str=s;
	return(lst);
}

elem BS1_Parse_IListArgs(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		b[0]=0;
		BS1_Parse_Token(s, b, &ty);
		if(!*b)break;
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, "(") || !strcmp(b, "[") ||
			!strcmp(b, "{")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			n=BS1_Parse_FunArgs(&s);
		}else
		{
			n=BS1_Parse_Expression3(&s);
		}

		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		BS1_Parse_Token(s, b, &ty);
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if(!strcmp(b, ";"))
		{
			s=BS1_Parse_Token(s, b, &ty);

			n=BS1_Parse_Expression3(&s);
			lst=BS1_TY_NAppend(lst, n);
			continue;
		}

		if(!strcmp(b, ","))
		{
			s=BS1_Parse_Token(s, b, &ty);
			continue;
		}
	}

	*str=s;
	return(lst);
}

elem BS1_Parse_RListArgs(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		b[0]=0;
		BS1_Parse_Token(s, b, &ty);
		if(!*b)break;
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, "(") || !strcmp(b, "[") ||
			!strcmp(b, "{")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			n=BS1_Parse_RListArgs(&s);
		}else
		{
			n=BS1_Parse_Expression3(&s);
		}

		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		BS1_Parse_Token(s, b, &ty);
		if((ty==BS1_TOKEN_BRACE) &&
			(!strcmp(b, ")") || !strcmp(b, "]") ||
			!strcmp(b, "}")))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if(!strcmp(b, ";"))
		{
			s=BS1_Parse_Token(s, b, &ty);

			n=BS1_Parse_Expression3(&s);
			lst=BS1_TY_NAppend(lst, n);
			continue;
		}

		if(!strcmp(b, ","))
		{
			s=BS1_Parse_Token(s, b, &ty);
			continue;
		}
	}

	*str=s;
	return(lst);
}


elem BS1_Parse_VarsList(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);
		if(!strcmp(b, ";"))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		s=BS1_Parse_Token(s, b, &ty);
		BS1_Parse_Token(s, b2, &ty2);

		if(ty!=BS1_TOKEN_NAME)
		{
			BS1_MSG_Error(s, "PDSCR_Parse_VarsList: Expected name, "
				"got '%s'\n", b);
			*str=NULL;
			return(BS1_MM_NULL);
		}

		n=SYM(b);

		BS1_Parse_Token(s, b, &ty);
		if(!strcmp(b, "="))
		{
			s=BS1_Parse_Token(s, b, &ty);
			n1=BS1_Parse_Expression(&s);

			n=CONS(n, CONS(n1, BS1_MM_NULL));

			BS1_Parse_Token(s, b, &ty);
		}

		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		s=BS1_Parse_Token(s, b, &ty);
		if(!strcmp(b, ";"))break;

		if(*b!=',')
		{
			BS1_MSG_Error(s, "PDSCR_Parse_VarsList: Invalid token %s "
				"in vars list\n", b);
			*str=NULL;
			return(BS1_MM_NULL);
		}
	}

	*str=s;
	return(lst);
}

elem BS1_Parse_DefType(char **str)
{
	char b[256];
	char *s;
	int i, ty, fl;

	s=*str;

	BS1_Parse_Token(s, b, &ty);
	fl=0;
	while(1)
	{
		i=0;
		if(!strcmp(b, "extern"))i=BS1_TYPEFL_EXTERN;
		if(!strcmp(b, "const"))i=BS1_TYPEFL_CONST;
		if(!strcmp(b, "final"))i=BS1_TYPEFL_CONST;
		if(!strcmp(b, "static"))i=BS1_TYPEFL_STATIC;
		if(!strcmp(b, "native"))i=BS1_TYPEFL_NATIVE;
		if(!strcmp(b, "public"))i=BS1_TYPEFL_PUBLIC;
		if(!strcmp(b, "private"))i=BS1_TYPEFL_PRIVATE;
		if(!strcmp(b, "protected"))i=BS1_TYPEFL_PROTECTED;
		if(!strcmp(b, "virtual"))i=BS1_TYPEFL_VIRTUAL;
		if(!strcmp(b, "volatile"))i=BS1_TYPEFL_VOLATILE;

		if(i)
		{
			fl|=i;
			s=BS1_Parse_Token(s, b, &ty);
			BS1_Parse_Token(s, b, &ty);
			continue;
		}

		break;
	}

	if(!strcmp(b, "byte") || !strcmp(b, "sbyte") ||
		!strcmp(b, "short") || !strcmp(b, "ushort") ||
		!strcmp(b, "int") || !strcmp(b, "uint") ||
		!strcmp(b, "long") || !strcmp(b, "ulong") ||
		!strcmp(b, "float") || !strcmp(b, "double") ||
		!strcmp(b, "string") || !strcmp(b, "var") ||
		!strcmp(b, "list") || !strcmp(b, "symbol"))
	{
		s=BS1_Parse_Token(s, b, &ty);

		if(fl)sprintf(b, "%s$%d", b, fl);

		*str=s;
		return(KEYSYM(b));
	}

	return(BS1_MM_NULL);
}

elem BS1_Parse_FunVarsList(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, lst;

	s=*str;
	lst=BS1_MM_NULL;

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);
		if(!strcmp(b, ")"))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		if(!strcmp(b, ";"))
		{
			n=BS1_Parse_Expression3(&s);
			lst=BS1_TY_NAppend(lst, n);
			continue;
		}

		n1=BS1_Parse_DefType(&s);

		s=BS1_Parse_Token(s, b, &ty);
		BS1_Parse_Token(s, b2, &ty2);

		if(ty!=BS1_TOKEN_NAME)
		{
			BS1_MSG_Error(s, "PDSCR_Parse_VarsFunList: Expected name, "
				"got '%s'\n", b);
			*str=NULL;
			return(BS1_MM_NULL);
		}

		n=SYM(b);
		if(n1!=BS1_MM_NULL)n=CONS(n1, CONS(n, BS1_MM_NULL));
		lst=BS1_TY_NAppend(lst, CONS(n, BS1_MM_NULL));

		if(!strcmp(b2, ","))
			s=BS1_Parse_Token(s, b2, &ty2);
	}

	*str=s;
	return(lst);
}

#if 0
elem BS1_Parse_MetafunExpr(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2;

	s=*str;
	b=kralloc(1024);
//	lst=NULL;

	n=NetParse_NewNode();
	s=BS1_Parse_Token(s, b2, &ty2);
	n2=BS1_Parse_FunArgs(&s);

	n1=NetParse_NewNode();
	n1->key=kstrdup("args");
	n1->first=n2;

	NetParse_AddChildNode(n, n1);

	n2=BS1_Parse_Expression(&s);
	n1=NetParse_NewNode();
	n1->key=kstrdup("body");
	n1->first=n2;
	NetParse_AddChildNode(n, n1);

	*str=s;
	return(n);
}

elem BS1_Parse_MetafunBlock(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2;

	s=*str;
	b=kralloc(1024);
//	lst=NULL;

	n=NetParse_NewNode();
	s=BS1_Parse_Token(s, b2, &ty2);
	n2=BS1_Parse_FunArgs(&s);

	n1=NetParse_NewNode();
	n1->key=kstrdup("args");
	n1->first=n2;

	NetParse_AddChildNode(n, n1);

	n2=BS1_Parse_BlockStatement2(&s);
	n1=NetParse_NewNode();
	n1->key=kstrdup("body");
	n1->first=n2;
	NetParse_AddChildNode(n, n1);

	*str=s;
	return(n);
}
#endif
#include <pdlib.h>
//#include <pdnet.h>
#include <pdscript.h>

PDSCR0_ParseItem *bs1_parse_exprs=NULL;
extern char *bs1_parse_curfilename;


int BS1_Parse_AddExpression(char *name, elem (*func)(char **s))
{
	PDSCR0_ParseItem *tmp;

	tmp=kalloc(sizeof(PDSCR0_ParseItem));
	tmp->name=kstrdup(name);
	tmp->func=func;

	tmp->next=bs1_parse_exprs;
	bs1_parse_exprs=tmp;

	return(0);
}

elem BS1_Parse_ParseExpressionName(char *name, char **s)
{
	PDSCR0_ParseItem *cur;

	cur=bs1_parse_exprs;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}

//	BS1_MSG_Error(s, "PDSCR_Parse_ParseStatementName: Invalid Name %s\n", name);
	return(NULL);
}

elem BS1_Parse_DotRef(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2, *n3;

	s=*str;
	b=kralloc(1024);
	b2=kralloc(1024);

	s=BS1_Parse_Token(s, b, &ty);

	n=NetParse_NewNode();
	n->key=kstrdup("ref");
	NetParse_AddAttr(n, "name", b);

	BS1_Parse_Token(s, b2, &ty2);
	while(!strcmp(b2, ".") || !strcmp(b2, "["))
	{
		s=BS1_Parse_Token(s, b2, &ty2);
		if(!strcmp(b2, "["))
		{
			n2=NetParse_NewNode();
			n2->key=kstrdup("obj");
			n2->first=n;

			n1=NetParse_NewNode();
			n1->key=kstrdup("indexref");
			n1->first=n2;
			n=n1;

			n2=BS1_Parse_Expression(&s);
			s=BS1_Parse_Token(s, b2, &ty2);

			n1=NetParse_NewNode();
			n1->key=kstrdup("index");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			BS1_Parse_Token(s, b2, &ty2);
			continue;
		}

		s=BS1_Parse_Token(s, b, &ty);

		n2=NetParse_NewNode();
		n2->key=kstrdup("obj");
		n2->first=n;

		n1=NetParse_NewNode();
		n1->key=kstrdup("objref");
		n1->first=n2;
		NetParse_AddAttr(n1, "name", b);

		n=n1;

		BS1_Parse_Token(s, b2, &ty2);
	}

	if(!strcmp(b2, "("))
	{
		n->key=kstrdup("methodcall");

		s=BS1_Parse_Token(s, b2, &ty2);
		n2=BS1_Parse_FunArgs(&s);

		n1=NetParse_NewNode();
		n1->key=kstrdup("args");
		n1->first=n2;

		NetParse_AddChildNode(n, n1);

		*str=s;
		return(n);
	}

	if(!strcmp(b2, "="))
	{
		if(!strcmp(n->key, "objref"))
			n->key=kstrdup("slotassign");
		if(!strcmp(n->key, "indexref"))
			n->key=kstrdup("indexassign");

		s=BS1_Parse_Token(s, b2, &ty2);
		n2=BS1_Parse_Expression(&s);

		n1=NetParse_NewNode();
		n1->key=kstrdup("value");
		n1->first=n2;

		NetParse_AddChildNode(n, n1);

		*str=s;
		return(n);
	}

	if(
		!strcmp(b2, "+=") ||
		!strcmp(b2, "-=") ||
		!strcmp(b2, "*=") ||
		!strcmp(b2, "/=") ||
		!strcmp(b2, "&=") ||
		!strcmp(b2, "|=") ||
		!strcmp(b2, "^=")
		)
	{
		n3=NetParse_NewNode();
		n3->key=kstrdup(n->key);
		n3->first=n->first;
		n3->attr=n->attr;

		if(!strcmp(n->key, "objref"))
			n->key=kstrdup("slotassign");
		if(!strcmp(n->key, "indexref"))
			n->key=kstrdup("indexassign");

		s=BS1_Parse_Token(s, b2, &ty2);

		n1=NetParse_NewNode();
		n1->key=kstrdup("binary");
		if(!strcmp(b2, "+="))NetParse_AddAttr(n1, "op", "+");
		if(!strcmp(b2, "-="))NetParse_AddAttr(n1, "op", "-");
		if(!strcmp(b2, "*="))NetParse_AddAttr(n1, "op", "*");
		if(!strcmp(b2, "/="))NetParse_AddAttr(n1, "op", "/");
		if(!strcmp(b2, "&="))NetParse_AddAttr(n1, "op", "&");
		if(!strcmp(b2, "|="))NetParse_AddAttr(n1, "op", "|");
		if(!strcmp(b2, "^="))NetParse_AddAttr(n1, "op", "^");

		n2=NetParse_NewNode();
		n2->key=kstrdup("left");
		n2->first=n3;
		NetParse_AddChildNode(n1, n2);

		n3=BS1_Parse_Expression(&s);
		n2=NetParse_NewNode();
		n2->key=kstrdup("right");
		n2->first=n3;
		NetParse_AddChildNode(n1, n2);

		n2=n1;
		n1=NetParse_NewNode();
		n1->key=kstrdup("value");
		n1->first=n2;

		NetParse_AddChildNode(n, n1);

		*str=s;
		return(n);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_XML(char **str)
{
	char *s, *b;
	int ty;
	elem n, *n1, *n2;

	s=*str;
	b=kralloc(1024);

	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "{"))
	{
		s=BS1_Parse_Token(s, b, &ty); //{
		n1=NetParse_XML_ParseExpr(&s);
		n=n1;

		while(*s)
		{
			BS1_Parse_Token(s, b, &ty);
			if(!strcmp(b, "}"))break;

			n2=NetParse_XML_ParseExpr(&s);
			n1->next=n2;
			n1=n2;
		}

		s=BS1_Parse_Token(s, b, &ty); //}
	}else n=NetParse_XML_ParseExpr(&s);

	*str=s;
	return(n);
}

#if 0
elem BS1_Parse_SubExpression(char **str)
{
	char *s, *b, *b2, *t;
	int ty, ty2;
	elem n, *n1, *n2;
	int i;

	s=*str;
	b=kralloc(1024);
	b2=kralloc(1024);

//	kprint("BS1_Parse_SubExpression: %p {\n", s);

#if 0
	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "#"))
	{
		s=BS1_Parse_Token(s, b, &ty); //'#'
		s=BS1_Parse_Token(s, b, &ty);	//name

		n=NULL;
		if(b[0]=='{')
		{
			n1=BS1_Parse_FunArgs(&s);

			n=NetParse_NewNode();
			n->key=kstrdup("matrix");
			n->first=n1;
		}else
		if(b[0]=='[')
		{
			n1=BS1_Parse_FunArgs(&s);

			n=NetParse_NewNode();
			n->key=kstrdup("vector");
			n->first=n1;
		}else
		if(b[0]==':')
		{
			s=BS1_Parse_Token(s, b, &ty);	//name
			n=NetParse_NewNode();
			n->key=kstrdup("keyword");
			NetParse_AddAttr(n, "name", b);
		}else
		if(ty==BS1_TOKEN_NAME)
		{
			n=NetParse_NewNode();
			n->key=kstrdup("symbol");
			NetParse_AddAttr(n, "name", b);
		}

		*str=s;
		return(n);
	}
#endif

/*
	s=BS1_Parse_Token(s, b, &ty);
	s=BS1_Parse_Token(s, b2, &ty2);
	if(!strcmp(b2, ".") || !strcmp(b2, "["))
	{
		n=BS1_Parse_DotRef(str);
		return(n);
	}
*/

	s=*str;

	s=BS1_Parse_Token(s, b, &ty);
	if(!s)return(NULL);

	if(!strcmp(b, "++") && (ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_Parse_Token(s, b2, &ty2);

		n=NetParse_NewNode();
		n->key=kstrdup("preinc");
		NetParse_AddAttr(n, "name", b2);

		*str=s;
		return(n);
	}
	if(!strcmp(b, "--") && (ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_Parse_Token(s, b2, &ty2);

		n=NetParse_NewNode();
		n->key=kstrdup("predec");
		NetParse_AddAttr(n, "name", b2);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "{") && (ty==BS1_TOKEN_BRACE))
	{
		n1=BS1_Parse_FunArgs(&s);

		n=NetParse_NewNode();
		n->key=kstrdup("array");
		n->first=n1;

		*str=s;
		return(n);
	}
	if(!strcmp(b, "[") && (ty==BS1_TOKEN_BRACE))
	{
		n1=BS1_Parse_FunArgs(&s);

		n=NetParse_NewNode();
		n->key=kstrdup("dict");
		n->first=n1;

		*str=s;
		return(n);
	}

	if(!strcmp(b, "-")  && (ty==BS1_TOKEN_OPERATOR))
	{
		BS1_Parse_Token(s, b2, &ty2);

		if((ty2==BS1_TOKEN_NUMBER) &&
			strncmp(b2, "0x", 2))
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);
			n=NetParse_NewNode();
			n->key=kstrdup("number");
			NetParse_AddAttr(n, "value", b);

			*str=s;
			return(n);
		}
	}

	if(ty==BS1_TOKEN_NAME)
	{
		n=BS1_Parse_ParseExpressionName(b, &s);
		if(n)
		{
			*str=s;
			return(n);
		}

		if(!strcmp(b, "lambda") || !strcmp(b, "fun"))
		{
			n=BS1_Parse_Lambda(&s);
			*str=s;
			return(n);
		}
		if(!strcmp(b, "let"))
		{
			n=BS1_Parse_Let(&s);
			*str=s;
			return(n);
		}

		if(!strcmp(b, "withcc"))
		{
			n=BS1_Parse_WithCC(&s);
			*str=s;
			return(n);
		}

		if(!strcmp(b, "object"))
		{
			n=BS1_Parse_Object(&s);
			*str=s;
			return(n);
		}
		if(!strcmp(b, "begin_object"))
		{
			n=BS1_Parse_BeginObject(&s);
			*str=s;
			return(n);
		}

		if(!strcmp(b, "quote_xml"))
		{
			n=BS1_Parse_XML(&s);
			*str=s;
			return(n);
		}

		if(!strcmp(b, "xml"))
		{
			n1=BS1_Parse_XML(&s);

			n=NetParse_NewNode();
			n->key=kstrdup("xml");
			n->first=n1;

			*str=s;
			return(n);
		}

		if(!strcmp(b, "quote"))
		{
			BS1_Parse_Token(s, b2, &ty2);

			if(!strcmp(b2, "("))
			{
				n1=BS1_Parse_Expression(&s);
			}else n1=BS1_Parse_BlockStatement2(&s);

			n=NetParse_NewNode();
			n->key=kstrdup("xml");
			n->first=n1;

			*str=s;
			return(n);
		}

		if(!strcmp(b, "clone"))
		{
			s=BS1_Parse_Token(s, b2, &ty2);

			n=NetParse_NewNode();
			n->key=kstrdup("clone");

			n1=BS1_Parse_Expression(&s);
			n->first=n1;

			*str=s;
			return(n);
		}
		if(!strcmp(b, "new"))
		{
			s=BS1_Parse_Token(s, b2, &ty2);

			n=NetParse_NewNode();
			n->key=kstrdup("new");

			n2=BS1_Parse_Expression(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("obj");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			s=BS1_Parse_Token(s, b2, &ty2);
			n2=BS1_Parse_FunArgs(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("args");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			*str=s;
			return(n);
		}
	}

	if(!strcmp(b, "(") && (ty==BS1_TOKEN_BRACE))
	{
		n=BS1_Parse_Expression(&s);
		if(!s)
		{
			str=s;
			return(NULL);
		}
		s=BS1_Parse_Token(s, b, &ty);

		i=0;
		t=NetParse_GetNodeAttr(n, "parens");
		if(t)i=katoi(t);
		NetParse_AddAttr(n, "parens", ksprint("%d", i+1));

//		kprint("BS1_Parse_SubExpression: %p }\n", s);
		*str=s;
		return(n);
	}

	BS1_Parse_Token(s, b2, &ty2);

	if(ty==BS1_TOKEN_NAME)
	{
		if(!strcmp(b2, "++") && (ty2==BS1_TOKEN_OPERATOR))
		{
			s=BS1_Parse_Token(s, b2, &ty2);

			n=NetParse_NewNode();
			n->key=kstrdup("postinc");
			NetParse_AddAttr(n, "name", b);

			*str=s;
			return(n);
		}
		if(!strcmp(b2, "--") && (ty2==BS1_TOKEN_OPERATOR))
		{
			s=BS1_Parse_Token(s, b2, &ty2);

			n=NetParse_NewNode();
			n->key=kstrdup("postdec");
			NetParse_AddAttr(n, "name", b);

			*str=s;
			return(n);
		}

		if(!strcmp(b2, ":=") && (ty2==BS1_TOKEN_OPERATOR))
		{
			s=BS1_Parse_Token(s, b2, &ty2);

			n=NetParse_NewNode();
			n->key=kstrdup("attr");
			NetParse_AddAttr(n, "name", b);

			n1=BS1_Parse_Expression(&s);
			n->first=n1;

			*str=s;
			return(n);
		}

		if(!strcmp(b2, "(") && (ty2==BS1_TOKEN_BRACE))
		{
			n=NetParse_NewNode();
			n->key=kstrdup("funcall");
			NetParse_AddAttr(n, "name", b);

			s=BS1_Parse_Token(s, b2, &ty2);
			n2=BS1_Parse_FunArgs(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("args");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

//			kprint("BS1_Parse_SubExpression: %p }\n", s);
			*str=s;
			return(n);
		}

#if 1
		//HACK: tighter binding '.'
		if(!strcmp(b2, "."))
		{
			n=NetParse_NewNode();
			n->key=kstrdup("ref");
			NetParse_AddAttr(n, "name", b);

			while(!strcmp(b2, "."))
			{
				s=BS1_Parse_Token(s, b2, &ty2); //.
				s=BS1_Parse_Token(s, b, &ty); //name

				n2=NetParse_NewNode();
				n2->key=kstrdup("obj");
				n2->first=n;

				n1=NetParse_NewNode();
				n1->key=kstrdup("objref");
				n1->first=n2;
				NetParse_AddAttr(n1, "name", b);
				n=n1;

#if 0
				BS1_Parse_Token(s, b2, &ty2);
				if(!strcmp(b2, "(") && (ty2==BS1_TOKEN_BRACE))
				{
					n->key=kstrdup("methodcall");

					s=BS1_Parse_Token(s, b2, &ty2);
					n2=BS1_Parse_FunArgs(&s);

					n1=NetParse_NewNode();
					n1->key=kstrdup("args");
					n1->first=n2;

					NetParse_AddChildNode(n, n1);
					break;
				}
#endif

				BS1_Parse_Token(s, b2, &ty2);
			}
			*str=s;
			return(n);
		}
#endif
	}

	if(ty==BS1_TOKEN_NAME)
	{
//		n1=NetParse_NewNode();
//		n1->text=kstrdup(b);

		n=NetParse_NewNode();
		n->key=kstrdup("ref");
//		n->first=n1;
		NetParse_AddAttr(n, "name", b);

//		kprint("BS1_Parse_SubExpression: %p }\n", s);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_NUMBER)
	{
//		n1=NetParse_NewNode();
//		n1->text=kstrdup(b);

		n=NetParse_NewNode();
		n->key=kstrdup("number");
//		n->first=n1;
		NetParse_AddAttr(n, "value", b);

//		kprint("BS1_Parse_SubExpression: %p }\n", s);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_STRING)
	{
		BS1_Parse_Token(s, b2, &ty2);
		while(ty2==BS1_TOKEN_STRING)
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);
			BS1_Parse_Token(s, b2, &ty2);
		}

//		n1=NetParse_NewNode();
//		n1->text=kstrdup(b);

		n=NetParse_NewNode();
		n->key=kstrdup("string");
//		n->first=n1;
		NetParse_AddAttr(n, "value", b);

//		kprint("BS1_Parse_SubExpression: %p }\n", s);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_CHARSTRING)
	{
		BS1_Parse_Token(s, b2, &ty2);
		while(ty2==BS1_TOKEN_CHARSTRING)
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);
			BS1_Parse_Token(s, b2, &ty2);
		}

//		n1=NetParse_NewNode();
//		n1->text=kstrdup(b);

		n=NetParse_NewNode();
		n->key=kstrdup("charstring");
//		n->first=n1;
		NetParse_AddAttr(n, "value", b);

//		kprint("BS1_Parse_SubExpression: %p }\n", s);
		*str=s;
		return(n);
	}

	BS1_MSG_Error(s, "PDSCR_Parse_SubExpression: "
		"Invalid Item '%s'\n", b);
	*(int *)(-1)=-1;

	*str=NULL;
	return(NULL);
}

elem BS1_Parse_Expression(char **str)
{
	char *s, *b, *b2, *t;
	int ty, ty2;
	elem n, *n1, *n2, *n3;

	s=*str;
	b=kralloc(1024);
	b2=kralloc(1024);

	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "#"))
	{
		s=BS1_Parse_Token(s, b, &ty); //'#'
		s=BS1_Parse_Token(s, b, &ty);	//name

		n=NULL;
		if(b[0]=='{')
		{
			n1=BS1_Parse_FunArgs(&s);

			n=NetParse_NewNode();
			n->key=kstrdup("matrix");
			n->first=n1;
		}else
		if(b[0]=='[')
		{
			n1=BS1_Parse_FunArgs(&s);

			n=NetParse_NewNode();
			n->key=kstrdup("vector");
			n->first=n1;
		}else
		if(b[0]==':')
		{
			s=BS1_Parse_Token(s, b, &ty);	//name
			n=NetParse_NewNode();
			n->key=kstrdup("keyword");
			NetParse_AddAttr(n, "name", b);
		}else
		if(ty==BS1_TOKEN_NAME)
		{
			n=NetParse_NewNode();
			n->key=kstrdup("symbol");
			NetParse_AddAttr(n, "name", b);
		}

		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_OPERATOR)
	{
		s=BS1_Parse_Token(s, b, &ty);
		BS1_Parse_Token(s, b2, &ty2);

		if(!strcmp(b, "-") &&
			(ty2==BS1_TOKEN_NUMBER) &&
			strncmp(b2, "0x", 2))
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);
			n=NetParse_NewNode();
			n->key=kstrdup("number");
			NetParse_AddAttr(n, "value", b);

			*str=s;
			return(n);
		}

		n1=BS1_Parse_SubExpression(&s);
		if(!s)
		{
			*str=s;
			return(n);
		}

		n=NetParse_NewNode();
		n->key=kstrdup("unary");
		n->first=n1;

		NetParse_AddAttr(n, "op", b);

		*str=s;
		return(n);
	}

	n1=BS1_Parse_SubExpression(&s);
	if(!s)
	{
		*str=s;
		return(n);
	}

//	BS1_Parse_Token(s, b, &ty);

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);
		if(!strcmp(b, "(") && (ty==BS1_TOKEN_BRACE))
		{
			t=NetParse_GetNodeAttr(n1, "parens");
			if(!strcmp(n1->key, "objref") && !t)
			{
				n=n1;
				n->key=kstrdup("methodcall");

				s=BS1_Parse_Token(s, b, &ty);
				n2=BS1_Parse_FunArgs(&s);

				n1=NetParse_NewNode();
				n1->key=kstrdup("args");
				n1->first=n2;

				NetParse_AddChildNode(n, n1);

				n1=n;
				continue;
			}

			n2=n1;

			n=NetParse_NewNode();
			n->key=kstrdup("funapply");

			n1=NetParse_NewNode();
			n1->key=kstrdup("func");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			s=BS1_Parse_Token(s, b, &ty); //'('
			n2=BS1_Parse_FunArgs(&s);
			if(!s)
			{
				*str=s;
				return(n);
			}

			n1=NetParse_NewNode();
			n1->key=kstrdup("args");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			n1=n;
			continue;
		}

		if(!strcmp(b, "["))
		{
			n=n1;

			n2=NetParse_NewNode();
			n2->key=kstrdup("obj");
			n2->first=n;

			n1=NetParse_NewNode();
			n1->key=kstrdup("indexref");
			n1->first=n2;
			n=n1;

			s=BS1_Parse_Token(s, b, &ty); //[
			n2=BS1_Parse_Expression(&s);
			s=BS1_Parse_Token(s, b, &ty);

			n1=NetParse_NewNode();
			n1->key=kstrdup("index");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			n1=n;
			continue;
		}

		if(!strcmp(b, "."))
		{
			s=BS1_Parse_Token(s, b, &ty); //.
			s=BS1_Parse_Token(s, b, &ty); //name

			n=n1;

			n2=NetParse_NewNode();
			n2->key=kstrdup("obj");
			n2->first=n;

			n1=NetParse_NewNode();
			n1->key=kstrdup("objref");
			n1->first=n2;
			NetParse_AddAttr(n1, "name", b);

#if 0
			BS1_Parse_Token(s, b2, &ty2);
			if(!strcmp(b2, "(") && (ty2==BS1_TOKEN_BRACE))
			{
				n=n1;

				n->key=kstrdup("methodcall");

				s=BS1_Parse_Token(s, b2, &ty2);
				n2=BS1_Parse_FunArgs(&s);

				n1=NetParse_NewNode();
				n1->key=kstrdup("args");
				n1->first=n2;

				NetParse_AddChildNode(n, n1);

				n1=n;
			}
#endif
			continue;
		}

		if(ty!=BS1_TOKEN_OPERATOR)
			break;

		if(!strcmp(b, "="))
		{
			s=BS1_Parse_Token(s, b, &ty);

			t=NetParse_GetNodeAttr(n1, "parens");
			if(!strcmp(n1->key, "ref") && !t)
			{
				n1->key=kstrdup("assign");
				n2=BS1_Parse_Expression(&s);
				n1->first=n2;
				continue;
			}

			if(!strcmp(n1->key, "objref") ||
				!strcmp(n1->key, "indexref"))
			{
				if(!strcmp(n1->key, "objref"))
					n1->key=kstrdup("slotassign");
				if(!strcmp(n1->key, "indexref"))
					n1->key=kstrdup("indexassign");

//				s=BS1_Parse_Token(s, b2, &ty2);
				n3=BS1_Parse_Expression(&s);

				n2=NetParse_NewNode();
				n2->key=kstrdup("value");
				n2->first=n3;

				NetParse_AddChildNode(n1, n2);

				continue;
			}

			n=NetParse_NewNode();
			n->key=kstrdup("assignexpr");
//			NetParse_AddAttr(n, "op", b);

			n2=n1;
			n1=NetParse_NewNode();
			n1->key=kstrdup("left");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			n2=BS1_Parse_SubExpression(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("right");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			n1=n;
			continue;
		}

		if(!strcmp(b, "?"))
		{
			s=BS1_Parse_Token(s, b, &ty); //?

			n=NetParse_NewNode();
			n->key=kstrdup("if");

			n2=n1;
			n1=NetParse_NewNode();
			n1->key=kstrdup("cond");
			n1->first=n2;
			NetParse_AddChildNode(n, n1);

			n2=BS1_Parse_Expression(&s);
			n1=NetParse_NewNode();
			n1->key=kstrdup("then");
			n1->first=n2;
			NetParse_AddChildNode(n, n1);

			s=BS1_Parse_Token(s, b, &ty); //:

			n2=BS1_Parse_Expression(&s);
			n1=NetParse_NewNode();
			n1->key=kstrdup("else");
			n1->first=n2;
			NetParse_AddChildNode(n, n1);

			n1=n;
			continue;

#if 0
			BS1_Parse_Token(s, b, &ty);
			if((ty==BS1_TOKEN_OPERATOR) || !strcmp(b, "("))
			{
				n1=n;
				continue;
			}

			*str=s;
			return(n);
#endif
		}

#if 0
		if(!strcmp(b2, "["))
		{
			s=BS1_Parse_Token(s, b, &ty); //[

			n2=NetParse_NewNode();
			n2->key=kstrdup("obj");
			n2->first=n1;

			n1=NetParse_NewNode();
			n1->key=kstrdup("indexref");
			n1->first=n2;
			n=n1;

			n2=BS1_Parse_Expression(&s);
			s=BS1_Parse_Token(s, b2, &ty2); //]

			n1=NetParse_NewNode();
			n1->key=kstrdup("index");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);

			BS1_Parse_Token(s, b, &ty);
			if(ty==BS1_TOKEN_OPERATOR)
			{
				n1=n;
				continue;
			}

			*str=s;
			return(n);
		}
#endif

		s=BS1_Parse_Token(s, b, &ty);

		n=NetParse_NewNode();
		n->key=kstrdup("binary");
		NetParse_AddAttr(n, "op", b);

		n2=n1;
		n1=NetParse_NewNode();
		n1->key=kstrdup("left");
		n1->first=n2;

		NetParse_AddChildNode(n, n1);

		n2=BS1_Parse_SubExpression(&s);

		n1=NetParse_NewNode();
		n1->key=kstrdup("right");
		n1->first=n2;

		NetParse_AddChildNode(n, n1);

		n1=n;
		continue;
#if 0
		BS1_Parse_Token(s, b, &ty);
		if((ty==BS1_TOKEN_OPERATOR) || !strcmp(b, "("))
		{
			n1=n;
			continue;
		}

		*str=s;
		return(n);
#endif
	}

	n=n1;

	*str=s;
	return(n);
}
#endif

elem BS1_Parse_Lambda(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2, *lst;

	s=*str;
	b=kralloc(1024);
	lst=NULL;

	n=NetParse_NewNode();
	n->key=kstrdup("lambda");

	s=BS1_Parse_Token(s, b, &ty);
	if(ty==BS1_TOKEN_NAME)
	{
		NetParse_AddAttr(n, "name", b);
		s=BS1_Parse_Token(s, b, &ty);
	}

	if(*b!='(')
	{
		BS1_MSG_Error(s, "PDSCR_Parse_Lambda: Expected '(' got '%s'\n", b);
		*str=NULL;
		return(n);
	}

	n2=BS1_Parse_VarsList(&s);

	n1=NetParse_NewNode();
	n1->key=kstrdup("args");
	n1->first=n2;
	NetParse_AddChildNode(n, n1);

/*	s=BS1_Parse_Token(s, b, &ty);
	if(*b!='{')
	{
		BS1_MSG_Error(s, "PDSCR_Parse_Lambda: Expected '{' got '%s'\n", b);
		*str=NULL;
		return(n);
	} */

	bs1_parse_curfilename=NULL;

//	n2=BS1_Parse_Block(&s);
	n2=BS1_Parse_BlockStatement2(&s);


	n1=NetParse_NewNode();
	n1->key=kstrdup("body");
	n1->first=n2;
	NetParse_AddChildNode(n, n1);

	*str=s;
	return(n);
}

elem BS1_Parse_WithCC(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2, *lst;

	s=*str;
	b=kralloc(1024);
	lst=NULL;

	n=NetParse_NewNode();
	n->key=kstrdup("withcc");

	s=BS1_Parse_Token(s, b, &ty); //(
	if(*b!='(')
	{
		BS1_MSG_Error(s, "PDSCR_Parse_WithCC: Expected '(' got '%s'\n", b);
		*str=NULL;
		return(n);
	}
	s=BS1_Parse_Token(s, b, &ty); //name
	NetParse_AddAttr(n, "name", b);
	s=BS1_Parse_Token(s, b, &ty); //)

	n1=BS1_Parse_BlockStatement2(&s);
	NetParse_AddChildNode(n, n1);

	*str=s;
	return(n);
}

elem BS1_Parse_Object(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2, *lst;

	s=*str;
	b=kralloc(1024);
	lst=NULL;

	n=NetParse_NewNode();
	n->key=kstrdup("object");

//	s=BS1_Parse_Token(s, b, &ty); //name
//	NetParse_AddAttr(n, "name", b);

	while(1)
	{
		BS1_Parse_Token(s, b, &ty); //name
		if(!strcmp(b, "clones"))
		{
			s=BS1_Parse_Token(s, b, &ty); //clones
			n2=BS1_Parse_Expression(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("clones");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);
			continue;
		}

		if(!strcmp(b, "extends"))
		{
			s=BS1_Parse_Token(s, b, &ty); //clones
			n2=BS1_Parse_Expression(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("extends");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);
			continue;
		}

		if(!strcmp(b, "toplevel"))
		{
			s=BS1_Parse_Token(s, b, &ty); //clones
			n2=BS1_Parse_Expression(&s);

			n1=NetParse_NewNode();
			n1->key=kstrdup("toplevel");
			n1->first=n2;

			NetParse_AddChildNode(n, n1);
			continue;
		}
		break;
	}

	n2=BS1_Parse_BlockStatement2(&s);
	n1=NetParse_NewNode();
	n1->key=kstrdup("body");
	n1->first=n2;
	NetParse_AddChildNode(n, n1);

	*str=s;
	return(n);
}

elem BS1_Parse_ObjectStmt(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2, *lst;

	s=*str;
	b=kralloc(1024);
	lst=NULL;

	s=BS1_Parse_Token(s, b, &ty); //name
	b2=kstrdup(b);

	n=BS1_Parse_Object(&s);
	NetParse_AddAttr(n, "name", b2);

	*str=s;
	return(n);
}

elem BS1_Parse_BeginObject(char **str)
{
	char *s, *b, *b2;
	int ty, ty2;
	elem n, *n1, *n2, *lst;

	s=*str;
	b=kralloc(1024);
	lst=NULL;

	n=NetParse_NewNode();
	n->key=kstrdup("begin_object");

	n2=BS1_Parse_Expression(&s);

	n1=NetParse_NewNode();
	n1->key=kstrdup("obj");
	n1->first=n2;

	NetParse_AddChildNode(n, n1);

	n2=BS1_Parse_BlockStatement2(&s);
	n1=NetParse_NewNode();
	n1->key=kstrdup("body");
	n1->first=n2;
	NetParse_AddChildNode(n, n1);

	*str=s;
	return(n);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

//Lit:		Literal values/builtin expressions
//PE:		(<expr>) <expr>[<expr>] <expr>.<name>
//IncDec:	++<name> --<name> + - ! ~ ... <name>++ <name>-- <expr>(<args>)       
//E:		<expr>**<expr>
//MD:		* / % \ &	*. /. %. \. &.
//AS:		+ - | ^		+. -. |. ^.
//SHLR:		<< >>
//RCmp:		< > <= >= == === != <=> <<== >>==
//Lop:		&&
//Lop2:		|| ^^
//TCond:	<expr>?<expr>:<expr>
//Attr:		:= :!= :< :> :<= :>= :<< :>> :<<= :>>=
//Equals:	= += -= *= /= \= %= &= |= ^= >>= <<=

elem BS1_Parse_Expression(char **str);

BS1_ParseItem *bs1_parse_exprs=NULL;

int BS1_Parse_AddExpression(char *name, elem (*func)(char **s))
{
	BS1_ParseItem *tmp;

	tmp=malloc(sizeof(BS1_ParseItem));
	tmp->name=strdup(name);
	tmp->func=func;

	tmp->next=bs1_parse_exprs;
	bs1_parse_exprs=tmp;

	return(0);
}

elem BS1_Parse_ParseExpressionName(char *name, char **s)
{
	BS1_ParseItem *cur;

	cur=bs1_parse_exprs;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}
	return(BS1_MM_NULL);
}

elem BS1_Parse_Number(char *str)
{
	long long l;
	char *s, *t;
	elem n;
	int i, sg;

	t=str;
	if((t[0]=='0') && (t[1]=='x'))
	{
		l=0; t+=2;
		while(*t)
		{
			l*=16;
			if((*t>='0') && (*t<='9'))l+=*t-'0';
			if((*t>='A') && (*t<='F'))l+=*t-'A'+10;
			if((*t>='a') && (*t<='f'))l+=*t-'a'+10;
			t++;
		}

		return(BS1_INT(l));
	}

	if(t[0]=='0')
	{
		l=0; t++;
		while(*t)
		{
			l*=8;
			if((*t>='0') && (*t<='7'))l+=*t-'0';
				else break;
			t++;
		}

		return(BS1_INT(l));
	}

	i=0; t=str;
	while(*t) { if(*t=='.')i++; if(*t=='e')i++; t++; }
	if(i)
	{
		n=FLONUM(atof(str));
		return(n);
	}

	t=str; l=0; sg=0;
	if(*t=='-') { sg=1; t++; }
	while(*t)
	{
		l*=10;
		if((*t>='0') && (*t<='9'))l+=*t-'0';
			else break;
		t++;
	}
	if(sg)l=-l;

	return(BS1_INT(l));
}

elem BS1_Parse_ExpressionLit(char **str)
{
	char b[256], b2[256];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2;
	int i;

	s=*str;

	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "$"))
	{
		s=BS1_Parse_Token(s, b, &ty); //'$'

		if(ty==BS1_TOKEN_NAME)
		{
			n1=BS1_Parse_Expression(&s);
			n=LIST2S("unquote", n1);
		}

		*str=s;
		return(n);
	}

	if(!strcmp(b, "#"))
	{
		s=BS1_Parse_Token(s, b, &ty); //'#'
		s=BS1_Parse_Token(s, b, &ty);	//name
		BS1_Parse_Token(s, b2, &ty2);	//name

		n=BS1_MM_NULL;
		if(!strcmp(b, "{"))
		{
			n1=BS1_Parse_FunArgs(&s);
			n=CONSS("array", n1);
		}else
		if(!strcmp(b, "["))
		{
			if(!strcmp(b2, "["))
			{
//				n1=BS1_Parse_FunArgs(&s);
				n1=BS1_Parse_IListArgs(&s);
				n=CONSS("matrix", n1);
			}else
			{
				n1=BS1_Parse_FunArgs(&s);
				n=CONSS("vector", n1);
			}
		}else
		if(!strcmp(b, "("))
		{
			n1=BS1_Parse_FunArgs(&s);
			n=CONSS("list", n1);
		}else
		if(!strcmp(b, ":"))
		{
			s=BS1_Parse_Token(s, b, &ty);	//name
			n=KEYSYM(b);
		}else
		if(ty==BS1_TOKEN_NAME)
		{
			n=LIST2S("quote", SYM(b));
		}else
		if(ty==BS1_TOKEN_OPERATOR)
		{
			n=LIST2S("quote", SYM(b));
		}else
		if(ty==BS1_TOKEN_CHARSTRING)
		{
			n=SYM(b);
		}else
		if(ty==BS1_TOKEN_STRING)
		{
			n=LIST2S("quote", SYM(b));
		}

		*str=s;
		return(n);
	}

	s=*str;

	s=BS1_Parse_Token(s, b, &ty);
	if(!s)return(BS1_MM_NULL);

	if(!strcmp(b, "{") && (ty==BS1_TOKEN_BRACE))
	{
		n1=BS1_Parse_FunArgs(&s);
		n=CONSS("list", n1);
		*str=s;
		return(n);
	}

	if(!strcmp(b, "[") && (ty==BS1_TOKEN_BRACE))
	{
		n1=BS1_Parse_FunArgs2(&s);
		n=CONSS("dict", n1);
		*str=s;
		return(n);
	}

#if 0
	if(!strcmp(b, "-")  && (ty==BS1_TOKEN_OPERATOR))
	{
		BS1_Parse_Token(s, b2, &ty2);

		if((ty2==BS1_TOKEN_NUMBER) && (b2[0]=='0') && (b2[1]=='x'))
		{
			s=BS1_Parse_Token(s, b2, &ty2);

			i=0; t=b2+2;
			while(*t)
			{
				i*=16;
				if((*t>='0') && (*t<='9'))i+=*t-'0';
				if((*t>='A') && (*t<='F'))i+=*t-'A'+10;
				if((*t>='a') && (*t<='f'))i+=*t-'a'+10;
				t++;
			}

			*str=s;
			return(FIXNUM(i));
		}

		if((ty2==BS1_TOKEN_NUMBER) &&
			strncmp(b2, "0x", 2))
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);

			i=0; t=b;
			while(*t)
			{
				if(*t=='.')i++;
				if(*t=='e')i++;
				t++;
			}

			if(i)n=FLONUM(atof(b));
				else n=FIXNUM(atoi(b));

			BS1_Parse_Token(s, b2, &ty2);
			if(!strcmp(b2, "i") && (ty2==BS1_TOKEN_NAME))
			{
				s=BS1_Parse_Token(s, b2, &ty2);
				if(!strcmp(b2, "i"))
					n=COMPLEX_I(atof(b));
			}

			*str=s;
			return(n);
		}
	}
#endif

	if(ty==BS1_TOKEN_NAME)
	{
		n=BS1_Parse_ParseExpressionName(b, &s);
		if(n)
		{
			*str=s;
			return(n);
		}

		if(!strcmp(b, "lambda") || !strcmp(b, "fun"))
		{
			s=BS1_Parse_Token(s, b, &ty); //'('

			if(ty==BS1_TOKEN_NAME)
			{
				s=BS1_Parse_Token(s, b2, &ty2); //'('

				n1=BS1_Parse_FunVarsList(&s);
				n2=BS1_Parse_BlockStatement2(&s);
				n=LIST4S("rlambda", SYM(b), n1, n2);
				*str=s;
				return(n);
			}

			n1=BS1_Parse_FunVarsList(&s);
			n2=BS1_Parse_BlockStatement2(&s);
			n=LIST3S("lambda", n1, n2);
			*str=s;
			return(n);
		}

		if(!strcmp(b, "with"))
		{
			n1=BS1_Parse_Expression(&s);
			n2=BS1_Parse_BlockStatement2(&s);
			n=LIST3S("with", n1, n2);
			*str=s;
			return(n);
		}

		if(!strcmp(b, "quote"))
		{
			BS1_Parse_Token(s, b2, &ty2);

			if(!strcmp(b2, "("))
			{
				s=BS1_Parse_Token(s, b2, &ty2);
				n1=BS1_Parse_FunArgs(&s);
				n1=CONS(SYM("begin"), n1);
			}else n1=BS1_Parse_BlockStatement2(&s);

			n=LIST2(SYM("quote"), n1);

			*str=s;
			return(n);
		}

#if 0
		if((*s==':') && s[1] && (s[1]<=' '))
		{
			s=BS1_Parse_Token(s, b2, &ty2); //':'

			n=KEYSYM(b);
			*str=s;
			return(n);
		}
#endif

		n=SYM(b);
		*str=s;
		return(n);
	}

	BS1_Parse_Token(s, b2, &ty2);

	if(ty==BS1_TOKEN_NUMBER)
	{
		if((b[0]=='0') && (b[1]=='x'))
		{
			i=0; t=b+2;
			while(*t)
			{
				i*=16;
				if((*t>='0') && (*t<='9'))i+=*t-'0';
				if((*t>='A') && (*t<='F'))i+=*t-'A'+10;
				if((*t>='a') && (*t<='f'))i+=*t-'a'+10;
				t++;
			}

			*str=s;
			return(FIXNUM(i));
		}

//		i=0; t=b;
//		while(*t) { if(*t=='.')i++; if(*t=='e')i++; t++; }
//		if(i)n=FLONUM(atof(b)); else n=BS1_INT(atoi(b));

		BS1_Parse_Token(s, b2, &ty2);
		if(!strcmp(b2, "i") && (ty2==BS1_TOKEN_NAME))
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			if(!strcmp(b2, "i"))n=COMPLEX_I(atof(b));

			*str=s;
			return(n);

		}

		n=BS1_Parse_Number(b);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_STRING)
	{
#if 0
		BS1_Parse_Token(s, b2, &ty2);
		while(ty2==BS1_TOKEN_STRING)
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);
			BS1_Parse_Token(s, b2, &ty2);
		}
#endif

		n=STRING(b);
		*str=s;
		return(n);
	}

	if(ty==BS1_TOKEN_CHARSTRING)
	{
		BS1_Parse_Token(s, b2, &ty2);
		while(ty2==BS1_TOKEN_CHARSTRING)
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			strcat(b, b2);
			BS1_Parse_Token(s, b2, &ty2);
		}

//		n=NetParse_NewNode();
//		n->key=kstrdup("charstring");
//		NetParse_AddAttr(n, "value", b);

		*str=s;
		return(n);
	}

	BS1_MSG_Error(s, "PDSCR_Parse_ExpressionLit: "
		"Invalid Item '%s'\n", b);
	*(int *)(-1)=-1;

	*str=NULL;
	return(BS1_MM_NULL);
}

elem BS1_Parse_ExpressionPE(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;
	int i;

	s=*str;
	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "(") && (ty==BS1_TOKEN_BRACE))
	{
		s=BS1_Parse_Token(s, b, &ty);	//(
//		n=BS1_Parse_Expression(&s);
//		s=BS1_Parse_Token(s, b, &ty);

		n=BS1_Parse_FunArgs(&s);
		n=CONS(SYM("begin"), n);

		*str=s;
		return(n);
	}

	n=BS1_Parse_ExpressionLit(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		if(!BS1_Parse_IsWhiteOnly(s))break;
		BS1_Parse_Token(s, b, &ty);

		if(!strcmp(b, "["))
		{
			s=BS1_Parse_Token(s, b, &ty); //[
			n1=BS1_Parse_Expression(&s);
			s=BS1_Parse_Token(s, b, &ty); //]
			n=LIST3S("getindex", n, n1);
			continue;
		}

		if(!strcmp(b, "."))
		{
			s=BS1_Parse_Token(s, b, &ty); //.
			s=BS1_Parse_Token(s, b, &ty); //name
			n=LIST3S("objref", n, SYM(b));
			continue;
		}

		break;
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionCast(char **str)
{
	elem n, n1;

	n1=BS1_Parse_DefType(str);
	n=BS1_Parse_ExpressionPE(str);

	if(n1!=BS1_MM_NULL)
		n=LIST2(n1, n);
	return(n);
}

elem BS1_Parse_ExpressionIncDec(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "++") && (ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionIncDec(&s);
		n=LIST2S("preinc!", n1);
		*str=s;
		return(n);
	}
	if(!strcmp(b, "--") && (ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionIncDec(&s);
		n=LIST2S("predec!", n1);
		*str=s;
		return(n);
	}

	if((!strcmp(b, "+") || !strcmp(b, "-") || !strcmp(b, "!") ||
		!strcmp(b, "~") || !strcmp(b, "|") || !strcmp(b, "/") ||
		!strcmp(b, "\\") || !strcmp(b, "%") || !strcmp(b, "^") ||
		!strcmp(b, "&") || !strcmp(b, "*") || !strcmp(b, "&&") ||
		!strcmp(b, "||") || !strcmp(b, "^^")) &&
			(ty==BS1_TOKEN_OPERATOR))
	{
		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionIncDec(&s);
		n=LIST3S("unary", SYM(b), n1);
		*str=s;
		return(n);
	}

	s=*str;
//	n=BS1_Parse_ExpressionPE(&s);
	n=BS1_Parse_ExpressionCast(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);
		if(!strcmp(b, "(") && (ty==BS1_TOKEN_BRACE))
		{
			if(FORM_IS(n, "objref"))
			{
				s=BS1_Parse_Token(s, b, &ty); //'('
				n1=BS1_Parse_FunArgs(&s);
				n=CONS3(SYM("methodcall"),
					CADR(n), CADDR(n), n1);
				continue;
			}

			s=BS1_Parse_Token(s, b, &ty); //'('
			n1=BS1_Parse_FunArgs(&s);
			if(!s)
			{
				*str=s;
				return(n);
			}

			n=CONS2(SYM("funcall"), n, n1);
			continue;
		}

		if(!strcmp(b, "++"))
		{
			s=BS1_Parse_Token(s, b, &ty);
			n=LIST2S("postinc!", n);
			continue;
		}
		if(!strcmp(b, "--"))
		{
			s=BS1_Parse_Token(s, b, &ty);
			n=LIST2S("postdec!", n);
			continue;
		}

#if 0
		if(!strcmp(b, "i"))
		{
			s=BS1_Parse_Token(s, b, &ty);
			n=LIST2S("complex", n);
			continue;
		}
#endif

		break;
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionE(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionIncDec(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_Parse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;
		if(strcmp(b, "**") && strcmp(b, "<<") && strcmp(b, ">>"))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionIncDec(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionMD(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionE(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_Parse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;

		if(strcmp(b, "*") && strcmp(b, "/") && strcmp(b, "%") &&
			strcmp(b, "\\") && strcmp(b, "&") &&
			strcmp(b, "*.") && strcmp(b, "/.") &&
			strcmp(b, "%.") && strcmp(b, "\\.") &&
			strcmp(b, "&."))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionE(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionAS(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionMD(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_Parse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;

		if(strcmp(b, "+") && strcmp(b, "-") &&
			strcmp(b, "|") && strcmp(b, "^") &&
			strcmp(b, "+.") && strcmp(b, "-.") &&
			strcmp(b, "|.") && strcmp(b, "^."))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionMD(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

#if 0
elem BS1_Parse_ExpressionSHLR(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionAS(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		t=BS1_Parse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if((s!=t) && (*s<=' ') && !(*t<=' '))
			break;
		if(strcmp(b, "<<") && strcmp(b, ">>"))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionAS(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}
#endif

elem BS1_Parse_ExpressionRCmp(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionAS(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, "<") && strcmp(b, ">") &&
			strcmp(b, "<=") && strcmp(b, ">=") &&
			strcmp(b, "==") && strcmp(b, "!=") &&
			strcmp(b, "<=>") && strcmp(b, "<<==") &&
			strcmp(b, ">>==") && strcmp(b, "===") &&
			strcmp(b, "!=="))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionAS(&s);
		n=LIST4S("binary", SYM(b), n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionLop(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionRCmp(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, "&&"))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionRCmp(&s);
//		n=LIST4S("binary", SYM(b), n, n1);

		if(FORM_IS(n, "and"))
		{
			n=BS1_TY_NAppend(n, LIST1(n1));
			continue;
		}

		n=LIST3S("and", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionLop2(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionLop(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, "||"))
			break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionLop(&s);
//		n=LIST4S("binary", SYM(b), n, n1);

		if(FORM_IS(n, "or"))
		{
			n=BS1_TY_NAppend(n, LIST1(n1));
			continue;
		}

		n=LIST3S("or", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionTCond(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n1=BS1_Parse_ExpressionLop2(&s);
	BS1_Parse_Token(s, b, &ty);
	if(strcmp(b, "?"))
	{
		*str=s;
		return(n1);
	}

	s=BS1_Parse_Token(s, b, &ty); //?
	n2=BS1_Parse_ExpressionLop2(&s);
	s=BS1_Parse_Token(s, b, &ty); //:
	n3=BS1_Parse_ExpressionTCond(&s);
	n=LIST4S("if", n1, n2, n3);

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionFunc(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, c, n1, n2, n3;
	int i;

	s=*str;
	n=BS1_Parse_ExpressionTCond(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	BS1_Parse_Token(s, b, &ty);
	if((ty==BS1_TOKEN_OPERATOR) || (ty==BS1_TOKEN_SEPERATOR))
		{ *str=s; return(n); }

	if((ty==BS1_TOKEN_BRACE) &&
		(!strcmp(b, ")") || !strcmp(b, "]") || !strcmp(b, "}")))
		{ *str=s; return(n); }

	if(!BS1_Parse_IsWhiteOnly(s) && !BS1_Parse_IsNextIndented(s))
		{ *str=s; return(n); }

	t=s;
//	printf("tf0 '%s'\n", b);

	if(FORM_IS(n, "funcall"))
	{
		c=CDDR(n);
		while(BS1_CONSP(c))
		{
			n1=CAR(c);
			if(!BS1_SYMBOLP(n1) &&
				!FORM_IS(n1, "cast"))
					break;
			if(FORM_IS(n1, "cast") && !BS1_SYMBOLP(CADR(n1)))
				break;
			c=CDR(c);
		}

		if(c!=BS1_MM_NULL) { *str=s; return(n); }

		n1=BS1_Parse_BlockStatement2(&t);
		if(n1!=BS1_MM_NULL)
		{
			n=LIST3S("define", CDR(n), n1);
			s=t;
		}

		*str=s;
		return(n);
	}

#if 0
	if(FORM_IS(n, "begin"))
	{
//		printf("tf1\n");

		n1=BS1_Parse_BlockStatement2(&t);
		if(n1!=BS1_MM_NULL)
		{
			n=LIST3S("lambda", CDR(n), n1);
			s=t;
		}

		*str=s;
		return(n);
	}
#endif

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionAttr(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
//	n=BS1_Parse_ExpressionTCond(&s);
	n=BS1_Parse_ExpressionFunc(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;
		if(strcmp(b, ":=") && strcmp(b, ":!=") && strcmp(b, ":<") &&
			strcmp(b, ":>") && strcmp(b, ":<=")  &&
			strcmp(b, ":>=") && strcmp(b, ":<<") && 
			strcmp(b, ":>>") && strcmp(b, ":<<=") &&
			strcmp(b, ":>>="))
			break;

		t=NULL;
		if(!strcmp(b, ":!="))t="!=";
		if(!strcmp(b, ":<"))t="<";
		if(!strcmp(b, ":>"))t=">";
		if(!strcmp(b, ":<="))t="<=";
		if(!strcmp(b, ":>="))t=">=";
		if(!strcmp(b, ":<<"))t="<<";
		if(!strcmp(b, ":>>"))t=">>";
		if(!strcmp(b, ":<<="))t="<<==";
		if(!strcmp(b, ":>>="))t=">>==";

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionAttr(&s);
		if(t)n=LIST4S("relattr", SYM(t), n, n1);
			else n=LIST3S("attr", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionEquals(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionAttr(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);

		if(ty!=BS1_TOKEN_OPERATOR)
			break;

		if(strcmp(b, "=") && strcmp(b, "+=") && strcmp(b, "-=") &&
		strcmp(b, "*=") && strcmp(b, "/=")  && strcmp(b, "%=")  &&
		strcmp(b, "\\=")  && strcmp(b, "&=") && strcmp(b, "|=") &&
		strcmp(b, "^=") && strcmp(b, "<<=") && strcmp(b, ">>="))
			break;

		t=NULL;
		if(!strcmp(b, "+="))t="+";
		if(!strcmp(b, "-="))t="-";
		if(!strcmp(b, "*="))t="*";
		if(!strcmp(b, "/="))t="/";
		if(!strcmp(b, "%="))t="%";
		if(!strcmp(b, "\\="))t="\\";
		if(!strcmp(b, "&="))t="&";
		if(!strcmp(b, "|="))t="|";
		if(!strcmp(b, "^="))t="^";
		if(!strcmp(b, "<<="))t="<<";
		if(!strcmp(b, ">>="))t=">>";

		s=BS1_Parse_Token(s, b, &ty);

		if(BS1_SYMBOLP(n))
		{
			n1=BS1_Parse_ExpressionEquals(&s);
			if(t)n=LIST3S("set!", n,
					LIST4S("binary", SYM(t), n, n1));
				else n=LIST3S("set!", n, n1);
			continue;
		}

		if(FORM_IS(n, "objref") || FORM_IS(n, "getindex"))
		{
			if(FORM_IS(n, "objref"))
			{
				n1=BS1_Parse_ExpressionEquals(&s);
				if(t)n1=LIST4S("binary", SYM(t), n, n1);
				n=LIST4S("objset!", CADR(n), CADDR(n), n1);
				continue;
			}
			if(FORM_IS(n, "getindex"))
			{
				n1=BS1_Parse_ExpressionEquals(&s);
				if(t)n1=LIST4S("binary", SYM(t), n, n1);
				n=LIST4S("setindex!", CADR(n), CADDR(n), n1);
				continue;
			}
		}

		if(FORM_IS(n, "begin"))
		{
			n1=BS1_Parse_ExpressionEquals(&s);
			n=LIST3S("setmulti!", CDR(n), n1);
			continue;
		}

		n1=BS1_Parse_ExpressionEquals(&s);
		if(t)n1=LIST3S(t, n, n1);
		n=LIST3S("setexpr!", n, n1);
		continue;
	}

	*str=s;
	return(n);
}

elem BS1_Parse_ExpressionComma(char **str)
{
	char b[64], b2[64];
	char *s, *t;
	int ty, ty2;
	elem n, n1, n2, n3;

	s=*str;
	n=BS1_Parse_ExpressionEquals(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	while(1)
	{
		BS1_Parse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_SEPERATOR)break;
		if(strcmp(b, ","))break;

		s=BS1_Parse_Token(s, b, &ty);
		n1=BS1_Parse_ExpressionE(&s);
		n=LIST3S("comma", n, n1);
	}

	*str=s;
	return(n);
}

elem BS1_Parse_Expression(char **str)
{
	return(BS1_Parse_ExpressionEquals(str));
}

elem BS1_Parse_Expression2(char **str)
{
	return(BS1_Parse_ExpressionComma(str));
}

elem BS1_Parse_Expression3(char **str)
{
	char b[64], b2[64];
	int ty, ty2;
	char *s;
	elem n;

	s=*str;
	n=BS1_Parse_ExpressionEquals(&s);
	if(n==BS1_MM_NULL) { *str=NULL; return(n); }

	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, ":"))
	{
		s=BS1_Parse_Token(s, b, &ty);
		if(BS1_SYMBOLP(n))n=KEYSYM(TOSYM(n));
			else n=LIST2S("colon", n);
	}

	*str=s;
	return(n);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

BS1_ParseItem *bs1_parse_stmts=NULL;
BS1_ParseItem *bs1_parse_blkstmts=NULL;

char *bs1_parse_curfilename=NULL;

int BS1_Parse_AddStatement(char *name, elem (*func)(char **s))
{
	BS1_ParseItem *tmp;

	tmp=malloc(sizeof(BS1_ParseItem));
	tmp->name=strdup(name);
	tmp->func=func;

	tmp->next=bs1_parse_stmts;
	bs1_parse_stmts=tmp;

	return(0);
}

elem BS1_Parse_ParseStatementName(char *name, char **s)
{
	BS1_ParseItem *cur;

	cur=bs1_parse_stmts;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}
	return(BS1_MM_NULL);
}

int BS1_Parse_AddBlockStatement(char *name,
	elem (*func)(char **s))
{
	BS1_ParseItem *tmp;

	tmp=malloc(sizeof(BS1_ParseItem));
	tmp->name=strdup(name);
	tmp->func=func;

	tmp->next=bs1_parse_blkstmts;
	bs1_parse_blkstmts=tmp;

	return(0);
}

elem BS1_Parse_ParseBlockStatementName(char *name, char **s)
{
	BS1_ParseItem *cur;

	cur=bs1_parse_blkstmts;
	while(cur)
	{
		if(!strcmp(name, cur->name))
			return(cur->func(s));
		cur=cur->next;
	}
	return(BS1_MM_NULL);
}

char *BS1_Parse_EatSemicolon(char *s)
{
	s=BS1_Parse_EatWhite(s);
	if(*s==';')s++;
	s=BS1_Parse_EatWhite(s);
	return(s);
}

elem BS1_Parse_Statement(char **str)
{
	char b[256], b2[256];
	char *s;
	int ty, ty2;
	elem n, n1, n2;

	s=*str;
	s=BS1_Parse_Token(s, b, &ty);
	BS1_Parse_Token(s, b2, &ty2);
	if(!*s)
	{
		*str=s;
		return(BS1_MM_NULL);
	}

	if(ty!=BS1_TOKEN_NAME)
	{
		s=*str;
		n=BS1_Parse_Expression(&s);
		*str=s;
		return(n);
	}

	n=BS1_Parse_ParseStatementName(b, &s);
	if(n!=BS1_MM_NULL)
	{
		*str=s;
		return(n);
	}

	if(!strcmp(b, "break"))
	{
		BS1_Parse_Token(s, b2, &ty2);
		if(ty2==BS1_TOKEN_NUMBER)
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			n=LIST2S("break", FIXNUM(atoi(b2)));
		}else n=LIST1S("break");

		*str=s;
		return(n);
	}

	if(!strcmp(b, "continue"))
	{
		BS1_Parse_Token(s, b2, &ty2);
		if(ty2==BS1_TOKEN_NUMBER)
		{
			s=BS1_Parse_Token(s, b2, &ty2);
			n=LIST2S("continue", FIXNUM(atoi(b2)));
		}else n=LIST1S("continue");

		*str=s;
		return(n);
	}

	if(!strcmp(b, "goto"))
	{
		s=BS1_Parse_Token(s, b2, &ty2);
		n=LIST2S("goto", STRING(b2));
		*str=s;
		return(n);
	}

	if(!strcmp(b, "throw"))
	{
		s=BS1_Parse_Token(s, b2, &ty2);
		n=LIST2S("throw", STRING(b2));
		*str=s;
		return(n);
	}

	if(!strcmp(b, "return"))
	{
		BS1_Parse_Token(s, b2, &ty2);
		if(b2[0]!=';')
			n1=BS1_Parse_Expression(&s);
			else n1=BS1_MM_NULL;

		n=LIST2S("return", n1);

		*str=s;
		return(n);
	}


	s=*str;
	s=BS1_Parse_EatWhite(s);
	if(!s || !*s)return(BS1_MM_NULL);

	n=BS1_Parse_Expression(&s);
	if(n!=BS1_MM_NULL)
	{
		*str=s;
		return(n);
	}

	BS1_MSG_Error(s, "PDSCR_Parse_Statement: Unrecognizable statement type\n");
	*str=NULL;
	return(BS1_MM_NULL);
}

elem BS1_Parse_BlockStatementInner(char **str)
{
	char b[256], b2[256];
	char *s, *s2;
	int ty, ty2;
	elem n, n1, n2, n3, n4;

	s=*str;
	s=BS1_Parse_Token(s, b, &ty);
	BS1_Parse_Token(s, b2, &ty2);
	if(!*s)
	{
		*str=s;
		return(BS1_MM_NULL);
	}

	if(ty==BS1_TOKEN_SEPERATOR)
	{
		*str=s;
		return(BS1_MM_NULL);
	}

	if((ty==BS1_TOKEN_NAME) && !strcmp(b2, ":"))
	{
		s=BS1_Parse_Token(s, b2, &ty2);	//:

		if(!strcmp(b, "default"))
		{
			n=LIST1S("case_default");
			*str=s;
			return(n);
		}

		n=LIST2S("label", SYM(b));

		*str=s;
		return(n);
	}

	if(!strcmp(b, "case"))
	{
		n1=BS1_Parse_Expression(&s);
		s=BS1_Parse_Token(s, b2, &ty2);	//:
		n=LIST2S("case", n1);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "function"))
	{
		s=BS1_Parse_Token(s, b, &ty);
		if(ty!=BS1_TOKEN_NAME)
		{
			BS1_MSG_Error(s, "PDSCR_Parse_Function: Invalid name %s\n", b);
			*str=NULL;
			return(n);
		}

		n1=SYM(b);
		s=BS1_Parse_Token(s, b, &ty); //(
		n2=BS1_Parse_FunVarsList(&s);
		bs1_parse_curfilename=NULL;
		n3=BS1_Parse_BlockStatement2(&s);
		n=LIST3S("define", LIST2(n1, n2), n3);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "if"))
	{
		s=BS1_Parse_Token(s, b, &ty);	//(
		n1=BS1_Parse_Expression(&s);
		s=BS1_Parse_Token(s, b, &ty);	//)
		n2=BS1_Parse_BlockStatement2(&s);

		BS1_Parse_Token(s, b, &ty);
		if(strcmp(b, "else"))
		{
			n=LIST3S("if", n1, n2);
			*str=s;
			return(n);
		}

		s=BS1_Parse_Token(s, b, &ty);	//else
		n3=BS1_Parse_BlockStatement2(&s);
		n=LIST4S("if", n1, n2, n3);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "begin"))
	{
		n1=BS1_Parse_BlockStatement2(&s);
		n=LIST2S("begin", n1);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "while"))
	{
		s=BS1_Parse_Token(s, b, &ty);	//'('
		n1=BS1_Parse_Expression(&s);
		s=BS1_Parse_Token(s, b, &ty);	//')'

		n2=BS1_Parse_BlockStatement2(&s);
		n=LIST3S("while", n1, n2);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "for"))
	{
		s=BS1_Parse_Token(s, b, &ty);		//(
		s2=BS1_Parse_Token(s, b, &ty);		//
		s2=BS1_Parse_Token(s2, b2, &ty);	//

		if(!strcmp(b2, "in"))
		{
			s=s2;

			n1=SYM(b);
			n2=BS1_Parse_Expression(&s);
			s=BS1_Parse_EatSemicolon(s);
			s=BS1_Parse_Token(s, b, &ty);	//)

			n3=BS1_Parse_BlockStatement2(&s);
			n=LIST4S("for_in", n1, n2, n3);

			*str=s;
			return(n);
		}

		n1=BS1_Parse_Expression2(&s);
		s=BS1_Parse_EatSemicolon(s);
		n2=BS1_Parse_Expression2(&s);
		s=BS1_Parse_EatSemicolon(s);
		n3=BS1_Parse_Expression2(&s);

		s=BS1_Parse_Token(s, b, &ty);	//)
		n4=BS1_Parse_BlockStatement2(&s);

		n=LIST5S("for", n1, n2, n3, n4);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "switch"))
	{
		s=BS1_Parse_Token(s, b, &ty);	//(
		n1=BS1_Parse_Expression(&s);
		s=BS1_Parse_Token(s, b, &ty);	//)

		s=BS1_Parse_Token(s, b, &ty); //{
		n2=BS1_Parse_Block(&s);

		n=CONS2(SYM("switch"), n1, n2);

		*str=s;
		return(n);
	}

	if(!strcmp(b, "try"))
	{
		n=BS1_Parse_BlockStatement2(&s);

		BS1_Parse_Token(s, b, &ty);
		while(!strcmp(b, "catch"))
		{
			s=BS1_Parse_Token(s, b, &ty);	//'catch'
			s=BS1_Parse_Token(s, b, &ty);	//name

			n1=BS1_Parse_BlockStatement2(&s);
			n=LIST4S("catch", SYM(b), n, n1);
		}

		*str=s;
		return(n);
	}

#if 0
	if(!strcmp(b, "var"))
	{
		n1=BS1_Parse_VarsList(&s);
		n=LIST2S("vars", n1);
		*str=s;
		return(n);
	}
#endif

	n=BS1_Parse_ParseBlockStatementName(b, &s);
	if(n)
	{
		*str=s;
		return(n);
	}


	s=*str;

	n=BS1_Parse_DefType(&s);
	if(n!=BS1_MM_NULL)
	{
		s2=BS1_Parse_Token(s, b, &ty);
		BS1_Parse_Token(s2, b2, &ty2);

		//typed function definition
		if((ty==BS1_TOKEN_NAME) && !strcmp(b2, "("))
		{
			s=BS1_Parse_Token(s, b, &ty);	//name
			s=BS1_Parse_Token(s, b2, &ty2);	//(

			bs1_parse_curfilename=NULL;
			n1=BS1_Parse_FunVarsList(&s);
			n2=BS1_Parse_BlockStatement2(&s);
			n=LIST5S("defun", n, SYM(b), n1, n2);
			*str=s;
			return(n);
		}

		n1=BS1_Parse_VarsList(&s);
		n=LIST3S("vars", n, n1);
		*str=s;
		return(n);
	}


	n=BS1_Parse_Statement(&s);
	s=BS1_Parse_EatSemicolon(s);
	*str=s;
	return(n);
}

elem BS1_Parse_BlockStatement(char **str)
{
	char b[64];
	int ty;
	elem n, n1;
	int i;
	char *s;

	s=*str;
	n=BS1_Parse_BlockStatementInner(&s);

	BS1_Parse_Token(s, b, &ty);
	while(!strcmp(b, "catch"))
	{
		s=BS1_Parse_Token(s, b, &ty);	//'catch'
		s=BS1_Parse_Token(s, b, &ty);	//name

		n1=BS1_Parse_BlockStatement2(&s);
		n=LIST4S("catch", SYM(b), n, n1);
	}

	*str=s;
	return(n);

#if 0
//	i=BS1_Parse_CalcLinenum(*str);

	if(!n)return(n);
	NetParse_AddAttr(n, "linenum", kitoa(i));

	s=BS1_Parse_GetFilename();
	if(s!=bs1_parse_curfilename)
	{
		NetParse_AddAttr(n, "filename", s);
		bs1_parse_curfilename=s;
	}

	return(n);
#endif
}

elem BS1_Parse_Block(char **str)
{
	char b[256];
	char *s;
	int ty, ty2;
	elem n, lst;

	s=*str;
	lst=BS1_MM_NULL;
	while(1)
	{
		BS1_Parse_Token(s, b, &ty);
		if(!*s || (*b=='}'))
		{
			s=BS1_Parse_Token(s, b, &ty);
			break;
		}

		n=BS1_Parse_BlockStatement(&s);
		if(n==BS1_MM_NULL)break;
		lst=BS1_TY_NAppend(lst, LIST1(n));
	}

	*str=s;
	return(lst);
}

elem BS1_Parse_BlockStatement2(char **str)
{
	char b[64];
	char *s;
	int ty;
	elem n;

	s=*str;

	BS1_Parse_Token(s, b, &ty);
	if(!strcmp(b, "{"))
	{
		s=BS1_Parse_Token(s, b, &ty);
		n=BS1_Parse_Block(&s);
		n=CONS(SYM("begin"), n);

		*str=s;
		return(n);
	}

	n=BS1_Parse_BlockStatement(str);
	return(n);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <stdarg.h>

#include <bgbscr1.h>


char *bs1_parse_pbase;
char *bs1_parse_fname;
int bs1_parse_linenum=1;

char *bs1_parse_pbasestack[16];
char *bs1_parse_fnamestack[16];
int bs1_parse_lnumstack[16];
int bs1_parse_lnumstackpos;

int BS1_Parse_GetLinenum()
	{ return(bs1_parse_linenum); }

char *BS1_Parse_GetFilename()
	{ return(bs1_parse_fname); }

int BS1_Parse_CalcLinenum(char *se)
{
	char *s;
	int i;

	if(!bs1_parse_pbase)
		return(0);

	s=bs1_parse_pbase;
	i=bs1_parse_linenum;
	while(s<se)
	{
		if(*s=='\n')i++;
		if((s[0]=='\r') && (s[1]!='\n'))i++;
		s++;
	}

	return(i);
}

int BS1_Parse_SetLinenum(char *fname, char *base, int num)
{
	bs1_parse_fname=fname;
	bs1_parse_pbase=base;
	bs1_parse_linenum=num;
	return(num);
}

int BS1_Parse_PushLinenum()
{
	bs1_parse_lnumstack[bs1_parse_lnumstackpos]=
		bs1_parse_linenum;
	bs1_parse_pbasestack[bs1_parse_lnumstackpos]=
		bs1_parse_pbase;
	bs1_parse_fnamestack[bs1_parse_lnumstackpos]=
		bs1_parse_fname;
	bs1_parse_lnumstackpos++;
	return(0);
}

int BS1_Parse_PopLinenum()
{
	bs1_parse_lnumstackpos--;
	bs1_parse_linenum=
		bs1_parse_lnumstack[bs1_parse_lnumstackpos];
	bs1_parse_pbase=
		bs1_parse_pbasestack[bs1_parse_lnumstackpos];
	bs1_parse_fname=
		bs1_parse_fnamestack[bs1_parse_lnumstackpos];
	return(bs1_parse_linenum);
}

static int BS1_MSG_Print(char *se, char *ty, char *s, va_list lst)
{
	char buf[256];
	char *t;

	t=buf;
	if(bs1_parse_fname)
	{
		sprintf(t, "%s: ", bs1_parse_fname);
		t+=strlen(t);
	}
	sprintf(t, "%s: %d: ", ty, BS1_Parse_CalcLinenum(se));
	t+=strlen(t);

	vsprintf(t, s, lst);

	printf("%s", buf);
//	kprint_logstr(buf);
	return(0);
}

int BS1_MSG_Note(char *se, char *s, ...)
{
	va_list lst;

	va_start(lst, s);
	BS1_MSG_Print(se, "note", s, lst);
	va_end(lst);
	return(0);
}

int BS1_MSG_Warning(char *se, char *s, ...)
{
	va_list lst;

	va_start(lst, s);
	BS1_MSG_Print(se, "warning", s, lst);
	va_end(lst);
	return(0);
}

int BS1_MSG_Error(char *se, char *s, ...)
{
	va_list lst;

	va_start(lst, s);
	BS1_MSG_Print(se, "error", s, lst);
	va_end(lst);

	*(int *)-1=-1;

	return(0);
}

char *BS1_Parse_EatWhiteOnly(char *s)
{
	while(*s && (*s<=' '))s++;
	return(s);
}

char *BS1_Parse_EatWhite(char *s)
{
	int i;

	while(*s && (*s<=' '))s++;

	if((s[0]=='/') && (s[1]=='/'))
	{
		while(*s && (*s!='\n'))s++;
		s=BS1_Parse_EatWhite(s);
		return(s);
	}
	if((s[0]=='/') && (s[1]=='*'))
	{
		s+=2;
		i=1;
		while(*s && i)
		{
			if((s[0]=='/') && (s[1]=='*'))
			{
				s+=2;
				i++;
				continue;
			}
			if((s[0]=='*') && (s[1]=='/'))
			{
				s+=2;
				i--;
				continue;
			}
			s++;
		}
		s=BS1_Parse_EatWhite(s);
		return(s);
	}

	return(s);
}

int BS1_Parse_IsWhiteOnly(char *s)
{
	while((*s==' ') || (*s=='\t'))
		s++;

	if((s[0]=='/') && (s[1]=='/'))return(0);
	if((s[0]=='/') && (s[1]=='*'))return(0);
	if((s[0]=='*') && (s[1]=='/'))return(0);

	if(*s>' ')return(1);
	if(*s==' ')return(1);
	if(*s=='\t')return(1);

	return(0);
}

int BS1_Parse_IsNextIndented(char *se)
{
	char *s, *b, *t;
	int i, j;

	if(!bs1_parse_pbase)
		return(0);

	s=bs1_parse_pbase;
	while(s<se)
	{
		if(*s=='\n')b=s+1;
		if((s[0]=='\r') && (s[1]!='\n'))b=s+2;
		s++;
	}

	t=b; i=0;
	while(*t && (*t<=' '))
	{
		if(*t=='\t')i+=8;
			else i++;
		t++;
	}

	while(*s)
	{
		if(*s=='\n') { b=s+1; break; }
		if((s[0]=='\r') && (s[1]!='\n')) { b=s+2; break; }
		s++;
	}

	t=b; j=0;
	while(*t && (*t<=' '))
	{
		if(*t=='\t')j+=8;
			else j++;
		t++;
	}

	return(j>i);
}

int BS1_Parse_IsLineBreak(char *se)
{
	char *s, *b, *t;
	int i, j;

	s=se;
	while(*s && (*s<=' '))
	{
		if(*s=='\r')return(1);
		if(*s=='\n')return(1);
		s++;
	}
	if(!*s)return(1);

	return(0);
}


int BS1_Parse_OpChar(int c)
{
	int i;

	switch(c)
	{
	case '~':
	case '!':
	case '@':
	case '#':
	case '$':
	case '%':
	case '^':
	case '&':
	case '*':
	case '-':
	case '=':
	case '+':

	case '\\':
	case '|':

	case ':':

	case '<':
	case '>':
	case '?':
	case '/':

	case '.':
		i=1;
		break;

	default:
		i=0;
		break;
	}
	return(i);
}

char *BS1_Parse_Token(char *s, char *b, int *ty)
{
	char *t;
	int i;

	*b=0;
	s=BS1_Parse_EatWhite(s);
	if(!*s)
	{
		*ty=BS1_TOKEN_NULL;
		return(s);
	}
	t=b;

	if((*s=='_') || ((*s>='a') && (*s<='z')) || ((*s>='A') && (*s<='Z')))
	{
		while(
			(*s=='_') ||
			((*s>='a') && (*s<='z')) ||
			((*s>='A') && (*s<='Z')) ||
			((*s>='0') && (*s<='9')))
			*t++=*s++;
		*t++=0;

		*ty=BS1_TOKEN_NAME;
		return(s);
	}

	if((*s>='0') && (*s<='9'))
	{
		if((s[0]=='0') && (s[1]=='x'))
		{
			*t++=*s++;
			*t++=*s++;
			while(((*s>='0') && (*s<='9')) ||
				((*s>='A') && (*s<='F')) ||
				((*s>='a') && (*s<='f')))
			{
				*t++=*s++;
			}
			*t++=0;

			*ty=BS1_TOKEN_NUMBER;
			return(s);
		}

		if(*s=='-')*t++=*s++;
		while(((*s>='0') && (*s<='9')) || (*s=='.') || (*s=='e'))
		{
			if(*s=='e')
			{
				*t++=*s++;
				if((*s=='+') || (*s=='-'))
					*t++=*s++;
				continue;
			}
			*t++=*s++;
		}
		*t++=0;

		*ty=BS1_TOKEN_NUMBER;
		return(s);
	}

	if((*s=='"') || (*s=='\'')) /* quoted string */
	{
		if(*s=='\'')i=1;
			else i=0;
		s++;
		while(*s)
		{
			if(!i)if(*s=='"')break;
			if(i)if(*s=='\'')break;

			if(*s=='\\')
			{
				s++;
				switch(*s)
				{
				case 'n':
					*t++='\n';
					break;
				case 't':
					*t++='\t';
					break;
				case 'r':
					*t++='\r';
					break;
				case '\\':
					*t++='\\';
					break;
				case '"':
					*t++='"';
					break;
				case '\'':
					*t++='\'';
					break;
				default:
					break;
				}
				s++;
			}else *t++=*s++;
		}
		*t++=0;
		if(*s)s++;

		*ty=BS1_TOKEN_STRING;
		if(i)*ty=BS1_TOKEN_CHARSTRING;
		return(s);
	}

	if(!strncmp(s, "...", 3))
	{
		*t++=*s++;
		*t++=*s++;
		*t++=*s++;
		*t++=0;

		*ty=BS1_TOKEN_MISC;
		return(s);
	}

	if((*s==',') || (*s==';') || ((*s=='.') && (s[1]!='.')))
	{
		*t++=*s++;
		*t++=0;

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_SEPERATOR;
		return(s);
	}

	if(
		!strncmp(s, "{:", 2) || !strncmp(s, ":}", 2) ||
		!strncmp(s, "[:", 2) || !strncmp(s, ":]", 2) ||
		!strncmp(s, "(:", 2) || !strncmp(s, ":)", 2))
	{
		*t++=*s++;
		*t++=*s++;
		*t++=0;

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_BRACE;
		return(s);
	}

	if(
		(*s=='{') || (*s=='}') ||
		(*s=='[') || (*s==']') ||
		(*s=='(') || (*s==')'))
	{
		*t++=*s++;
		*t++=0;

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_BRACE;
		return(s);
	}

	if(BS1_Parse_OpChar(*s))
	{
		if(
			!strncmp(s, "::==", 4) ||
			!strncmp(s, "<<==", 4) ||
			!strncmp(s, ">>==", 4) ||
			!strncmp(s, ":<<=", 4) ||
			!strncmp(s, ":>>=", 4)
			)
		{
			*t++=*s++;
			*t++=*s++;
			*t++=*s++;
			*t++=*s++;
			*t++=0;
		}else if(
			!strncmp(s, "===", 3) ||
			!strncmp(s, "!==", 3) ||
			!strncmp(s, "<=>", 3) ||
			!strncmp(s, "<<=", 3) ||
			!strncmp(s, ">>=", 3) ||
			!strncmp(s, ":!=", 3) ||
			!strncmp(s, ":<=", 3) ||
			!strncmp(s, ":>=", 3) ||
			!strncmp(s, ":<<", 3) ||
			!strncmp(s, ":>>", 3)
			)
		{
			*t++=*s++;
			*t++=*s++;
			*t++=*s++;
			*t++=0;
		}else if(
			!strncmp(s, "==", 2) ||
			!strncmp(s, "<=", 2) ||
			!strncmp(s, ">=", 2) ||
			!strncmp(s, "!=", 2) ||
			!strncmp(s, "<<", 2) ||
			!strncmp(s, ">>", 2) ||
			!strncmp(s, "&&", 2) ||
			!strncmp(s, "||", 2) ||

			!strncmp(s, "..", 2) ||
			!strncmp(s, "**", 2) ||
			!strncmp(s, "%%", 2) ||
			!strncmp(s, "::", 2) ||

			!strncmp(s, "++", 2) ||
			!strncmp(s, "--", 2) ||

			!strncmp(s, "+=", 2) ||
			!strncmp(s, "-=", 2) ||
			!strncmp(s, "*=", 2) ||
			!strncmp(s, "/=", 2) ||
			!strncmp(s, "\\=", 2) ||
			!strncmp(s, "&=", 2) ||
			!strncmp(s, "|=", 2) ||
			!strncmp(s, "^=", 2) ||

			!strncmp(s, "+.", 2) ||
			!strncmp(s, "-.", 2) ||
			!strncmp(s, "*.", 2) ||
			!strncmp(s, "/.", 2) ||
			!strncmp(s, "\\.", 2) ||
			!strncmp(s, "&.", 2) ||
			!strncmp(s, "|.", 2) ||
			!strncmp(s, "^.", 2) ||

			!strncmp(s, ":=", 2) ||
			!strncmp(s, ":<", 2) ||
			!strncmp(s, ":>", 2)
			)
		{
			*t++=*s++;
			*t++=*s++;
			*t++=0;
		}else
		{
			*t++=*s++;
			*t++=0;
		}

//		kprint("token: %p '%s'\n", s, b);
		*ty=BS1_TOKEN_OPERATOR;
		if(!strcmp(b, ":"))*ty=BS1_TOKEN_SEPERATOR;

		return(s);
	}

	BS1_MSG_Error(s, "BS1_Parse_Token: Parse Error Char '%c'\n", *s);
	*ty=BS1_TOKEN_NULL;
	return(NULL);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <stdarg.h>

#include <bgbscr1.h>
#include <bgbasm.h>

//#define JIT_OFFS(n)	((&BS1_SVMState.n)-(&BS1_SVMState))

extern char *bs1_ops_strs[];
extern char *bs1_ops_args[];

extern elem bs1_svm_toplevel;

BS1_SVMState bs1_jit_svmstate;	//example VM state
#define JIT_OFFS(n)	(((byte *)(&(bs1_jit_svmstate.n)))-((byte *)(&bs1_jit_svmstate)))


elem bs1_jit_temp[16];		//temp "registers"
BS1_JitContext *bs1_jit_ctx;
int bs1_jit_seq=1;


elem BS1_JIT_PopDict(BS1_SVMState *ctx)
{
	elem t, u, v;

	t=BS1_SVM_PopList(ctx);
	u=BS1_SObj_New();
	v=t;
	while(BS1_CONSP(v))
	{
		BS1_SObj_BindSlot(u, CAR(v), CADR(v));
		v=CDDR(v);
	}
	BS1_GC_CheckRef(t);
	return(u);
}

elem BS1_JIT_PopVector(BS1_SVMState *ctx)
{
	elem t, u, v;

	t=BS1_SVM_PopList(ctx);
	u=BS1_TYVec_List2FVec(t);
	BS1_GC_CheckRef(t);
	return(u);
}

elem BS1_JIT_PopMatrix(BS1_SVMState *ctx)
{
	elem t, u, v;

	t=BS1_SVM_PopList(ctx);
	u=BS1_TYMat_List2FMat(t);
	BS1_GC_CheckRef(t);
	return(u);
}

elem BS1_JIT_AddFl(elem a, elem b) { return(FLONUM(TOFLOAT(a)+TOFLOAT(b))); }
elem BS1_JIT_SubFl(elem a, elem b) { return(FLONUM(TOFLOAT(a)+TOFLOAT(b))); }
elem BS1_JIT_MulFl(elem a, elem b) { return(FLONUM(TOFLOAT(a)+TOFLOAT(b))); }
elem BS1_JIT_DivFl(elem a, elem b) { return(FLONUM(TOFLOAT(a)+TOFLOAT(b))); }
elem BS1_JIT_NegFl(elem a) { return(FLONUM(-TOFLOAT(a))); }

int BS1_JIT_CmpEFl(elem a, elem b) { return(TOFLOAT(a)==TOFLOAT(b)); }
int BS1_JIT_CmpNeFl(elem a, elem b) { return(TOFLOAT(a)!=TOFLOAT(b)); }
int BS1_JIT_CmpLFl(elem a, elem b) { return(TOFLOAT(a)<TOFLOAT(b)); }
int BS1_JIT_CmpGFl(elem a, elem b) { return(TOFLOAT(a)>TOFLOAT(b)); }
int BS1_JIT_CmpLeFl(elem a, elem b) { return(TOFLOAT(a)<=TOFLOAT(b)); }
int BS1_JIT_CmpGeFl(elem a, elem b) { return(TOFLOAT(a)>=TOFLOAT(b)); }

elem BS1_JIT_DivFn(elem a, elem b) { return(FLONUM(TOFLOAT(a)/TOFLOAT(b))); }


int BS1_JIT_RetCleanup(BS1_SVMState *ctx)
{
	elem t;

#ifdef BS1_BLKSTKARGS
	if(ctx->klenv && !ctx->vlenv)
	{
		t=BS1_SVM_PopF(ctx);
		BS1_SVM_PopMark(ctx);
//		ctx->args=ctx->markstack[ctx->markstackpos-1];
//		ctx->eargs=ctx->stackpos;
		BS1_SVM_PushF(ctx, t);
	}
#endif

	BS1_SVM_PopFrame(ctx);
	if(ctx->flowstackpos<0)
		return(2);
	return(0);
}

elem _cdecl BS1_JIT_Lookup(BS1_SVMState *ctx, elem key)
{
	*(int *)-1=-1;
}


void BS1_JIT_Init()
{
	static int init=0;
	int i, j, k, l;

	if(init)return;
	init=1;

	bs1_jit_ctx=malloc(sizeof(BS1_JitContext));
	memset(bs1_jit_ctx, 0, sizeof(BS1_JitContext));

	BASM_RegisterPtr("IncRef", &BS1_GC_IncRef);
	BASM_RegisterPtr("DecRef", &BS1_GC_DecRef);
	BASM_RegisterPtr("SafeDecRef", &BS1_GC_SafeDecRef);
	BASM_RegisterPtr("CheckRef", &BS1_GC_CheckRef);

	BASM_RegisterPtr("Lookup", &BS1_SVM_Lookup);
	BASM_RegisterPtr("Assign", &BS1_SVM_Assign);
	BASM_RegisterPtr("Bind", &BS1_SVM_Bind);
	BASM_RegisterPtr("LexBind", &BS1_SVM_LexBind);

	BASM_RegisterPtr("LoadIndex", &BS1_SVM_LoadIndex);
	BASM_RegisterPtr("StoreIndex", &BS1_SVM_StoreIndex);

	BASM_RegisterPtr("LookupIdx", &BS1_SVM_LookupIdx);
	BASM_RegisterPtr("AssignIdx", &BS1_SVM_AssignIdx);
	BASM_RegisterPtr("AssignIdxF", &BS1_SVM_AssignIdxF);

	BASM_RegisterPtr("CallObj", &BS1_SVM_CallObj);
	BASM_RegisterPtr("TailCallObj", &BS1_SVM_TailCallObj);
	BASM_RegisterPtr("MethodCall", &BS1_SVM_MethodCall);
	BASM_RegisterPtr("MethodTailCall", &BS1_SVM_MethodTailCall);

	BASM_RegisterPtr("Unary", &BS1_SVM_Unary);
	BASM_RegisterPtr("Binary", &BS1_SVM_Binary);
	BASM_RegisterPtr("CondUnary", &BS1_Opr_CondUnary);
	BASM_RegisterPtr("CondBinary", &BS1_Opr_CondBinary);

	BASM_RegisterPtr("GetCar", &BS1_TY_GetCar);
	BASM_RegisterPtr("GetCdr", &BS1_TY_GetCdr);
	BASM_RegisterPtr("GetCaar", &BS1_TY_GetCaar);
	BASM_RegisterPtr("GetCdar", &BS1_TY_GetCdar);
	BASM_RegisterPtr("GetCadr", &BS1_TY_GetCadr);
	BASM_RegisterPtr("GetCddr", &BS1_TY_GetCddr);

	BASM_RegisterPtr("PopList2", &BS1_SVM_PopList2);

	BASM_RegisterPtr("PopDict", &BS1_JIT_PopDict);
	BASM_RegisterPtr("PopVector", &BS1_JIT_PopVector);
	BASM_RegisterPtr("PopMatrix", &BS1_JIT_PopMatrix);

	BASM_RegisterPtr("AddFl", &BS1_JIT_AddFl);
	BASM_RegisterPtr("SubFl", &BS1_JIT_SubFl);
	BASM_RegisterPtr("MulFl", &BS1_JIT_MulFl);
	BASM_RegisterPtr("DivFl", &BS1_JIT_DivFl);
	BASM_RegisterPtr("NegFl", &BS1_JIT_NegFl);
	BASM_RegisterPtr("DivFn", &BS1_JIT_DivFn);

	BASM_RegisterPtr("CmpEFl", &BS1_JIT_CmpEFl);
	BASM_RegisterPtr("CmpNeFl", &BS1_JIT_CmpNeFl);
	BASM_RegisterPtr("CmpLFl", &BS1_JIT_CmpLFl);
	BASM_RegisterPtr("CmpGFl", &BS1_JIT_CmpGFl);
	BASM_RegisterPtr("CmpLeFl", &BS1_JIT_CmpLeFl);
	BASM_RegisterPtr("CmpGeFl", &BS1_JIT_CmpGeFl);

	BASM_RegisterPtr("RetCleanup", &BS1_JIT_RetCleanup);

	basm_print("JIT_Base: ret;\n");

	basm_print("incref: push eax; call IncRef; pop eax; ret;\n");
	basm_print("decref: push eax; call DecRef; pop eax; ret;\n");
	basm_print("safedecref: push eax; call SafeDecRef; pop eax; ret;\n");
	basm_print("checkref: push eax; call CheckRef; pop eax; ret;\n");

	basm_print("incref2: push ecx; push eax; call IncRef; pop eax; pop ecx; ret;\n");
	basm_print("decref2: push ecx; push eax; call DecRef; pop eax; pop ecx; ret;\n");
	basm_print("safedecref2: push ecx; push eax; call SafeDecRef; pop eax; pop ecx; ret;\n");
	basm_print("checkref2: push ecx; push eax; call CheckRef; pop eax; pop ecx; ret;\n");

//	basm_print("mark: push edi; push esi; call PushMark; add esp, 8; ret;\n");

//	basm_print("syncstack: mov eax, edi; sub eax, [esi+%d]; shr eax, 2;\n"
//		"mov [esi+%d], eax; ret;\n",
//		JIT_OFFS(stack), JIT_OFFS(stackpos));
}

char *BS1_JIT_GenSym()
{
	char buf[64];
	sprintf(buf, "JIT$%d", bs1_jit_seq++);
	return(strdup(buf));
}


#define BS1_JIT_CACHE

#ifdef BS1_JIT_CACHE

void BS1_JIT_PushEAX_F(BS1_JitContext *ctx)
{
//	basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");
	ctx->fl|=BS1_JITFL_EAX;
}

void BS1_JIT_PushEAX(BS1_JitContext *ctx)
{
//	basm_print("call incref; mov [edi+ebx*4], eax; inc_r ebx;\n");

//	ctx->fl&=~BS1_JITFL_ECX_EARG;
	ctx->fl|=BS1_JITFL_EAX;
//	basm_print("call incref;\n");
	BS1_JIT_IncRef(ctx);
}

void BS1_JIT_Push(BS1_JitContext *ctx, elem val)
{
	if(ctx->fl&BS1_JITFL_EAX)
		basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");

	if(BS1_HEAPP(val))
	{
//		ctx->fl&=~BS1_JITFL_ECX_EARG;
		basm_print("mov eax, 0x%x;\n", val);
		BS1_JIT_IncRef(ctx);
		ctx->fl|=BS1_JITFL_EAX;
		return;
	}

	if(!val)
	{
		basm_print("xor eax, eax;\n");
		ctx->fl|=BS1_JITFL_EAX;
		return;
	}

	basm_print("mov eax, 0x%x;\n", val);
	ctx->fl|=BS1_JITFL_EAX;
}

#endif

#ifndef BS1_JIT_CACHE

void BS1_JIT_PushEAX_F(BS1_JitContext *ctx)
{
	basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");
}

void BS1_JIT_PushEAX(BS1_JitContext *ctx)
{
	BS1_JIT_IncRef(ctx);
	basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");
//	ctx->fl&=~BS1_JITFL_ECX_EARG;
}

void BS1_JIT_Push(BS1_JitContext *ctx, elem val)
{
	if(BS1_HEAPP(val))
	{
		basm_print("mov eax, 0x%x; call incref;\n"
			"mov [edi+ebx*4], eax; inc_r ebx;\n", val);
		return;
	}

	basm_print("mov dword [edi+ebx*4], 0x%x; inc_r ebx;\n", val);
}
#endif


void BS1_JIT_PopEAX_F(BS1_JitContext *ctx)
{
	if(ctx->fl&BS1_JITFL_EAX)
	{
		ctx->fl&=~BS1_JITFL_EAX;
		return;
	}
	basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
}

void BS1_JIT_PopEAX(BS1_JitContext *ctx)
{
//	ctx->fl&=~BS1_JITFL_ECX_EARG;

	if(ctx->fl&BS1_JITFL_EAX)
	{
		ctx->fl&=~BS1_JITFL_EAX;
		BS1_JIT_SafeDecRef(ctx);
		return;
	}
	basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
	BS1_JIT_SafeDecRef(ctx);
}

void BS1_JIT_PopToArg(BS1_JitContext *ctx)
{
	ctx->fl&=~BS1_JITFL_ECX_EARG;

	if(ctx->fl&BS1_JITFL_EAX)
	{
		ctx->fl&=~BS1_JITFL_EAX;
		basm_print("push eax; call SafeDecRef;\n");
		return;
	}
	basm_print("dec_r ebx; push dword [edi+ebx*4]; call SafeDecRef;\n");
}

void BS1_JIT_PopToArgF(BS1_JitContext *ctx)
{
	if(ctx->fl&BS1_JITFL_EAX)
	{
		ctx->fl&=~BS1_JITFL_EAX;
		basm_print("push eax;\n");
		return;
	}
	basm_print("dec_r ebx; push dword [edi+ebx*4];\n");
}

void BS1_JIT_PopDestroy(BS1_JitContext *ctx)
{
//	ctx->fl&=~BS1_JITFL_ECX_EARG;

	if(ctx->fl&BS1_JITFL_EAX)
	{
		ctx->fl&=~BS1_JITFL_EAX;
		BS1_JIT_DecRef(ctx);
		return;
	}

	basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
	BS1_JIT_DecRef(ctx);
}

void BS1_JIT_PopBool(BS1_JitContext *ctx)
{
//	ctx->fl&=~BS1_JITFL_ECX_EARG;

	if(ctx->fl&BS1_JITFL_EAX)
	{
		ctx->fl&=~BS1_JITFL_EAX;
		BS1_JIT_DecRef(ctx);
		return;
	}

	basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
	BS1_JIT_DecRef(ctx);
}

void BS1_JIT_IncRef(BS1_JitContext *ctx)
{
	if(ctx->fl&BS1_JITFL_ECX_EARG)
	{
		basm_print("call incref2;\n");
		return;
	}
	basm_print("call incref;\n");
}

void BS1_JIT_DecRef(BS1_JitContext *ctx)
{
	if(ctx->fl&BS1_JITFL_ECX_EARG)
	{
		basm_print("call decref2;\n");
		return;
	}
	basm_print("call decref;\n");
}

void BS1_JIT_SafeDecRef(BS1_JitContext *ctx)
{
	if(ctx->fl&BS1_JITFL_ECX_EARG)
	{
		basm_print("call safedecref2;\n");
		return;
	}
	basm_print("call safedecref;\n");
}


void BS1_JIT_FlattenStack(BS1_JitContext *ctx)
{
	ctx->fl&=~BS1_JITFL_ECX_EARG;

	if(!(ctx->fl&BS1_JITFL_EAX))return;

	ctx->fl&=~BS1_JITFL_EAX;
	basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");
}

void BS1_JIT_AdjustStack(BS1_JitContext *ctx)
{
	BS1_JIT_FlattenStack(ctx);
	basm_print("mov [esi+%d], ebx;\n", JIT_OFFS(stackpos));
}

void BS1_JIT_Return(BS1_JitContext *ctx)
{
	BS1_JIT_AdjustStack(ctx);
	basm_print("push esi; call RetCleanup; pop ecx; pop ebx;\n"
		"pop edi; pop esi; pop ebp; ret;\n");
}

void BS1_JIT_Entry(BS1_JitContext *ctx)
{
	basm_print("push ebp; mov ebp, esp; push esi; push edi; push ebx;\n");
	basm_print("mov esi, [ebp+8]; mov edi, [esi+%d]; mov ebx, [esi+%d];\n",
		JIT_OFFS(stack), JIT_OFFS(stackpos));
	ctx->fl&=~255;
}

void BS1_JIT_Call(BS1_JitContext *ctx)
{
	char *s;

	s=BS1_JIT_GenSym(); BS1_JIT_PopEAX(ctx); BS1_JIT_AdjustStack(ctx);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	basm_print("push eax; push dword [esi+%d]; push esi;\n"
		"call CallObj; add esp, 12;\n", JIT_OFFS(self));
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_TailCall(BS1_JitContext *ctx)
{
	char *s;

	s=BS1_JIT_GenSym(); BS1_JIT_PopEAX(ctx); BS1_JIT_AdjustStack(ctx);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	basm_print("push eax; push dword [esi+%d]; push esi;\n"
		"call TailCallObj; add esp, 12;\n", JIT_OFFS(self));
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_CallS(BS1_JitContext *ctx, elem t)
{
	char *s;

	s=BS1_JIT_GenSym();
	BS1_JIT_AdjustStack(ctx);
	basm_print("push dword 0x%x; push esi; call Lookup; add esp, 8;\n", t);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	basm_print("push eax; push dword [esi+%d]; push esi;\n"
		"call CallObj; add esp, 12;\n", JIT_OFFS(self));
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_TailCallS(BS1_JitContext *ctx, elem t)
{
	char *s;

	s=BS1_JIT_GenSym();
	BS1_JIT_AdjustStack(ctx);
	basm_print("push dword 0x%x; push esi; call Lookup; add esp, 8;\n", t);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	basm_print("push eax; push dword [esi+%d]; push esi;\n"
		"call TailCallObj; add esp, 12;\n", JIT_OFFS(self));
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_MethodCall(BS1_JitContext *ctx)
{
	char *s;

	s=BS1_JIT_GenSym(); BS1_JIT_PopToArg(ctx);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	BS1_JIT_PopToArg(ctx); BS1_JIT_AdjustStack(ctx);
	basm_print("push esi; call MethodCall; add esp, 12;\n");
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_MethodTailCall(BS1_JitContext *ctx)
{
	char *s;

	s=BS1_JIT_GenSym(); BS1_JIT_PopToArg(ctx); 
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	BS1_JIT_PopToArg(ctx);	BS1_JIT_AdjustStack(ctx);
	basm_print("push esi; call MethodTailCall; add esp, 12;\n");
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_MethodCallS(BS1_JitContext *ctx, elem t)
{
	char *s;

	s=BS1_JIT_GenSym(); basm_print("push dword 0x%x;\n", t);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	BS1_JIT_PopToArg(ctx); BS1_JIT_AdjustStack(ctx);
	basm_print("push esi; call MethodCall; add esp, 12;\n");
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_MethodTailCallS(BS1_JitContext *ctx, elem t)
{
	char *s;

	s=BS1_JIT_GenSym(); basm_print("push dword 0x%x;\n", t);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	BS1_JIT_PopToArg(ctx); BS1_JIT_AdjustStack(ctx);
	basm_print("push esi; call MethodTailCall; add esp, 12;\n");
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_CallCF(BS1_JitContext *ctx)
{
	char *s;

	s=BS1_JIT_GenSym(); BS1_JIT_AdjustStack(ctx);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	basm_print("push dword [esi+%d];\n", JIT_OFFS(func));
	basm_print("push dword [esi+%d]; push esi;\n"
		"call CallObj; add esp, 12;\n", JIT_OFFS(self));
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}

void BS1_JIT_TailCallCF(BS1_JitContext *ctx)
{
	char *s;

	s=BS1_JIT_GenSym(); BS1_JIT_AdjustStack(ctx);
	basm_print("mov dword [esi+%d], %s;\n", JIT_OFFS(thunk), s);
	basm_print("push dword [esi+%d];\n", JIT_OFFS(func));
	basm_print("push dword [esi+%d]; push esi;\n"
		"call TailCallObj; add esp, 12;\n", JIT_OFFS(self));
	basm_print("xor eax, eax; pop ebx; pop edi; pop esi; pop ebp; ret;\n\n");
	basm_print("%s:\n", s); BS1_JIT_Entry(ctx);
}


elem BS1_JIT_ReadID(BS1_JitContext *ctx)
{
	elem t;
	int i;

	i=*ctx->ip++;
	if(i&128)i=((i&127)<<8)|(*ctx->ip++);
	t=BS1_TY_GetArrayElem2(ctx->lit, i);
	return(t);
}

int BS1_JIT_ReadIDX(BS1_JitContext *ctx)
{
	int i;
	i=*ctx->ip++;
	if(i&128)i=((i&127)<<8)|(*ctx->ip++);
	return(i);
}

void BS1_JIT_PreStep(BS1_JitContext *ctx)
{
	char buf[64];
	byte *ip, *ip1;
	char *s;
	int i, j;

	ip=ctx->ip;
	i=*ip++;
	if(i>=192)i=(i-192)*256+(*ip++);
	switch(i)
	{
	case BS1_SOP_JMP:
	case BS1_SOP_JMP_TRUE:		case BS1_SOP_JMP_FALSE:

	case BS1_SOP_JMP_E_FN:		case BS1_SOP_JMP_NE_FN:
	case BS1_SOP_JMP_E_FL:		case BS1_SOP_JMP_NE_FL:
	case BS1_SOP_JMP_L_FN:		case BS1_SOP_JMP_G_FN:
	case BS1_SOP_JMP_LE_FN:		case BS1_SOP_JMP_GE_FN:
	case BS1_SOP_JMP_L_FL:		case BS1_SOP_JMP_G_FL:
	case BS1_SOP_JMP_LE_FL:		case BS1_SOP_JMP_GE_FL:

	case BS1_SOP_JMP_E_ZFN:		case BS1_SOP_JMP_NE_ZFN:
	case BS1_SOP_JMP_L_ZFN:		case BS1_SOP_JMP_G_ZFN:
	case BS1_SOP_JMP_LE_ZFN:	case BS1_SOP_JMP_GE_ZFN:
		i=*ip++; i|=(*ip++)<<8; i=((signed short)i); ip1=ip+i;
		for(j=0; j<ctx->n_lbl; j++)
			if(ctx->lbl[j]==ip1)
				break;
		if(j>=ctx->n_lbl)
		{
			j=ctx->n_lbl++;
			ctx->lbl[j]=ip1;
			ctx->lbln[j]=BS1_JIT_GenSym();
//			printf("LBL %08X %s\n", (int)ip1, ctx->lbln[j]);
		}
		break;

	case BS1_SOP_JMP_COND_U:	case BS1_SOP_JMP_COND_B:

	case BS1_SOP_JMP_E_LZFN:	case BS1_SOP_JMP_NE_LZFN:
	case BS1_SOP_JMP_L_LZFN:	case BS1_SOP_JMP_G_LZFN:
	case BS1_SOP_JMP_LE_LZFN:	case BS1_SOP_JMP_GE_LZFN:

	case BS1_SOP_JMP_E_FNC:		case BS1_SOP_JMP_NE_FNC:
	case BS1_SOP_JMP_L_FNC:		case BS1_SOP_JMP_G_FNC:
	case BS1_SOP_JMP_LE_FNC:	case BS1_SOP_JMP_GE_FNC:
		ip++;
		i=*ip++; i|=(*ip++)<<8; i=((signed short)i); ip1=ip+i;
		for(j=0; j<ctx->n_lbl; j++)
			if(ctx->lbl[j]==ip1)
				break;
		if(j>=ctx->n_lbl)
		{
			j=ctx->n_lbl++;
			ctx->lbl[j]=ip1;
			ctx->lbln[j]=BS1_JIT_GenSym();
//			printf("LBL %08X %s\n", (int)ip1, ctx->lbln[j]);
		}
		break;

	case BS1_SOP_JMP_E_LFN:		case BS1_SOP_JMP_NE_LFN:
	case BS1_SOP_JMP_L_LFN:		case BS1_SOP_JMP_G_LFN:
	case BS1_SOP_JMP_LE_LFN:	case BS1_SOP_JMP_GE_LFN:

	case BS1_SOP_JMP_E_LFNC:	case BS1_SOP_JMP_NE_LFNC:
	case BS1_SOP_JMP_L_LFNC:	case BS1_SOP_JMP_G_LFNC:
	case BS1_SOP_JMP_LE_LFNC:	case BS1_SOP_JMP_GE_LFNC:
		ip+=2;
		i=*ip++; i|=(*ip++)<<8; i=((signed short)i); ip1=ip+i;
		for(j=0; j<ctx->n_lbl; j++)
			if(ctx->lbl[j]==ip1)
				break;
		if(j>=ctx->n_lbl)
		{
			j=ctx->n_lbl++;
			ctx->lbl[j]=ip1;
			ctx->lbln[j]=BS1_JIT_GenSym();
//			printf("LBL %08X %s\n", (int)ip1, ctx->lbln[j]);
		}
		break;

	default:
		s=bs1_ops_args[i];
		while(*s)
		{
			if((*s=='I') || (*s=='S') || (*s=='T') || (*s=='N'))
				{ i=*ip++; if(i&128)ip++; }
			if(*s=='A')ip+=2;
			if(*s=='C')ip++;
			if(*s=='B')ip++;
			if(*s=='W')ip+=2;
			if(*s=='b')ip++;
			s++;
		}
		break;
	}

	ctx->ip=ip;
}

char *BS1_JIT_GetLabel(BS1_JitContext *ctx, byte *ip)
{
	int i;
	for(i=0; i<ctx->n_lbl; i++)
		if(ctx->lbl[i]==ip)
			return(ctx->lbln[i]);
	return(NULL);
}

int BS1_JIT_DumpOpcode(BS1_JitContext *ctx)
{
	static char *bops[]={"add", "sub", "mul", "div", "mod", "and", "or",
		"xor", "shl", "shr", "eq", "eqv", "neq", "neqv", "l",
		"g", "le", "ge", "idiv", "dadd", "dsub", "dmul", "ddiv",
		"dmod", "dand", "dor", "dxor", "didiv", "exp"};
	static char *uops[]={"neg", "not", "lnot", "pos", "umul", "udiv",
		"uidiv", "umod", "uand", "uor", "uxor", "uland", "ulor",
		"ulxor", "inc", "dec"};
	static char buf[256];

	elem t;
	byte *ip, *ip1;
	char *s;
	int i, j, k;

	ip=ctx->ip;

	i=*ip++;
	if(i>=192)
	{
		i=(i-192)*256+(*ip++);
		basm_print("; %08X %02X%02X ", ctx->ip,
			ctx->ip[0], ctx->ip[1]);
	}else
	{
		basm_print("; %08X %02X ", ctx->ip, i);
	}

	k=0; s=bs1_ops_args[i]; ip1=ip;
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T') || (*s=='N'))
			{ j=*ip1++; k++; if(j&128)k++; s++; continue; }
		if(*s=='A') { ip1+=2; k+=2; s++; continue; }

		if(*s=='C') { ip1++; k++; s++; continue; }
		if(*s=='B') { ip1++; k++; s++; continue; }
		if(*s=='W') { ip1++; k+=2; s++; continue; }
		if(*s=='H') { ip1++; k+=2; s++; continue; }

		if(*s=='u') { ip1++; k++; s++; continue; }
		if(*s=='b') { ip1++; k++; s++; continue; }

		s++;
	}

	ip1=ip;
	for(j=0; j<k; j++)basm_print("%02X", *ip1++);

	if(i<192)basm_print("  ");
	for(; j<4; j++)basm_print("  ");

	basm_print(" %s ", bs1_ops_strs[i]);

	s=bs1_ops_args[i];
	while(*s)
	{
		if((*s=='I') || (*s=='S') || (*s=='T'))
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			t=BS1_TY_GetArrayElem2(ctx->lit, i);
//			BS1_TY_Print(t);
			if(BS1_SYMBOLP(t))basm_print("%s", BS1_TOSYM(t));
			if(BS1_KEYWORDP(t))basm_print("%s", BS1_TOSYM(t));
			if(BS1_STRINGP(t))basm_print("'%s'", BS1_TOSTRING(t));
			basm_print(" ");
			s++;
			continue;
		}
		if(*s=='N')
		{
			i=*ip++;
			if(i&128)i=((i&127)<<8)|(*ip++);
			basm_print("%d ", i);
			s++;
			continue;
		}
		if(*s=='A')
		{
			i=*ip++; i|=(*ip++)<<8;
			basm_print("%08X ", ip+((short)i));
			s++;
			continue;
		}
		if(*s=='C') { i=(signed char)(*ip++); basm_print("%d ", i);
			s++; continue; }
		if(*s=='B') { i=*ip++; basm_print("%d ", i); s++; continue; }
		if(*s=='W') { i=*ip++; i|=(*ip++)<<8; basm_print("%d ", i);
			s++; continue; }
		if(*s=='H') { i=*ip++; i|=(*ip++)<<8;
			basm_print("%g ", i/100.0); s++; continue; }
		if(*s=='u') { i=*ip++; basm_print("%s ", uops[i]);
			s++; continue; }
		if(*s=='b') { i=*ip++; basm_print("%s ", bops[i]);
			s++; continue; }
		s++;
	}

	basm_print("\n");
}


int BS1_JIT_Step(BS1_JitContext *ctx)
{
	elem t, u, v;
	int i, j, rs;
	char *s, *s1, *s2;

#ifndef BS1_JIT_CACHE
	ctx->fl&=~BS1_JITFL_ECX_EARG;
#endif

	BS1_JIT_DumpOpcode(ctx);

	for(i=0; i<ctx->n_lbl; i++)
		if(ctx->lbl[i]==ctx->ip)
	{
		BS1_JIT_FlattenStack(ctx);
		basm_print("%s:\n", ctx->lbln[i]);
	}

	i=*ctx->ip++;
	if(i>=192)i=(i-192)*256+(*ctx->ip++);

	switch(i)
	{
	case BS1_SOP_NOP:
		break;
	case BS1_SOP_BLOCK:
		break;
	case BS1_SOP_DBGMARK:
		break;
	case BS1_SOP_CGENAST:
		break;

	case BS1_SOP_PUSH:
		t=BS1_JIT_ReadID(ctx);
		BS1_JIT_Push(ctx, t);
		break;
	case BS1_SOP_POP:
		BS1_JIT_PopDestroy(ctx);
		break;
	case BS1_SOP_LOAD:
		BS1_JIT_FlattenStack(ctx);
		t=BS1_JIT_ReadID(ctx);
		basm_print("push dword 0x%x; push esi; call Lookup; add esp, 8;\n", t);
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_STORE:
		t=BS1_JIT_ReadID(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword 0x%x; push esi; call Assign; add esp, 12;\n", t);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_BIND:
		t=BS1_JIT_ReadID(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword 0x%x; push esi; call Bind; add esp, 12;\n", t);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_DYNBIND:
		break;
	case BS1_SOP_LEXBIND:
		t=BS1_JIT_ReadID(ctx);
		BS1_JIT_PopToArgF(ctx);
		BS1_JIT_AdjustStack(ctx);
		basm_print("push dword 0x%x; push esi; call LexBind; add esp, 12;\n", t);
		basm_print("mov ebx, [esi+%d];\n", JIT_OFFS(stackpos));
		ctx->fl&=~255;
		break;

	case BS1_SOP_LOADINDEX:
		BS1_JIT_PopToArgF(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_STOREINDEX:
		BS1_JIT_PopToArgF(ctx);
		BS1_JIT_PopToArgF(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_LOADINDEX_S:
		t=BS1_JIT_ReadID(ctx);
		basm_print("push dword 0x%x; ", t);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_STOREINDEX_S:
		t=BS1_JIT_ReadID(ctx);
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword 0x%x; ", t);
		basm_print("push eax;\n");
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_LOADINDEX_I:
		basm_print("push dword %d;\n", FIXNUM(*ctx->ip++));
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_STOREINDEX_I:
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d; push eax;\n", FIXNUM(*ctx->ip++));
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_LOADINDEX_0:
		basm_print("push dword %d;\n", BS1_MM_FIXNUM_0);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_LOADINDEX_1:
		basm_print("push dword %d;\n", BS1_MM_FIXNUM_1);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_LOADINDEX_2:
		basm_print("push dword %d;\n", BS1_MM_FIXNUM_2);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_LOADINDEX_3:
		basm_print("push dword %d;\n", BS1_MM_FIXNUM_3);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push esi; call LoadIndex; add esp, 12;\n");
		BS1_JIT_PushEAX(ctx);
		break;

	case BS1_SOP_STOREINDEX_0:
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d; push eax;\n", BS1_MM_FIXNUM_0);
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_STOREINDEX_1:
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d; push eax;\n", BS1_MM_FIXNUM_1);
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_STOREINDEX_2:
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d; push eax;\n", BS1_MM_FIXNUM_2);
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_STOREINDEX_3:
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d; push eax ;\n", BS1_MM_FIXNUM_3);
		basm_print("push esi; call StoreIndex; add esp, 16;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_PUSHSELF:
		BS1_JIT_FlattenStack(ctx);
		basm_print("mov eax, [esi+%d];\n", JIT_OFFS(self));
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_PUSH_NULL:
		BS1_JIT_Push(ctx, BS1_MM_NULL);
		break;
	case BS1_SOP_PUSH_TRUE:
		BS1_JIT_Push(ctx, BS1_MM_TRUE);
		break;
	case BS1_SOP_PUSH_FALSE:
		BS1_JIT_Push(ctx, BS1_MM_FALSE);
		break;
	case BS1_SOP_PUSH_SV:
		i=(signed char)(*ctx->ip++);
		BS1_JIT_Push(ctx, FIXNUM(i));
		break;
	case BS1_SOP_PUSH_SV_P:
		i=*ctx->ip++;
		BS1_JIT_Push(ctx, FIXNUM(i));
		break;
	case BS1_SOP_PUSH_SV_N:
		i=*ctx->ip++;
		BS1_JIT_Push(ctx, FIXNUM(-i));
		break;
	case BS1_SOP_PUSH_SV_F:
		i=*ctx->ip++;
		i+=(*ctx->ip++)<<8;
		BS1_JIT_Push(ctx, FLONUM(((short)i)/100.0));
		break;

	case BS1_SOP_PUSH_0: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_0); break;
	case BS1_SOP_PUSH_1: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_1); break;
	case BS1_SOP_PUSH_2: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_2); break;
	case BS1_SOP_PUSH_3: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_3); break;
	case BS1_SOP_PUSH_4: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_4); break;
	case BS1_SOP_PUSH_5: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_5); break;
	case BS1_SOP_PUSH_6: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_6); break;
	case BS1_SOP_PUSH_7: BS1_JIT_Push(ctx, BS1_MM_FIXNUM_7); break;
	case BS1_SOP_PUSH_CF: BS1_JIT_Push(ctx, ctx->func); break;

	case BS1_SOP_LLOAD:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword %d;\n", *ctx->ip++);
		basm_print("push esi; call LookupIdx; add esp, 8;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_LSTORE:
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d;\n", *ctx->ip++);
		basm_print("push esi; call AssignIdx; add esp, 12;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_LLOAD_F:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword %d;\n", *ctx->ip++);
		basm_print("push esi; call LookupIdx; add esp, 8;\n");
		BS1_JIT_PushEAX_F(ctx);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_LSTORE_F:
		BS1_JIT_PopToArgF(ctx);
		basm_print("push dword %d;\n", *ctx->ip++);
		basm_print("push esi; call AssignIdxF; add esp, 12;\n");
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_LLOAD_F2:
		if(ctx->fl&BS1_JITFL_EAX)
			basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");
		i=*ctx->ip++;
		if(!(ctx->fl&BS1_JITFL_ECX_EARG))
		{
			basm_print("mov ecx, [esi+%d]; ", JIT_OFFS(eargs));
			ctx->fl|=BS1_JITFL_ECX_EARG;
		}
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		BS1_JIT_PushEAX_F(ctx);
		break;
	case BS1_SOP_LSTORE_F2:
		i=*ctx->ip++;
		BS1_JIT_PopEAX_F(ctx);
		if(!(ctx->fl&BS1_JITFL_ECX_EARG))
		{
			basm_print("mov ecx, [esi+%d]; ", JIT_OFFS(eargs));
			ctx->fl|=BS1_JITFL_ECX_EARG;
		}
		basm_print("mov [edi+ecx*4-%d], eax;\n", (i+1)*4);
		break;

	case BS1_SOP_LINC_FN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("push dword %d;\n", i);
		basm_print("push esi; call LookupIdxF; add esp, 8;\n");
		basm_print("add, eax, 4;\n");
		basm_print("push eax; push dword %d;\n", i);
		basm_print("push esi; call AssignIdxF; add esp, 12;\n");
		break;
	case BS1_SOP_LDEC_FN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("push dword %d;\n", i);
		basm_print("push esi; call LookupIdxF; add esp, 8;\n");
		basm_print("sub, eax, 4;\n");
		basm_print("push eax; push dword %d;\n", i);
		basm_print("push esi; call AssignIdxF; add esp, 12;\n");
		break;

	case BS1_SOP_LINC_FN2:
//		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		if(!(ctx->fl&BS1_JITFL_ECX_EARG))
		{
			basm_print("mov ecx, [esi+%d]; ", JIT_OFFS(eargs));
			ctx->fl|=BS1_JITFL_ECX_EARG;
		}
		basm_print("add dword [edi+ecx*4-%d], 4;\n", (i+1)*4);
		break;
	case BS1_SOP_LDEC_FN2:
//		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		if(!(ctx->fl&BS1_JITFL_ECX_EARG))
		{
			basm_print("mov ecx, [esi+%d]; ", JIT_OFFS(eargs));
			ctx->fl|=BS1_JITFL_ECX_EARG;
		}
		basm_print("add dword [edi+ecx*4-%d], 4;\n", (i+1)*4);
		break;

	case BS1_SOP_CLEARENV: break;
	case BS1_SOP_BINDPATTERN: break;
	case BS1_SOP_LOADMINDEX: break;
	case BS1_SOP_STOREMINDEX: break;

	case BS1_SOP_TRYLOAD:
		break;

	case BS1_SOP_CAST:
		break;

	case BS1_SOP_MARK:
		BS1_JIT_FlattenStack(ctx);
		basm_print("mov ecx, [esi+%d]; ", JIT_OFFS(markstackpos));
		basm_print("mov edx, [esi+%d];\n", JIT_OFFS(markstack));
		basm_print("mov [edx+ecx*4], ebx; ");
		basm_print("inc dword [esi+%d];\n", JIT_OFFS(markstackpos));
	break;

	case BS1_SOP_CALL:	BS1_JIT_Call(ctx); break;
	case BS1_SOP_TAILCALL:	BS1_JIT_TailCall(ctx); break;
	case BS1_SOP_CALL_S:
		t=BS1_JIT_ReadID(ctx); BS1_JIT_CallS(ctx, t); break;
	case BS1_SOP_TAILCALL_S:
		t=BS1_JIT_ReadID(ctx); BS1_JIT_TailCallS(ctx, t); break;

	case BS1_SOP_METHODCALL:	BS1_JIT_MethodCall(ctx); break;
	case BS1_SOP_METHODTAILCALL:	BS1_JIT_MethodTailCall(ctx); break;
	case BS1_SOP_METHODCALL_S:
		t=BS1_JIT_ReadID(ctx); BS1_JIT_MethodCallS(ctx, t); break;
	case BS1_SOP_METHODTAILCALL_S:
		t=BS1_JIT_ReadID(ctx); BS1_JIT_MethodTailCallS(ctx, t); break;

	case BS1_SOP_CALL_CF:		BS1_JIT_CallCF(ctx); break;
	case BS1_SOP_TAILCALL_CF:	BS1_JIT_TailCallCF(ctx); break;

	case BS1_SOP_RET:	BS1_JIT_Return(ctx); break;

	case BS1_SOP_CAR:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call GetCar;\n"
			"call incref; mov [edi+ebx*4-4], eax;\n"
			"pop eax; call checkref;\n");
		break;
	case BS1_SOP_CDR:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call GetCdr;\n"
			"call incref; mov [edi+ebx*4-4], eax;\n"
			"pop eax; call checkref;\n");
		break;
	case BS1_SOP_CAAR:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call GetCaar;\n"
			"call incref; mov [edi+ebx*4-4], eax;\n"
			"pop eax; call checkref;\n");
		break;
	case BS1_SOP_CDAR:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call GetCdar;\n"
			"call incref; mov [edi+ebx*4-4], eax;\n"
			"pop eax; call checkref;\n");
		break;
	case BS1_SOP_CADR:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call GetCadr;\n"
			"call incref; mov [edi+ebx*4-4], eax;\n"
			"pop eax; call checkref;\n");
		break;
	case BS1_SOP_CDDR:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call GetCddr;\n"
			"call incref; mov [edi+ebx*4-4], eax;\n"
			"pop eax; call checkref;\n");
		break;

	case BS1_SOP_CLOSE:
//		basm_print("push dword [edi+ebx*4-4]; call SafeDecRef; call Close;\n"
//			"pop ecx; call incref; mov [edi+ebx*4-4], eax;\n");
		BS1_JIT_PopToArg(ctx);
		basm_print("call Close;\n");
		BS1_JIT_PushEAX(ctx);
		break;

	case BS1_SOP_DUP:
//		basm_print("mov eax, [edi+ebx*4-4]; call incref;\n"
//			"mov [edi+ebx*4], eax; inc_r ebx;\n");
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PushEAX_F(ctx);
		BS1_JIT_FlattenStack(ctx);
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_DUP_F:
//		basm_print("mov eax, [edi+ebx*4-4]; mov [edi+ebx*4], eax; inc_r ebx;\n");
		BS1_JIT_PopEAX_F(ctx);
		BS1_JIT_PushEAX_F(ctx);
		basm_print("mov [edi+ebx*4], eax; inc_r ebx;\n");
		BS1_JIT_PushEAX_F(ctx);
		break;
	case BS1_SOP_EXCH:
//		BS1_JIT_FlattenStack(ctx);
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("xchg eax, [edi+ebx*4-4];\n");
			break;
		}

		basm_print("mov eax, [edi+ebx*4-4]; mov edx, [edi+ebx*4-8];\n"
			"mov [edi+ebx*4-8], eax; mov [edi+ebx*4-4], edx;\n");
		break;
	case BS1_SOP_INDEX:
		BS1_JIT_FlattenStack(ctx);
		i=BS1_JIT_ReadIDX(ctx);
		basm_print("mov eax, [edi+ebx*4-%d];\n"
			"mov [edi+ebx*4], eax; inc_r ebx;\n", (i+1)*4);
		BS1_JIT_IncRef(ctx);
		break;
	case BS1_SOP_RINDEX:
		BS1_JIT_FlattenStack(ctx);
		i=BS1_JIT_ReadIDX(ctx);
		basm_print("mov eax, [esi+%d]; mov ecx, [esi+%d]; dec ecx;\n"
			"mov edx, [eax+ecx*4]; add edx, %d;\n",
				JIT_OFFS(markstack),
				JIT_OFFS(markstackpos), i);
		basm_print("mov ecx, [esi+%d]; mov eax, [ecx+edx*4];\n",
			JIT_OFFS(stack));
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_SETINDEX:
		BS1_JIT_FlattenStack(ctx);
		i=BS1_JIT_ReadIDX(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; "
			"mov [edi+ebx*4-%d], eax;\n",
				(i+1)*4);
		break;
	case BS1_SOP_SETRINDEX:
		BS1_JIT_FlattenStack(ctx);
		i=BS1_JIT_ReadIDX(ctx);
		basm_print("mov eax, [esi+%d]; mov ecx, [esi+%d]; dec ecx;\n"
			"mov edx, [eax+ecx*4]; add edx, %d;\n",
				JIT_OFFS(markstack),
				JIT_OFFS(markstackpos), i);
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(stack));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("mov [ecx+edx*4], eax;\n");
		break;

	case BS1_SOP_DUP_R:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [edi+ebx*4-4]; call incref;\n"
			"mov [esi+%d], eax;\n", JIT_OFFS(reg)+i*4);
		break;
	case BS1_SOP_DUP_RF:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [edi+ebx*4-4]; mov [esi+%d], eax;\n",
			JIT_OFFS(reg)+i*4);
		break;
	case BS1_SOP_PUSH_R:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [esi+%d]; call incref;\n"
			"mov [edi+ebx*4], eax; inc_r ebx;\n", JIT_OFFS(reg)+i*4);
		break;
	case BS1_SOP_PUSH_RF:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [esi+%d]; mov [edi+ebx*4], eax; inc_r ebx;\n",
			JIT_OFFS(reg)+i*4);
		break;
	case BS1_SOP_POP_R:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; mov [esi+%d], eax;\n",
			JIT_OFFS(reg)+i*4);
		break;

	case BS1_SOP_UNARYOP:
		i=*ctx->ip++;
		BS1_JIT_PopToArg(ctx);
		basm_print("push dword %d; push esi;\n"
			"call Unary; add esp, 12;\n", i);
		BS1_JIT_PushEAX(ctx);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_BINARYOP:
		i=*ctx->ip++;
		BS1_JIT_PopToArg(ctx);
		BS1_JIT_PopToArg(ctx);
		basm_print("push dword %d; push esi; call Binary; add esp, 16;\n", i);
		BS1_JIT_PushEAX(ctx);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_JMP:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8; i=((signed short)i);
		s=BS1_JIT_GetLabel(ctx, ctx->ip+i);
		basm_print("jmp %s;\n", s);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_TRUE:
//		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8; i=((signed short)i);

		s=BS1_JIT_GetLabel(ctx, ctx->ip+i);
		s1=BS1_JIT_GenSym(); s2=BS1_JIT_GenSym();

		BS1_JIT_PopEAX(ctx);
		basm_print("cmp eax, 0x%x; je_b %s;\n", BS1_MM_NULL, s1);
		basm_print("cmp eax, 0x%x; je_b %s;\n", BS1_MM_FALSE, s1);
		basm_print("cmp eax, 0x%x; je_b %s;\n", BS1_MM_FIXNUM_0, s1);
		basm_print("jmp_b %s; %s: jmp %s; %s: ", s2, s1, s, s2);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_FALSE:
//		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8; i=((signed short)i);
		s=BS1_JIT_GetLabel(ctx, ctx->ip+i);

		BS1_JIT_PopEAX(ctx);
		basm_print("cmp eax, 0x%x; je %s;\n", BS1_MM_NULL, s);
		basm_print("cmp eax, 0x%x; je %s;\n", BS1_MM_FALSE, s);
		basm_print("cmp eax, 0x%x; je %s;\n", BS1_MM_FIXNUM_0, s);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_JMP_COND_U:
//		BS1_JIT_FlattenStack(ctx);

		j=*ctx->ip++;
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);

//		j=BS1_Opr_CondUnary(j, BS1_SVM_Pop(ctx));

		s=BS1_JIT_GetLabel(ctx, ctx->ip+i);
		BS1_JIT_PopToArg(ctx);
		basm_print("push dword %d; call CondUnary;\n"
			"add esp, 8;\n", j);
		basm_print("or eax, eax; jnz %s;\n", s);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_COND_B:
//		BS1_JIT_FlattenStack(ctx);

		j=*ctx->ip++;
//		j=BS1_Opr_CondBinary(j, u, v);
		i=*ctx->ip++;
		i|=(*ctx->ip++)<<8;
		i=((signed short)i);
		s=BS1_JIT_GetLabel(ctx, ctx->ip+i);

		BS1_JIT_PopToArg(ctx);
		BS1_JIT_PopToArg(ctx);
		basm_print("push dword %d; call CondBinary; add esp, 12;\n", j);
		basm_print("or eax, eax; jnz %s;\n", s);
		ctx->fl&=~BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_LIST:
		BS1_JIT_AdjustStack(ctx);
		basm_print("call PopList2;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_DICT:
		BS1_JIT_AdjustStack(ctx);
		basm_print("call PopDict;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_VECTOR:
		BS1_JIT_AdjustStack(ctx);
		basm_print("call PopVector;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_COMPLEX_I:
		BS1_JIT_AdjustStack(ctx);
		basm_print("call PopComplexI;\n");
		BS1_JIT_PushEAX(ctx);
		break;
	case BS1_SOP_MATRIX:
		BS1_JIT_AdjustStack(ctx);
		basm_print("call PopMatrix;\n");
		BS1_JIT_PushEAX(ctx);
		break;

	case BS1_SOP_INC_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("add eax, 4;\n");
			break;
		}
		basm_print("add dword [edi+ebx*4-4], 4;\n");
		break;
	case BS1_SOP_DEC_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("sub eax, 4;\n");
			break;
		}
		basm_print("sub dword [edi+ebx*4-4], 4;\n");
		break;
	case BS1_SOP_INC2_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("add eax, 8;\n");
			break;
		}
		basm_print("add dword [edi+ebx*4-4], 8;\n");
		break;
	case BS1_SOP_DEC2_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("sub eax, 8;\n");
			break;
		}
		basm_print("sub dword [edi+ebx*4-4], 8;\n");
		break;

	case BS1_SOP_ADD_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("and al, 0xFC; add [edi+ebx*4-4], eax;\n");
			ctx->fl&=~BS1_JITFL_EAX;
			break;
		}
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n"
			"and al, 0xFC; add [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_SUB_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("and al, 0xFC; sub [edi+ebx*4-4], eax;\n");
			ctx->fl&=~BS1_JITFL_EAX;
			break;
		}
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n"
			"and al, 0xFC; sub [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_MUL_FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"sar eax, 2; sar ecx, 2; xor edx, edx; imul ecx;\n"
			"shl eax, 2; or eax, 2; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_DIV_FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call DivFn; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_IDIV_FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"sar eax, 2; sar ecx, 2; xor edx, edx; idiv ecx;\n"
			"shl eax, 2; or eax, 2; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_MOD_FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"sar eax, 2; sar ecx, 2; xor edx, edx; idiv ecx;\n"
			"shl edx, 2; or edx, 2; mov [edi+ebx*4-4], edx;\n");
		break;
	case BS1_SOP_AND_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("and [edi+ebx*4-4], eax;\n");
			ctx->fl&=~BS1_JITFL_EAX;
			break;
		}
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; and [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_OR_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("or [edi+ebx*4-4], eax;\n");
			ctx->fl&=~BS1_JITFL_EAX;
			break;
		}
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; or [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_XOR_FN:
		if(ctx->fl&BS1_JITFL_EAX)
		{
			basm_print("and al, 0xFC; xor [edi+ebx*4-4], eax;\n");
			ctx->fl&=~BS1_JITFL_EAX;
			break;
		}
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n"
			"and al, 0xFC; xor [edi+ebx*4-4], eax;\n");
		break;

	case BS1_SOP_CMP_L_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"cmp eax, ecx; jge_b %s; mov eax, 0x%x; jmp_b %s;\n"
			"%s: mov eax, 0x%x; %s: mov [edi+ebx*4-4], eax;\n",
				s, BS1_MM_TRUE, s1, s, BS1_MM_FALSE, s1);
		break;
	case BS1_SOP_CMP_G_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"cmp eax, ecx; jle_b %s; mov eax, 0x%x; jmp_b %s;\n"
			"%s: mov eax, 0x%x; %s: mov [edi+ebx*4-4], eax;\n",
				s, BS1_MM_TRUE, s1, s, BS1_MM_FALSE, s1);
		break;
	case BS1_SOP_CMP_LE_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"cmp eax, ecx; jg_b %s; mov eax, 0x%x; jmp_b %s;\n"
			"%s: mov eax, 0x%x; %s: mov [edi+ebx*4-4], eax;\n",
				s, BS1_MM_TRUE, s1, s, BS1_MM_FALSE, s1);
		break;
	case BS1_SOP_CMP_GE_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"cmp eax, ecx; jl_b %s; mov eax, 0x%x; jmp_b %s;\n"
			"%s: mov eax, 0x%x; %s: mov [edi+ebx*4-4], eax;\n",
				s, BS1_MM_TRUE, s1, s, BS1_MM_FALSE, s1);
		break;
	case BS1_SOP_CMP_E_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"cmp eax, ecx; jne_b %s; mov eax, 0x%x; jmp_b %s;\n"
			"%s: mov eax, 0x%x; %s: mov [edi+ebx*4-4], eax;\n",
				s, BS1_MM_TRUE, s1, s, BS1_MM_FALSE, s1);
		break;
	case BS1_SOP_CMP_NE_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"cmp eax, ecx; je_b %s; mov eax, 0x%x; jmp_b %s;\n"
			"%s: mov eax, 0x%x; %s: mov [edi+ebx*4-4], eax;\n",
				s, BS1_MM_TRUE, s1, s, BS1_MM_FALSE, s1);
		break;

	case BS1_SOP_ADD_FN_C:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("add dword [edi+ebx*4-4], %d;\n", i<<2);
		break;
	case BS1_SOP_SUB_FN_C:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("sub dword [edi+ebx*4-4], %d;\n", i<<2);
		break;
	case BS1_SOP_MUL_FN_C:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [edi+ebx*4-4]; and al, 0xFC; imul eax, %d;\n"
			"or eax, 2; mov [edi+ebx*4-4], eax;\n", i);
		break;

	case BS1_SOP_SHL_FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"sar eax, 2; sar ecx, 2; shl eax, cl;\n"
			"shl eax, 2; or eax, 2; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_SHR_FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; mov eax, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"sar eax, 2; sar ecx, 2; sar eax, cl;\n"
			"shl eax, 2; or eax, 2; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_EXP_FN:
		BS1_JIT_FlattenStack(ctx);
		s=BS1_JIT_GenSym(); s1=BS1_JIT_GenSym();
		basm_print("dec_r ebx; mov edx, [edi+ebx*4-4]; mov ecx, [edi+ebx*4];\n"
			"sar edx, 2; sar ecx, 2; mov eax, 1;\n"
			"%s: or ecx, ecx; jz_b %s; imul eax, edx; jmp_b %s;\n"
			"%s: shl eax, 2; or eax, 2; mov [edi+ebx*4-4], eax;\n",
			s, s1, s, s1);
		break;

	case BS1_SOP_SHL_FN_C:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [edi+ebx*4-4]; sar eax, 2; shl eax, %d;\n"
			"or eax, 2; mov [edi+ebx*4-4], eax;\n", i+2);
		break;
	case BS1_SOP_SHR_FN_C:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov eax, [edi+ebx*4-4]; sar eax, %d; shl eax, 2;\n"
			"or eax, 2; mov [edi+ebx*4-4], eax;\n", i+2);
		break;
	case BS1_SOP_EXP_FN_C:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++;
		basm_print("mov edx, [edi+ebx*4-4]; sar edx, 2; mov eax, 1;\n");
		while(i--)basm_print("imul eax, edx;\n");
		basm_print("shl eax, 2; or eax, 2; mov [edi+ebx*4-4], eax;\n");
		break;


	case BS1_SOP_CONV_FN2FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call ConvFnFl; pop edx;\n"
			" mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CONV_FL2FN:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call ConvFlFn; pop edx;\n"
			" mov [edi+ebx*4-4], eax;\n");
		break;

	case BS1_SOP_ADD_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call AddFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_SUB_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call SubFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_MUL_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call MulFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_DIV_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call DivFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CMP_L_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call CmpLFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CMP_G_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call CmpGFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CMP_LE_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call CmpLeFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CMP_GE_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call CmpGeFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CMP_E_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call CmpEFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_CMP_NE_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("dec_r ebx; push dword [edi+ebx*4]; push dword [edi+ebx*4-4];\n"
			"call CmpNeFl; add esp, 8; mov [edi+ebx*4-4], eax;\n");
		break;
	case BS1_SOP_NEG_FL:
		BS1_JIT_FlattenStack(ctx);
		basm_print("push dword [edi+ebx*4-4]; call NegFl; pop edx;\n"
			" mov [edi+ebx*4-4], eax;\n");
		break;

	case BS1_SOP_JMP_L_FN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; mov eax, [edi+ebx*4];\n"
			"cmp eax, [edi+ebx*4+4]; jl %s;\n", s);
		break;

	case BS1_SOP_JMP_G_FN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; mov eax, [edi+ebx*4];\n"
			"cmp eax, [edi+ebx*4+4]; jg %s;\n", s);
		break;
	case BS1_SOP_JMP_LE_FN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; mov eax, [edi+ebx*4];\n"
			"cmp eax, [edi+ebx*4+4]; jle %s;\n", s);
		break;
	case BS1_SOP_JMP_GE_FN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; mov eax, [edi+ebx*4];\n"
			"cmp eax, [edi+ebx*4+4]; jge %s;\n", s);
		break;

	case BS1_SOP_JMP_L_FL:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; push dword [edi+ebx*4+4]; push dword [edi+ebx*4];\n"
			"call CmpLFl; add esp, 8; or eax, eax; jnz %s;\n", s);
		break;
	case BS1_SOP_JMP_G_FL:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; push dword [edi+ebx*4+4]; push dword [edi+ebx*4];\n"
			"call CmpGFl; add esp, 8; or eax, eax; jnz %s;\n", s);
		break;
	case BS1_SOP_JMP_LE_FL:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; push dword [edi+ebx*4+4]; push dword [edi+ebx*4];\n"
			"call CmpLeFl; add esp, 8; or eax, eax; jnz %s;\n", s);
		break;
	case BS1_SOP_JMP_GE_FL:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("sub ebx, 2; push dword [edi+ebx*4+4]; push dword [edi+ebx*4];\n"
			"call CmpGeFl; add esp, 8; or eax, eax; jnz %s;\n", s);
		break;

	case BS1_SOP_JMP_E_LFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; j=*ctx->ip++;
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		basm_print("cmp eax, [edi+ecx*4-%d];\n", (j+1)*4);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("je %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_NE_LFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; j=*ctx->ip++;
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		basm_print("cmp eax, [edi+ecx*4-%d];\n", (j+1)*4);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("jne %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_JMP_L_LFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; j=*ctx->ip++;
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		basm_print("cmp eax, [edi+ecx*4-%d];\n", (j+1)*4);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("jl %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_G_LFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; j=*ctx->ip++;
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		basm_print("cmp eax, [edi+ecx*4-%d];\n", (j+1)*4);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("jg %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_LE_LFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; j=*ctx->ip++;
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		basm_print("cmp eax, [edi+ecx*4-%d];\n", (j+1)*4);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("jle %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_GE_LFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; j=*ctx->ip++;
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (i+1)*4);
		basm_print("cmp eax, [edi+ecx*4-%d];\n", (j+1)*4);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("jge %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;

	case BS1_SOP_JMP_E_ZFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("je %s;\n", s);
		break;
	case BS1_SOP_JMP_NE_ZFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jne %s;\n", s);
		break;
	case BS1_SOP_JMP_L_ZFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jl %s;\n", s);
		break;
	case BS1_SOP_JMP_G_ZFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jg %s;\n", s);
		break;
	case BS1_SOP_JMP_LE_ZFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jle %s;\n", s);
		break;
	case BS1_SOP_JMP_GE_ZFN:
		BS1_JIT_FlattenStack(ctx);
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4];\n");
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jge %s;\n", s);
		break;

	case BS1_SOP_JMP_E_LZFN:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("je %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_NE_LZFN:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jne %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_L_LZFN:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jl %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_G_LZFN:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jg %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_LE_LZFN:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jle %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_GE_LZFN:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", BS1_MM_FIXNUM_0);
		basm_print("jge %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;


	case BS1_SOP_JMP_E_FNC:
		BS1_JIT_FlattenStack(ctx);
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; cmp eax, 0x%x;\n"
			"je %s;\n", t, s);
		break;
	case BS1_SOP_JMP_NE_FNC:
		BS1_JIT_FlattenStack(ctx);
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; cmp eax, 0x%x;\n"
			"jne %s;\n", t, s);
		break;
	case BS1_SOP_JMP_L_FNC:
		BS1_JIT_FlattenStack(ctx);
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; cmp eax, 0x%x;\n"
			"jl %s;\n", t, s);
		break;
	case BS1_SOP_JMP_G_FNC:
		BS1_JIT_FlattenStack(ctx);
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; cmp eax, 0x%x;\n"
			"jg %s;\n", t, s);
		break;
	case BS1_SOP_JMP_LE_FNC:
		BS1_JIT_FlattenStack(ctx);
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; cmp eax, 0x%x;\n"
			"jle %s;\n", t, s);
		break;
	case BS1_SOP_JMP_GE_FNC:
		BS1_JIT_FlattenStack(ctx);
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("dec_r ebx; mov eax, [edi+ebx*4]; cmp eax, 0x%x;\n"
			"jge %s;\n", t, s);
		break;

	case BS1_SOP_JMP_E_LFNC:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", t);
		basm_print("je %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_NE_LFNC:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", t);
		basm_print("jne %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_L_LFNC:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", t);
		basm_print("jl %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_G_LFNC:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", t);
		basm_print("jg %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_LE_LFNC:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", t);
		basm_print("jle %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;
	case BS1_SOP_JMP_GE_LFNC:
		BS1_JIT_FlattenStack(ctx);
		j=*ctx->ip++;
		t=FIXNUM((signed char)(*ctx->ip++));
		i=*ctx->ip++; i|=(*ctx->ip++)<<8;
		s=BS1_JIT_GetLabel(ctx, ctx->ip+((signed short)i));
		basm_print("mov ecx, [esi+%d];\n", JIT_OFFS(eargs));
		basm_print("mov eax, [edi+ecx*4-%d];\n", (j+1)*4);
		basm_print("cmp eax, 0x%x;\n", t);
		basm_print("jge %s;\n", s);
		ctx->fl|=BS1_JITFL_ECX_EARG;
		break;

	default:
		break;
	}

	basm_print("\n");

	return(0);
}


void BS1_JIT_CompileBlock(elem blk)
{
	BS1_JitContext *ctx;
	BS1_SVMBlock *fcn;
	byte *ip;
	char *buf;

	BS1_JIT_Init();


	fcn=BS1_TY_GetObjData(blk);

	//don't bother with top-level expressions or anonymous closures
	if(!BS1_SYMBOLP(fcn->name))
		return;

	SET(fcn->th_name, SYM(BS1_JIT_GenSym()));

	ctx=bs1_jit_ctx;
	ctx->lit=fcn->lit;
	ctx->args=fcn->args;
	ctx->local=BS1_MM_NULL;
	ctx->func=blk;
	ctx->blk=fcn;	//counter-intuitive...

	ctx->n_lbl=0;

	ctx->ip=fcn->body;
	while(ctx->ip<(fcn->body+fcn->szbody))
		BS1_JIT_PreStep(ctx);

	BASM_BeginAssembly(BS1_TOSYM(fcn->th_name));
//	ip=BASM_GetIP();

	basm_print("; Func '%s'->'%s'\n",
		BS1_TOSYM(fcn->name), BS1_TOSYM(fcn->th_name));
	basm_print("%s:\n", BS1_TOSYM(fcn->th_name));
	BS1_JIT_Entry(ctx);
	basm_print("\n");

	ctx->ip=fcn->body;
	while(ctx->ip<(fcn->body+fcn->szbody))
		BS1_JIT_Step(ctx);

	ip=BASM_EndAssembly();
	fcn->thunk=ip;
}

/* Autogenerated source */

char *bs1_tyh_strs[]={
"_",
"symbol",
"int",
"svmlambda",
"array",
"xlong",
"fmatrix",
"svmblk",
"svmctx",
"double",
"bytearray",
"char",
"complex",
"keyword",
"fvector",
"svmbuiltin",
"cons",
"string",
"float",
"svmfixed",
"long",
"handle",
"rational",
"object",
""};

int bs1_tyh_idx[]={
0x005E,
0x02DC,
0x0865,
0x1657,
0x488C,
0x5017,
0x6899,
0x6D09,
0x6EC9,
0x8BAE,
0x94AD,
0xA2DF,
0xA5DD,
0xA937,
0xB1EB,
0xB305,
0xB3CF,
0xBE22,
0xCCA1,
0xD87B,
0xD92E,
0xDB3E,
0xE651,
0xEA6F,
0};
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

elem *bs1_mm_blockd[BS1_MM_MAXBLK];
byte *bs1_mm_blockm[BS1_MM_MAXBLK];
int bs1_mm_n_blocks;		//number of blocks

int bs1_mm_r_block;		//block rover
int bs1_mm_r_cell;		//cell rover

elem *bs1_mm_lobj[BS1_MM_MAXLOBJ];
int bs1_mm_lobjsz[BS1_MM_MAXLOBJ];
int bs1_mm_lobjhd[BS1_MM_MAXLOBJ];
int bs1_mm_n_lobj;		//number of blocks

void *BS1_MM_RAlloc(int sz)
{
	static char buf[1<<20];
	static int pos=0;
	char *s;
	if((pos+sz)>(1<<20))pos=0;
	s=buf+pos;
	pos+=sz;
	return((void *)s);
}

char *BS1_RStrDup(char *s)
{
	char *t;

	t=(char *)BS1_MM_RAlloc(strlen(s)+1);
	strcpy(t, s);
	return(t);
}

void BS1_StrCpy(char *t, char *s)
{
	char *s1, *t1;
	if(t>s)
	{
		s1=s+strlen(s)+1;
		t1=t+strlen(s)+1;
		while(s1>=s)*t1--=*s1--;
		return;
	}

	while(*s)*t++=*s++;
	*t++=0;
}

int BS1_MM_AddBlock()
{
	elem *td;
	byte *tm;

	elem t;
	int i;

	if(bs1_mm_n_blocks>=BS1_MM_MAXBLK)
		return(-1);

	printf("Add Block\n");

	i=bs1_mm_n_blocks++;

#if 0
	bs1_mm_blockd[i]=malloc((BS1_MM_BLKCELLS+1)*2*sizeof(elem));
	t=(elem)(bs1_mm_blockd[i]);
	if(t&7)
	{
		bs1_mm_blockd[i]=(elem *)((t+7)&(~7));
	}
#endif

	bs1_mm_blockd[i]=malloc(BS1_MM_BLKCELLS*2*sizeof(elem));

	bs1_mm_blockm[i]=malloc(BS1_MM_BLKCELLS);
	memset(bs1_mm_blockm[i], 0, BS1_MM_BLKCELLS);

	//insert sorted
	while((i>0) && (bs1_mm_blockd[i]<bs1_mm_blockd[i-1]))
	{
		td=bs1_mm_blockd[i-1];
		tm=bs1_mm_blockm[i-1];
		bs1_mm_blockd[i-1]=bs1_mm_blockd[i];
		bs1_mm_blockm[i-1]=bs1_mm_blockm[i];
		bs1_mm_blockd[i]=td;
		bs1_mm_blockm[i]=tm;
		i--;
	}

	bs1_mm_r_block=i;
	bs1_mm_r_cell=0;

	return(0);
}

int BS1_MM_FindFreeCells(int num, int *ri, int *rj)
{
	int i, j, k, n;

	i=bs1_mm_r_block;
	j=bs1_mm_r_cell;
	n=2;

	if(!bs1_mm_n_blocks)return(-1);

	while(n)
	{
		while(j<BS1_MM_BLKCELLS)
		{
			for(k=j; k<BS1_MM_BLKCELLS; k++)
				if(!bs1_mm_blockm[i][k])
					break;
			j=k;

			for(k=j; k<BS1_MM_BLKCELLS; k++)
				if(bs1_mm_blockm[i][k])
					break;
			if((k-j)>=num)break;
			j=k;
		}

		if(j<BS1_MM_BLKCELLS)
		{
			*ri=i; *rj=j;

			j+=num;
			if(j>=BS1_MM_BLKCELLS)
			{
				i=(i+1)%bs1_mm_n_blocks;
				j=0;
			}
			bs1_mm_r_block=i;
			bs1_mm_r_cell=j;

			return(0);
		}

		if(i==bs1_mm_r_block)n--;
		i=(i+1)%bs1_mm_n_blocks;
		j=0;
	}

	return(-1);
}

elem BS1_MM_MultiCons(int num)
{
	elem t;
	int i, j, k, n;

	i=bs1_mm_r_block;
	j=bs1_mm_r_cell;
	n=2;
	t=BS1_MM_NULL;

	if(!bs1_mm_n_blocks)return(-1);

	while(n && (num>0))
	{
		while((j<BS1_MM_BLKCELLS) && (num>0))
		{
			for(k=j; k<BS1_MM_BLKCELLS; k++)
				if(!bs1_mm_blockm[i][k])
			{
				bs1_mm_blockm[i][k]=0x81;
				bs1_mm_blockd[i][k*2+0]=BS1_MM_NULL;
				bs1_mm_blockd[i][k*2+1]=t;
//				t=(elem)(bs1_mm_blockd[i]+k*2)|4;
				t=BS1_MM_ElemFromCell(i, k);
				num--;
				if(num<=0)break;
			}
			j=k;
		}

		if(j<BS1_MM_BLKCELLS)
		{
			bs1_mm_r_block=i;
			bs1_mm_r_cell=j;
			return(t);
		}

		if(i==bs1_mm_r_block)n--;
		i=(i+1)%bs1_mm_n_blocks;
		j=0;
	}

	bs1_mm_r_block=i;
	bs1_mm_r_cell=j;
	return(t);
}

elem BS1_MM_AllocCons()
{
	elem t;
	int i, j, k;

	k=BS1_MM_FindFreeCells(1, &i, &j);
	if(k)
	{
//		printf("retry cons\n");
		BS1_MM_AddBlock();
		BS1_MM_FindFreeCells(1, &i, &j);
	}

//	printf("alloc cons %d %d\n", i, j);

	bs1_mm_blockm[i][j]=0x81;
	bs1_mm_blockd[i][j*2+0]=BS1_MM_NULL;
	bs1_mm_blockd[i][j*2+1]=BS1_MM_NULL;

	t=BS1_MM_ElemFromCell(i, j);
	return(t);

//	return((elem)(bs1_mm_blockd[i]+j*2)|4);
}

elem BS1_MM_AllocObj(int ty, int sz)
{
	elem *p, t;
	int i, j, k, n;

	if(sz>=BS1_MM_MAXOBJ)
	{
		p=malloc(sz);

		for(i=0; i<bs1_mm_n_lobj; i++)
			if(!bs1_mm_lobj[i])
				break;
		if(i>=bs1_mm_n_lobj)
			i=bs1_mm_n_lobj++;

		bs1_mm_lobj[i]=p;
		bs1_mm_lobjsz[i]=sz;
		bs1_mm_lobjhd[i]=ty;

		return((i<<8)|BS1_MM_LOBJ);
//		return(((elem)p)|6);
	}

	n=(sz+sizeof(elem)+(2*sizeof(elem)-1))/(2*sizeof(elem));
	k=BS1_MM_FindFreeCells(n, &i, &j);
	if(k)
	{
		BS1_MM_AddBlock();
		BS1_MM_FindFreeCells(n, &i, &j);
	}

	for(k=0; k<n; k++)
		bs1_mm_blockm[i][j+k]=0x83;
	bs1_mm_blockm[i][j]=0x82;

	memset(&bs1_mm_blockd[i][j*2], 0, sz+sizeof(elem));
	bs1_mm_blockd[i][j*2+0]=ty|(sz<<16);

	t=BS1_MM_ElemFromCell(i, j);
	return(t);

//	return((elem)(bs1_mm_blockd[i]+j*2)|5);
}

elem BS1_MM_AllocObjA64(int ty, int sz)
{
	return(BS1_MM_AllocObj(ty, sz+4));
}

elem BS1_MM_AllocObjAPtr(int ty, int sz)
{
	if(sizeof(void *)==8)
		return(BS1_MM_AllocObj(ty, sz+4));
	return(BS1_MM_AllocObj(ty, sz));
}

elem BS1_MM_AllocObjName(char *ty, int sz)
{
	return(BS1_MM_AllocObj(BS1_TY_HashType(ty), sz));
}

elem BS1_MM_AllocObjNameAPtr(char *ty, int sz)
{
	return(BS1_MM_AllocObj(BS1_TY_HashType(ty), sz));
}

int BS1_MM_FindElemCell(elem t, int *ri, int *rj)
{
	elem *p;
	int i, j;

	if(((t&7)!=4) && ((t&7)!=5))
		return(-1);

	*ri=(t>>3)/BS1_MM_BLKCELLS;
	*rj=(t>>3)&(BS1_MM_BLKCELLS-1);
	return(0);

#if 0
	p=(elem *)(t&(~7));

	for(i=0; i<bs1_mm_n_blocks; i++)
	{
		j=p-bs1_mm_blockd[i];

		if(j<0)break;
		if(j>=BS1_MM_BLKCELLS)continue;

		*ri=i; *rj=j/2;
		return(0);
	}
	return(-1);
#endif
}

void BS1_MM_FindElemCell2(elem t, int *ri, int *rj)
{
	elem *p;
	int i, j;

	*ri=(t>>3)/BS1_MM_BLKCELLS;
	*rj=(t>>3)&(BS1_MM_BLKCELLS-1);
	return;

#if 0
	if(bs1_mm_n_blocks==1)
	{
		p=(elem *)(t&(~7));
		j=p-bs1_mm_blockd[0];
		*ri=0; *rj=j/2;
		return;
	}

	p=(elem *)(t&(~7));
	for(i=0; i<bs1_mm_n_blocks; i++)
	{
		j=p-bs1_mm_blockd[i];
		if(j<0)break;
		if(j>=(2*BS1_MM_BLKCELLS))continue;
		*ri=i; *rj=j/2;
		return;
	}
#endif
}

elem BS1_MM_ElemFromCell(int i, int j)
{
	elem t;

	t=BS1_MM_NULL;
	switch(bs1_mm_blockm[i][j]&3)
	{
	case 0: break;
	case 1:
		t=((i*BS1_MM_BLKCELLS+j)<<3)|4;
		break;
	case 2:
		t=((i*BS1_MM_BLKCELLS+j)<<3)|5;
		break;
	case 3: break;
	default: break;
	}
	return(t);
}

int BS1_MM_FindElemLObj(elem t)
{
	elem *p;
	int i, j;

	if((t&255)==BS1_MM_LOBJ)
		return(t>>8);
	return(-1);
}

int BS1_MM_FreeCells(int i, int j)
{
	int k;

	switch(bs1_mm_blockm[i][j]&3)
	{
	case 0: break;
	case 1:
		bs1_mm_blockm[i][j]=0;
		break;
	case 2:
		bs1_mm_blockm[i][j]=0;
		for(k=j+1; k<BS1_MM_BLKCELLS; k++)
		{
			if((bs1_mm_blockm[i][k]&3)!=3)
				break;
			bs1_mm_blockm[i][k]=0;
		}
		break;
	case 3: break;
	default: break;
	}
}

int BS1_MM_FreeObj(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)
	{
		i=BS1_MM_FindElemLObj(t);
		if(i>=0)
		{
			free(bs1_mm_lobj[i]);
			bs1_mm_lobj[i]=NULL;
			return(0);
		}

		return(k);
	}
	BS1_MM_FreeCells(i, j);
	return(0);
}

int BS1_MM_GetObjType(elem t)
{
	elem *p;
	int i, j;

	if((t&7)==5)
	{
//		p=(elem *)(t&(~7));
		p=BS1_TY_GetCellPtr(t);
		return(p[0]&0xFFFF);
	}
	if((t&255)==BS1_MM_LOBJ)
	{
		i=BS1_MM_FindElemLObj(t);
		return(bs1_mm_lobjhd[i]&0xFFFF);
	}
	return(-1);
}

int BS1_MM_GetObjSize(elem t)
{
	elem *p;
	int i, j;

	if((t&7)==5)
	{
//		p=(elem *)(t&(~7));
		p=BS1_TY_GetCellPtr(t);
		return((p[0]>>16)&0xFFFF);
	}
	if((t&255)==BS1_MM_LOBJ)
	{
		i=BS1_MM_FindElemLObj(t);
		return(bs1_mm_lobjsz[i]);
	}
	return(-1);
}

int BS1_MM_GetObjMark(elem t)
{
//	elem *p;
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)
	{
		i=BS1_MM_FindElemLObj(t);
		if(i>=0)
		{
			return((bs1_mm_lobjhd[i]>>16)&0xFF);
//			p=bs1_mm_lobj[i];
//			return(p[0]>>16);
		}

		return(k);
	}

	k=bs1_mm_blockm[i][j];
	return(k);
}

elem BS1_MM_GetPtrElem(void *ptr)
{
	elem *p, *q;
	int i, j;

//	j=(2*sizeof(elem))-1;
	p=(elem *)ptr;

	for(i=0; i<bs1_mm_n_blocks; i++)
	{
		j=p-bs1_mm_blockd[i];

		if(j<0)break;
		if(j>=(2*BS1_MM_BLKCELLS))continue;
		j/=2;

		while((j>0) && (bs1_mm_blockm[i][j]==3))
			j--;

		if(bs1_mm_blockm[i][j]==1)
//			return(((elem)(bs1_mm_blockd[i]+(j*2)))|4);
			return(((i*BS1_MM_BLKCELLS+j)<<3)|4);
		if(bs1_mm_blockm[i][j]==2)
//			return(((elem)(bs1_mm_blockd[i]+(j*2)))|5);
			return(((i*BS1_MM_BLKCELLS+j)<<3)|5);

		return(BS1_MM_NULL);
	}

	for(i=0; i<bs1_mm_n_lobj; i++)
	{
		j=(bs1_mm_lobjsz[i]+sizeof(elem)-1)/sizeof(elem);
		q=bs1_mm_lobj[i]+j;
		if((p>=bs1_mm_lobj[i]) && (p<q))
			return((i<<8)|BS1_MM_LOBJ);
//			return(((elem)bs1_mm_lobj[i])|6);
	}

	return(BS1_MM_NULL);
}

void *BS1_TY_GetElemPtr(elem t)
{
	int i, j;

//	if((t&7)==4)
//		return((void *)(t&(~7)));
//	if((t&7)==5)
//		return((void *)(((elem *)(t&(~7)))+1));

	if((t&7)==4)
	{
		i=(t>>3)/BS1_MM_BLKCELLS;
		j=(t>>3)&(BS1_MM_BLKCELLS-1);
		return((void *)(bs1_mm_blockd[i]+j*2));
	}
	if((t&7)==5)
	{
		i=(t>>3)/BS1_MM_BLKCELLS;
		j=(t>>3)&(BS1_MM_BLKCELLS-1);
		return((void *)(bs1_mm_blockd[i]+j*2+1));
	}

	if((t&255)==BS1_MM_LOBJ)
		return(bs1_mm_lobj[t>>8]);
	return(NULL);
}

void *BS1_TY_GetElemPtrA64(elem t)
{
	elem *ta;
	void *p;
	int i, j;

//	if((t&7)==4)
//		return((void *)(t&(~7)));
//	if((t&7)==5)
//	{
//		ta=(elem *)(t&(~7));
//		if(sizeof(elem)==4)
//			return((void *)(ta+2));
//		return((void *)(ta+1));
//	}

	if((t&7)==4)
	{
		i=(t>>3)/BS1_MM_BLKCELLS;
		j=(t>>3)&(BS1_MM_BLKCELLS-1);
		return((void *)(bs1_mm_blockd[i]+j*2));
	}
	if((t&7)==5)
	{
		i=(t>>3)/BS1_MM_BLKCELLS;
		j=(t>>3)&(BS1_MM_BLKCELLS-1);
		return((void *)(bs1_mm_blockd[i]+j*2+2));
	}

	if((t&255)==BS1_MM_LOBJ)
		return(bs1_mm_lobj[t>>8]);
	return(p);
}

elem *BS1_TY_GetCellPtr(elem t)
{
	int i, j;

//	i=(t>>3)/BS1_MM_BLKCELLS;
	i=t>>(BS1_MM_BLKBITS+3);
	j=(t>>3)&(BS1_MM_BLKCELLS-1);
	return(bs1_mm_blockd[i]+j*2);
}


int BS1_MM_HeapUsed()
{
	int i, j, k, l;

	l=0;
	for(i=0; i<bs1_mm_n_blocks; i++)
		for(j=0; j<BS1_MM_BLKCELLS; j++)
	{
		k=bs1_mm_blockm[i][j];
		if(k&3)l++;
	}
	return(l);
}

int BS1_MM_HeapFree()
{
	int i, j, k, l;

	l=0;
	for(i=0; i<bs1_mm_n_blocks; i++)
		for(j=0; j<BS1_MM_BLKCELLS; j++)
	{
		k=bs1_mm_blockm[i][j];
		if(!(k&3))l++;
	}
	return(l);
}

int BS1_MM_HeapSize()
{
	int i, j;

	j=0;
	for(i=0; i<bs1_mm_n_blocks; i++)
		j+=BS1_MM_BLKCELLS;
	return(j);
}
/* Autogenerated source */
/* OPS 202, W/Args 101, W/Flow 193 */

int bs1_ops_nops=294;

char *bs1_ops_strs[]={
"nop", "block", "dbgmark", "cgenast", "", "", "", "", "", "", "", 
"", "", "", "", "", "push", "pop", "load", "store", "bind", "dynbind", 
"lexbind", "loadindex", "storeindex", "pushself", "clearenv", "bindpattern", 
"loadmindex", "storemindex", "tryload", "cast", "mark", "call", "tailcall", 
"call_s", "tailcall_s", "methodcall", "methodtailcall", "methodcall_s", 
"methodtailcall_s", "ret", "pushenv", "popenv", "begincc", "beginobj", 
"frame", "", "dup", "exch", "index", "rindex", "setindex", "setrindex", 
"dup_f", "dup_r", "dup_rf", "push_r", "push_rf", "pop_r", "", "", 
"", "", "unaryop", "binaryop", "push_null", "push_true", "push_false", 
"push_sv", "push_0", "push_1", "push_2", "push_3", "push_4", "push_5", 
"push_6", "push_7", "push_cf", "call_cf", "tailcall_cf", "car", "cdr", 
"caar", "cdar", "cadr", "cddr", "push_sv_p", "push_sv_n", "push_sv_f", 
"lload", "lstore", "lload_f", "lstore_f", "lload_f2", "lstore_f2", 
"linc_fn", "ldec_fn", "linc_fn2", "ldec_fn2", "loadindex_s", "storeindex_s", 
"loadindex_i", "storeindex_i", "loadindex_0", "loadindex_1", "loadindex_2", 
"loadindex_3", "storeindex_0", "storeindex_1", "storeindex_2", "storeindex_3", 
"throw", "begintry", "endtry", "catch", "", "", "jmp", "jmp_true", 
"jmp_false", "jmp_cond_u", "jmp_cond_b", "", "", "", "", "", "array", 
"dict", "attr", "object", "vector", "terminal", "complex", "matrix", 
"list", "complex_i", "close", "close2", "flink", "", "", "", "inc_fn", 
"dec_fn", "inc2_fn", "dec2_fn", "add_fn", "sub_fn", "mul_fn", "div_fn", 
"idiv_fn", "mod_fn", "and_fn", "or_fn", "xor_fn", "cmp_l_fn", "cmp_g_fn", 
"cmp_le_fn", "cmp_ge_fn", "cmp_e_fn", "cmp_ne_fn", "neg_fn", "not_fn", 
"add_fn_c", "sub_fn_c", "mul_fn_c", "conv_fn2fl", "conv_fl2fn", "add_fl", 
"sub_fl", "mul_fl", "div_fl", "cmp_l_fl", "cmp_g_fl", "cmp_le_fl", 
"cmp_ge_fl", "cmp_e_fl", "cmp_ne_fl", "neg_fl", "jmp_e_fn", "jmp_ne_fn", 
"jmp_e_fl", "jmp_ne_fl", "shl_fn", "shr_fn", "exp_fn", "shl_fn_c", 
"shr_fn_c", "exp_fn_c", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "jmp_l_fn", "jmp_g_fn", "jmp_le_fn", "jmp_ge_fn", "jmp_l_fl", 
"jmp_g_fl", "jmp_le_fl", "jmp_ge_fl", "jmp_e_lfn", "jmp_ne_lfn", 
"jmp_l_lfn", "jmp_g_lfn", "jmp_le_lfn", "jmp_ge_lfn", "jmp_e_zfn", 
"jmp_ne_zfn", "jmp_l_zfn", "jmp_g_zfn", "jmp_le_zfn", "jmp_ge_zfn", 
"jmp_e_lzfn", "jmp_ne_lzfn", "jmp_l_lzfn", "jmp_g_lzfn", "jmp_le_lzfn", 
"jmp_ge_lzfn", "jmp_e_fnc", "jmp_ne_fnc", "jmp_l_fnc", "jmp_g_fnc", 
"jmp_le_fnc", "jmp_ge_fnc", "jmp_e_lfnc", "jmp_ne_lfnc", "jmp_l_lfnc", 
"jmp_g_lfnc", "jmp_le_lfnc", "jmp_ge_lfnc", ""};

char *bs1_ops_args[]={
"", "", "TW", "I", "", "", "", "", "", "", "", "", "", "", "", "", 
"I", "", "S", "S", "S", "S", "S", "", "", "", "", "", "", "", "S", 
"S", "", "", "", "S", "S", "", "", "S", "S", "", "", "", "A", "A", 
"A", "", "", "", "N", "N", "N", "N", "", "B", "B", "B", "B", "B", 
"", "", "", "", "u", "b", "", "", "", "C", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "B", "B", "H", "B", "B", 
"B", "B", "B", "B", "B", "B", "B", "B", "S", "S", "B", "B", "", "", 
"", "", "", "", "", "", "S", "", "", "SA", "", "", "A", "A", "A", 
"uA", "bA", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "B", "B", "B", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "A", "A", "A", "A", "", 
"", "", "B", "B", "B", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "A", "A", "A", "A", "A", "A", "A", "A", "BBA", "BBA", 
"BBA", "BBA", "BBA", "BBA", "A", "A", "A", "A", "A", "A", "BA", "BA", 
"BA", "BA", "BA", "BA", "CA", "CA", "CA", "CA", "CA", "CA", "BCA", 
"BCA", "BCA", "BCA", "BCA", "BCA", ""};

char *bs1_ops_sfis[]={
"=", "=", "=", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"=v", "v=", "=v", "v=", "v=", "v=", "v=", "vv=v", "vvv=", "=v", "=", 
"vv=", "", "", "=v", "v=v", "=", "M*v=v", "M*v=", "M*=v", "M*=", 
"M*vv=v", "M*vv=", "M*v=v", "M*v=", "v=", "=", "=", "=v", "=", "=", 
"", "x=xx", "xy=yx", "=v", "=v", "v=", "v=", "x=xx", "v=v", "v=v", 
"=v", "=v", "v=", "", "", "", "", "v=v", "vv=v", "=v", "=v", "=v", 
"=i", "=i", "=i", "=i", "=i", "=i", "=i", "=i", "=i", "=v", "M*=v", 
"M*=", "v=v", "v=v", "v=v", "v=v", "v=v", "v=v", "=i", "=i", "=f", 
"=v", "=v", "=v", "=v", "=v", "=v", "=", "=", "=", "=", "v=v", "vv=", 
"v=v", "vv=", "v=v", "v=v", "v=v", "v=v", "vv=", "vv=", "vv=", "vv=", 
"", "", "", "", "", "", "=", "v=", "v=", "v=", "vv=", "", "", "", 
"", "", "M*=v", "M*=v", "vv=v", "M*=v", "M*=v", "", "", "M*=v", "M*=v", 
"f=f", "v=v", "v=v", "vv=v", "", "", "", "i=i", "i=i", "i=i", "i=i", 
"ii=i", "ii=i", "ii=i", "ii=i", "ii=i", "ii=i", "ii=i", "ii=i", "ii=i", 
"ii=b", "ii=b", "ii=b", "ii=b", "ii=b", "ii=b", "i=i", "i=i", "i=i", 
"i=i", "i=i", "i=f", "f=i", "ff=f", "ff=f", "ff=f", "ff=f", "ff=b", 
"ff=b", "ff=b", "ff=b", "ff=b", "ff=b", "f=f", "ii=", "ii=", "ff=", 
"ff=", "ii=i", "ii=i", "ii=i", "i=i", "i=i", "i=i", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "ii=", "ii=", "ii=", "ii=", 
"ff=", "ff=", "ff=", "ff=", "=", "=", "=", "=", "=", "=", "i=", "i=", 
"i=", "i=", "i=", "i=", "=", "=", "=", "=", "=", "=", "i=", "i=", 
"i=", "i=", "i=", "i=", "=", "=", "=", "=", "=", "=", ""};

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

// #define BS1_GC_NOREFS

extern elem *bs1_mm_blockd[BS1_MM_MAXBLK];
extern byte *bs1_mm_blockm[BS1_MM_MAXBLK];
extern int bs1_mm_n_blocks;		//number of blocks

extern elem *bs1_mm_lobj[BS1_MM_MAXLOBJ];
extern int bs1_mm_lobjsz[BS1_MM_MAXLOBJ];
extern int bs1_mm_n_lobj;		//number of blocks


elem *bs1_gc_roots[4096];
int bs1_gc_rootsn[4096];
int bs1_gc_n_roots;

elem *bs1_gc_rootstack[16384];
int bs1_gc_rootstackpos;

int bs1_gc_posstack[256];
int bs1_gc_posstackpos;

elem *bs1_gc_markstack=NULL;
int bs1_gc_markstack_pos;
int bs1_gc_markstack_size;

elem bs1_gc_conspool=BS1_MM_NULL;	//pool of free conses
int bs1_gc_freecons=0;
int bs1_gc_tcons=0;
int bs1_gc_tfcons=0;


void BS1_GC_PrintStats()
{
	static int lloss;
	int cc, ch, cd, cf, ct;
	int i, j, k;

	cc=0; ch=0; cd=0; cf=0; ct=0;
	for(i=0; i<bs1_mm_n_blocks; i++)
		for(j=0; j<BS1_MM_BLKCELLS; j++)
	{
		k=bs1_mm_blockm[i][j];
		ct++;

		if((k&3)==0)cf++;
		if((k&3)==1)cc++;
		if((k&3)==2)ch++;
		if((k&3)==3)cd++;
	}

	printf("Heap Used=%d/%d, Cons=%d, Obj=%d (Head=%d, Data=%d)\n",
		ct-cf, ct, cc, ch+cd, ch, cd);

	i=bs1_gc_tcons-bs1_gc_tfcons;
	j=i-lloss;
	lloss=i;

	printf("CONS New=%d Freed=%d (Loss=%d, Diff=%d)\n",
		bs1_gc_tcons, bs1_gc_tfcons, i, j);
}

void BS1_GC_AddRoot(elem *p)
{
	int i;

	*p=BS1_MM_NULL;

	for(i=0; i<bs1_gc_n_roots; i++)
		if(bs1_gc_roots[i]==p)
	{
		bs1_gc_rootsn[i]=1;
		return;
	}

	i=bs1_gc_n_roots++;
	bs1_gc_roots[i]=p;
	bs1_gc_rootsn[i]=1;
}

void BS1_GC_AddRootArray(elem *p, int n)
{
	int i;

	for(i=0; i<n; i++)p[i]=BS1_MM_NULL;

	for(i=0; i<bs1_gc_n_roots; i++)
		if(bs1_gc_roots[i]==p)
	{
		bs1_gc_rootsn[i]=n;
		return;
	}

	i=bs1_gc_n_roots++;
	bs1_gc_roots[i]=p;
	bs1_gc_rootsn[i]=n;
}


void BS1_GC_PushRoot(elem *p)
{
	int i;

	*p=BS1_MM_NULL;
	i=bs1_gc_rootstackpos++;
	bs1_gc_rootstack[i]=p;
}

void BS1_GC_PushRootPos()
{
	int i;

	i=bs1_gc_posstackpos++;
	bs1_gc_posstack[i]=bs1_gc_rootstackpos;
}

void BS1_GC_PopRootPos()
{
	int i;

	bs1_gc_posstackpos--;
	i=bs1_gc_posstackpos;
	bs1_gc_rootstackpos=bs1_gc_posstack[i];
}


#ifndef BS1_GC_NOREFS

void BS1_GC_Assign(elem *p, elem t)
{
	if(*p)BS1_GC_DecRef(*p);
	if(t)BS1_GC_IncRef(t);
	*p=t;
}

void BS1_GC_Clear(elem *p)
{
	if(!*p)return;
	BS1_GC_DecRef(*p);
	*p=BS1_MM_NULL;
}

#else

void BS1_GC_Assign(elem *p, elem t)
	{ *p=t; }
void BS1_GC_Clear(elem *p)
	{ *p=BS1_MM_NULL; }

#endif

elem BS1_GC_AllocCons()
{
	elem t;

#ifdef BS1_GC_CONSPOOL
	if(bs1_gc_conspool)
	{
		t=bs1_gc_conspool;
		bs1_gc_conspool=CDRF(t);
		bs1_gc_freecons--;

		BS1_GC_SetProtectRef(t);
		bs1_gc_tcons++;
		return(t);
	}

//	printf("MC\n");
	bs1_gc_conspool=BS1_MM_MultiCons(256);

	bs1_gc_freecons=0;
	t=bs1_gc_conspool;
	while(t) { bs1_gc_freecons++; t=CDRF(t); }

	if(!bs1_gc_conspool)
	{
		BS1_MM_AddBlock();
		bs1_gc_conspool=BS1_MM_MultiCons(256);
//		bs1_gc_freecons=256;

		bs1_gc_freecons=0;
		t=bs1_gc_conspool;
		while(t) { bs1_gc_freecons++; t=CDRF(t); }
	}

	if(!bs1_gc_conspool)return(BS1_MM_NULL);

	t=bs1_gc_conspool;
	bs1_gc_conspool=CDRF(t);
	bs1_gc_freecons--;

	CDRF(t)=BS1_MM_NULL;

	BS1_GC_SetProtectRef(t);
	bs1_gc_tcons++;
	return(t);
#else
	t=BS1_MM_AllocCons();
	BS1_GC_SetProtectRef(t);
	bs1_gc_tcons++;
	return(t);
#endif
}


int BS1_GC_BlackenCells(int i, int j)
{
	int k, l;

	k=bs1_mm_blockm[i][j];
	switch(k&3)
	{
	case 0: break;
	case 1:
		bs1_mm_blockm[i][j]=(k&(~12))+4;
		break;
	case 2:
		bs1_mm_blockm[i][j]=(k&(~12))+4;
		for(l=j+1; l<BS1_MM_BLKCELLS; l++)
		{
			k=bs1_mm_blockm[i][l];
			if((k&3)!=3)break;
			bs1_mm_blockm[i][l]=(k&(~12))+4;
		}
		break;
	case 3: break;
	default: break;
	}
}

int BS1_GC_LockCells(int i, int j)
{
	int k, l;

	k=bs1_mm_blockm[i][j];
	switch(k&3)
	{
	case 0: break;
	case 1:
		bs1_mm_blockm[i][j]=(k&(~12))+12;
		break;
	case 2:
		bs1_mm_blockm[i][j]=(k&(~12))+12;
		for(l=j+1; l<BS1_MM_BLKCELLS; l++)
		{
			k=bs1_mm_blockm[i][l];
			if((k&3)!=3)break;
			bs1_mm_blockm[i][l]=(k&(~12))+12;
		}
		break;
	case 3: break;
	default: break;
	}
}

int BS1_GC_FreeCellObj(int i, int j)
{
	int k;

	k=bs1_mm_blockm[i][j];
	if((k&3)==0)return(-1);
	if((k&3)==3)return(-1);

	if((k&3)==1)
	{
		BS1_GC_DecRef(bs1_mm_blockd[i][j*2+0]);
		BS1_GC_DecRef(bs1_mm_blockd[i][j*2+1]);

#ifndef BS1_GC_CONSPOOL
		bs1_mm_blockm[i][j]=0;
		bs1_gc_tfcons++;
#else
		bs1_mm_blockm[i][j]=0x01;
		bs1_mm_blockd[i][j*2+0]=BS1_MM_NULL;
		bs1_mm_blockd[i][j*2+1]=bs1_gc_conspool;
//		bs1_gc_conspool=(elem)(bs1_mm_blockd[i]+j*2)|4;
		bs1_gc_conspool=BS1_MM_ElemFromCell(i, j);

		bs1_gc_freecons++;
		bs1_gc_tfcons++;
#endif

		return(0);
	}

	if((k&3)==2)
	{
		//incomplete
//		BS1_TY_CallDestroyFunc((elem)(bs1_mm_blockd[i]+j*2)|5);
		BS1_TY_CallDestroyFunc(BS1_MM_ElemFromCell(i, j));
	}

	BS1_MM_FreeCells(i, j);
	return(0);
}

int BS1_GC_FreeObj(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)return(k);
	BS1_GC_FreeCellObj(i, j);
	return(0);
}

#ifndef BS1_GC_NOREFS

void BS1_GC_IncRef(elem t)
{
	int i, j, k;

	if(((t&7)!=4) && ((t&7)!=5))return;
	BS1_MM_FindElemCell2(t, &i, &j);

//	k=bs1_mm_blockm[i][j];
//	if(((k&3)!=1) && ((k&3)!=2))return(-1);

	k=(bs1_mm_blockm[i][j]>>4)&7;
	if(k<7)
	{
		bs1_mm_blockm[i][j]+=16;
		bs1_mm_blockm[i][j]&=0x7F;
	}
}

void BS1_GC_DecRef(elem t)
{
	int i, j, k;

//	k=BS1_MM_FindElemCell(t, &i, &j);
//	if(k)return(k);
//	k=bs1_mm_blockm[i][j];
//	if(((k&3)!=1) && ((k&3)!=2))return(-1);

	if(((t&7)!=4) && ((t&7)!=5))return;
	BS1_MM_FindElemCell2(t, &i, &j);

	k=(bs1_mm_blockm[i][j]>>4)&7;
	if(k<7)
	{
		if(k>1)
		{
			bs1_mm_blockm[i][j]-=16;
		}else if(k)
		{
			BS1_GC_FreeCellObj(i, j);
		}
	}
//	return(0);
}

void BS1_GC_SafeDecRef(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)return;

	k=bs1_mm_blockm[i][j];
	if(((k&3)!=1) && ((k&3)!=2))return;

	k=(bs1_mm_blockm[i][j]>>4)&7;
	if(k && (k<7))
		bs1_mm_blockm[i][j]-=16;
	if(k<2)bs1_mm_blockm[i][j]|=0x80;
}

void BS1_GC_CheckRef(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)return;

	k=bs1_mm_blockm[i][j];
	if(((k&3)!=1) && ((k&3)!=2))return;

	k=(bs1_mm_blockm[i][j]>>4)&7;
	if(!k)BS1_GC_FreeCellObj(i, j);
}

void BS1_GC_SetManyRef(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)return;

	k=bs1_mm_blockm[i][j];
	if(((k&3)!=1) && ((k&3)!=2))return;
	bs1_mm_blockm[i][j]|=7<<4;
}

void BS1_GC_SetProtectRef(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)return;
	bs1_mm_blockm[i][j]|=0x80;
}

int BS1_GC_GetRefCount(elem t)
{
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)return(8);

	k=bs1_mm_blockm[i][j];
	if(((k&3)!=1) && ((k&3)!=2))return(4);

	k=(bs1_mm_blockm[i][j]>>4)&7;
	return(k);
}

#else

void BS1_GC_IncRef (elem t) {}
void BS1_GC_DecRef (elem t) {}
void BS1_GC_SafeDecRef (elem t) {}
void BS1_GC_CheckRef (elem t) {}
void BS1_GC_SetManyRef (elem t) {}
void BS1_GC_SetProtectRef (elem t) {}
int BS1_GC_GetRefCount(elem t)
	{ return(1); }

#endif


int BS1_GC_ClearMarks()
{
	int i, j, k;

	for(i=0; i<bs1_mm_n_blocks; i++)
		for(j=0; j<BS1_MM_BLKCELLS; j++)
	{
		k=bs1_mm_blockm[i][j];
		if(((k&0xC)==0x4) || (k&0xC)==0x8)
			bs1_mm_blockm[i][j]=k&(~0xC);
	}

	for(i=0; i<bs1_mm_n_lobj; i++)
	{
		if(!bs1_mm_lobj[i])
			continue;
		j=bs1_mm_lobj[i][0];
		k=j>>16;
		if(((k&0xC)==0x4) || (k&0xC)==0x8)
			bs1_mm_lobj[i][0]=j&(~0x000C0000);
	}
}

int BS1_GC_Sweep()
{
	elem *p;
	int i, j, k;

	for(i=0; i<bs1_mm_n_blocks; i++)
		for(j=0; j<BS1_MM_BLKCELLS; j++)
	{
		k=bs1_mm_blockm[i][j];
		if(!k || (k&0xC))continue;

		if((k&3)==1)
		{
			p=bs1_mm_blockd[i]+j*2;
			BS1_GC_DecRef(p[0]);
			BS1_GC_DecRef(p[1]);
			bs1_mm_blockm[i][j]=0;
			continue;
		}
		if((k&3)==2)
		{
//			BS1_TY_CallDestroyFunc(
//				(elem)(bs1_mm_blockd[i]+j*2)|5);
			BS1_TY_CallDestroyFunc(BS1_MM_ElemFromCell(i, j));
			bs1_mm_blockm[i][j]=0;
			continue;
		}

		bs1_mm_blockm[i][j]=0;
	}
}

void BS1_GC_MarkRef(elem t)
{
	if(((t&7)!=4) && ((t&7)!=5) && ((t&7)!=6))
		return;

	if(!bs1_gc_markstack)
	{
		bs1_gc_markstack_pos=0;
		bs1_gc_markstack_size=4096;
		bs1_gc_markstack=malloc(bs1_gc_markstack_size*sizeof(elem));
	}

	bs1_gc_markstack[bs1_gc_markstack_pos++]=t;

	if(bs1_gc_markstack_pos>=bs1_gc_markstack_size)
	{
		bs1_gc_markstack_size+=bs1_gc_markstack_size>>1;
		bs1_gc_markstack=realloc(bs1_gc_markstack,
			bs1_gc_markstack_size*sizeof(elem));
	}
}

void BS1_GC_MarkObj(elem t)
{
	elem *p;
	int i, j, k;

	k=BS1_MM_FindElemCell(t, &i, &j);
	if(k)
	{
		i=BS1_MM_FindElemLObj(t);
		if(i>=0)
		{
			p=bs1_mm_lobj[i];
			k=p[0]>>16;

			if(((k>>2)&3)==1)
				return;

			BS1_TY_CallMarkFunc(t);
			if(((k>>2)&3)==0)
				p[0]|=1<<18;
		}

		return;
	}

	k=bs1_mm_blockm[i][j];
	if(((k>>2)&3)==1)
		return;

	if((k&3)==1)
	{
		p=bs1_mm_blockd[i]+j*2;
		BS1_GC_MarkRef(p[0]);
		BS1_GC_MarkRef(p[1]);

		if(((k>>2)&3)==0)
			bs1_mm_blockm[i][j]=k|4;
		return;
	}

	if((k&3)==2)
	{
		BS1_TY_CallMarkFunc(t);

		if(((k>>2)&3)==0)
			BS1_GC_BlackenCells(i, j);
		return;
	}
}

void BS1_GC_Mark()
{
	elem t;
	int i, j;

	for(i=0; i<bs1_gc_n_roots; i++)
	{
		for(j=0; j<bs1_gc_rootsn[i]; j++)
		{
			t=bs1_gc_roots[i][j];
			BS1_GC_MarkRef(t);
		}
	}

	for(i=0; i<bs1_gc_rootstackpos; i++)
	{
		t=bs1_gc_rootstack[i][0];
		BS1_GC_MarkRef(t);
	}

	while(bs1_gc_markstack_pos)
	{
		bs1_gc_markstack_pos--;
		t=bs1_gc_markstack[bs1_gc_markstack_pos];
		BS1_GC_MarkObj(t);
	}
}

int BS1_GC_MarkProtect()
{
	elem *p;
	int i, j, k;

	for(i=0; i<bs1_mm_n_blocks; i++)
		for(j=0; j<BS1_MM_BLKCELLS; j++)
	{
		k=bs1_mm_blockm[i][j];
		if(!(k&0x80))continue;

		if((k&3)==1)
		{
//			p=bs1_mm_blockd[i]+j*2;
//			BS1_GC_MarkRef(((elem)p)|4);
			BS1_GC_MarkRef(BS1_MM_ElemFromCell(i, j));
			continue;
		}
		if((k&3)==2)
		{
//			p=bs1_mm_blockd[i]+j*2;
//			BS1_GC_MarkRef(((elem)p)|5);
			BS1_GC_MarkRef(BS1_MM_ElemFromCell(i, j));
			continue;
		}
	}
}

void BS1_GC_Collect()
{
	bs1_gc_conspool=BS1_MM_NULL;
	bs1_gc_freecons=0;

	BS1_GC_ClearMarks();
	BS1_GC_MarkProtect();
	BS1_GC_Mark();
	BS1_GC_Sweep();
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>

struct ty_methods_s {
void (*mark)(elem obj);
void (*destroy)(elem obj);
void (*print)(char **str, elem obj);
elem (*parse)(char **str);

elem (*load_index)(elem obj, elem slot);
elem (*store_index)(elem obj, elem slot, elem val);
elem (*call)(elem obj, elem fcn, elem args);
elem (*methodcall)(elem obj, elem slot, elem args);
};

extern char *bs1_tyh_strs[];
extern int bs1_tyh_idx[];

char *bs1_ty_hash[65536];
elem bs1_ty_strhash[4096];

struct ty_methods_s *bs1_ty_methods[65536];

int BS1_TY_SymsUsed()
{
	int i, j;

	j=0;
	for(i=0; i<65536; i++)
		if(bs1_ty_hash[i])j++;
	return(j);
}

int BS1_TY_SymsMax()
{
	return(65536);
}


void BS1_TY_BeginSetFunc(int ty)
{
	if(bs1_ty_methods[ty])return;
	bs1_ty_methods[ty]=malloc(sizeof(struct ty_methods_s));
	memset(bs1_ty_methods[ty], 0, sizeof(struct ty_methods_s));
}

void BS1_TY_SetMarkFunc(int ty, void (*fcn)(elem obj))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->mark=fcn;
}

void BS1_TY_SetDestroyFunc(int ty, void (*fcn)(elem obj))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->destroy=fcn;
}

void BS1_TY_SetPrintFunc(int ty, void (*fcn)(char **str, elem obj))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->print=fcn;
}

void BS1_TY_SetParseFunc(int ty, elem (*fcn)(char **str))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->parse=fcn;
}

void BS1_TY_SetLoadIndexFunc(int ty, elem (*fcn)(elem obj, elem slot))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->load_index=fcn;
}

void BS1_TY_SetStoreIndexFunc(int ty,
	elem (*fcn)(elem obj, elem slot, elem val))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->store_index=fcn;
}

void BS1_TY_SetCallFunc(int ty, elem (*fcn)(elem obj, elem fcn, elem args))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->call=fcn;
}

void BS1_TY_SetMethodCallFunc(int ty,
	elem (*fcn)(elem obj, elem slot, elem args))
{
	BS1_TY_BeginSetFunc(ty);
	bs1_ty_methods[ty]->methodcall=fcn;
}


void BS1_TY_CallMarkFunc(elem obj)
{
	elem *p;
	int ty;

//	p=(elem *)(obj&(~7));
	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return;
	if(!bs1_ty_methods[ty]->mark)return;
	bs1_ty_methods[ty]->mark(obj);
}

void BS1_TY_CallDestroyFunc(elem obj)
{
	elem *p;
	int ty;

//	p=(elem *)(obj&(~7));
	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return;
	if(!bs1_ty_methods[ty]->destroy)return;
	bs1_ty_methods[ty]->destroy(obj);
}

int BS1_TY_CallPrintFunc(char **str, elem obj)
{
	elem *p;
	int ty;

	if(((obj&7)!=5) && ((obj&7)!=6))
		return(-1);
//	p=(elem *)(obj&(~7));
	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return(-1);
	if(!bs1_ty_methods[ty]->print)return(-1);
	bs1_ty_methods[ty]->print(str, obj);
}


elem BS1_TY_LoadIndex(elem obj, elem slot)
{
	elem *p, t;
	int ty;

	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return(BS1_MM_NULL);
	if(!bs1_ty_methods[ty]->load_index)return(BS1_MM_NULL);
	t=bs1_ty_methods[ty]->load_index(obj, slot);
	return(t);
}

elem BS1_TY_StoreIndex(elem obj, elem slot, elem val)
{
	elem *p, t;
	int ty;

	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return(BS1_MM_NULL);
	if(!bs1_ty_methods[ty]->store_index)return(BS1_MM_NULL);
	t=bs1_ty_methods[ty]->store_index(obj, slot, val);
	return(t);
}

elem BS1_TY_Call(elem obj, elem fcn, elem args)
{
	elem *p, t;
	int ty;

//	p=BS1_TY_GetCellPtr(obj);
	p=BS1_TY_GetCellPtr(fcn);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return(BS1_MM_NULL);
	if(!bs1_ty_methods[ty]->call)return(BS1_MM_NULL);
	t=bs1_ty_methods[ty]->call(obj, fcn, args);
	return(t);
}

elem BS1_TY_MethodCall(elem obj, elem slot, elem args)
{
	elem *p, t;
	int ty;

	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return(BS1_MM_NULL);
	if(!bs1_ty_methods[ty]->methodcall)
	{
		t=BS1_TY_LoadIndex(obj, slot);
		if(t==BS1_MM_NULL)return(t);

		t=BS1_TY_Call(obj, t, args);
		return(t);
//		return(BS1_MM_NULL);
	}

	t=bs1_ty_methods[ty]->methodcall(obj, slot, args);
	return(t);
}

int BS1_TY_HasMethodCall(elem obj)
{
	elem *p;
	int ty;

	p=BS1_TY_GetCellPtr(obj);
	ty=(*p)&65535;

	if(!bs1_ty_methods[ty])return(0);
	if(!bs1_ty_methods[ty]->methodcall)return(0);
	return(1);
}

#if 0
int BS1_TY_HashIndex(char **hash, char *str)
{
	char *s;
	int i, j, k;

	i=0; s=str;
	while(*s)
	{
		i=(i>>14)^(i<<2)^(*s++);
		i&=0xFFFF;
	}

	s=str;
	while(*s)
	{
		if(!hash[i])
		{
			hash[i]=strdup(str);
			return(i);
		}
		if(!strcmp(str, hash[i]))
			return(i);
		i=(i>>(14))^(i<<2)^(*s++);
		i&=0xFFFF;
	}

	//no unique hash found
	//try a psuedorandom sequence using the hash as a seed
	for(j=0; j<1024; j++)
	{
		i*=65521;
		k=(i>>16)&0xFFFF;

		if(!hash[k])
		{
			hash[k]=strdup(str);
			return(k);
		}
		if(!strcmp(str, hash[k]))
			return(k);
	}

	printf("BS1_TY_HashType: Fail Hash Type %s\n", str);

	return(-1);
}
#endif

int BS1_TY_HashIndex(char **hash, char *str)
{
	char *s;
	int i, j, k;

	i=0; s=str;
	while(*s)i=(i*65521)+(*s++);
	for(j=0; j<256; j++)
	{
		i*=65521;
		k=(i>>16)&0xFFFF;

		if(!hash[k])
		{
			hash[k]=strdup(str);
			return(k);
		}
		if(!strcmp(str, hash[k]))
			return(k);
	}

	printf("BS1_TY_HashType: Fail Hash Type %s\n", str);

	return(-1);
}

int BS1_TY_HashType(char *str)
{
	int i;
	i=BS1_TY_HashIndex(bs1_ty_hash, str);
	return(i);
}

char *BS1_TY_HashTypeString(char *str)
{
	int i;
	i=BS1_TY_HashIndex(bs1_ty_hash, str);
	return(bs1_ty_hash[i]);
}

int BS1_TY_GetType(elem t)
{
	int i;

	i=-1;
	switch(t&7)
	{
	case BS1_MM_MISC:
		switch(t&255)
		{
		case BS1_MM_LIT: break;
		case BS1_MM_CHAR: i=BS1_TYH_CHAR; break;
		case BS1_MM_SYMBOL: i=BS1_TYH_SYMBOL; break;
		case BS1_MM_KEYWORD: i=BS1_TYH_KEYWORD; break;
		case BS1_MM_LOBJ: i=BS1_MM_GetObjType(t); break;
		case BS1_MM_HANDLE: i=BS1_TYH_HANDLE; break;
		case BS1_MM_RATIONAL: i=BS1_TYH_RATIONAL; break;
		}
		break;

	case BS1_MM_FIXNUM: i=BS1_TYH_INT; break;
	case BS1_MM_FIXNUM2: i=BS1_TYH_INT; break;
	case BS1_MM_FLONUM: i=BS1_TYH_FLOAT; break;
	case BS1_MM_FLONUM2: i=BS1_TYH_FLOAT; break;

	case BS1_MM_CONS: i=BS1_TYH_CONS; break;
	case BS1_MM_OBJ: i=BS1_MM_GetObjType(t); break;

	default:
		break;
	}

	return(i);
}

char *BS1_TY_GetTypeName(elem t)
{
	int i;

	i=BS1_TY_GetType(t);
	if(i<0)return(NULL);

	return(bs1_ty_hash[i]);
}

void *BS1_TY_GetObjData(elem t)
{
	return(BS1_TY_GetElemPtr(t));
}

void *BS1_TY_GetObjDataA64(elem t)
{
	return(BS1_TY_GetElemPtrA64(t));
}

void *BS1_TY_GetObjDataAPtr(elem t)
{
	if(sizeof(void *)==8)
		return(BS1_TY_GetElemPtrA64(t));
	return(BS1_TY_GetElemPtr(t));
}


elem BS1_TY_HashSymbol(char *str)
{
	int i;
	if(!str)return(BS1_MM_NULL);
	i=BS1_TY_HashIndex(bs1_ty_hash, str);
	return((i<<8)|BS1_MM_SYMBOL);
}

elem BS1_TY_HashKeyword(char *str)
{
	int i;
	if(!str)return(BS1_MM_NULL);
	i=BS1_TY_HashIndex(bs1_ty_hash, str);
	return((i<<8)|BS1_MM_KEYWORD);
}

elem BS1_TY_HashString(char *str)
{
	elem t;
	char *s;
	int i, j, k;

	if(!str)return(BS1_MM_NULL);

	i=0; s=str;
	while(*s)
	{
//		i=(i>>10)^(i<<2)^(*s++);
//		i&=0xFFF;

		i=(i*251)+(*s++);
	}
	i=((i*251)>>8)&0xFFF;

	if(bs1_ty_strhash[i])
	{
		t=bs1_ty_strhash[i];
//		s=(char *)(((elem *)(t&(~7)))+1);
		s=BS1_TY_GetObjData(t);
		if(!strcmp(s, str))return(t);
	}

	t=BS1_MM_AllocObj(BS1_TYH_STRING, strlen(str)+1);
//	s=(char *)(((elem *)(t&(~7)))+1);
	s=BS1_TY_GetObjData(t);
	strcpy(s, str);

	bs1_ty_strhash[i]=t;
	return(t);
}


char *BS1_TY_GetSymbol(elem t)
{
	if(((t&0xFF)!=BS1_MM_SYMBOL) && ((t&0xFF)!=BS1_MM_KEYWORD))
		return(NULL);
	return(bs1_ty_hash[(t>>8)&0xFFFF]);
}

int BS1_TY_GetSymbolIndex(elem t)
{
	if(((t&0xFF)!=BS1_MM_SYMBOL) && ((t&0xFF)!=BS1_MM_KEYWORD))
		return(-1);
	return((t>>8)&0xFFFF);
}

char *BS1_TY_GetString(elem t)
{
	char *s;

	if(((t&0xFF)==BS1_MM_SYMBOL) || ((t&0xFF)==BS1_MM_KEYWORD))
		return(bs1_ty_hash[(t>>8)&0xFFFF]);

	if(BS1_TY_GetType(t)!=BS1_TYH_STRING)
		return(NULL);

	s=BS1_TY_GetObjData(t);
	return(s);
}

int BS1_TY_GetInt(elem t)
{
	int i, j;

	if((t&3)==BS1_MM_FIXNUM)
	{
		i=t>>2;
		if(t&0x80000000)i|=0xC0000000;
		return(i);
	}
	if((t&3)==BS1_MM_FLONUM)
	{
		i=t&0xFFFFFFFC;
		i=(int)(*(float *)(&i));
		return(i);
	}
	if((t&255)==BS1_MM_CHAR)
		return(t>>8);
	if(BS1_COMPLEXP(t))
		return((int)BS1_REAL(t));

	if((t&255)==BS1_MM_RATIONAL)
	{
		i=(t>>20)&0xFFF;
		j=(t>>8)&0xFFF;
		if(i&0x800)i=((-1)&(~0xFFF))|i;
		return(i/j);
	}

	return(0);
}

s64 BS1_TY_GetLong(elem t)
{
	double *fp;
	s64 *lp;
	int i, j;

	if((t&3)==BS1_MM_FIXNUM)
	{
		i=t>>2;
		if(t&0x80000000)i|=0xC0000000;
		return(i);
	}
	if((t&3)==BS1_MM_FLONUM)
	{
		i=t&0xFFFFFFFC;
		i=(int)(*(float *)(&i));
		return(i);
	}
	if((t&255)==BS1_MM_CHAR)
		return(t>>8);

	if(BS1_LONGP(t))
	{
		lp=BS1_TY_GetObjDataA64(t);
		return(*lp);
	}
	if(BS1_DOUBLEP(t))
	{
		fp=BS1_TY_GetObjDataA64(t);
		return(*fp);
	}
	if(BS1_COMPLEXP(t))
		return((s64)BS1_REAL(t));

	if((t&255)==BS1_MM_RATIONAL)
	{
		i=(t>>20)&0xFFF;
		j=(t>>8)&0xFFF;
		if(i&0x800)i=((-1)&(~0xFFF))|i;
		return(i/j);
	}

	return(0);
}

float BS1_TY_GetFloat(elem t)
{
	int i, j;
	float f;

	if((t&3)==BS1_MM_FIXNUM)
	{
		i=t>>2;
		if(t&0x80000000)i|=0xC0000000;
		f=i;
		return(f);
	}

	if((t&3)==BS1_MM_FLONUM)
	{
		i=t&0xFFFFFFFC;
		f=*(float *)(&i);
		return(f);
	}

	if(BS1_COMPLEXP(t))
		return(BS1_REAL(t));
	if(BS1_LONGP(t))
		return(BS1_TOLONG(t));

	if((t&255)==BS1_MM_RATIONAL)
	{
		i=(t>>20)&0xFFF;
		j=(t>>8)&0xFFF;
		if(i&0x800)i=((-1)&(~0xFFF))|i;
		return(((float)i)/j);
	}

	return(0);
}

double BS1_TY_GetDouble(elem t)
{
	double *fp;
	s64 *lp;
	int i, j;
	float f;

	if((t&3)==BS1_MM_FIXNUM)
	{
		i=t>>2;
		if(t&0x80000000)i|=0xC0000000;
		return(i);
	}

	if((t&3)==BS1_MM_FLONUM)
	{
		i=t&0xFFFFFFFC;
		f=*(float *)(&i);
		return(f);
	}

	if(BS1_LONGP(t))
	{
		lp=BS1_TY_GetObjDataA64(t);
		return(*lp);
	}
	if(BS1_DOUBLEP(t))
	{
		fp=BS1_TY_GetObjDataA64(t);
		return(*fp);
	}

	if(BS1_COMPLEXP(t))
		return(BS1_REAL(t));
	if(BS1_LONGP(t))
		return(BS1_TOLONG(t));

	if((t&255)==BS1_MM_RATIONAL)
	{
		i=(t>>20)&0xFFF;
		j=(t>>8)&0xFFF;
		if(i&0x800)i=((-1)&(~0xFFF))|i;
		return(((double)i)/j);
	}

	return(0);
}

void BS1_TY_GetRational(elem t, int *ri, int *rj)
{
	int i, j;

	if((t&3)==BS1_MM_FIXNUM)
	{
		i=t>>2;
		if(t&0x80000000)i|=0xC0000000;
		*ri=i;
		*rj=1;
		return;
	}

	if((t&255)==BS1_MM_RATIONAL)
	{
		i=(t>>20)&0xFFF;
		j=(t>>8)&0xFFF;
		if(i&0x800)i=((-1)&(~0xFFF))|i;
		*ri=i; *rj=j;
		return;
	}

	*ri=0; *rj=1;
}

elem BS1_TY_Int(s64 i)
{
	elem t, *p;

	if((i>(-(1<<28))) && (i<(1<<28)))
		return((i<<2)|BS1_MM_FIXNUM);

	t=BS1_MM_AllocObjA64(BS1_TYH_LONG, 8);
	p=BS1_TY_GetObjDataA64(t);
	*(s64 *)p=i;
	return(t);
}

elem BS1_TY_Long(s64 i)
{
	elem t, *p;

	t=BS1_MM_AllocObjA64(BS1_TYH_LONG, 8);
	p=BS1_TY_GetObjDataA64(t);
	*(s64 *)p=i;
	return(t);
}

elem BS1_TY_Char(int i)
{
	return((i<<8)|BS1_MM_CHAR);
}

elem BS1_TY_Float(double f)
{
	elem t, *p;
	float g;
	int i, s;

	g=f;
	i=*(int *)(&g);
	if((i&2) && ((i&0xFFFC)!=0xFFFC))i+=2;

	t=(i&(~3))|BS1_MM_FLONUM;
	return(t);
}

elem BS1_TY_Rational(int i, int j)
{
	if(j<2)return(FIXNUM(i));

	if((i>2047) || (i<-2047))
		return(BS1_TY_Float(((double)i)/j));
	if((j<0) || (j>4095))
		return(BS1_TY_Float(((double)i)/j));

	return((i<<20)|(j<<8)|BS1_MM_RATIONAL);
}


int BS1_TY_GetBool(elem t)
{
	int i;
	if(t==BS1_MM_FALSE)return(0);
	if(t==BS1_MM_FIXNUM)return(0);
	if(t==BS1_MM_NULL)return(0);
	return(1);
}


elem BS1_TY_Cons(elem a, elem b)
{
	elem t;
	elem *p;
	int i, j, k;

	t=BS1_GC_AllocCons();
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);

	BS1_GC_IncRef(a);
	BS1_GC_IncRef(b);
	p[0]=a; p[1]=b;

	return(t);
}

elem BS1_TY_GetCar(elem t)
{
	elem *p;
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	return(p[0]);
}

elem BS1_TY_GetCdr(elem t)
{
	elem *p;
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	return(p[1]);
}

elem BS1_TY_SetCar(elem t, elem a)
{
	elem *p;

//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	BS1_GC_DecRef(p[0]);
	BS1_GC_IncRef(a);
	p[0]=a;
	return(t);
}

elem BS1_TY_SetCdr(elem t, elem a)
{
	elem *p;

//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	BS1_GC_DecRef(p[1]);
	BS1_GC_IncRef(a);
	p[1]=a;
	return(t);
}

void BS1_TY_SetCar2(elem t, elem a)
{
	elem *p;
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	p[0]=a;
}

void BS1_TY_SetCdr2(elem t, elem a)
{
	elem *p;
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	p[1]=a;
}

elem BS1_TY_GetCaar(elem t)
	{ return(BS1_TY_GetCar(BS1_TY_GetCar(t))); }
elem BS1_TY_GetCdar(elem t)
	{ return(BS1_TY_GetCdr(BS1_TY_GetCar(t))); }
elem BS1_TY_GetCadr(elem t)
	{ return(BS1_TY_GetCar(BS1_TY_GetCdr(t))); }
elem BS1_TY_GetCddr(elem t)
	{ return(BS1_TY_GetCdr(BS1_TY_GetCdr(t))); }

elem BS1_TY_Reverse(elem l)
{
	elem t, c, r;

	c=l; r=BS1_MM_NULL;

	while(c)
	{
		t=BS1_TY_GetCar(c);
		r=BS1_TY_Cons(t, r);
		c=BS1_TY_GetCdr(c);
	}

	return(r);
}

/* Special Case:
The first elem will have no references, but the last will have one.
Reverse and adjust counts so that the output has 0 for the first item,
and 1 for the last (safe dec ref as the count for the new start will hit 0,
but it should not be freed).
Normal Case: The last Item will gain a count from the (now) previous cons,
and the now first item will lose a count. Presumably the holder would update
its slots, increasing the count for the first item and decreasing for the last.
*/
elem BS1_TY_NReverse(elem l)
{
	elem c, r, n;

	c=l; r=BS1_MM_NULL;
	while(c)
	{
		n=BS1_TY_GetCdr(c);
		BS1_TY_SetCdr2(c, r);
		r=c; c=n;
	}

	BS1_GC_IncRef(l);
	BS1_GC_SafeDecRef(r);
	return(r);
}


elem BS1_TY_CopyList(elem a)
{
	if(a==BS1_MM_NULL)return(a);
	return(BS1_TY_Cons(BS1_TY_GetCar(a),
		BS1_TY_CopyList(BS1_TY_GetCdr(a))));
}

elem BS1_TY_Append(elem a, elem b)
{
	if(a==BS1_MM_NULL)return(BS1_TY_CopyList(b));
	return(BS1_TY_Cons(BS1_TY_GetCar(a),
		BS1_TY_Append(BS1_TY_GetCdr(a), b)));
}

elem BS1_TY_NAppend(elem a, elem b)
{
	elem c, t;

	if(a==BS1_MM_NULL)return(b);
	if(b==BS1_MM_NULL)return(a);

	c=a;
	while(1)
	{
		t=BS1_TY_GetCdr(c);
		if(t==BS1_MM_NULL)break;
		c=t;
	}
	BS1_TY_SetCdr(c, b);
	return(a);
}

int BS1_TY_IsListP(elem l)
{
	while(BS1_CONSP(l))l=CDR(l);
	return(l==BS1_MM_NULL);
}

int BS1_TY_GetListLen(elem l)
{
	int i;

	i=0;
	while(BS1_CONSP(l)) { i++; l=CDR(l); }
	if(l!=BS1_MM_NULL)return(-(i+1));
	return(i);
}


elem BS1_TY_ListToArray(elem l)
{
	elem c, t, *p;
	int i;

	i=0; c=l;
	while(BS1_CONSP(t))
		{ i++; c=CDR(c); }

	t=BS1_MM_AllocObj(BS1_TYH_ARRAY, i*sizeof(elem));
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);

	i=0; c=l;
	while(BS1_CONSP(t))
		{ i++; p[i]=CAR(c); c=CDR(c); }
	return(t);
}

elem BS1_TY_NewArray(int n)
{
	elem t, *p;
	int i;

	t=BS1_MM_AllocObj(BS1_TYH_ARRAY, n*sizeof(elem));
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);

	return(t);
}

elem BS1_TY_NewArrayFromArray(elem *arr, int n)
{
	elem t, *p;
	int i;

	t=BS1_MM_AllocObj(BS1_TYH_ARRAY, n*sizeof(elem));
//	p=(elem *)(t&(~7));
	p=BS1_TY_GetCellPtr(t);
	for(i=0; i<n; i++)SET(p[i+1], arr[i]);
	return(t);
}

elem BS1_TY_NewArray2(elem a, elem b)
{
	elem arr[8], t;
	arr[0]=a; arr[1]=b;
	t=BS1_TY_NewArrayFromArray(arr, 2);
	return(t);
}

elem BS1_TY_NewArray3(elem a, elem b, elem c)
{
	elem arr[8], t;
	arr[0]=a; arr[1]=b; arr[2]=c;
	t=BS1_TY_NewArrayFromArray(arr, 3);
	return(t);
}

elem BS1_TY_NewArray4(elem a, elem b, elem c, elem d)
{
	elem arr[8], t;
	arr[0]=a; arr[1]=b; arr[2]=c; arr[3]=d;
	t=BS1_TY_NewArrayFromArray(arr, 4);
	return(t);
}

elem BS1_TY_NewArray5(elem a, elem b, elem c, elem d, elem e)
{
	elem arr[8], t;
	arr[0]=a; arr[1]=b; arr[2]=c; arr[3]=d; arr[4]=e;
	t=BS1_TY_NewArrayFromArray(arr, 5);
	return(t);
}

elem BS1_TY_NewArray6(elem a, elem b, elem c, elem d, elem e, elem f)
{
	elem arr[8], t;
	arr[0]=a; arr[1]=b; arr[2]=c; arr[3]=d; arr[4]=e; arr[5]=f;
	t=BS1_TY_NewArrayFromArray(arr, 6);
	return(t);
}


int BS1_TY_GetArrayLen(elem t)
{
	int i;
	i=BS1_MM_GetObjSize(t);
	return(i/sizeof(elem));
}

elem BS1_TY_GetArrayElem(elem t, int idx)
{
	elem *p;
	int i;

	i=BS1_MM_GetObjSize(t)/sizeof(elem);
	p=BS1_TY_GetObjData(t);
	if(idx>=i)return(BS1_MM_NULL);
	return(p[idx]);
}

elem BS1_TY_GetArrayElem2(elem t, int idx)
{
	elem *p;
	p=BS1_TY_GetObjData(t);
	return(p[idx]);
}

int BS1_TY_SetArrayElem(elem t, int idx, elem a)
{
	elem *p;
	int i;

	i=BS1_MM_GetObjSize(t)/sizeof(elem);
	p=BS1_TY_GetObjData(t);
	if(idx>=i)return(-1);

	BS1_GC_DecRef(p[idx+1]);
	BS1_GC_IncRef(a);
	p[idx+1]=a;

	return(0);
}


char *BS1_TY_PrintFloat(float f)
{
	char *b, *t;
	int i;

	b=BS1_MM_RAlloc(64);

	if(fabs(f-((int)f))<0.0000001)
	{
		sprintf(b, "%d", (int)f);
		return(b);
	}

	if(fabs(f)<1)
	{
		t=b;
		if(f<0) { *t++='-'; f=-f; }
		*t++='0';
		*t++='.';

		f*=10;
		i=6;
		while((f<0.998) && i--) { *t++='0'; f*=10; }

		if(fabs(rint(f)-f)<=0.01)
		{
			i=rint(f);
			if(i>9)i=9;
			*t++='0'+i;
			*t++=0;
			return(b);
		}

		*t++='0'+(((int)f)%10);
		f*=10;
		*t++='0'+(((int)f)%10);
		f*=10;
		*t++='0'+(((int)f)%10);
		f*=10;

		*t++=0;
		return(b);
	}

	sprintf(b, "%g", f);
	return(b);
}

char *BS1_TY_PrintLong(elem l)
{
	char *b, *t;
	s64 li;
	int i, sg;

	if(BS1_LONGP(l))
	{
		b=BS1_MM_RAlloc(64);
		t=b+64;
		*(--t)=0;

		li=BS1_TOLONG(l); sg=0;
		if(li<0) { li=-li; sg=1; }

		while(li)
		{
			*(--t)='0'+(li%10);
			li/=10;
		}
		if(sg)*(--t)='-';
		return(t);
	}

	return(BS1_TYRat_XLong2String(l));
#if 0
	if(BS1_XLONGP(l))
	{
		b=BS1_MM_RAlloc(128);
		t=b+64;
		*(--t)=0;

		li=BS1_TOLONG(l); sg=0;
		if(li<0) { li=-li; sg=1; }

		while(li)
		{
			*(--t)='0'+(li%10);
			li/=10;
		}
		if(sg)*(--t)='-';
		return(t);
	}
#endif


	return("<large>");
}

int BS1_TY_Print(elem t)
{
	elem c;
	float f, g;
	int i, j, k, l;

	if(t==BS1_MM_NULL)
	{
		printf("()");
		return(0);
	}

	if((t&255)==BS1_MM_MISC)
	{
		switch(t)
		{
		case BS1_MM_TRUE: printf("#t"); break;
		case BS1_MM_FALSE: printf("#f"); break;
		default: printf("#u"); break;
		}
		return(0);
	}

	i=BS1_TY_GetType(t);
	switch(i)
	{
	case BS1_TYH_INT:
		printf("%d", BS1_TY_GetInt(t));
		break;
	case BS1_TYH_FLOAT:
		f=BS1_TY_GetFloat(t);
		if(fabs(f)<0.000000001)f=0;
//		printf("%.10g", f);
		printf("%s", BS1_TY_PrintFloat(f));
		break;
	case BS1_TYH_CHAR:
		printf("#\\%d", BS1_TY_GetInt(t));
		break;
	case BS1_TYH_COMPLEX:
		f=BS1_REAL(t); g=BS1_IMAG(t);
		if(fabs(f)<0.000001)f=0;
		if(fabs(g)<0.000001)g=0;

//		printf("%.10g+%.10gi", f, g);
		if(f!=0)
		{
			if(g>0)printf("%s+%si", BS1_TY_PrintFloat(f),
				BS1_TY_PrintFloat(g));
			else if(g<0) printf("%s%si", BS1_TY_PrintFloat(f),
				BS1_TY_PrintFloat(g));
			else printf("%s", BS1_TY_PrintFloat(f));
		}else
		{
			if(g!=0)printf("%si", BS1_TY_PrintFloat(g));
				else printf("0");
		}
		break;
	case BS1_TYH_RATIONAL:
		BS1_TY_GetRational(t, &j, &k);
		printf("%d/%d", j, k);
		break;
	case BS1_TYH_LONG:
	case BS1_TYH_XLONG:
		printf("%s", BS1_TY_PrintLong(t));
		break;

	case BS1_TYH_SYMBOL:
		printf("%s", BS1_TY_GetSymbol(t));
		break;
	case BS1_TYH_KEYWORD:
		printf("%s:", BS1_TY_GetSymbol(t));
		break;
	case BS1_TYH_STRING:
		printf("\"%s\"", BS1_TY_GetString(t));
		break;

	case BS1_TYH_CONS:
		printf("(");
		c=t;
		while(BS1_TY_GetType(c)==BS1_TYH_CONS)
		{
			BS1_TY_Print(BS1_TY_GetCar(c));
			c=BS1_TY_GetCdr(c);
			if(c)printf(" ");
		}
		if(c)
		{
			printf(". ");
			BS1_TY_Print(c);
		}
		printf(")");
		break;
	case BS1_TYH_ARRAY:
		i=BS1_TY_GetArrayLen(t);

		printf("#(");
		for(j=0; j<i; j++)
		{
			c=BS1_TY_GetArrayElem(t, j);
			BS1_TY_Print(c);
			if((j+1)<i)printf(" ");
		}
		printf(")");
		break;
	case BS1_TYH_FVECTOR:
		i=BS1_TYVec_GetVecLen(t);
		printf("#[");
		for(j=0; j<i; j++)
		{
			printf("%g", BS1_TYVec_GetVecVal(t, j));
			if((j+1)<i)printf(" ");
		}
		printf("]");
		break;
	case BS1_TYH_FMATRIX:
		i=BS1_TYMat_GetYS(t);
		j=BS1_TYMat_GetXS(t);

		printf("#[");
		for(k=0; k<i; k++)
		{
			printf("[");
			for(l=0; l<j; l++)
			{
				printf("%g", BS1_TYMat_GetIndex(t, l, k));
				if((l+1)<j)printf(" ");
			}
			printf("]");
			if((k+1)<i)printf(" ");
		}
		printf("]");
		break;

	default:
		printf("#<%s:%08X>", BS1_TY_GetTypeName(t), t);
		break;
	}

	return(0);
}

int BS1_TY_PrintLN(elem t)
{
	BS1_TY_Print(t);
	printf("\n");
}

int BS1_TY_PrintTC(elem t)
{
	elem c;
	int i, j;
	char *s;

	i=BS1_GC_GetRefCount(t);
	s=BS1_TY_GetTypeName(t);
	if(!strcmp(s, "cons"))s="C";
	if(!strcmp(s, "symbol"))s="S";
	if(!strcmp(s, "keyword"))s="K";
	if(!strcmp(s, "string"))s="T";
	if(!strcmp(s, "int"))s="I";
	if(!strcmp(s, "float"))s="F";

	printf("%d%s:", i, s);
//	printf("%d%s:", i, BS1_TY_GetTypeName(t));

	if(t==BS1_MM_NULL)
	{
		printf("()");
		return(0);
	}

	if((t&255)==BS1_MM_MISC)
	{
		switch(t)
		{
		case BS1_MM_TRUE: printf("#t"); break;
		case BS1_MM_FALSE: printf("#f"); break;
		default: printf("#u"); break;
		}
		return(0);
	}

	i=BS1_TY_GetType(t);
	switch(i)
	{
	case BS1_TYH_INT:
		printf("%d", BS1_TY_GetInt(t));
		break;
	case BS1_TYH_FLOAT:
		printf("%g", BS1_TY_GetFloat(t));
		break;
	case BS1_TYH_CHAR:
		printf("#\\%d", BS1_TY_GetInt(t));
		break;
	case BS1_TYH_COMPLEX:
		printf("%g+%gi", BS1_REAL(t), BS1_IMAG(t));
		break;
	case BS1_TYH_LONG:
		printf("%ld", BS1_TY_GetLong(t));
		break;

	case BS1_TYH_SYMBOL:
		printf("%s", BS1_TY_GetSymbol(t));
		break;
	case BS1_TYH_KEYWORD:
		printf("%s:", BS1_TY_GetSymbol(t));
		break;
	case BS1_TYH_STRING:
		printf("\"%s\"", BS1_TY_GetString(t));
		break;

	case BS1_TYH_CONS:
		printf("(");
		c=t;
		while(BS1_TY_GetType(c)==BS1_TYH_CONS)
		{
			BS1_TY_PrintTC(BS1_TY_GetCar(c));
			c=BS1_TY_GetCdr(c);
			if(c)printf(" <%d> ", BS1_GC_GetRefCount(c));
		}
		if(c)
		{
			printf(". ");
			BS1_TY_PrintTC(c);
		}
		printf(")");
		break;
	case BS1_TYH_ARRAY:
		i=BS1_TY_GetArrayLen(t);

		printf("#(");
		for(j=0; j<i; j++)
		{
			c=BS1_TY_GetArrayElem(t, j);
			BS1_TY_PrintTC(c);
			if((j+1)<i)printf(" ");
		}
		printf(")");
		break;
	case BS1_TYH_FVECTOR:
		i=BS1_TYVec_GetVecLen(t);
		printf("#[");
		for(j=0; j<i; j++)
		{
			printf("%g", BS1_TYVec_GetVecVal(t, j));
			if((j+1)<i)printf(" ");
		}
		printf("]");
		break;
	default:
		printf("#<%s:%08X>", BS1_TY_GetTypeName(t), t);
		break;
	}

	return(0);
}

static void bs1_ty_array_mark(elem obj)
{
	elem *p;
	int i, j;

	i=BS1_MM_GetObjSize(obj)/sizeof(elem);
//	p=(elem *)(obj&(~7));
	p=BS1_TY_GetCellPtr(obj);

	for(j=0; j<i; j++)
		BS1_GC_MarkRef(p[j+1]);
}

static void bs1_ty_array_destroy(elem obj)
{
	elem *p;
	int i, j;

	i=BS1_MM_GetObjSize(obj)/sizeof(elem);
//	p=(elem *)(obj&(~7));
	p=BS1_TY_GetCellPtr(obj);

	for(j=0; j<i; j++)
		BS1_GC_DecRef(p[j+1]);
}

int BS1_TY_Init()
{
	static int init=0;
	int i;

	if(init)return;
	init=1;

	BS1_MM_AddBlock();

	for(i=0; i<65536; i++)
	{
		bs1_ty_hash[i]=NULL;
		bs1_ty_methods[i]=NULL;
	}

	bs1_ty_hash[0]="";
	for(i=0; bs1_tyh_idx[i]; i++)
		bs1_ty_hash[bs1_tyh_idx[i]]=bs1_tyh_strs[i];

	BS1_TY_SetMarkFunc(BS1_TYH_ARRAY, &bs1_ty_array_mark);
	BS1_TY_SetDestroyFunc(BS1_TYH_ARRAY, &bs1_ty_array_destroy);
}
#include <stdio.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>

int BS1_TYVec_GetVecLen(elem a)
{
	int i;
	i=BS1_MM_GetObjSize(a)/sizeof(float);
//	printf("vec %d\n", i);
	return(i);
}

float BS1_TYVec_GetVecVal(elem a, int idx)
{
	float *fa;
	int i;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	if(idx>=i)return(0);

	fa=BS1_TY_GetObjData(a);
	return(fa[idx]);
}

float BS1_TYVec_GetVecVal2(elem a, int idx)
{
	float *fa;
	int i;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	if(idx>=i)return(1);

	fa=BS1_TY_GetObjData(a);
	return(fa[idx]);
}

void BS1_TYVec_SetVecVal(elem a, int idx, float f)
{
	float *fa;
	int i;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	if(idx>=i)return;

	fa=BS1_TY_GetObjData(a);
	fa[idx]=f;
}

elem BS1_TYVec_List2FVec(elem l)
{
	float *fa;
	elem c, t;
	int i;

	c=l; i=0;
	while(BS1_CONSP(c)) { i++; c=CDR(c); }

//	printf("vec %d\n", i);

	t=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
	fa=BS1_TY_GetObjData(t);

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		fa[i]=TOFLOAT(CAR(c));
		i++; c=CDR(c);
	}

	return(t);
}

elem BS1_TYVec_MakeFVec(float *fa, int n)
{
	float *fb;
	elem t;
	int i;

	t=BS1_MM_AllocObj(BS1_TYH_FVECTOR, n*sizeof(float));
	fb=BS1_TY_GetObjData(t);
	if(fa)for(i=0; i<n; i++)fb[i]=fa[i];
	return(t);
}

elem BS1_TYVec_MakeFVec2(float a, float b)
{
	float *fa;
	elem t;

	t=BS1_MM_AllocObj(BS1_TYH_FVECTOR, 2*sizeof(float));
	fa=BS1_TY_GetObjData(t);
	fa[0]=a; fa[1]=b;
	return(t);
}

elem BS1_TYVec_MakeFVec3(float a, float b, float c)
{
	float *fa;
	elem t;

	t=BS1_MM_AllocObj(BS1_TYH_FVECTOR, 3*sizeof(float));
	fa=BS1_TY_GetObjData(t);
	fa[0]=a; fa[1]=b; fa[2]=c;
	return(t);
}

elem BS1_TYVec_MakeFVec4(float a, float b, float c, float d)
{
	float *fa;
	elem t;

	t=BS1_MM_AllocObj(BS1_TYH_FVECTOR, 4*sizeof(float));
	fa=BS1_TY_GetObjData(t);
	fa[0]=a; fa[1]=b; fa[2]=c; fa[3]=d;
	return(t);
}

elem BS1_TYVec_AddVec(elem a, elem b)
{
	float *fa, *fb, *fc;
	elem c, t;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	j=BS1_MM_GetObjSize(b)/sizeof(float);
	fa=BS1_TY_GetObjData(a);
	fb=BS1_TY_GetObjData(b);

	if(i!=j)return(BS1_MM_NULL);

	c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
	fc=BS1_TY_GetObjData(c);
	for(j=0; j<i; j++)fc[j]=fa[j]+fb[j];
	return(c);
}

elem BS1_TYVec_SubVec(elem a, elem b)
{
	float *fa, *fb, *fc;
	elem c, t;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	j=BS1_MM_GetObjSize(b)/sizeof(float);
	fa=BS1_TY_GetObjData(a);
	fb=BS1_TY_GetObjData(b);

	if(i!=j)return(BS1_MM_NULL);

	c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
	fc=BS1_TY_GetObjData(c);
	for(j=0; j<i; j++)fc[j]=fa[j]-fb[j];
	return(c);
}


elem BS1_TYVec_DotVec(elem a, elem b)
{
	float *fa, *fb;
	float f;
	elem c, t;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	j=BS1_MM_GetObjSize(b)/sizeof(float);
	fa=BS1_TY_GetObjData(a);
	fb=BS1_TY_GetObjData(b);

	if(i!=j)return(BS1_MM_NULL);

	f=0;
	for(j=0; j<i; j++)f+=fa[j]*fb[j];
	return(FLONUM(f));
}

elem BS1_TYVec_ScaleVecNum(elem a, elem b)
{
	float *fa, *fb, *fc;
	elem c, t;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	fa=BS1_TY_GetObjData(a);

	c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
	fc=BS1_TY_GetObjData(c);
	for(j=0; j<i; j++)fc[j]=fa[j]*TOFLOAT(b);
	return(c);
}

elem BS1_TYVec_CrossVec(elem a, elem b)
{
	float *fa, *fb, *fc;
	float f;
	elem c, t;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	j=BS1_MM_GetObjSize(b)/sizeof(float);
	fa=BS1_TY_GetObjData(a);
	fb=BS1_TY_GetObjData(b);

	if(i!=j)return(BS1_MM_NULL);

	if(i==2)
	{
		f=fa[0]*fb[1]-fa[1]*fb[0];
		return(FLONUM(f));
	}

	if(i==3)
	{
		c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
		fc=BS1_TY_GetObjData(c);

		fc[0]=(fa[1]*fb[2])-(fa[2]*fb[1]);
		fc[1]=(fa[2]*fb[0])-(fa[0]*fb[2]);
		fc[2]=(fa[0]*fb[1])-(fa[1]*fb[0]);

		return(c);
	}

	if(i==4)
	{
		c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, 3*sizeof(float));
		fc=BS1_TY_GetObjData(c);

		fc[0]=(fa[1]*fb[2])-(fa[2]*fb[1]);
		fc[1]=(fa[2]*fb[0])-(fa[0]*fb[2]);
		fc[2]=(fa[0]*fb[1])-(fa[1]*fb[0]);

		return(c);
	}

	return(BS1_MM_NULL);
}

elem BS1_TYVec_CrossVec2(elem a, elem b)
{
	float *fa, *fb, *fc;
	float f;
	elem c, t;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	j=BS1_MM_GetObjSize(b)/sizeof(float);
	fa=BS1_TY_GetObjData(a);
	fb=BS1_TY_GetObjData(b);

	if(i!=j)return(BS1_MM_NULL);

	if(i==2)
	{
		f=fa[0]*fb[1]-fa[1]*fb[0];
		return(FLONUM(f));
	}

	if(i==3)
	{
		c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
		fc=BS1_TY_GetObjData(c);

		fc[0]=(fa[1]*fb[2])-(fa[2]*fb[1]);
		fc[1]=(fa[2]*fb[0])-(fa[0]*fb[2]);
		fc[2]=(fa[0]*fb[1])-(fa[1]*fb[0]);

		return(c);
	}

	if(i==4)
	{
		c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
		fc=BS1_TY_GetObjData(c);

		fc[0]=(fa[3]*fb[0])+(fa[0]*fb[3])+(fa[1]*fb[2])-(fa[2]*fb[1]);
		fc[1]=(fa[3]*fb[1])+(fa[1]*fb[3])+(fa[2]*fb[0])-(fa[0]*fb[2]);
		fc[2]=(fa[3]*fb[2])+(fa[2]*fb[3])+(fa[0]*fb[1])-(fa[1]*fb[0]);
		fc[3]=(fa[3]*fb[3])-(fa[0]*fb[0])-(fa[1]*fb[1])-(fa[2]*fb[2]);

		return(c);
	}

	return(BS1_MM_NULL);
}


elem BS1_TYVec_VecLength(elem a)
{
	float *fa;
	elem t;
	float f;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	fa=BS1_TY_GetObjData(a);

	f=0;
	for(j=0; j<i; j++)f+=fa[j]*fa[j];
	t=FLONUM(sqrt(f));

	return(t);
}

elem BS1_TYVec_Normalize(elem a)
{
	float *fa, *fc;
	elem c, t;
	float f;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	fa=BS1_TY_GetObjData(a);

	f=0;
	for(j=0; j<i; j++)f+=fa[j]*fa[j];
	f=sqrt(f);
	if(f<0.000001)f=1;
	f=1.0/f;

	c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
	fc=BS1_TY_GetObjData(c);
	for(j=0; j<i; j++)fc[j]=fa[j]*f;
	return(c);
}

elem BS1_TYVec_Conjugate(elem a)
{
	float *fa, *fc;
	elem c, t;
	float f;
	int i, j;

	i=BS1_MM_GetObjSize(a)/sizeof(float);
	fa=BS1_TY_GetObjData(a);

	if(i!=4)return(BS1_MM_NULL);

	c=BS1_MM_AllocObj(BS1_TYH_FVECTOR, i*sizeof(float));
	fc=BS1_TY_GetObjData(c);

	fc[0]=-fa[0];
	fc[1]=-fa[1];
	fc[2]=-fa[2];
	fc[3]=fa[3];

	return(c);
}


//code for complexes...

elem BS1_TYVec_Complex(float a, float b)
{
	float *fa;
	elem t;
	int i;

	if(fabs(b)<0.000001)
		return(FLONUM(a));

	t=BS1_MM_AllocObj(BS1_TYH_COMPLEX, 2*sizeof(float));
	fa=BS1_TY_GetObjData(t);

	fa[0]=a;
	fa[1]=b;
	return(t);
}

float BS1_TYVec_GetReal(elem t)
{
	float *fa;

	if(!BS1_COMPLEXP(t))
		return(TOFLOAT(t));

	fa=BS1_TY_GetObjData(t);
	return(fa[0]);
}

float BS1_TYVec_GetImag(elem t)
{
	float *fa;

	if(!BS1_COMPLEXP(t))
		return(0);

	fa=BS1_TY_GetObjData(t);
	return(fa[1]);
}

elem BS1_TYVec_AddComplex(elem a, elem b)
{
	float f0, g0, f1, g1;

	f0=BS1_TYVec_GetReal(a); g0=BS1_TYVec_GetImag(a);
	f1=BS1_TYVec_GetReal(b); g1=BS1_TYVec_GetImag(b);
	return(BS1_TYVec_Complex(f0+f1, g0+g1));
}

elem BS1_TYVec_SubComplex(elem a, elem b)
{
	float f0, g0, f1, g1;

	f0=BS1_TYVec_GetReal(a); g0=BS1_TYVec_GetImag(a);
	f1=BS1_TYVec_GetReal(b); g1=BS1_TYVec_GetImag(b);
	return(BS1_TYVec_Complex(f0-f1, g0-g1));
}

elem BS1_TYVec_MulComplex(elem a, elem b)
{
	float f0, g0, f1, g1;

	f0=BS1_TYVec_GetReal(a); g0=BS1_TYVec_GetImag(a);
	f1=BS1_TYVec_GetReal(b); g1=BS1_TYVec_GetImag(b);
	return(BS1_TYVec_Complex(f0*f1-g0*g1, f0*g1+g0*f1));
}

elem BS1_TYVec_DivComplex(elem a, elem b)
{
	float f0, g0, f1, g1;
	float f, g, h;

	f0=BS1_TYVec_GetReal(a); g0=BS1_TYVec_GetImag(a);
	f1=BS1_TYVec_GetReal(b); g1=BS1_TYVec_GetImag(b);

	h=f1*f1+g1*g1;
	if(h==0)return(BS1_MM_NULL);

	f=(f0*f1+g0*g1)/h;
	g=-(f0*g1-g0*f1)/h;

	return(BS1_TYVec_Complex(f, g));
}

elem BS1_TYVec_ExpComplex(elem a, elem b)
{
	double f0, g0, f1, g1;
	double f, g, h;
	int i, j;

	f0=BS1_REAL(a); g0=BS1_IMAG(a);
	f1=BS1_REAL(b); g1=BS1_IMAG(b);

	//complex^complex
	if(BS1_COMPLEXP(b))
	{
		g=atan2(g0, f0);
		h=pow(f0*f0+g0*g0, f1/2)*pow(M_E, -g1*g);
		f=f1*g + 0.5*f1*log(f0*f0+g0*g0);
		return(BS1_COMPLEX(h*cos(f), h*sin(f)));
	}

	//complex^int
	if(BS1_FIXNUMP(b))
	{
		f=1; g=0;

		i=TOINT(b);
		j=(i<0)?(-i):i;
		while(j--)
		{
			f1=f; g1=g;
			f=f1*f0-g1*g0;
			g=f1*g0+g1*f0;
		}
		if(i<0)
		{
			h=f*f+g*g;
			f=f/h;
			g=-g/h;
		}

		return(BS1_COMPLEX(f, g));
	}

	//complex^real
	g=sqrt(f0*f0+g0*g0);
	h=atan2(g0, f0);
	f=pow(g, f1)*cos(f1*h);
	g=pow(g, f1)*sin(f1*h);
	return(BS1_COMPLEX(f, g));
}

/*
S-Expression Parser
*/

#include <bgbscr1.h>

#define BS1_TTY_SPECIAL		1
#define BS1_TTY_SYMBOL		2
#define BS1_TTY_STRING		3

char *BS1_ParseS_EatWhite(char *s)
{
	int i, r;

	i=0;
	while(*s && *s<=' ')
	{
		i=1;
		s++;
	}
	if(*s == ';')while(*s && *s!='\n')
	{
		i=1;
		s++;
	}
	if(*s == '#' && s[1]=='!')
	{
		i=1;
		r=1;
		s+=2;
		while(*s && r)
		{
			if(*s=='!' && s[1]=='#')
			{
				r--;
				s+=2;
				continue;
			}
			if(*s=='#' && s[1]=='!')
			{
				r++;
				s+=2;
				continue;
			}
			s++;
		}
	}
	if(*s == '#' && s[1]=='|')
	{
		i=1;
		r=1;
		s+=2;
		while(*s && r)
		{
			if(*s=='|' && s[1]=='#')
			{
				r--;
				s+=2;
				continue;
			}
			if(*s=='#' && s[1]=='|')
			{
				r++;
				s+=2;
				continue;
			}
			s++;
		}
	}
	if(*s == '#' && s[1]==';')
	{
		i=1;
		s+=2;
		BS1_ParseS_Item(&s, 0);
	}

	if(i)s=BS1_ParseS_EatWhite(s);

	return(s);
}

int BS1_ParseS_SpecialP(char *s)
{
	switch(*s)
	{
	case '(':
		return(1);
		break;
	case ')':
		return(1);
		break;
	case '[':
		return(1);
		break;
	case ']':
		return(1);
		break;
	case '{':
		return(1);
		break;
	case '}':
		return(1);
		break;

	case '\'':
		return(1);
		break;
	case '`':
		return(1);
		break;
	case '#':
		return(1);
		break;
//	case '.':
//		return(1);
//		break;
	case '\\':
		return(1);
		break;
	case ',':
		return(1);
		break;
	case '@':
		return(1);
		break;
	default:
		return(0);
		break;
	}
	return(0);
}

char *BS1_ParseS_Token(char *s, char *b, int *t)
{
	char tb[256];
	char *ob;

	if(!b)b=tb;
	ob=b;
	*b=0;

	if(t)*t=0;

	s=BS1_ParseS_EatWhite(s);
	if(!*s)return(s);

	if(BS1_ParseS_SpecialP(s))
	{
		if(t)*t=BS1_TTY_SPECIAL;

		*b++=*s++;
		*b=0;
	}else if(*s=='"') /* quoted string */
	{
		if(t)*t=BS1_TTY_STRING;
		s++;
		while(*s && *s!='"')
		{
			if(*s=='\\')
			{
				s++;
				switch(*s)
				{
				case 'n':
					*b++='\n';
					break;
				case 't':
					*b++='\t';
					break;
				case 'r':
					*b++='\r';
					break;
				case '\\':
					*b++='\\';
					break;
				case '"':
					*b++='"';
					break;
				default:
					break;
				}
				s++;
			}else *b++=*s++;
		}
		*b++=0;
		s++;
	}else
	{	/* alphanumeric string that can contain '_' */
		if(t)*t=BS1_TTY_SYMBOL;

		while(*s && *s>' ' && !BS1_ParseS_SpecialP(s))
			*b++=*s++;
		*b++=0;
	}
	return(s);
}

elem BS1_ParseS_List(char **s, int ind)
{
	elem t, l;
	char buf[256];
	int ty;

	l=BS1_MM_NULL;

	while(1)
	{
		if(!**s)return(BS1_MM_NULL);
		BS1_ParseS_Token(*s, buf, &ty);

		if(ty!=BS1_TTY_STRING)
		{
			if(buf[0]==')')break;
			if(buf[0]==']')break;
			if(buf[0]=='}')break;

			if((buf[0]=='.') && (buf[1]==0))
			{
				*s=BS1_ParseS_Token(*s, buf, &ty);
				t=BS1_ParseS_Item(s, ind);
				*s=BS1_ParseS_Token(*s, buf, &ty);
				l=BS1_TY_NReverse(l);
				BS1_TY_NAppend(l, t);
				return(l);
			}
		}

		t=BS1_ParseS_Item(s, ind);
		l=CONS(t, l);
	}
	*s=BS1_ParseS_Token(*s, buf, &ty);
	l=BS1_TY_NReverse(l);
	return(l);
}

double BS1_ParseS_Float(char *s)
{
	double x, y;
	int sg;

	sg=1;
	x=0;
	y=0;
	while(*s)
	{
		if(*s=='-')
		{
			sg*=-1;
			s++;
		}
		if(*s=='.')
		{
			y=1;
			s++;
		}

		if(*s>='0' && *s<='9')
		{
			x=(x*10)+(*s-'0');
			y=y*10;
			s++;
		}
	}
	if(y==0)y=1;
	x=(x*sg)/y;
	return(x);
}

static int bs1_isdigit(char c)
	{ return((c>='0') && (c<='9')); }
static int bs1_isupper(char c)
	{ return((c>='A') && (c<='Z')); }
static int bs1_islower(char c)
	{ return((c>='a') && (c<='z')); }
static int bs1_isalpha(char c)
	{ return(bs1_isupper(c) || bs1_islower(c)); }
static int bs1_isalnum(char c)
	{ return(bs1_isalpha(c) || bs1_isdigit(c)); }

static int bs1_strlen(char *str)
	{ char *s; s=str; while(*s)s++; return(s-str); }
static int bs1_lcase(char c)
	{ return(((c>='A') && (c<='Z'))?(c-'A'+'a'):c); }
static int bs1_stricmp(char *s0, char *s1)
{
	while(*s0 && *s1 && bs1_lcase(*s0)==bs1_lcase(*s1)) { s0++; s1++; }
	return((*s0==*s1)?0:(*s0>*s1)?1:-1);
}

static int bs1_atoi(char *str)
{
	char *s;
	int i, j;

	s=str;
	if((s[0]=='0') && (s[1]=='x'))
	{
		s+=2; i=0;
		while(*s)
		{
			j=-1;
			if((*s>='0') && (*s<='9'))j=*s-'0';
			if((*s>='A') && (*s<='F'))j=*s-'A'+10;
			if((*s>='a') && (*s<='f'))j=*s-'a'+10;
			if(j<0)break;
			i=i*16+j;
			s++;
		}
		return(i);
	}
	if(*s=='0')
	{
		s++; i=0;
		while(*s)
		{
			j=-1;
			if((*s>='0') && (*s<='7'))j=*s-'0';
			if(j<0)break;
			i=i*8+j;
			s++;
		}
		return(i);
	}

	i=0;
	while(*s)
	{
		j=-1;
		if((*s>='0') && (*s<='9'))j=*s-'0';
		if(j<0)break;
		i=i*10+j;
		s++;
	}
	return(i);
}

elem BS1_ParseS_Item(char **s, int ind)
{
	char buf[256], buf2[16];
	int ty, i;
	elem t;
	char *s2, *t2;

	t=BS1_MM_NULL;

	*s=BS1_ParseS_EatWhite(*s);
	if(!**s)return(BS1_MM_NULL);

	*s=BS1_ParseS_Token(*s, buf, &ty);
	switch(ty)
	{
	case BS1_TTY_STRING:
		t=STRING(buf);
		break;
	case BS1_TTY_SYMBOL:
		if(bs1_isdigit(buf[0]) || ((buf[0]=='-') && bs1_isdigit(buf[1])))
		{
			i=0; s2=buf;
			while(*s2)
			{
				if(*s2=='.')i++;
				if(*s2=='e')i++;
				s2++;
			}

			if(i)t=FLONUM(BS1_ParseS_Float(buf));
				else t=FIXNUM(bs1_atoi(buf));
		}else
		{
			if(buf[0]==':') { t=KEYSYM(buf+1); }
				else if(buf[bs1_strlen(buf)-1]==':')
			{
				buf[bs1_strlen(buf)-1]=0;
				t=KEYSYM(buf);
			}else t=SYM(buf);
		}
		break;
	case BS1_TTY_SPECIAL:
		switch(buf[0])
		{
		case '(':
			t=BS1_ParseS_List(s, ind);
			break;
		case '[':
			t=BS1_ParseS_List(s, ind);
			t=CONS(SYM("list"), t);
			break;
		case '#':
			switch(**s)
			{
			case 't':
				*s=BS1_ParseS_Token(*s, buf, &ty);
				t=BS1_MM_TRUE;
				break;
			case 'f':
				*s=BS1_ParseS_Token(*s, buf, &ty);
				t=BS1_MM_FALSE;
				break;
			case 'z':
				*s=BS1_ParseS_Token(*s, buf, &ty);
				t=BS1_MM_NULL;
				break;

			case 'o':
				*s=BS1_ParseS_Token(*s, buf, &ty);
				buf[0]='0';
				t=FIXNUM(bs1_atoi(buf));
				break;
			case '(':
				t=BS1_ParseS_Item(s, ind);
				t=BS1_TY_ListToArray(t);
				break;
			case '[':
				*s=*s+1;
				t=BS1_ParseS_List(s, ind);
				t=CONS(SYM("vector"), t);
				break;
			case '\\':
				//*s=BS1_ParseS_Token(*s, buf, &ty); /* slash */
				*s=*s+1;
				i=**s;
				buf[1]=0;
				if(bs1_isalpha(i))*s=BS1_ParseS_Token(*s, buf, &ty); /* char name */
					else *s=*s+1;
				if(buf[1])
				{
					t=BS1_MM_NULL;
					if(!bs1_stricmp(buf, "space"))t=BS1_CHAR(' ');
					if(!bs1_stricmp(buf, "backspace"))t=BS1_CHAR('\x08');
					if(!bs1_stricmp(buf, "tab"))t=BS1_CHAR('\t');
					if(!bs1_stricmp(buf, "newline"))t=BS1_CHAR('\n');
					if(!bs1_stricmp(buf, "return"))t=BS1_CHAR('\r');
					if(buf[0]=='x')
					{
						t2=buf2; *t2++='0';
						*t2++='x'; s2=buf+1;
						while(*s2)*s2++=*t2++; *t2++=0;
						t=BS1_CHAR(bs1_atoi(buf2));
					}
				}else t=BS1_TY_Char(i);
				break;
			case '"':
				*s=BS1_ParseS_Token(*s, buf, &ty);
				t=SYM(buf);
				break;
			default:
				//unknown
				t=BS1_MM_NULL;
				break;
			}
			break;
		case '\'':
			t=BS1_ParseS_Item(s, ind);
			t=CONS(t, BS1_MM_NULL);
			t=CONS(SYM("quote"), t);
			break;
		case '`':
			t=BS1_ParseS_Item(s, ind);
			t=CONS(t, BS1_MM_NULL);
			t=CONS(SYM("quasiquote"), t);
			break;
		case ',':
			if(**s=='@')
			{
				*s=*s+1;
				t=BS1_ParseS_Item(s, ind);
				t=CONS(t, BS1_MM_NULL);
				t=CONS(SYM("unquote-splicing"), t);
			}else if(**s==',')
			{
				*s=*s+1;
				t=BS1_ParseS_Item(s, ind);
				t=CONS(t, BS1_MM_NULL);
				t=CONS(SYM("doublemark"), t);
			}else
			{
				t=BS1_ParseS_Item(s, ind);
				t=CONS(t, BS1_MM_NULL);
				t=CONS(SYM("unquote"), t);
			}
			break;
		default:
//			printf("parse: unknown special '%c'.\n", buf[0]);
			break;
		}
		break;
	default:
//		printf("parse wrong type.\n");
		return(BS1_MM_NULL);
		break;
	}
	return(t);
}

elem BS1_ParseS_FromString(char *s)
{
	return(BS1_ParseS_Item(&s, 0));
}

elem BS1_ParseS_MultiFromString(char *s)
{
	elem t, l;

	l=BS1_MM_NULL;
	while(1)
	{
		s=BS1_ParseS_EatWhite(s);
		if(!*s)break;

		t=BS1_ParseS_Item(&s, 0);
		l=CONS(t, l);
	}
	l=BS1_TY_NReverse(l);

	return(l);
}
#include <bgbscr1.h>

#include <stdio.h>
#include <string.h>
#include <math.h>

#include <bgbscr1.h>

elem bs1_opr_uops[16];
elem bs1_opr_bops[64];

int BS1_Opr_Init()
{
	int i;

	for(i=0; i<16; i++)bs1_opr_uops[i]=BS1_MM_NULL;
	for(i=0; i<64; i++)bs1_opr_bops[i]=BS1_MM_NULL;
	BS1_GC_AddRootArray(bs1_opr_uops, 16);
	BS1_GC_AddRootArray(bs1_opr_bops, 64);
}

void BS1_OPR_AddUnaryFcn(int op, char *ty, elem (*fcn)(elem a))
{
	BS1_SVMFixed *fp;
	elem t;

	t=BS1_MM_AllocObjA64(BS1_TYH_SVMFIXED, sizeof(void *));

	fp=BS1_TY_GetObjDataA64(t);
	fp->fcn=fcn;
	fp->nargs=1;

	t=LIST2(KEYSYM(ty), t);
	SET(bs1_opr_uops[op], CONS(t, bs1_opr_uops[op]));
}

void BS1_OPR_AddBinaryFcn(int op, char *ta, char *tb,
	elem (*fcn)(elem a, elem b))
{
	BS1_SVMFixed *fp;
	elem t;

	t=BS1_MM_AllocObjA64(BS1_TYH_SVMFIXED, sizeof(void *));

	fp=BS1_TY_GetObjDataA64(t);
	fp->fcn=fcn;
	fp->nargs=2;

	t=LIST3(KEYSYM(ta), KEYSYM(tb), t);
	SET(bs1_opr_bops[op], CONS(t, bs1_opr_bops[op]));
}

elem BS1_Opr_ApplyUnaryFcn(elem a, elem f)
{
	BS1_SVMFixed *fcn;
	elem (*fp)(elem a);
	elem t;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMFIXED)
	{
		fcn=BS1_TY_GetObjDataA64(f);
		fp=fcn->fcn;
		t=fp(a);
		return(t);
	}

	t=BS1_TY_Call(BS1_MM_NULL, f, LIST1(a));
	return(t);
}

elem BS1_Opr_ApplyBinaryFcn(elem a, elem b, elem f)
{
	BS1_SVMFixed *fcn;
	elem (*fp)(elem a, elem b);
	elem t;

	if(BS1_TY_GetType(f)==BS1_TYH_SVMFIXED)
	{
		fcn=BS1_TY_GetObjDataA64(f);
		fp=fcn->fcn;
		t=fp(a, b);
		return(t);
	}

	t=BS1_TY_Call(BS1_MM_NULL, f, LIST2(a, b));
	return(t);
}

elem BS1_Opr_UnaryGeneric(int op, elem a)
{
	elem c, t, ty;

	ty=KEYSYM(BS1_TY_GetTypeName(a));

	c=bs1_opr_uops[op];
	while(BS1_CONSP(c))
	{
		if(CAADR(c)==ty)
		{
			t=CADAR(c);
			t=BS1_Opr_ApplyUnaryFcn(a, t);
			return(t);
		}
		c=CDR(c);
	}

	c=bs1_opr_uops[op];
	while(BS1_CONSP(c))
	{
		if(CAADR(c)==BS1_MM_NULL)
		{
			t=CADAR(c);
			t=BS1_Opr_ApplyUnaryFcn(a, t);
			if(t!=BS1_MM_NULL)return(t);
		}
		c=CDR(c);
	}

	return(BS1_MM_NULL);
}

elem BS1_Opr_BinaryGeneric(int op, elem a, elem b)
{
	elem c, t, ta, tb;

	ta=KEYSYM(BS1_TY_GetTypeName(a));
	tb=KEYSYM(BS1_TY_GetTypeName(b));

	c=bs1_opr_bops[op];
	while(BS1_CONSP(c))
	{
		if((CAADR(c)==ta) && (CADADR(c)==tb))
		{
			t=CADDAR(c);
			t=BS1_Opr_ApplyBinaryFcn(a, b, t);
			return(t);
		}
		c=CDR(c);
	}

	c=bs1_opr_bops[op];
	while(BS1_CONSP(c))
	{
		if((CAADR(c)==ta) && (CADADR(c)==BS1_MM_NULL))
		{
			t=CADDAR(c);
			t=BS1_Opr_ApplyBinaryFcn(a, b, t);
			if(t!=BS1_MM_NULL)return(t);
		}
		c=CDR(c);
	}

	c=bs1_opr_bops[op];
	while(BS1_CONSP(c))
	{
		if((CAADR(c)==BS1_MM_NULL) && (CADADR(c)==BS1_MM_NULL))
		{
			t=CADDAR(c);
			t=BS1_Opr_ApplyBinaryFcn(a, b, t);
			if(t!=BS1_MM_NULL)return(t);
		}
		c=CDR(c);
	}

	return(BS1_MM_NULL);
}


elem BS1_Opr_Add(elem a, elem b)
{
	char *s0, *s1, *s2;

//	if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b))
//	if(BS1_LINTP(a) && BS1_LINTP(b))
//		return(BS1_INT(TOLONG(a)+TOLONG(b)));

	if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b))
		return(BS1_INT(TOLONG(a)+TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_AddLong(a, b));

	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
	{
		if(BS1_RATIONALP(a) || BS1_RATIONALP(b))
		{
			if(BS1_RATIONALP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Add(a, b));
			if(BS1_RATIONALP(a) && BS1_FIXNUMP(b))
				return(BS1_TYRat_Add(a, b));
			if(BS1_FIXNUMP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Add(a, b));
		}

		if(BS1_COMPLEXP(a) || BS1_COMPLEXP(b))
			return(BS1_TYVec_AddComplex(a, b));
		return(FLONUM(TOFLOAT(a)+TOFLOAT(b)));
	}

	if(BS1_FVECTORP(a) && BS1_FVECTORP(b))
		return(BS1_TYVec_AddVec(a, b));

	if(BS1_FMATRIXP(a) && BS1_FMATRIXP(b))
		return(BS1_TYMat_AddMatrix(a, b));

	if(BS1_STRINGP(a) && BS1_STRINGP(b))
	{
		s0=TOSTRING(a); s1=TOSTRING(b);
		s2=BS1_MM_RAlloc(strlen(s0)+strlen(s1)+4);
		strcpy(s2, s0); strcat(s2, s1);
		return(STRING(s2));
	}

	return(BS1_Opr_BinaryGeneric(BS1_OPR_ADD, a, b));
//	return(BS1_MM_NULL);
}

elem BS1_Opr_DAdd(elem a, elem b)
{
	elem t;

	t=BS1_Opr_BinaryGeneric(BS1_OPR_DADD, a, b);
	if(t!=BS1_MM_NULL)return(0);
	return(BS1_Opr_Add(a, b));
}

elem BS1_Opr_Sub(elem a, elem b)
{
//	if(BS1_LINTP(a) && BS1_LINTP(b))
//		return(BS1_INT(TOLONG(a)-TOLONG(b)));
	if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b))
		return(BS1_INT(TOLONG(a)-TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_SubLong(a, b));

	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
	{
		if(BS1_RATIONALP(a) || BS1_RATIONALP(b))
		{
			if(BS1_RATIONALP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Sub(a, b));
			if(BS1_RATIONALP(a) && BS1_FIXNUMP(b))
				return(BS1_TYRat_Sub(a, b));
			if(BS1_FIXNUMP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Sub(a, b));
		}

		if(BS1_COMPLEXP(a) || BS1_COMPLEXP(b))
			return(BS1_TYVec_SubComplex(a, b));
		return(FLONUM(TOFLOAT(a)-TOFLOAT(b)));
	}

	if(BS1_FVECTORP(a) && BS1_FVECTORP(b))
		return(BS1_TYVec_SubVec(a, b));
	if(BS1_FMATRIXP(a) && BS1_FMATRIXP(b))
		return(BS1_TYMat_SubMatrix(a, b));

	return(BS1_Opr_BinaryGeneric(BS1_OPR_SUB, a, b));
//	return(BS1_MM_NULL);
}

elem BS1_Opr_DSub(elem a, elem b)
{
	elem t;

	t=BS1_Opr_BinaryGeneric(BS1_OPR_DSUB, a, b);
	if(t!=BS1_MM_NULL)return(0);
	return(BS1_Opr_Sub(a, b));
}

elem BS1_Opr_Mul(elem a, elem b)
{
//	if(BS1_LINTP(a) && BS1_LINTP(b))
//		return(BS1_INT(TOLONG(a)*TOLONG(b)));
	if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b))
		return(BS1_INT(TOLONG(a)*TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_MulLong(a, b));

	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
	{
		if(BS1_RATIONALP(a) || BS1_RATIONALP(b))
		{
			if(BS1_RATIONALP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Mul(a, b));
			if(BS1_RATIONALP(a) && BS1_FIXNUMP(b))
				return(BS1_TYRat_Mul(a, b));
			if(BS1_FIXNUMP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Mul(a, b));
		}

		if(BS1_COMPLEXP(a) || BS1_COMPLEXP(b))
			return(BS1_TYVec_MulComplex(a, b));
		return(FLONUM(TOFLOAT(a)*TOFLOAT(b)));
	}

	if(BS1_FVECTORP(a))
	{
		if(BS1_FVECTORP(b))
			return(BS1_TYVec_DotVec(a, b));
		if(BS1_NUMBERP(b))
			return(BS1_TYVec_ScaleVecNum(a, b));
	}else if(BS1_FVECTORP(b))
	{
		if(BS1_NUMBERP(b))
			return(BS1_TYVec_ScaleVecNum(b, a));
	}

	if(BS1_FMATRIXP(a))
	{
		if(BS1_FMATRIXP(b))
			return(BS1_TYMat_MultMatrix(a, b));
		if(BS1_NUMBERP(b))
			return(BS1_TYMat_ScaleMatrix(a, b));
		if(BS1_FVECTORP(b))
			return(BS1_TYMat_MultMatrixVector(a, b));
	}else if(BS1_FMATRIXP(b))
	{
		if(BS1_NUMBERP(a))
			return(BS1_TYMat_ScaleMatrix(b, a));
		if(BS1_FVECTORP(a))
			return(BS1_TYMat_MultMatrixVector(a, b));
	}

	return(BS1_Opr_BinaryGeneric(BS1_OPR_MUL, a, b));
//	return(BS1_MM_NULL);
}

elem BS1_Opr_DMul(elem a, elem b)
{
	elem t;

	t=BS1_Opr_BinaryGeneric(BS1_OPR_DMUL, a, b);
	if(t!=BS1_MM_NULL)return(0);
	return(BS1_Opr_Mul(a, b));
}

elem BS1_Opr_Div(elem a, elem b)
{
	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(FLONUM(TOFLOAT(a)/TOINT(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_DivLong(a, b));

	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
	{
		if(BS1_RATIONALP(a) || BS1_RATIONALP(b))
		{
			if(BS1_RATIONALP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Div(a, b));
			if(BS1_RATIONALP(a) && BS1_FIXNUMP(b))
				return(BS1_TYRat_Div(a, b));
			if(BS1_FIXNUMP(a) && BS1_RATIONALP(b))
				return(BS1_TYRat_Div(a, b));
		}

		if(BS1_COMPLEXP(a) || BS1_COMPLEXP(b))
			return(BS1_TYVec_DivComplex(a, b));
		return(FLONUM(TOFLOAT(a)/TOFLOAT(b)));
	}

	if(BS1_FVECTORP(a) && BS1_NUMBERP(b))
		return(BS1_TYVec_ScaleVecNum(a,
			FLONUM(1.0/TOFLOAT(b))));
	if(BS1_FMATRIXP(a) && (BS1_FMATRIXP(b) || BS1_NUMBERP(b)))
		return(BS1_TYMat_DivMatrix(a, b));

	return(BS1_Opr_BinaryGeneric(BS1_OPR_DIV, a, b));
//	return(BS1_MM_NULL);
}

elem BS1_Opr_DDiv(elem a, elem b)
{
	elem t;

	if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b))
		return(BS1_TY_Rational(TOINT(a), TOINT(b)));

	t=BS1_Opr_BinaryGeneric(BS1_OPR_DDIV, a, b);
	if(t!=BS1_MM_NULL)return(0);
	return(BS1_Opr_Div(a, b));
}

elem BS1_Opr_IDiv(elem a, elem b)
{
	elem t;

	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(BS1_INT(TOLONG(a)/TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_DivLong(a, b));

	return(BS1_Opr_BinaryGeneric(BS1_OPR_IDIV, a, b));
}

elem BS1_Opr_Mod(elem a, elem b)
{
	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(BS1_INT(TOLONG(a)%TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_ModLong(a, b));
	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
		return(FLONUM(fmod(TOFLOAT(a), TOFLOAT(b))));

	if(BS1_FVECTORP(a) && BS1_FVECTORP(b))
		return(BS1_TYVec_CrossVec(a, b));

	return(BS1_Opr_BinaryGeneric(BS1_OPR_MOD, a, b));
}

elem BS1_Opr_Shl(elem a, elem b)
{
//	if(BS1_LINTP(a) && BS1_LINTP(b))
//		return(BS1_INT(TOLONG(a)<<TOINT(b)));
	if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b) && (TOINT(b)<32))
		return(BS1_INT(TOLONG(a)<<TOINT(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_ShlLong(a, b));
	return(BS1_Opr_BinaryGeneric(BS1_OPR_SHL, a, b));
}

elem BS1_Opr_Shr(elem a, elem b)
{
	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(BS1_INT(TOLONG(a)>>TOINT(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_ShrLong(a, b));
	return(BS1_Opr_BinaryGeneric(BS1_OPR_SHR, a, b));
}

elem BS1_Opr_And(elem a, elem b)
{
	char *s0, *s1, *s2;

	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(BS1_INT(TOLONG(a)&TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_AndLong(a, b));

	if(BS1_STRINGP(a) && BS1_STRINGP(b))
	{
		s0=TOSTRING(a); s1=TOSTRING(b);
		s2=BS1_MM_RAlloc(strlen(s0)+strlen(s1)+4);
		strcpy(s2, s0); strcat(s2, s1);
		return(STRING(s2));
	}

	return(BS1_Opr_BinaryGeneric(BS1_OPR_AND, a, b));
}

elem BS1_Opr_Or(elem a, elem b)
{
	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(BS1_INT(TOLONG(a)|TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_OrLong(a, b));
	return(BS1_Opr_BinaryGeneric(BS1_OPR_OR, a, b));
}

elem BS1_Opr_Xor(elem a, elem b)
{
	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(BS1_INT(TOLONG(a)^TOLONG(b)));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_XorLong(a, b));
	if(BS1_FVECTORP(a) && BS1_FVECTORP(b))
		return(BS1_TYVec_CrossVec2(a, b));
	return(BS1_Opr_BinaryGeneric(BS1_OPR_XOR, a, b));
}

elem BS1_Opr_Exp(elem a, elem b)
{
	s64 i, j, k;
	if(BS1_LINTP(a) && BS1_LINTP(b))
	{
		i=1;
		j=TOLONG(a);
		k=TOLONG(b);
		if(k<0)
		{
			k=-k;
			while(k--)i*=j;
			return(FLONUM(1.0/i));
		}
		while(k--)i*=j;
		return(BS1_INT(i));
	}

	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
	{
//		if(BS1_COMPLEXP(a) || BS1_COMPLEXP(b))
//			return(BS1_TYVec_ExpComplex(a, b));
//		return(FLONUM(pow(TOFLOAT(a), TOFLOAT(b))));

		return(BS1_TYVec_ExpComplex(a, b));
	}

	return(BS1_Opr_BinaryGeneric(BS1_OPR_EXP, a, b));
}


int BS1_Opr_IsEqual(elem a, elem b)
{
	elem ca, cb;
	int i;

	if(a==b)return(1);
	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
	{
		if(BS1_COMPLEXP(a) || BS1_COMPLEXP(b))
			return((BS1_REAL(a)==BS1_REAL(b)) &&
				(BS1_IMAG(a)==BS1_IMAG(b)));

		if(BS1_FIXNUMP(a) && BS1_FIXNUMP(b))
			return(a==b);
		if(BS1_LINTP(a) && BS1_LINTP(b))
			return(TOLONG(a)==TOLONG(b));
		if(BS1_LXINTP(a) && BS1_LXINTP(b))
			return(BS1_TYRat_EqualLong(a, b));

		return(TOFLOAT(a)==TOFLOAT(b));
	}

	if(BS1_TY_GetType(a)!=BS1_TY_GetType(b))
		return(0);

	if(BS1_STRINGP(a))
	{
		i=!strcmp(BS1_TY_GetString(a), BS1_TY_GetString(b));
		return(i);
	}

	if(BS1_CONSP(a))
	{
		ca=a; cb=b;
		while(BS1_CONSP(ca) && BS1_CONSP(cb))
		{
			i=BS1_Opr_IsEqual(CAR(ca), CAR(cb));
			ca=CDR(ca); cb=CDR(cb);
			if(!i)return(0);
		}
		i=BS1_Opr_IsEqual(ca, cb);
		return(i);
	}

	return(TOBOOL(BS1_Opr_BinaryGeneric(BS1_OPR_EQV, a, b)));
}

int BS1_Opr_IsLess(elem a, elem b)
{
	int i;

	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(TOLONG(a)<TOLONG(b));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_LessLong(a, b));
	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
		return(TOFLOAT(a)<TOFLOAT(b));

	if(BS1_STRINGP(a) && BS1_STRINGP(b))
	{
		i=strcmp(BS1_TY_GetString(a), BS1_TY_GetString(b))<0;
		return(i);
	}
	return(TOBOOL(BS1_Opr_BinaryGeneric(BS1_OPR_L, a, b)));
}

int BS1_Opr_IsGreater(elem a, elem b)
{
	int i;

	if(BS1_LINTP(a) && BS1_LINTP(b))
		return(TOLONG(a)>TOLONG(b));
	if(BS1_LXINTP(a) && BS1_LXINTP(b))
		return(BS1_TYRat_GreaterLong(a, b));
	if(BS1_NUMBERP(a) && BS1_NUMBERP(b))
		return(TOFLOAT(a)>TOFLOAT(b));

	if(BS1_STRINGP(a) && BS1_STRINGP(b))
	{
		i=strcmp(BS1_TY_GetString(a), BS1_TY_GetString(b))>0;
		return(i);
	}
	return(TOBOOL(BS1_Opr_BinaryGeneric(BS1_OPR_G, a, b)));
}

int BS1_Opr_IsLessEqual(elem a, elem b)
	{ return(BS1_Opr_IsLess(a, b) || BS1_Opr_IsEqual(a, b)); }
int BS1_Opr_IsGreaterEqual(elem a, elem b)
	{ return(BS1_Opr_IsGreater(a, b) || BS1_Opr_IsEqual(a, b)); }


elem BS1_Opr_Binary(int op, elem a, elem b)
{
	elem t;

	switch(op)
	{
	case BS1_OPR_ADD: t=BS1_Opr_Add(a, b); break;
	case BS1_OPR_SUB: t=BS1_Opr_Sub(a, b); break;
	case BS1_OPR_MUL: t=BS1_Opr_Mul(a, b); break;
	case BS1_OPR_DIV: t=BS1_Opr_Div(a, b); break;
	case BS1_OPR_MOD: t=BS1_Opr_Mod(a, b); break;
	case BS1_OPR_AND: t=BS1_Opr_And(a, b); break;
	case BS1_OPR_OR:  t=BS1_Opr_Or (a, b); break;
	case BS1_OPR_XOR: t=BS1_Opr_Xor(a, b); break;
	case BS1_OPR_SHL: t=BS1_Opr_Shl(a, b); break;
	case BS1_OPR_SHR: t=BS1_Opr_Shr(a, b); break;
	case BS1_OPR_EXP: t=BS1_Opr_Exp(a, b); break;

	case BS1_OPR_EQ:  t=BS1_BOOL(a==b); break;
	case BS1_OPR_EQV: t=BS1_BOOL(BS1_Opr_IsEqual(a, b)); break;
	case BS1_OPR_NEQ: t=BS1_BOOL(a!=b); break;
	case BS1_OPR_NEQV: t=BS1_BOOL(!BS1_Opr_IsEqual(a, b)); break;
	case BS1_OPR_L:   t=BS1_BOOL(BS1_Opr_IsLess(a, b)); break;
	case BS1_OPR_G:   t=BS1_BOOL(BS1_Opr_IsGreater(a, b)); break;
	case BS1_OPR_LE:  t=BS1_BOOL(BS1_Opr_IsLessEqual(a, b)); break;
	case BS1_OPR_GE:  t=BS1_BOOL(BS1_Opr_IsGreaterEqual(a, b)); break;

	case BS1_OPR_DADD: t=BS1_Opr_DAdd(a, b); break;
	case BS1_OPR_DSUB: t=BS1_Opr_DSub(a, b); break;
	case BS1_OPR_DMUL: t=BS1_Opr_DMul(a, b); break;
	case BS1_OPR_DDIV: t=BS1_Opr_DDiv(a, b); break;
	case BS1_OPR_IDIV: t=BS1_Opr_IDiv(a, b); break;

	default: t=BS1_Opr_BinaryGeneric(op, a, b); break;
	}
	return(t);
}

elem BS1_Opr_Unary(int op, elem a)
{
	elem t;

//	printf("UN %d ", op);
//	BS1_TY_PrintLN(a);

	t=BS1_MM_NULL;
	switch(op)
	{
	case BS1_OPR_POS:
		t=a;
		break;
	case BS1_OPR_NEG:
		if(BS1_FIXNUMP(a))t=FIXNUM(-TOINT(a));
		if(BS1_LINTP(a))t=BS1_INT(-TOLONG(a));
		if(BS1_LXINTP(a))t=BS1_TYRat_NegLong(a);
		if(BS1_FLONUMP(a))t=FLONUM(-TOFLOAT(a));
		if(BS1_FVECTORP(a))t=BS1_TYVec_ScaleVecNum(a, FLONUM(-1));
		if(BS1_COMPLEXP(a))t=BS1_COMPLEX(-BS1_REAL(a), -BS1_IMAG(a));
		if(BS1_FMATRIXP(a))t=BS1_TYMat_ScaleMatrix(a, FLONUM(-1));
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;
	case BS1_OPR_NOT:
		if(BS1_FIXNUMP(a))t=FIXNUM(~TOINT(a));
		if(BS1_FVECTORP(a))t=BS1_TYVec_Conjugate(a);
		if(BS1_FMATRIXP(a))t=BS1_TYMat_InvertMatrix(a);
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;
	case BS1_OPR_LNOT:
		t=BS1_BOOL(!BS1_TY_GetBool(a));
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;

	case BS1_OPR_INC:
		if(BS1_FIXNUMP(a))t=FIXNUM(TOINT(a)+1);
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;
	case BS1_OPR_DEC:
		if(BS1_FIXNUMP(a))t=FIXNUM(TOINT(a)-1);
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;

	case BS1_OPR_UOR:
		if(BS1_FIXNUMP(a))t=FIXNUM((TOINT(a)<0)?-TOINT(a):TOINT(a));
		if(BS1_FLONUMP(a))t=FLONUM(fabs(TOFLOAT(a)));
		if(BS1_FVECTORP(a))t=BS1_TYVec_VecLength(a);
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;
	case BS1_OPR_UIDIV:
		if(BS1_FVECTORP(a))t=BS1_TYVec_Normalize(a);
		if(t==BS1_MM_NULL)t=BS1_Opr_UnaryGeneric(op, a);
		break;

	default: t=BS1_Opr_UnaryGeneric(op, a); break;
	}
	return(t);
}


int BS1_Opr_CondBinary(int op, elem a, elem b)
{
	elem i;

	switch(op)
	{
	case BS1_OPR_EQ:  i=(a==b); break;
	case BS1_OPR_EQV: i=(BS1_Opr_IsEqual(a, b)); break;
	case BS1_OPR_NEQ: i=(a!=b); break;
	case BS1_OPR_NEQV: i=(!BS1_Opr_IsEqual(a, b)); break;
	case BS1_OPR_L:   i=(BS1_Opr_IsLess(a, b)); break;
	case BS1_OPR_G:   i=(BS1_Opr_IsGreater(a, b)); break;
	case BS1_OPR_LE:  i=(BS1_Opr_IsLessEqual(a, b)); break;
	case BS1_OPR_GE:  i=(BS1_Opr_IsGreaterEqual(a, b)); break;
	default: i=0; break;
	}
	return(i);
}

int BS1_Opr_CondUnary(int op, elem a)
{
	elem i;

	i=0;
	switch(op)
	{
	case BS1_OPR_LNOT:
		i=!BS1_TY_GetBool(a);
		break;
	default: break;
	}
	return(i);
}


elem BS1_Opr_LoadIndex(elem obj, elem key)
{
	elem c, t;
	int i;

	if(BS1_ARRAYP(obj))
	{
		i=BS1_TY_GetInt(key);
		t=BS1_TY_GetArrayElem(obj, i);
		return(t);
	}

	if(BS1_TY_GetType(obj)==BS1_TYH_OBJECT)
	{
		t=BS1_SObj_GetSlot(obj, key);
		return(t);
	}

	if(BS1_CONSP(obj))
	{
		c=obj; i=TOINT(key);
		while(BS1_CONSP(c) && i)
			{ i--; c=CDR(c); }
		if(BS1_CONSP(c))return(CAR(c));

		return(BS1_MM_NULL);
	}

	if(BS1_FVECTORP(obj))
	{
		t=FLONUM(BS1_TYVec_GetVecVal(obj, TOINT(key)));
		return(t);
	}

	if(BS1_HANDLEP(obj))
	{
		t=BS1_TYHDL_GetSlot(obj, key);
		return(t);
	}

	t=BS1_TY_LoadIndex(obj, key);
	return(t);
}

void BS1_Opr_StoreIndex(elem obj, elem key, elem val)
{
	elem c;
	int i;

	if(BS1_ARRAYP(obj))
	{
		i=BS1_TY_GetInt(key);
		BS1_TY_SetArrayElem(obj, i, val);
		return;
	}

	if(BS1_TY_GetType(obj)==BS1_TYH_OBJECT)
	{
		BS1_SObj_SetSlot(obj, key, val);
		return;
	}

	if(BS1_CONSP(obj))
	{
		c=obj; i=TOINT(key);
		while(BS1_CONSP(c) && i)
			{ i--; c=CDR(c); }
		if(BS1_CONSP(c))BS1_TY_SetCar(c, val);

		return;
	}

	if(BS1_FVECTORP(obj))
	{
		BS1_TYVec_SetVecVal(obj, TOINT(key), TOFLOAT(val));
		return;
	}

	if(BS1_HANDLEP(obj))
	{
		BS1_TYHDL_SetSlot(obj, key, val);
		return;
	}

	BS1_TY_StoreIndex(obj, key, val);
}
/*
Code implementing 256 bit math with arrays of 32 bit ints.
*/

#include <bgbscr1.h>

#if 0

void BS1_LXI_Add32O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])+(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	c[1]+=l>>32;
}

void BS1_LXI_Add64(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])+(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l=(u64)(a[1])+(u64)(b[1])+(l>>32);
	c[1]=l&0xFFFFFFFF;
}

void BS1_LXI_Add64O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])+(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l=(u64)(a[1])+(u64)(b[1])+(l>>32);
	c[1]=l&0xFFFFFFFF;
	l=c[2]+(l>>32);
	c[2]=l&0xFFFFFFFF;
	c[3]+=l>>32;
}

void BS1_LXI_Add128(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Add64(a+2, b+2, c+2);
	BS1_LXI_Add64O(a, b, c);
}

void BS1_LXI_Add128O(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Add64O(a+2, b+2, c+2);
	BS1_LXI_Add64O(a, b, c);
}

void BS1_LXI_Add256(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Add128(a+4, b+4, c+4);
	BS1_LXI_Add128O(a, b, c);
}

void BS1_LXI_Add256O(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Add128O(a+4, b+4, c+4);
	BS1_LXI_Add128O(a, b, c);
}

void BS1_LXI_Sub64O(u32 *a, u32 *b, u32 *c)
{
	s64 l;

	l=(u64)(a[0])-(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l=(u64)(a[1])-(u64)(b[1])+(l>>32);
	c[1]=l&0xFFFFFFFF;
	l=c[2]+(l>>32);
	c[2]=l&0xFFFFFFFF;
	c[3]+=l>>32;
}

void BS1_LXI_Sub128(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Sub64(a+2, b+2, c+2);
	BS1_LXI_Sub64O(a, b, c);
}

void BS1_LXI_Sub128O(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Sub64O(a+2, b+2, c+2);
	BS1_LXI_Sub64O(a, b, c);
}

void BS1_LXI_Sub256(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Sub128(a+4, b+4, c+4);
	BS1_LXI_Sub128O(a, b, c);
}

void BS1_LXI_Sub256O(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Sub128O(a+4, b+4, c+4);
	BS1_LXI_Sub128O(a, b, c);
}
#endif

void BS1_LXI_Add256F(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])+(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l=(u64)(a[1])+(u64)(b[1])+(l>>32);
	c[1]=l&0xFFFFFFFF;
	l=(u64)(a[2])+(u64)(b[2])+(l>>32);
	c[2]=l&0xFFFFFFFF;
	l=(u64)(a[3])+(u64)(b[3])+(l>>32);
	c[3]=l&0xFFFFFFFF;
	l=(u64)(a[4])+(u64)(b[4])+(l>>32);
	c[4]=l&0xFFFFFFFF;
	l=(u64)(a[5])+(u64)(b[5])+(l>>32);
	c[5]=l&0xFFFFFFFF;
	l=(u64)(a[6])+(u64)(b[6])+(l>>32);
	c[6]=l&0xFFFFFFFF;
	l=(u64)(a[7])+(u64)(b[7])+(l>>32);
	c[7]=l&0xFFFFFFFF;
}

void BS1_LXI_Sub256F(u32 *a, u32 *b, u32 *c)
{
	s64 l;

	l=(u64)(a[0])-(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l=(u64)(a[1])-(u64)(b[1])+(l>>32);
	c[1]=l&0xFFFFFFFF;
	l=(u64)(a[2])-(u64)(b[2])+(l>>32);
	c[2]=l&0xFFFFFFFF;
	l=(u64)(a[3])-(u64)(b[3])+(l>>32);
	c[3]=l&0xFFFFFFFF;
	l=(u64)(a[4])-(u64)(b[4])+(l>>32);
	c[4]=l&0xFFFFFFFF;
	l=(u64)(a[5])-(u64)(b[5])+(l>>32);
	c[5]=l&0xFFFFFFFF;
	l=(u64)(a[6])-(u64)(b[6])+(l>>32);
	c[6]=l&0xFFFFFFFF;
	l=(u64)(a[7])-(u64)(b[7])+(l>>32);
	c[7]=l&0xFFFFFFFF;
}

void BS1_LXI_Copy256F(u32 *a, u32 *c)
{
	c[0]=a[0];	c[1]=a[1];
	c[2]=a[2];	c[3]=a[3];
	c[4]=a[4];	c[5]=a[5];
	c[6]=a[6];	c[7]=a[7];
}

void BS1_LXI_Neg256F(u32 *a, u32 *c)
{
	u64 l;

	l=(~(u64)(a[0]))+1;
	c[0]=l&0xFFFFFFFF;
	l=(~(u64)(a[1]))+(l>>32);
	c[1]=l&0xFFFFFFFF;
	l=(~(u64)(a[2]))+(l>>32);
	c[2]=l&0xFFFFFFFF;
	l=(~(u64)(a[3]))+(l>>32);
	c[3]=l&0xFFFFFFFF;
	l=(~(u64)(a[4]))+(l>>32);
	c[4]=l&0xFFFFFFFF;
	l=(~(u64)(a[5]))+(l>>32);
	c[5]=l&0xFFFFFFFF;
	l=(~(u64)(a[6]))+(l>>32);
	c[6]=l&0xFFFFFFFF;
	l=(~(u64)(a[7]))+(l>>32);
	c[7]=l&0xFFFFFFFF;
}


void BS1_LXI_Mul32O(u32 *a, u32 *b, u32 *c)
{
	u64 l;
	l=(u64)(a[0])*(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	c[1]+=l>>32;
}

void BS1_LXI_Mul32AO(u32 *a, u32 *b, u32 *c)
{
	u64 l;
	l=(u64)(a[0])*(u64)(b[0])+(u64)(c[0]);
	c[0]=l&0xFFFFFFFF;
	c[1]+=l>>32;
}

void BS1_LXI_Mul64AO(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Mul32AO(a+1, b+1, c+2);
	BS1_LXI_Mul32AO(a+1, b+0, c+1);
	BS1_LXI_Mul32AO(a+0, b+1, c+1);
	BS1_LXI_Mul32AO(a+0, b+0, c+0);
}

void BS1_LXI_Mul128AO(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Mul64AO(a+2, b+2, c+4);
	BS1_LXI_Mul64AO(a+2, b+0, c+2);
	BS1_LXI_Mul64AO(a+0, b+2, c+2);
	BS1_LXI_Mul64AO(a+0, b+0, c+0);
}

void BS1_LXI_Mul256AO(u32 *a, u32 *b, u32 *c)
{
	BS1_LXI_Mul128AO(a+4, b+4, c+8);
	BS1_LXI_Mul128AO(a+4, b+0, c+4);
	BS1_LXI_Mul128AO(a+0, b+4, c+4);
	BS1_LXI_Mul128AO(a+0, b+0, c+0);
}

void BS1_LXI_Mul64O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])*(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[1])*(u64)(b[0]);
	l+=(u64)(a[0])*(u64)(b[1]);
	c[1]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[1])*(u64)(b[1]);
	c[2]=l&0xFFFFFFFF;
}

void BS1_LXI_Mul128O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])*(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[1]);
	l+=(u64)(a[1])*(u64)(b[0]);
	c[1]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[2]);
	l+=(u64)(a[1])*(u64)(b[1]);
	l+=(u64)(a[2])*(u64)(b[0]);
	c[2]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[3]);
	l+=(u64)(a[1])*(u64)(b[2]);
	l+=(u64)(a[2])*(u64)(b[1]);
	l+=(u64)(a[3])*(u64)(b[0]);
	c[3]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[1])*(u64)(b[3]);
	l+=(u64)(a[2])*(u64)(b[2]);
	l+=(u64)(a[3])*(u64)(b[1]);
	c[4]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[2])*(u64)(b[3]);
	l+=(u64)(a[3])*(u64)(b[2]);
	c[5]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[3])*(u64)(b[3]);
	c[6]=l&0xFFFFFFFF;
	l>>=32;
	c[7]=l&0xFFFFFFFF;
}

void BS1_LXI_Mul256(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])*(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[1]);
	l+=(u64)(a[1])*(u64)(b[0]);
	c[1]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[2]);
	l+=(u64)(a[1])*(u64)(b[1]);
	l+=(u64)(a[2])*(u64)(b[0]);
	c[2]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[3]);
	l+=(u64)(a[1])*(u64)(b[2]);
	l+=(u64)(a[2])*(u64)(b[1]);
	l+=(u64)(a[3])*(u64)(b[0]);
	c[3]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[4]);
	l+=(u64)(a[1])*(u64)(b[3]);
	l+=(u64)(a[2])*(u64)(b[2]);
	l+=(u64)(a[3])*(u64)(b[1]);
	l+=(u64)(a[4])*(u64)(b[0]);
	c[4]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[5]);
	l+=(u64)(a[1])*(u64)(b[4]);
	l+=(u64)(a[2])*(u64)(b[3]);
	l+=(u64)(a[3])*(u64)(b[2]);
	l+=(u64)(a[4])*(u64)(b[1]);
	l+=(u64)(a[5])*(u64)(b[0]);
	c[5]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[6]);
	l+=(u64)(a[1])*(u64)(b[5]);
	l+=(u64)(a[2])*(u64)(b[4]);
	l+=(u64)(a[3])*(u64)(b[3]);
	l+=(u64)(a[4])*(u64)(b[2]);
	l+=(u64)(a[5])*(u64)(b[1]);
	l+=(u64)(a[6])*(u64)(b[0]);
	c[6]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[7]);
	l+=(u64)(a[1])*(u64)(b[6]);
	l+=(u64)(a[2])*(u64)(b[5]);
	l+=(u64)(a[3])*(u64)(b[4]);
	l+=(u64)(a[4])*(u64)(b[3]);
	l+=(u64)(a[5])*(u64)(b[2]);
	l+=(u64)(a[6])*(u64)(b[1]);
	l+=(u64)(a[7])*(u64)(b[0]);
	c[7]=l&0xFFFFFFFF;
	l>>=32;
}

void BS1_LXI_Mul256O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=(u64)(a[0])*(u64)(b[0]);
	c[0]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[1]);
	l+=(u64)(a[1])*(u64)(b[0]);
	c[1]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[2]);
	l+=(u64)(a[1])*(u64)(b[1]);
	l+=(u64)(a[2])*(u64)(b[0]);
	c[2]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[3]);
	l+=(u64)(a[1])*(u64)(b[2]);
	l+=(u64)(a[2])*(u64)(b[1]);
	l+=(u64)(a[3])*(u64)(b[0]);
	c[3]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[4]);
	l+=(u64)(a[1])*(u64)(b[3]);
	l+=(u64)(a[2])*(u64)(b[2]);
	l+=(u64)(a[3])*(u64)(b[1]);
	l+=(u64)(a[4])*(u64)(b[0]);
	c[4]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[5]);
	l+=(u64)(a[1])*(u64)(b[4]);
	l+=(u64)(a[2])*(u64)(b[3]);
	l+=(u64)(a[3])*(u64)(b[2]);
	l+=(u64)(a[4])*(u64)(b[1]);
	l+=(u64)(a[5])*(u64)(b[0]);
	c[5]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[6]);
	l+=(u64)(a[1])*(u64)(b[5]);
	l+=(u64)(a[2])*(u64)(b[4]);
	l+=(u64)(a[3])*(u64)(b[3]);
	l+=(u64)(a[4])*(u64)(b[2]);
	l+=(u64)(a[5])*(u64)(b[1]);
	l+=(u64)(a[6])*(u64)(b[0]);
	c[6]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[0])*(u64)(b[7]);
	l+=(u64)(a[1])*(u64)(b[6]);
	l+=(u64)(a[2])*(u64)(b[5]);
	l+=(u64)(a[3])*(u64)(b[4]);
	l+=(u64)(a[4])*(u64)(b[3]);
	l+=(u64)(a[5])*(u64)(b[2]);
	l+=(u64)(a[6])*(u64)(b[1]);
	l+=(u64)(a[7])*(u64)(b[0]);
	c[7]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[1])*(u64)(b[7]);
	l+=(u64)(a[2])*(u64)(b[6]);
	l+=(u64)(a[3])*(u64)(b[5]);
	l+=(u64)(a[4])*(u64)(b[4]);
	l+=(u64)(a[5])*(u64)(b[3]);
	l+=(u64)(a[6])*(u64)(b[2]);
	l+=(u64)(a[7])*(u64)(b[1]);
	c[8]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[2])*(u64)(b[7]);
	l+=(u64)(a[3])*(u64)(b[6]);
	l+=(u64)(a[4])*(u64)(b[5]);
	l+=(u64)(a[5])*(u64)(b[4]);
	l+=(u64)(a[6])*(u64)(b[3]);
	l+=(u64)(a[7])*(u64)(b[2]);
	c[9]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[3])*(u64)(b[7]);
	l+=(u64)(a[4])*(u64)(b[6]);
	l+=(u64)(a[5])*(u64)(b[5]);
	l+=(u64)(a[6])*(u64)(b[4]);
	l+=(u64)(a[7])*(u64)(b[3]);
	c[10]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[4])*(u64)(b[7]);
	l+=(u64)(a[5])*(u64)(b[6]);
	l+=(u64)(a[6])*(u64)(b[5]);
	l+=(u64)(a[7])*(u64)(b[4]);
	c[11]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[5])*(u64)(b[7]);
	l+=(u64)(a[6])*(u64)(b[6]);
	l+=(u64)(a[7])*(u64)(b[5]);
	c[12]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[6])*(u64)(b[7]);
	l+=(u64)(a[7])*(u64)(b[6]);
	c[13]=l&0xFFFFFFFF;
	l>>=32;

	l+=(u64)(a[7])*(u64)(b[7]);
	c[14]=l&0xFFFFFFFF;
	l>>=32;

	c[15]=l&0xFFFFFFFF;
}

void BS1_LXI_Div32O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=a[1];
	l=(l<<32)+a[0];
	l/=b[0];
	c[0]=l&0xFFFFFFFF;
}

void BS1_LXI_Div64O(u32 *a, u32 *b, u32 *c)
{
	u64 l;

	l=a[2];
	l=(l<<32)/b[0];
	c[1]=l&0xFFFFFFFF;
	
}


void BS1_LXI_Shr256(u32 *a, int b, u32 *c)
{
	int i;
	u64 l;

	for(i=0; i<8; i++)c[i]=a[i];
	while(b>=32)
	{
		for(i=0; i<7; i++)c[i]=c[i+1];
		c[7]=0;
		b-=32;
	}
	if(!b)return;

	for(i=0; i<7; i++)
		c[i]=(c[i]>>b)+(c[i+1]<<(32-b));
	c[7]=c[7]>>b;
}

int BS1_LXI_Shl256(u32 *a, int b, u32 *c)
{
	int i;
	u64 l;

	for(i=0; i<8; i++)c[i]=a[i];

	while(b>=32)
	{
		for(i=7; i>0; i--)c[i]=c[i-1];
		c[0]=0;
		b-=32;
	}
	if(!b)return;

	for(i=7; i>0; i--)
		c[i]=(c[i]<<b)+(c[i-1]>>(32-b));
	c[0]=c[0]<<b;
}

void BS1_LXI_Shl256O(u32 *a, int b, u32 *c)
{
	int i;
	u64 l;

	for(i=0; i<8; i++)c[i]=a[i];
	for(; i<16; i++)c[i]=0;
	while(b>=32)
	{
		for(i=15; i>0; i--)c[i]=c[i-1];
		c[0]=0;
		b-=32;
	}
	if(!b)return;

	for(i=15; i>0; i--)
		c[i]=(c[i]<<b)+(c[i-1]>>(32-b));
	c[0]=c[0]<<b;
}

void BS1_LXI_Shr512_1(u32 *a, u32 *c)
{
	int i;
	for(i=0; i<15; i++)c[i]=(a[i]>>1)+(a[i+1]<<31);
	c[15]=a[15]>>1;
}

int BS1_LXI_CmpG_512(u32 *a, u32 *b)
{
	int i;

	for(i=15; i>=0; i--)
	{
		if(a[i]<b[i])return(0);
		if(a[i]>b[i])return(1);
	}
	return(0);
}


void BS1_LXI_Div256(u32 *a, u32 *b, u32 *c, u32 *r)
{
	u32 q[16], t[16];
	int i, j;

	for(i=0; i<8; i++)q[i]=a[i];
	for(i=8; i<16; i++)q[i]=0;

	for(i=0; i<8; i++)c[i]=0;

	for(i=0; i<8; i++)t[i+8]=b[i];
	for(i=0; i<8; i++)t[i]=0;

	for(i=256; i>=0; i--)
	{
		if(BS1_LXI_CmpG_512(t, q))
		{
			BS1_LXI_Shr512_1(t, t);
			continue;
		}

		BS1_LXI_Sub256F(q, t, q);
		c[i>>5]|=1<<(i&31);
		BS1_LXI_Shr512_1(t, t);
	}

	BS1_LXI_Copy256F(q, r);
}

void BS1_LXI_Div256S(u32 *a, u32 *b, u32 *c)
{
	u32 at[8], bt[8], ct[8];
	int sg;

	sg=0;
	if(a[7]&0x80000000)
	{
		BS1_LXI_Neg256F(a, at);
		sg=!sg;
	}else BS1_LXI_Copy256F(a, at);
	if(b[7]&0x80000000)
	{
		BS1_LXI_Neg256F(b, bt);
		sg=!sg;
	}else BS1_LXI_Copy256F(b, bt);

	BS1_LXI_Div256(at, bt, c, ct);
	if(sg)BS1_LXI_Neg256F(c, c);
}

void BS1_LXI_Mod256S(u32 *a, u32 *b, u32 *c)
{
	u32 at[8], bt[8], ct[8];
	int sg;

	sg=0;
	if(a[7]&0x80000000)
	{
		BS1_LXI_Neg256F(a, at);
		sg=!sg;
	}else BS1_LXI_Copy256F(a, at);
	if(b[7]&0x80000000)
	{
		BS1_LXI_Neg256F(b, bt);
		sg=!sg;
	}else BS1_LXI_Copy256F(b, bt);

	BS1_LXI_Div256(at, bt, ct, c);
}


int BS1_LXI_Mod256I(u32 *a, int b, u32 *c)
{
	u32 at[8], bt[8], ct[8];

	u64 li;
	int i, r;

#if 0
	li=0;
	for(i=7; i>=0; i--)
	{
		li=(li<<32)+a[i];
		c[i]=li/b;
	}
	r=li%b;
#endif

	BS1_LXI_Copy256F(a, at);
	for(i=0; i<8; i++)bt[i]=0;
	bt[0]=b;

	BS1_LXI_Div256(at, bt, c, ct);
	r=ct[0];

#if 0
	r=a[0]%b;
	c[0]=(a[0]/b)+((a[1]%b)*(1LL<<32)/b);
	c[1]=(a[1]/b)+((a[2]%b)*(1LL<<32)/b);
	c[2]=(a[2]/b)+((a[3]%b)*(1LL<<32)/b);
	c[3]=(a[3]/b)+((a[4]%b)*(1LL<<32)/b);
	c[4]=(a[4]/b)+((a[5]%b)*(1LL<<32)/b);
	c[5]=(a[5]/b)+((a[6]%b)*(1LL<<32)/b);
	c[6]=(a[6]/b)+((a[7]%b)*(1LL<<32)/b);
	c[7]=(a[7]/b);
#endif

	return(r);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <bgbscr1.h>

static char *bs1_print(char *t, char *s, ...)
{
	va_list lst;

	va_start(lst, s);
	vsprintf(t, s, lst);
	va_end(lst);

	t+=strlen(t);
	return(t);
}

char *BS1_S_PrintList(char *s, elem l)
{
	elem c;

	c=l;
	while(BS1_CONSP(c))
	{
		s=BS1_S_Print(s, CAR(c), -1);
		c=CDR(c);
		if(BS1_CONSP(c))s=bs1_print(s, " ");
	}
	if(c!=BS1_MM_NULL)
	{
		s=bs1_print(s, " . ");
		s=BS1_S_Print(s, c, -1);
	}

	return(s);
}

char *BS1_S_PrintListInd(char *s, elem l, int ind)
{
	elem c;
	int i;

	c=l;
	while(BS1_CONSP(c))
	{
		i=ind;
		while(i--)*s++=' ';

		s=BS1_S_Print(s, CAR(c), ind);
		c=CDR(c);
		if(BS1_CONSP(c))s=bs1_print(s, "\n");
	}
	if(c!=BS1_MM_NULL)
	{
		s=bs1_print(s, " . ");
		s=BS1_S_Print(s, c, ind);
	}
	s=bs1_print(s, "\n");

	return(s);
}

char *BS1_S_Print(char *s, elem t, int ind)
{
	elem c;
	char *s1;
	float f, g;
	int i, j, k, l;

	if(t==BS1_MM_NULL)
	{
		s=bs1_print(s, "()");
		return(s);
	}

	if((t&255)==BS1_MM_MISC)
	{
		switch(t)
		{
		case BS1_MM_TRUE: s=bs1_print(s, "#t"); break;
		case BS1_MM_FALSE: s=bs1_print(s, "#f"); break;
		default: s=bs1_print(s, "#u"); break;
		}
		return(s);
	}

	if(BS1_CONSP(t))
	{
		s1=bs1_print(s, "(");
		s1=BS1_S_PrintList(s1, t);
		s1=bs1_print(s1, ")");

		if((ind<0) || ((ind+(s1-s))<76))
			return(s1);

		s=bs1_print(s, "(");
		c=t;

		i=0;
		if(BS1_SYMBOLP(CAR(c)))
		{
			s1=TOSYM(CAR(c));
			i=strlen(s1)+2;
			if(i>8)i=8;

			s=bs1_print(s, "%s\n", s1);
			c=CDR(c);

			t=CDR(t);
		}

		s=BS1_S_PrintListInd(s, t, ind+i);

		j=ind+i;
		while(j--)*s++=' ';
		s=bs1_print(s, ")");
		return(s);
	}

	if(BS1_ARRAYP(t))
	{
		i=BS1_TY_GetArrayLen(t);

		s1=bs1_print(s, "#(");
		for(j=0; j<i; j++)
		{
			c=BS1_TY_GetArrayElem(t, j);
			s1=BS1_S_Print(s1, c, -1);
			if((j+1)<i)s1=bs1_print(s1, " ");
		}
		s1=bs1_print(s1, ")");

		if((ind<0) || ((ind+(s1-s))<76))
			return(s1);

		s=bs1_print(s, "#(");
		for(j=0; j<i; j++)
		{
			c=BS1_TY_GetArrayElem(t, j);
			s=BS1_S_Print(s, c, ind+2);
			s=bs1_print(s, "\n");

			if((j+1)<i)
			{
				k=ind+2;
				while(k--)*s++=' ';
			}
		}
		k=ind;
		while(k--)*s++=' ';
		s=bs1_print(s, ")");

		return(s);
	}

	i=BS1_TY_GetType(t);
	switch(i)
	{
	case BS1_TYH_INT:
		s=bs1_print(s, "%d", TOINT(t));
		break;
	case BS1_TYH_FLOAT:
		s=bs1_print(s, "%g", TOFLOAT(t));
		break;
	case BS1_TYH_CHAR:
		s=bs1_print(s, "#\\%d", TOINT(t));
		break;
	case BS1_TYH_COMPLEX:
		f=BS1_REAL(t); g=BS1_IMAG(t);
		if(fabs(f)<0.000001)f=0;
		if(fabs(g)<0.000001)g=0;

		if(f!=0)
		{
			s=bs1_print(s, "%s", BS1_TY_PrintFloat(f));
			if(g>0)s=bs1_print(s, "+%si", BS1_TY_PrintFloat(g));
			else if(g<0)s=bs1_print(s, "%si", BS1_TY_PrintFloat(g));
		}else
		{
			if(g!=0)s=bs1_print(s, "%si", BS1_TY_PrintFloat(g));
				else s=bs1_print(s, "0");
		}
		break;
	case BS1_TYH_RATIONAL:
		BS1_TY_GetRational(t, &j, &k);
		s=bs1_print(s, "%d/%d", j, k);
		break;

	case BS1_TYH_SYMBOL:
		s=bs1_print(s, "%s", TOSYM(t));
		break;
	case BS1_TYH_KEYWORD:
		s=bs1_print(s, "%s:", TOSYM(t));
		break;
	case BS1_TYH_STRING:
//		s=bs1_print(s, "\"%s\"", TOSTRING(t));

		s1=TOSTRING(t);
		*s++='\"';
		while(*s1)
		{
			if(*s1>=' ')
			{
				if(*s1=='\"')*s++='\\';
				if(*s1=='\'')*s++='\\';
				if(*s1=='\\')*s++='\\';

				*s++=*s1++;
				continue;
			}
			switch(*s1)
			{
			case '\r': s=bs1_print(s, "\\r"); break;
			case '\n': s=bs1_print(s, "\\n"); break;
			case '\t': s=bs1_print(s, "\\t"); break;
			case '\x1B': s=bs1_print(s, "\\e"); break;
			default: s=bs1_print(s, "\\x%02X", *s1); break;
			}
			s1++;
		}
		*s++='\"';
		break;

	case BS1_TYH_FVECTOR:
		i=BS1_TYVec_GetVecLen(t);
		s=bs1_print(s, "#[");
		for(j=0; j<i; j++)
		{
			s=bs1_print(s, "%g", BS1_TYVec_GetVecVal(t, j));
			if((j+1)<i)s=bs1_print(s, " ");
		}
		s=bs1_print(s, "]");
		break;
	default:
		s=bs1_print(s, "#<%s:%08X>", BS1_TY_GetTypeName(t), t);
		break;
	}

	return(s);
}

char *BS1_S_PrintS(elem t)
{
	static char buf[4096];
	BS1_S_Print(buf, t, -1);
	return(BS1_RStrDup(buf));
}

void BS1_S_PrintFmt(elem t)
{
	static char buf[4096];
	BS1_S_Print(buf, t, 0);

	printf("%s\n", buf);
}
#include <stdio.h>
#include <math.h>

#include <bgbscr1.h>

int bs1_tyrat_nprimes4096=564;

int bs1_tyrat_primes4096[]={
    2,    3,    5,    7,   11,   13,   17,   19,   23,   29,   31,   37,
   41,   43,   47,   53,   59,   61,   67,   71,   73,   79,   83,   89,
   97,  101,  103,  107,  109,  113,  127,  131,  137,  139,  149,  151,
  157,  163,  167,  173,  179,  181,  191,  193,  197,  199,  211,  223,
  227,  229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,
  283,  293,  307,  311,  313,  317,  331,  337,  347,  349,  353,  359,
  367,  373,  379,  383,  389,  397,  401,  409,  419,  421,  431,  433,
  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,
  509,  521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,
  599,  601,  607,  613,  617,  619,  631,  641,  643,  647,  653,  659,
  661,  673,  677,  683,  691,  701,  709,  719,  727,  733,  739,  743,
  751,  757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,
  829,  839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,
  919,  929,  937,  941,  947,  953,  967,  971,  977,  983,  991,  997,
 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,
 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163,
 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249,
 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321,
 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439,
 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,
 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601,
 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693,
 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783,
 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877,
 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987,
 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069,
 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143,
 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267,
 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347,
 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423,
 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543,
 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657,
 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713,
 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801,
 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903,
 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011,
 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119,
 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221,
 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323,
 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413,
 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527,
 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607,
 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697,
 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797,
 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907,
 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003,
 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093
};

int BS1_TYRat_GCF(int i, int j)
{
	int k, l, b;

	if(i<0)i=-i;

	if((i<2) || (j<2))
		return(1);

	b=1;
	for(k=0; k<564; k++)
	{
		l=bs1_tyrat_primes4096[k];
		if((l>i) || (l>j))break;

		if(!(i%l) && !(j%l))b=l;
	}

	return(b);
}

int BS1_TYRat_LCF(int i, int j)
{
	int k, l;

	if(i<0)i=-i;

	if((i<2) || (j<2))
		return(1);

	for(k=0; k<564; k++)
	{
		l=bs1_tyrat_primes4096[k];
		if((l>i) || (l>j))break;

		if(!(i%l) && !(j%l))
			return(l);
	}

	return(1);
}

void BS1_TYRat_Reduce(int *ri, int *rj)
{
	int k;

	k=BS1_TYRat_LCF(*ri, *rj);
	while(k>1)
	{
		*ri/=k; *rj/=k;
		k=BS1_TYRat_LCF(*ri, *rj);
	}
}


elem BS1_TYRat_Add(elem a, elem b)
{
	int i, j, k, i0, j0, i1, j1;

	BS1_TY_GetRational(a, &i0, &j0);
	BS1_TY_GetRational(b, &i1, &j1);
	i=i0+i1;
	j=j0+j1;

	BS1_TYRat_Reduce(&i, &j);
	return(BS1_TY_Rational(i, j));
}

elem BS1_TYRat_Sub(elem a, elem b)
{
	int i, j, k, i0, j0, i1, j1;

	BS1_TY_GetRational(a, &i0, &j0);
	BS1_TY_GetRational(b, &i1, &j1);
	i=i0-i1;
	j=j0-j1;

	BS1_TYRat_Reduce(&i, &j);
	return(BS1_TY_Rational(i, j));
}

elem BS1_TYRat_Mul(elem a, elem b)
{
	int i, j, k, i0, j0, i1, j1;

	BS1_TY_GetRational(a, &i0, &j0);
	BS1_TY_GetRational(b, &i1, &j1);
	i=i0*i1;
	j=j0*j1;

	BS1_TYRat_Reduce(&i, &j);
	return(BS1_TY_Rational(i, j));
}

elem BS1_TYRat_Div(elem a, elem b)
{
	int i, j, k, i0, j0, i1, j1;

	BS1_TY_GetRational(a, &i0, &j0);
	BS1_TY_GetRational(b, &i1, &j1);
	i=i0*j1;
	j=j0*i1;

	BS1_TYRat_Reduce(&i, &j);
	return(BS1_TY_Rational(i, j));
}



void BS1_TYRat_UnwrapLong(elem t, unsigned int *lv)
{
	unsigned int *lp;
	int i;

	if(BS1_XLONGP(t))
	{
		lp=BS1_TY_GetObjData(t);
		for(i=0; i<8; i++)lv[i]=lp[i];
	}else if(BS1_LONGP(t))
	{
		lp=BS1_TY_GetObjDataA64(t);
		lv[0]=lp[0]; lv[1]=lp[1];
		for(i=2; i<8; i++)lv[i]=
			(lv[1]&0x80000000)?0xFFFFFFFF:0x00000000;
	}else
	{
		lv[0]=TOINT(t);
		for(i=1; i<8; i++)lv[i]=
			(lv[0]&0x80000000)?0xFFFFFFFF:0x00000000;
	}
}

elem BS1_TYRat_WrapLong(unsigned int *lv)
{
	unsigned int *lp;
	elem t;
	int i;

	for(i=2; i<8; i++)
		if((lv[i]!=0) && (lv[i]!=0xFFFFFFFF))
			break;

	if(i>=8)
	{
		t=BS1_MM_AllocObjA64(BS1_TYH_LONG, 8);
		lp=BS1_TY_GetObjDataA64(t);
		lp[0]=lv[0]; lp[1]=lv[1];
		return(t);
	}

	t=BS1_MM_AllocObj(BS1_TYH_XLONG, 32);
	lp=BS1_TY_GetObjData(t);
	for(i=0; i<8; i++)lp[i]=lv[i];
	return(t);
}

elem BS1_TYRat_AddLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	long long li, lj;

	if(BS1_LINTP(a) && BS1_LINTP(b))
	{
		li=BS1_TOLONG(a); lj=BS1_TOLONG(b);
		if(fabs(((double)li)+lj)<(1LL<<60))
			return(BS1_LONG(li+lj));
	}

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	BS1_LXI_Add256F(lva, lvb, lvc);
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_SubLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	long long li, lj;

	if(BS1_LINTP(a) && BS1_LINTP(b))
	{
		li=BS1_TOLONG(a); lj=BS1_TOLONG(b);
		if(fabs(((double)li)-lj)<(1LL<<60))
			return(BS1_LONG(li-lj));
	}

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	BS1_LXI_Sub256F(lva, lvb, lvc);
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_MulLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	long long li, lj;
	int i, j, k;

	if(BS1_LINTP(a) && BS1_LINTP(b))
	{
		li=BS1_TOLONG(a); lj=BS1_TOLONG(b);
		if(fabs(((double)li)*lj)<(1LL<<60))
			return(BS1_LONG(li*lj));
	}

	printf("LX overflow\n");

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	BS1_LXI_Mul256(lva, lvb, lvc);

#if 0
	for(i=0; i<8; i++)lvc[i]=0;

	for(i=0; i<8; i++)
		for(j=0; j<8; j++)
	{
		if((i+j)>=8)break;

		li=lva[i];
		li*=lvb[j];

		for(k=i+j; li && (k<8); k++)
		{
			li+=lvc[k];
			lvc[k]=li&0xFFFFFFFF;
			li>>=32;
		}
	}
#endif

	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_DivLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	BS1_LXI_Div256S(lva, lvb, lvc);
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_ModLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	BS1_LXI_Mod256S(lva, lvb, lvc);
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_ShlLong(elem a, elem b)
{
	unsigned int lva[8], lvc[8];
	long long li, lj;

	if(BS1_LINTP(a) && BS1_LINTP(b))
	{
		li=BS1_TOLONG(a); lj=BS1_TOLONG(b);
		if((lj<60) && (fabs(((double)li)*(1<<lj))<(1LL<<60)))
			return(BS1_LONG(li<<lj));
	}

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_LXI_Shl256(lva, TOINT(b), lvc);
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_ShrLong(elem a, elem b)
{
	unsigned int lva[8], lvc[8];
	BS1_TYRat_UnwrapLong(a, lva);
	BS1_LXI_Shr256(lva, TOINT(b), lvc);
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_AndLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	int i;

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	for(i=0; i<8; i++)lvc[i]=lva[i]&lvc[i];
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_OrLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	int i;

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	for(i=0; i<8; i++)lvc[i]=lva[i]|lvc[i];
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_XorLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8], lvc[8];
	int i;

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	for(i=0; i<8; i++)lvc[i]=lva[i]^lvc[i];
	return(BS1_TYRat_WrapLong(lvc));
}

elem BS1_TYRat_NegLong(elem a)
{
	unsigned int lva[8];
	BS1_TYRat_UnwrapLong(a, lva);
	BS1_LXI_Neg256F(lva, lva);
	return(BS1_TYRat_WrapLong(lva));
}

int BS1_TYRat_EqualLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8];
	int i;

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	for(i=0; i<8; i++)if(lva[i]!=lvb[i])
		return(0);
	return(1);
}

int BS1_TYRat_LessLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8];
	int i;

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	for(i=7; i>=0; i--)
	{
		if(lva[i]<lvb[i])return(1);
		if(lva[i]>lvb[i])return(0);
	}
	return(0);
}

int BS1_TYRat_GreaterLong(elem a, elem b)
{
	unsigned int lva[8], lvb[8];
	int i;

	BS1_TYRat_UnwrapLong(a, lva);
	BS1_TYRat_UnwrapLong(b, lvb);
	for(i=7; i>=0; i--)
	{
		if(lva[i]<lvb[i])return(0);
		if(lva[i]>lvb[i])return(1);
	}
	return(0);
}


char *BS1_TYRat_XLong2String(elem a)
{
	unsigned int lva[8];
	char *b, *t;
	s64 li;
	int i, j, sg;

	b=BS1_MM_RAlloc(128);
	t=b+64;
	*(--t)=0;

	BS1_TYRat_UnwrapLong(a, lva);

	sg=0;
	if(lva[7]&0x80000000) { BS1_LXI_Neg256F(lva, lva); sg=!sg; }

//	sprintf(b, "%08X%08X%08X%08X%08X%08X%08X%08X",
//		lva[7], lva[6], lva[5], lva[4],
//		lva[3], lva[2], lva[1], lva[0]);
//	return(b);

#if 1
	while(1)
	{
		for(i=0; i<8; i++)
			if(lva[i])break;
		if(i>=8)break;

		i=BS1_LXI_Mod256I(lva, 10, lva);
		*(--t)='0'+i;
	}
#endif

	if(sg)*(--t)='-';
	return(t);
}
#include <stdio.h>
#include <math.h>

#include <bgbscr1.h>

elem BS1_TYMat_List2FMat(elem l)
{
	float *fa, *fb;
	int *ia;
	elem c, t;
	int xs, ys;
	int i, j, k;

	c=l; xs=0; ys=0;
	while(BS1_CONSP(c))
	{
		if(!BS1_FVECTORP(CAR(c)))break;
		i=BS1_TYVec_GetVecLen(CAR(c));
		if(ys && (i!=xs))break;
		xs=i; ys++; c=CDR(c);
	}

	if(!xs || !ys || (c!=BS1_MM_NULL))
	{
		printf("Malformed Matrix\n");
		return(BS1_MM_NULL);
	}

//	printf("Mat %dx%d\n", xs, ys);

	t=BS1_MM_AllocObj(BS1_TYH_FMATRIX, sizeof(int)+xs*ys*sizeof(float));
	ia=BS1_TY_GetObjData(t);
	fa=(float *)(ia+1);

	ia[0]=(ys<<8)+xs;

	c=l; i=0;
	while(BS1_CONSP(c))
	{
		fb=BS1_TY_GetObjData(CAR(c));
		for(j=0; j<xs; j++)fa[i++]=fb[j];
		c=CDR(c);
	}

	return(t);
}

elem BS1_TY_MakeMatrix(int xs, int ys)
{
	float *fa;
	int *ia;
	elem t;
	int i, j, k;

	t=BS1_MM_AllocObj(BS1_TYH_FMATRIX, sizeof(int)+xs*ys*sizeof(float));
	ia=BS1_TY_GetObjData(t);
	fa=(float *)(ia+1);

	ia[0]=(ys<<8)+xs;

	for(i=0; i<xs*ys; i++)fa[i]=0;
	return(t);
}

int BS1_TYMat_GetXS(elem t)
{
	int *ia;
	if(!BS1_FMATRIXP(t))return(-1);
	ia=BS1_TY_GetObjData(t);
	return(ia[0]&0xFF);
}

int BS1_TYMat_GetYS(elem t)
{
	int *ia;
	if(!BS1_FMATRIXP(t))return(-1);
	ia=BS1_TY_GetObjData(t);
	return((ia[0]>>8)&0xFF);
}

float *BS1_TYMat_GetBody(elem t)
{
	int *ia;

	if(!BS1_FMATRIXP(t))return(NULL);
	ia=BS1_TY_GetObjData(t);
	return((float *)(ia+1));
}

float *BS1_TYMat_GetBody2(elem t, int *rxs, int *rys)
{
	int *ia;

	if(!BS1_FMATRIXP(t))return(NULL);
	ia=BS1_TY_GetObjData(t);
	if(rxs)*rxs=ia[0]&0xFF;
	if(rys)*rys=(ia[0]>>8)&0xFF;

	return((float *)(ia+1));
}


float BS1_TYMat_GetIndex(elem t, int x, int y)
{
	int *ia;
	float *fa;
	int xs, ys;

	if(!BS1_FMATRIXP(t))return(0);
	ia=BS1_TY_GetObjData(t);
	xs=ia[0]&0xFF; ys=(ia[0]>>8)&0xFF;
	fa=(float *)(ia+1);

	if((x<0) || (x>=xs))return(0);
	if((y<0) || (y>=ys))return(0);

	return(fa[y*xs+x]);
}

void BS1_TYMat_SetIndex(elem t, int x, int y, float v)
{
	int *ia;
	float *fa;
	int xs, ys;

	if(!BS1_FMATRIXP(t))return;
	ia=BS1_TY_GetObjData(t);
	xs=ia[0]&0xFF; ys=(ia[0]>>8)&0xFF;
	fa=(float *)(ia+1);

	if((x<0) || (x>=xs))return;
	if((y<0) || (y>=ys))return;

	fa[y*xs+x]=v;
}

elem BS1_TYMat_AddMatrix(elem a, elem b)
{
	elem c;
	int xs, ys;
	int i, j, k;

	if(!BS1_FMATRIXP(a))return(BS1_MM_NULL);
	if(!BS1_FMATRIXP(b))return(BS1_MM_NULL);

	xs=BS1_TYMat_GetXS(a);
	ys=BS1_TYMat_GetYS(a);

	if(xs!=BS1_TYMat_GetXS(b))return(BS1_MM_NULL);
	if(ys!=BS1_TYMat_GetYS(b))return(BS1_MM_NULL);

	c=BS1_TY_MakeMatrix(xs, ys);

	for(i=0; i<ys; i++)for(j=0; j<xs; j++)
		BS1_TYMat_SetIndex(c, j, i,
			BS1_TYMat_GetIndex(a, j, i)+
			BS1_TYMat_GetIndex(b, j, i));

	return(c);
}

elem BS1_TYMat_SubMatrix(elem a, elem b)
{
	elem c;
	int xs, ys;
	int i, j, k;

	if(!BS1_FMATRIXP(a))return(BS1_MM_NULL);
	if(!BS1_FMATRIXP(b))return(BS1_MM_NULL);

	xs=BS1_TYMat_GetXS(a);
	ys=BS1_TYMat_GetYS(a);

	if(xs!=BS1_TYMat_GetXS(b))return(BS1_MM_NULL);
	if(ys!=BS1_TYMat_GetYS(b))return(BS1_MM_NULL);

	c=BS1_TY_MakeMatrix(xs, ys);

	for(i=0; i<ys; i++)for(j=0; j<xs; j++)
		BS1_TYMat_SetIndex(c, j, i,
			BS1_TYMat_GetIndex(a, j, i)-
			BS1_TYMat_GetIndex(b, j, i));

	return(c);
}

elem BS1_TYMat_ScaleMatrix(elem a, elem b)
{
	elem c;
	int xs, ys;
	int i, j, k;
	float f;

	if(!BS1_FMATRIXP(a))return(BS1_MM_NULL);

	xs=BS1_TYMat_GetXS(a);
	ys=BS1_TYMat_GetYS(a);
	c=BS1_TY_MakeMatrix(xs, ys);
	f=TOFLOAT(b);

	for(i=0; i<ys; i++)for(j=0; j<xs; j++)
		BS1_TYMat_SetIndex(c, j, i,
			BS1_TYMat_GetIndex(a, j, i)*f);

	return(c);
}

elem BS1_TYMat_MultMatrix(elem a, elem b)
{
	float *fa, *fb, *fc;
	int xs0, ys0, xs1, ys1;
	elem c;
	int xs, ys, zs;
	int i, j, k;
	float f;

	if(!BS1_FMATRIXP(a))return(BS1_MM_NULL);
	if(!BS1_FMATRIXP(b))return(BS1_MM_NULL);

	fa=BS1_TYMat_GetBody2(a, &xs0, &ys0);
	fb=BS1_TYMat_GetBody2(b, &xs1, &ys1);
	if(xs0!=ys1)return(BS1_MM_NULL);

	xs=xs1;
	ys=ys0;
	zs=xs0;

	c=BS1_TY_MakeMatrix(xs, ys);
	fc=BS1_TYMat_GetBody(c);

	for(i=0; i<ys; i++)for(j=0; j<xs; j++)
	{
		f=0;
		for(k=0; k<zs; k++)f+=fa[i*xs0+k]*fb[k*xs1+j];
		fc[i*xs+j]=f;
	}

#if 0
	for(i=0; i<ys; i++)for(j=0; j<xs; j++)
	{
		f=0;
		for(k=0; k<zs; k++)f+=
			BS1_TYMat_GetIndex(a, k, i)*
			BS1_TYMat_GetIndex(b, j, k);
		BS1_TYMat_SetIndex(c, j, i, f);
	}
#endif

	return(c);
}


elem BS1_TYMat_MultMatrixVector(elem a, elem b)
{
	elem c;
	int xs, ys, zs;
	int i, j, k;
	float f;

	if(BS1_FVECTORP(a) && BS1_FMATRIXP(b))
	{
		xs=BS1_TYMat_GetXS(b);
		zs=BS1_TYMat_GetYS(b);
//		c=BS1_TYVec_MakeFVec(NULL, zs);
		c=BS1_TYVec_MakeFVec(NULL, BS1_TYVec_GetVecLen(a));

		for(i=0; i<xs; i++)
		{
			f=0;
			for(k=0; k<zs; k++)f+=
				BS1_TYVec_GetVecVal2(a, k)*
				BS1_TYMat_GetIndex(b, i, k);
			BS1_TYVec_SetVecVal(c, i, f);
		}
		return(c);
	}

	if(BS1_FMATRIXP(a) && BS1_FVECTORP(b))
	{
		ys=BS1_TYMat_GetYS(a);
		zs=BS1_TYMat_GetXS(a);
//		c=BS1_TYVec_MakeFVec(NULL, zs);
		c=BS1_TYVec_MakeFVec(NULL, BS1_TYVec_GetVecLen(b));

		for(i=0; i<ys; i++)
		{
			f=0;
			for(k=0; k<zs; k++)f+=
				BS1_TYMat_GetIndex(a, k, i)*
				BS1_TYVec_GetVecVal2(b, k);
			BS1_TYVec_SetVecVal(c, i, f);
		}
		return(c);
	}

	return(BS1_MM_NULL);
}

void BS1_TYMat_Inverse(float *a, float *b, int n)
{
	static float a2buf[8*8*2], a3buf[16];
	float *a2p[8], *a3p;
	float f;
	int i, j, k;

	for(i=0; i<n*n*2; i++)a2buf[i]=0;
	for(i=0; i<n*n; i++)b[i]=0;
	for(i=0; i<n; i++)a2p[i]=&a2buf[i*n*2];
	for(i=0; i<n; i++)for(j=0; j<n; j++)
		a2p[i][j]=a[i*n+j];
	for(i=0; i<n; i++)a2p[i][i+n]=1.0;

	for(i=0; i<n; i++)
	{
		if(a2p[i][i]==0) /* search for a new pivot in a lower row */
		{
			for(j=n-1; j>i; j--)if(a2p[j][i]!=0)
			{
				a3p=a2p[i];
				a2p[i]=a2p[j];
				a2p[j]=a3p;
			}
			if(a2p[i][i]==0)return; /* no pivot */
		}

		f=1.0/a2p[i][i];
		for(j=0; j<2*n; j++)a2p[i][j]*=f;

		for(j=0; j<n; j++)if(i!=j)
		{
			f=-a2p[j][i];
			for(k=0; k<2*n; k++)a2p[j][k]+=a2p[i][k]*f;
		}
	}

	for(i=0; i<n; i++)for(j=0; j<n; j++)
		b[i*n+j]=a2p[i][j+n];
}

elem BS1_TYMat_InvertMatrix(elem a)
{
	int *ia;
	float *fa, *fb;
	elem c;
	int xs, ys, zs;
	int i, j, k;

	if(!BS1_FMATRIXP(a))return(BS1_MM_NULL);

	xs=BS1_TYMat_GetXS(a);
	ys=BS1_TYMat_GetYS(a);

	if(xs!=ys)return(BS1_MM_NULL);

	c=BS1_TY_MakeMatrix(xs, ys);

	ia=BS1_TY_GetObjData(a);
	fa=(float *)(ia+1);
	ia=BS1_TY_GetObjData(c);
	fb=(float *)(ia+1);

	BS1_TYMat_Inverse(fa, fb, xs);

#if 0
	for(i=0; i<ys; i++)
	{
		for(j=0; j<xs; j++)
			printf("%g ", fa[i*xs+j]);
		printf("\n");
	}

	for(i=0; i<ys; i++)
	{
		for(j=0; j<xs; j++)
			printf("%g ", fb[i*xs+j]);
		printf("\n");
	}
#endif

	return(c);
}

elem BS1_TYMat_DivMatrix(elem a, elem b)
{
	elem c;
	float f;

	if(BS1_FMATRIXP(b))
	{
		b=BS1_TYMat_InvertMatrix(b);
		if(b==BS1_MM_NULL)return(BS1_MM_NULL);
		c=BS1_TYMat_MultMatrix(a, b);
		BS1_GC_CheckRef(b);
		return(c);
	}

	if(BS1_NUMBERP(b))
	{
		f=TOFLOAT(b);
		if(fabs(f)<0.0001)return(BS1_MM_NULL);
		c=BS1_TYMat_ScaleMatrix(a, FLONUM(1.0/f));
		return(c);
	}

	return(BS1_MM_NULL);
}
/*
external handle interface
handles will refer to objects external to the vm

handles will be located in the misc space (24 bit).
there will thus be 256 16bit groups.
the first 16 groups will be special, in that they will refer to an outside
heap, and will be a 20 bit space.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

typedef struct {
elem (*get_slot)(void *p, char *s);
elem (*set_slot)(void *p, char *s, elem v);
elem (*apply)(void *p, elem a);
elem (*mapply)(void *p, char *s, elem a);
}BS1_HdlOps;

void **bs1_tyhdl_arr0;
int bs1_tyhdl_arr0_sz;
BS1_HdlOps *bs1_tyhdl_arr0_ops;

void **bs1_tyhdl_arr[240];
int bs1_tyhdl_arr_sz[240];
BS1_HdlOps *bs1_tyhdl_arr_ops[240];

elem bs1_tyhdl_export[4096];

void BS1_TYHDL_Init()
{
	static int init=0;

	if(init)return;
	init=1;

	BS1_GC_AddRootArray(bs1_tyhdl_export, 4096);

	bs1_tyhdl_arr0=malloc(256*sizeof(void *));
	bs1_tyhdl_arr0_sz=256;
	bs1_tyhdl_arr0_ops=malloc(sizeof(BS1_HdlOps));

	memset(bs1_tyhdl_arr0, 0, 256*sizeof(void *));
	memset(bs1_tyhdl_arr0_ops, 0, sizeof(BS1_HdlOps));
}

void BS1_TYHDL_SetGetSlot(int ns, elem (*fn)(void *p, char *s))
{
	if(!ns)
	{
		bs1_tyhdl_arr0_ops->get_slot=fn;
		return;
	}
	bs1_tyhdl_arr_ops[ns-16]->get_slot=fn;
}

void BS1_TYHDL_SetSetSlot(int ns, elem (*fn)(void *p, char *s, elem v))
{
	if(!ns)
	{
		bs1_tyhdl_arr0_ops->set_slot=fn;
		return;
	}
	bs1_tyhdl_arr_ops[ns-16]->set_slot=fn;
}

void BS1_TYHDL_SetApply(int ns, elem (*fn)(void *p, elem a))
{
	if(!ns)
	{
		bs1_tyhdl_arr0_ops->apply=fn;
		return;
	}
	bs1_tyhdl_arr_ops[ns-16]->apply=fn;
}

void BS1_TYHDL_SetMApply(int ns, elem (*fn)(void *p, char *s, elem a))
{
	if(!ns)
	{
		bs1_tyhdl_arr0_ops->mapply=fn;
		return;
	}
	bs1_tyhdl_arr_ops[ns-16]->mapply=fn;
}



int BS1_TYHDL_IndexFromElem(elem t)
{
	int i;

	BS1_TYHDL_Init();

	for(i=0; i<4096; i++)
		if(bs1_tyhdl_export[i]==t)
			return(i);
	for(i=0; i<4096; i++)
		if(!bs1_tyhdl_export[i])
	{
		SET(bs1_tyhdl_export[i], t);
		return(i);
	}
	return(-1);
}

elem BS1_TYHDL_ElemFromIndex(int i)
{
	BS1_TYHDL_Init();
	return(bs1_tyhdl_export[i]);
}


elem BS1_TYHDL_ElemFromPtr(void *p)
{
	elem t;
	int i, j;

	BS1_TYHDL_Init();

	//in array
	for(i=0; i<bs1_tyhdl_arr0_sz; i++)
		if(bs1_tyhdl_arr0[i]==p)
	{
		t=BS1_MM_HANDLE|(i<<8);
		return(t);
	}

	//look for a free spot
	for(i=0; i<bs1_tyhdl_arr0_sz; i++)
		if(!bs1_tyhdl_arr0[i])
	{
		bs1_tyhdl_arr0[i]=p;
		t=BS1_MM_HANDLE|(i<<8);
		return(t);
	}

	//attempt to figure new size
	i=bs1_tyhdl_arr0_sz;
	j=i+(i>>1);
	if(j>=(1<<20))j=1<<20;
	if(j==i)return(BS1_MM_NULL);

	//expand the array
	bs1_tyhdl_arr0_sz=j;
	bs1_tyhdl_arr0=realloc(bs1_tyhdl_arr0, j*sizeof(void *));
	memset(bs1_tyhdl_arr0+i, 0, (j-i)*sizeof(void *));

	bs1_tyhdl_arr0[i]=p;
	t=BS1_MM_HANDLE|(i<<8);
	return(t);
}

void *BS1_TYHDL_PtrFromElem(elem o)
{
	void *p;
	char *s;
	elem t;
	int i;

	if((t&0xFF)!=BS1_MM_HANDLE)return(NULL);

	i=(t>>8)&0xFF;
	if(i<16)p=bs1_tyhdl_arr0[t>>12];
		else p=bs1_tyhdl_arr[i-16][t>>16];
	return(p);
}


elem BS1_TYHDL_GetSlot(elem o, elem n)
{
	void *p;
	char *s;
	elem t;
	int i;

	if((t&0xFF)!=BS1_MM_HANDLE)return(BS1_MM_NULL);
	s=BS1_TOSYM(n);
	if(!s)return(BS1_MM_NULL);

	i=(t>>8)&0xFF;
	if(i<16)
	{
		if(!bs1_tyhdl_arr0_ops->get_slot)return(BS1_MM_NULL);
		p=bs1_tyhdl_arr0[t>>12];
		if(!p)return(BS1_MM_NULL);

		t=bs1_tyhdl_arr0_ops->get_slot(p, s);
		return(t);
	}

	i-=16;
	if(!bs1_tyhdl_arr_ops[i])return(BS1_MM_NULL);
	if(!bs1_tyhdl_arr_ops[i]->get_slot)return(BS1_MM_NULL);
	p=bs1_tyhdl_arr[i][t>>16];
	if(!p)return(BS1_MM_NULL);

	t=bs1_tyhdl_arr_ops[i]->get_slot(p, s);
	return(t);
}

elem BS1_TYHDL_SetSlot(elem o, elem n, elem v)
{
	void *p;
	char *s;
	elem t;
	int i;

	if((t&0xFF)!=BS1_MM_HANDLE)return(BS1_MM_NULL);
	s=BS1_TOSYM(n);
	if(!s)return(BS1_MM_NULL);

	i=(t>>8)&0xFF;
	if(i<16)
	{
		if(!bs1_tyhdl_arr0_ops->set_slot)return(BS1_MM_NULL);
		p=bs1_tyhdl_arr0[t>>12];
		if(!p)return(BS1_MM_NULL);

		t=bs1_tyhdl_arr0_ops->set_slot(p, s, v);
		return(t);
	}

	i-=16;
	if(!bs1_tyhdl_arr_ops[i])return(BS1_MM_NULL);
	if(!bs1_tyhdl_arr_ops[i]->set_slot)return(BS1_MM_NULL);
	p=bs1_tyhdl_arr[i][t>>16];
	if(!p)return(BS1_MM_NULL);

	t=bs1_tyhdl_arr_ops[i]->set_slot(p, s, v);
	return(t);
}

elem BS1_TYHDL_Call(elem o, elem a)
{
	void *p;
	elem t;
	int i;

	if((t&0xFF)!=BS1_MM_HANDLE)return(BS1_MM_NULL);

	i=(t>>8)&0xFF;
	if(i<16)
	{
		if(!bs1_tyhdl_arr0_ops->apply)
			return(BS1_MM_NULL);
		p=bs1_tyhdl_arr0[t>>12];
		if(!p)return(BS1_MM_NULL);

		t=bs1_tyhdl_arr0_ops->apply(p, a);
		return(t);
	}

	i-=16;
	if(!bs1_tyhdl_arr_ops[i])return(BS1_MM_NULL);
	if(!bs1_tyhdl_arr_ops[i]->apply)return(BS1_MM_NULL);
	p=bs1_tyhdl_arr[i][t>>16];
	if(!p)return(BS1_MM_NULL);

	t=bs1_tyhdl_arr_ops[i]->apply(p, a);
	return(t);
}

elem BS1_TYHDL_CallMethod(elem o, elem n, elem a)
{
	void *p;
	char *s;
	elem t;
	int i;

	if((t&0xFF)!=BS1_MM_HANDLE)return(BS1_MM_NULL);
	s=BS1_TOSYM(n);
	if(!s)return(BS1_MM_NULL);

	i=(t>>8)&0xFF;
	if(i<16)
	{
		if(!bs1_tyhdl_arr0_ops->mapply)
			return(BS1_MM_NULL);
		p=bs1_tyhdl_arr0[t>>12];
		if(!p)return(BS1_MM_NULL);

		t=bs1_tyhdl_arr0_ops->mapply(p, s, a);
		return(t);
	}

	i-=16;
	if(!bs1_tyhdl_arr_ops[i])return(BS1_MM_NULL);
	if(!bs1_tyhdl_arr_ops[i]->mapply)return(BS1_MM_NULL);
	p=bs1_tyhdl_arr[i][t>>16];
	if(!p)return(BS1_MM_NULL);

	t=bs1_tyhdl_arr_ops[i]->mapply(p, s, a);
	return(t);
}
/* Autogenerated source */
/* OPS 397, W/Args 6, W/Flow 392 */

int bs1_opsr_nops=938;

char *bs1_opsr_strs[]={
"nop", "block", "dbgmark", "cgenast", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "mark", "call_i", "call_l", "call_f", "call_d", "call_p", 
"call_is", "call_ls", "call_fs", "call_ds", "call_ps", "ret_i", "ret_l", 
"ret_f", "ret_d", "ret_p", "dup_i", "dup_l", "dup_f", "dup_d", "dup_p", 
"exch_i", "exch_l", "exch_f", "exch_d", "exch_p", "", "", "", "", 
"", "", "push_null", "push_p", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "jmp", "jmp_true", "jmp_false", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "push_li", "push_ls", "push_rs", "push_i", 
"push_l", "push_ji", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "load_i", "load_l", "load_p", 
"load_b", "load_w", "load_c", "load_s", "load_f", "load_d", "", "", 
"", "", "", "", "", "store_i", "store_l", "store_p", "store_b", "store_w", 
"store_c", "store_s", "store_f", "store_d", "", "", "", "", "", "", 
"", "loadslot_i", "loadslot_l", "loadslot_p", "loadslot_b", "loadslot_w", 
"loadslot_c", "loadslot_s", "loadslot_f", "loadslot_d", "", "", "", 
"", "", "", "", "storeslot_i", "storeslot_l", "storeslot_p", "storeslot_b", 
"storeslot_w", "storeslot_c", "storeslot_s", "storeslot_f", "storeslot_d", 
"", "", "", "", "", "", "", "loadindex_i", "loadindex_l", "loadindex_p", 
"loadindex_b", "loadindex_w", "loadindex_c", "loadindex_s", "loadindex_f", 
"loadindex_d", "", "", "", "", "", "", "", "storeindex_i", "storeindex_l", 
"storeindex_p", "storeindex_b", "storeindex_w", "storeindex_c", "storeindex_s", 
"storeindex_f", "storeindex_d", "", "", "", "", "", "", "", "loadindex_ic", 
"loadindex_lc", "loadindex_pc", "loadindex_bc", "loadindex_wc", "loadindex_cc", 
"loadindex_sc", "loadindex_fc", "loadindex_dc", "", "", "", "", "", 
"", "", "storeindex_ic", "storeindex_lc", "storeindex_pc", "storeindex_bc", 
"storeindex_wc", "storeindex_cc", "storeindex_sc", "storeindex_fc", 
"storeindex_dc", "", "", "", "", "", "", "", "conv_il", "conv_ip", 
"conv_ib", "conv_iw", "conv_ic", "conv_is", "conv_if", "conv_id", 
"conv_li", "conv_lp", "conv_lb", "conv_lw", "conv_lc", "conv_ls", 
"conv_lf", "conv_ld", "conv_pi", "conv_pl", "conv_pb", "conv_pw", 
"conv_pc", "conv_ps", "", "", "conv_bi", "conv_bl", "conv_bp", "conv_bw", 
"conv_bc", "conv_bs", "conv_bf", "conv_bd", "conv_wi", "conv_wl", 
"conv_wp", "conv_wb", "conv_wc", "conv_ws", "conv_wf", "conv_wd", 
"conv_ci", "conv_cl", "conv_cp", "conv_cb", "conv_cw", "conv_cs", 
"conv_cf", "conv_cd", "conv_si", "conv_sl", "conv_sp", "conv_sb", 
"conv_sw", "conv_sc", "conv_sf", "conv_sd", "conv_fi", "conv_fl", 
"", "conv_fb", "conv_fw", "conv_fc", "conv_fs", "conv_fd", "conv_di", 
"conv_dl", "", "conv_db", "conv_dw", "conv_dc", "conv_ds", "conv_df", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "add_i", "add_l", "add_p", "add_f", "add_d", 
"add_pi", "add_ic", "add_lc", "add_pc", "add_pi_2", "add_pi_4", "add_pi_8", 
"add_pi_16", "add_pi_p", "", "", "sub_i", "sub_l", "sub_p", "sub_f", 
"sub_d", "sub_pi", "sub_ic", "sub_lc", "sub_pc", "sub_pi_2", "sub_pi_4", 
"sub_pi_8", "sub_pi_16", "sub_pi_p", "", "", "mul_i", "mul_l", "mul_p", 
"mul_f", "mul_d", "mul_ic", "mul_lc", "mul_pc", "", "", "", "", "", 
"", "", "", "div_i", "div_l", "div_p", "div_f", "dif_d", "div_ic", 
"div_lc", "div_pc", "mod_i", "mod_l", "mod_p", "mod_ic", "mod_lc", 
"mod_pc", "", "", "and_i", "and_l", "and_p", "and_ic", "and_lc", 
"and_pc", "", "", "", "", "", "", "", "", "", "", "or_i", "or_l", 
"or_p", "or_ic", "or_lc", "or_pc", "", "", "", "", "", "", "", "", 
"", "", "xor_i", "xor_l", "xor_p", "xor_ic", "xor_lc", "xor_pc", 
"", "", "", "", "", "", "", "", "", "", "shl_i", "shl_l", "shl_p", 
"shl_ic", "shl_lc", "shl_pc", "", "", "", "", "", "", "", "", "", 
"", "shr_i", "shr_l", "shr_p", "shr_ic", "shr_lc", "shr_pc", "", 
"", "", "", "", "", "", "", "", "", "cmp_eq_i", "cmp_eq_l", "cmp_eq_p", 
"cmp_eq_f", "cmp_eq_d", "cmp_eq_ic", "cmp_eq_lc", "cmp_ne_i", "cmp_ne_l", 
"cmp_ne_p", "cmp_ne_f", "cmp_ne_d", "cmp_ne_ic", "cmp_ne_lc", "cmp_l_i", 
"cmp_l_l", "cmp_l_p", "cmp_l_f", "cmp_l_d", "cmp_l_ic", "cmp_l_lc", 
"cmp_g_i", "cmp_g_l", "cmp_g_p", "cmp_g_f", "cmp_g_d", "cmp_g_ic", 
"cmp_g_lc", "cmp_le_i", "cmp_le_l", "cmp_le_p", "cmp_le_f", "cmp_le_d", 
"cmp_le_ic", "cmp_le_lc", "cmp_ge_i", "cmp_ge_l", "cmp_ge_p", "cmp_ge_f", 
"cmp_ge_d", "cmp_ge_ic", "cmp_ge_lc", "", "", "", "", "", "", "inc_i", 
"inc_l", "inc_p", "inc2_i", "inc2_l", "inc2_p", "dec_i", "dec_l", 
"dec_p", "dec2_i", "dec2_l", "dec2_p", "not_i", "not_l", "not_p", 
"", "neg_i", "neg_l", "neg_p", "neg_f", "neg_d", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "begin_arg0", "begin_arg1", "begin_arg2", "begin_arg3", 
"begin_arg4", "begin_arg5", "begin_arg6", "begin_arg7", "begin_arg8", 
"begin_arg9", "begin_arg10", "begin_arg11", "begin_arg12", "begin_arg13", 
"begin_arg14", "begin_arg15", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "end_arg0", "end_arg1", "end_arg2", "end_arg3", 
"end_arg4", "end_arg5", "end_arg6", "end_arg7", "end_arg8", "end_arg9", 
"end_arg10", "end_arg11", "end_arg12", "end_arg13", "end_arg14", 
"end_arg15", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "jmp_eq_i", "jmp_eq_l", "jmp_eq_p", "jmp_eq_f", "jmp_eq_d", "jmp_eq_ic", 
"jmp_eq_lc", "jmp_ne_i", "jmp_ne_l", "jmp_ne_p", "jmp_ne_f", "jmp_ne_d", 
"jmp_ne_ic", "jmp_ne_lc", "jmp_l_i", "jmp_l_l", "jmp_l_p", "jmp_l_f", 
"jmp_l_d", "jmp_l_ic", "jmp_l_lc", "jmp_g_i", "jmp_g_l", "jmp_g_p", 
"jmp_g_f", "jmp_g_d", "jmp_g_ic", "jmp_g_lc", "jmp_le_i", "jmp_le_l", 
"jmp_le_p", "jmp_le_f", "jmp_le_d", "jmp_le_ic", "jmp_le_lc", "jmp_ge_i", 
"jmp_ge_l", "jmp_ge_p", "jmp_ge_f", "jmp_ge_d", "jmp_ge_ic", "jmp_ge_lc", 
""};

char *bs1_opsr_args[]={
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "I", "Z", "S", "I", "I", "I", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", ""};

char *bs1_opsr_sfis[]={
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "*=*M", 
"M*p=i", "M*p=l", "M*p=f", "M*p=s", "M*p=p", "M*S=i", "M*S=l", "M*S=f", 
"M*S=s", "M*S=p", "i=", "l=", "f=", "s=", "p=", "j=jj", "m=mm", "g=gg", 
"s=ss", "q=qq", "ij=ji", "mn=ml", "fg=gf", "st=ts", "pq=qp", "", 
"", "", "", "", "", "=p", "S=p", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "b=", "b=", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "=I", "=S", "=S", "=i", "=l", "=I", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "S=i", 
"S=l", "S=p", "S=i", "S=i", "S=i", "S=i", "S=f", "S=s", "", "", "", 
"", "", "", "", "iS=", "lS=", "pS=", "iS=", "iS=", "iS=", "iS=", 
"fS=", "sS=", "", "", "", "", "", "", "", "pS=i", "pS=l", "pS=q", 
"pS=i", "pS=i", "pS=i", "pS=i", "pS=f", "pS=s", "", "", "", "", "", 
"", "", "ipS=", "lpS=", "qpS=", "ipS=", "ipS=", "ipS=", "ipS=", "fpS=", 
"spS=", "", "", "", "", "", "", "", "pi=j", "pi=l", "pi=q", "pi=j", 
"pi=j", "pi=j", "pi=j", "pi=f", "pi=s", "", "", "", "", "", "", "", 
"jpi=", "lpi=", "qpi=", "jpi=", "jpi=", "jpi=", "jpi=", "fpi=", "spi=", 
"", "", "", "", "", "", "", "pI=i", "pI=l", "pI=p", "pI=i", "pI=i", 
"pI=i", "pI=i", "pI=f", "pI=s", "", "", "", "", "", "", "", "ipI=", 
"lpI=", "qpI=", "ipI=", "ipI=", "ipI=", "ipI=", "fpI=", "spI=", "", 
"", "", "", "", "", "", "i=l", "i=p", "i=j", "i=j", "i=j", "i=j", 
"i=f", "i=s", "l=i", "l=p", "l=j", "l=j", "l=j", "l=j", "l=f", "l=s", 
"p=i", "p=l", "p=i", "p=i", "p=i", "p=i", "", "", "i=j", "i=l", "i=p", 
"i=j", "i=j", "i=j", "i=f", "i=s", "i=j", "i=l", "i=p", "i=j", "i=j", 
"i=j", "i=f", "i=s", "i=j", "i=l", "i=p", "i=j", "i=j", "i=j", "i=f", 
"i=s", "i=j", "i=l", "i=p", "i=j", "i=j", "i=j", "i=f", "i=s", "f=i", 
"f=l", "", "f=i", "f=i", "f=i", "f=i", "f=s", "s=i", "s=l", "", "s=i", 
"s=i", "s=i", "s=i", "s=f", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "ij=k", "lm=n", "pq=r", 
"fg=h", "st=u", "pi=q", "iI=j", "lI=m", "pI=q", "pi=q", "pi=q", "pi=q", 
"pi=q", "pi=q", "", "", "ij=k", "lm=n", "pq=r", "fg=h", "st=u", "pi=q", 
"iI=j", "lI=m", "pI=q", "pi=q", "pi=q", "pi=q", "pi=q", "pi=q", "", 
"", "ij=k", "lm=n", "pq=r", "fg=h", "st=u", "iI=j", "lI=m", "pI=q", 
"", "", "", "", "", "", "", "", "ij=k", "lm=n", "pq=r", "fg=h", "st=u", 
"iI=j", "lI=m", "pI=q", "ij=k", "lm=n", "pq=r", "iI=j", "lI=m", "pI=q", 
"", "", "ij=k", "lm=n", "pq=r", "iI=j", "lI=m", "pI=q", "", "", "", 
"", "", "", "", "", "", "", "ij=k", "lm=n", "pq=r", "iI=j", "lI=m", 
"pI=q", "", "", "", "", "", "", "", "", "", "", "ij=k", "lm=n", "pq=r", 
"iI=j", "lI=m", "pI=q", "", "", "", "", "", "", "", "", "", "", "ij=k", 
"lm=n", "lm=n", "iI=j", "lI=m", "pI=q", "", "", "", "", "", "", "", 
"", "", "", "ij=k", "lm=n", "lm=n", "iI=j", "lI=m", "pI=q", "", "", 
"", "", "", "", "", "", "", "", "ij=b", "lm=b", "pq=b", "fg=b", "st=b", 
"iI=b", "lI=b", "ij=b", "lm=b", "pq=b", "fg=b", "st=b", "iI=b", "lI=b", 
"ij=b", "lm=b", "pq=b", "fg=b", "st=b", "iI=b", "lI=b", "ij=b", "lm=b", 
"pq=b", "fg=b", "st=b", "iI=b", "lI=b", "ij=b", "lm=b", "pq=b", "fg=b", 
"st=b", "iI=b", "lI=b", "ij=b", "lm=b", "pq=b", "fg=b", "st=b", "iI=b", 
"lI=b", "", "", "", "", "", "", "i=j", "l=m", "p=q", "i=j", "l=m", 
"p=q", "i=j", "l=m", "p=q", "i=j", "l=m", "p=q", "i=j", "l=m", "p=q", 
"", "i=j", "l=m", "p=q", "f=g", "s=t", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "=", "=", "=", "=", "=", "=", "=", "=", "=", "=", "=", "=", 
"=", "=", "=", "=", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "=", "=", "=", "=", "=", "=", "=", "=", "=", "=", "=", "=", 
"=", "=", "=", "=", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "ij=", "lm=", "pq=", "fg=", "st=", "iI=", "lI=", "ij=", "lm=", 
"pq=", "fg=", "st=", "iI=", "lI=", "ij=", "lm=", "pq=", "fg=", "st=", 
"iI=", "lI=", "ij=", "lm=", "pq=", "fg=", "st=", "iI=", "lI=", "ij=", 
"lm=", "pq=", "fg=", "st=", "iI=", "lI=", "ij=", "lm=", "pq=", "fg=", 
"st=", "iI=", "lI=", ""};

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>
#include <math.h>

elem bs1_func_sqrt(BS1_SVMState *ctx, elem args)
{
	elem a;
	float f0, g0, f, g, h;

	a=CAR(args);
	if(BS1_COMPLEXP(a))
	{
		f0=BS1_REAL(a);
		g0=BS1_IMAG(a);

		g=sqrt(f0*f0+g0*g0);
		h=atan2(g0, f0);
		f=pow(g, 0.5)*cos(0.5*h);
		g=pow(g, 0.5)*sin(0.5*h);
		return(BS1_COMPLEX(f, g));
	}

	f=TOFLOAT(a);
	if(f<0)return(BS1_COMPLEX_I(sqrt(-f)));
	return(FLONUM(sqrt(f)));
}

elem bs1_func_floor(BS1_SVMState *ctx, elem args)
{
	return(FLONUM(floor(TOFLOAT(CAR(args)))));
}

elem bs1_func_ceil(BS1_SVMState *ctx, elem args)
{
	return(FLONUM(ceil(TOFLOAT(CAR(args)))));
}

elem bs1_func_round(BS1_SVMState *ctx, elem args)
{
	return(FLONUM(floor(TOFLOAT(CAR(args))+0.5)));
}

elem bs1_func_truncate(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f-=(int)f;
	return(FLONUM(f));
}

elem bs1_func_pow(BS1_SVMState *ctx, elem args)
{
	return(BS1_TYVec_ExpComplex(CAR(args), CADR(args)));

//	float f, g;
//	f=TOFLOAT(CAR(args));
//	g=TOFLOAT(CADR(args));
//	f=pow(f, g);
//	return(FLONUM(f));
}

elem bs1_func_degrees(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f*=180/M_PI;
	return(FLONUM(f));
}

elem bs1_func_radians(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f*=M_PI/180;
	return(FLONUM(f));
}

elem bs1_func_cos(BS1_SVMState *ctx, elem args)
{
	float f;
	f=cos(TOFLOAT(CAR(args)));
	return(FLONUM(f));
}

elem bs1_func_sin(BS1_SVMState *ctx, elem args)
{
	float f;
	f=sin(TOFLOAT(CAR(args)));
	return(FLONUM(f));
}

elem bs1_func_tan(BS1_SVMState *ctx, elem args)
{
	float f;
	f=tan(TOFLOAT(CAR(args)));
	return(FLONUM(f));
}

elem bs1_func_cosd(BS1_SVMState *ctx, elem args)
{
	float f;
	f=cos(TOFLOAT(CAR(args))*(M_PI/180));
	return(FLONUM(f));
}

elem bs1_func_sind(BS1_SVMState *ctx, elem args)
{
	float f;
	f=sin(TOFLOAT(CAR(args))*(M_PI/180));
	return(FLONUM(f));
}

elem bs1_func_tand(BS1_SVMState *ctx, elem args)
{
	float f;
	f=tan(TOFLOAT(CAR(args))*(M_PI/180));
	return(FLONUM(f));
}

elem bs1_func_acos(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f=acos(f);
	return(FLONUM(f));
}

elem bs1_func_asin(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f=asin(f);
	return(FLONUM(f));
}

elem bs1_func_atan(BS1_SVMState *ctx, elem args)
{
	float f, g;
	if(CDR(args)==BS1_MM_NULL)
	{
		f=TOFLOAT(CAR(args));
		f=atan(f);
	}else
	{
		f=TOFLOAT(CAR(args));
		g=TOFLOAT(CADR(args));
		f=atan2(f, g);
	}
	return(FLONUM(f));
}

elem bs1_func_ln(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f=log(f);
	return(FLONUM(f));
}

elem bs1_func_log(BS1_SVMState *ctx, elem args)
{
	float f, g;

	f=TOFLOAT(CAR(args));

	g=M_E;
	if(CDR(args)!=BS1_MM_NULL)g=TOFLOAT(CADR(args));
	f=log(f)/log(g);
	return(FLONUM(f));
}

elem bs1_func_log2(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f=log2(f);
	return(FLONUM(f));
}

elem bs1_func_log10(BS1_SVMState *ctx, elem args)
{
	float f;
	f=TOFLOAT(CAR(args));
	f=log10(f);
	return(FLONUM(f));
}

elem bs1_func_real(BS1_SVMState *ctx, elem args)
	{ return(FLONUM(BS1_REAL(CAR(args)))); }

elem bs1_func_imag(BS1_SVMState *ctx, elem args)
	{ return(FLONUM(BS1_IMAG(CAR(args)))); }


int BS1_BuiltinMath_Init()
{
	static int init=0;

	if(init)return(0);
	init=1;

	BS1_SVM_AddBinding("math.PI", FLONUM(M_PI));
	BS1_SVM_AddBinding("math.E", FLONUM(M_E));
	BS1_SVM_AddBinding("math.I", BS1_COMPLEX(0, 1));
//	BS1_SVM_AddBinding("math.CJ", PDSCR_Maths_MakeComplex2(0, 0, 1));
//	BS1_SVM_AddBinding("math.CK", PDSCR_Maths_MakeComplex3(0, 0, 0, 1));

	BS1_SVM_AddBuiltin("math.sqrt",
		"(x): square root",
		&bs1_func_sqrt, 1);
	BS1_SVM_AddBuiltin("math.floor",
		"(x): round down",
		&bs1_func_floor, 1);
	BS1_SVM_AddBuiltin("math.ceil",
		"(x): round up",
		&bs1_func_ceil, 1);
	BS1_SVM_AddBuiltin("math.round",
		"(x): round nearest",
		&bs1_func_round, 1);
	BS1_SVM_AddBuiltin("math.truncate",
		"(x): fractional part",
		&bs1_func_truncate, 1);
	BS1_SVM_AddBuiltin("math.pow",
		"(x, y): raise x to y",
		&bs1_func_pow, 2);

	BS1_SVM_AddBuiltin("math.degrees",
		"(x): radians to degrees",
		&bs1_func_degrees, 1);
	BS1_SVM_AddBuiltin("math.radians",
		"(x): degrees to radians",
		&bs1_func_radians, 1);

	BS1_SVM_AddBuiltin("math.cos", "(x): cosine",
		&bs1_func_cos, 1);
	BS1_SVM_AddBuiltin("math.sin", "(x): sine",
		&bs1_func_sin, 1);
	BS1_SVM_AddBuiltin("math.tan", "(x): tangent",
		&bs1_func_tan, 1);

	BS1_SVM_AddBuiltin("math.cos_d", "(x): cosine degrees",
		&bs1_func_cosd, 1);
	BS1_SVM_AddBuiltin("math.sin_d", "(x): sine degrees",
		&bs1_func_sind, 1);
	BS1_SVM_AddBuiltin("math.tan_d", "(x): tangent degrees",
		&bs1_func_tand, 1);

	BS1_SVM_AddBuiltin("math.acos", "(x): arc cosine",
		&bs1_func_acos, 1);
	BS1_SVM_AddBuiltin("math.asin", "(x): arc sine",
		&bs1_func_asin, 1);
	BS1_SVM_AddBuiltin("math.atan", "(f)|(f, g): arc tangent",
		&bs1_func_atan, -2);

	BS1_SVM_AddBuiltin("math.ln", "(x): natural log",
		&bs1_func_ln, 1);
	BS1_SVM_AddBuiltin("math.log", "(x[, b]):logarithm",
		&bs1_func_log, -2);
	BS1_SVM_AddBuiltin("math.log2", "(x): log 2",
		&bs1_func_log2, 1);
	BS1_SVM_AddBuiltin("math.log10", "(x): log 10",
		&bs1_func_log10, 1);

	BS1_SVM_AddBuiltin("math.real", "(x): real portion of a complex",
		&bs1_func_real, 1);
	BS1_SVM_AddBuiltin("math.imag", "(x): imaginary portion of a complex",
		&bs1_func_imag, 1);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bgbscr1.h>

elem bs1_func_print(BS1_SVMState *ctx, elem args)
{
	elem c;

	c=args;
	while(BS1_CONSP(c))
	{
		if(BS1_STRINGP(CAR(c)))
			printf("%s", BS1_TY_GetString(CAR(c)));
		if(BS1_SYMBOLP(CAR(c)))
			printf("%s", BS1_TY_GetSymbol(CAR(c)));
		if(BS1_KEYWORDP(CAR(c)))
			printf("%s", BS1_TY_GetSymbol(CAR(c)));
		if(BS1_FIXNUMP(CAR(c)))printf("%d", TOINT(CAR(c)));
		if(BS1_FLONUMP(CAR(c)))printf("%g", TOFLOAT(CAR(c)));
		if(BS1_CHARP(CAR(c)))printf("%c", TOINT(CAR(c)));

		if(BS1_CONSP(CAR(c)))BS1_TY_Print(CAR(c));

		if(BS1_FVECTORP(CAR(c)))printf("%s", BS1_S_PrintS(CAR(c)));
		if(BS1_FMATRIXP(CAR(c)))printf("%s", BS1_S_PrintS(CAR(c)));

		c=CDR(c);
	}

	return(BS1_MM_NULL);
}

elem bs1_func_println(BS1_SVMState *ctx, elem args)
{
	elem t;

	t=bs1_func_print(ctx, args);
	printf("\n");
	return(t);
}

elem bs1_func_load(BS1_SVMState *ctx, elem args)
{
	FILE *fd;
	elem t0, t1, t2;
	char *s, *buf;
	int sz;

	if(!BS1_CONSP(args))
		return(BS1_MM_NULL);

	t0=CAR(args); t1=ctx->self;
	if(BS1_CONSP(CDR(args)))
		t1=CADR(args);

	s=TOSTRING(t0);
	if(!s)return(BS1_MM_NULL);
	fd=fopen(s, "rb");
	if(!fd)return(BS1_MM_NULL);
	fseek(fd, 0, 2);
	sz=ftell(fd);

	buf=malloc(sz);
	fseek(fd, 0, 0);
	fread(buf, 1, sz, fd);
	fclose(fd);

	t2=BS1_SVM_EvalStringObj(buf, t1);
	free(buf);

	return(t2);
}

elem bs1_func_eval(BS1_SVMState *ctx, elem args)
{
	FILE *fd;
	elem t0, t1, t2;
	char *s, *buf;
	int sz;

	if(!BS1_CONSP(args))
		return(BS1_MM_NULL);

	t0=CAR(args); t1=ctx->self;
	if(BS1_CONSP(CDR(args)))
		t1=CADR(args);

	if(BS1_STRINGP(t0))
	{
		s=TOSTRING(t0);
		t2=BS1_SVM_EvalStringObj(s, t1);
	}else
	{
		t2=BS1_SVM_EvalExprsObj(LIST1(t0), t1);
	}
	return(t2);
}

elem bs1_func_car(BS1_SVMState *ctx, elem args) { return(CAR(CAR(args))); }
elem bs1_func_cdr(BS1_SVMState *ctx, elem args)	{ return(CDR(CAR(args))); }

elem bs1_func_caar(BS1_SVMState *ctx, elem args) { return(CAAR(CAR(args))); }
elem bs1_func_cdar(BS1_SVMState *ctx, elem args) { return(CDAR(CAR(args))); }
elem bs1_func_cadr(BS1_SVMState *ctx, elem args) { return(CADR(CAR(args))); }
elem bs1_func_cddr(BS1_SVMState *ctx, elem args) { return(CDDR(CAR(args))); }

elem bs1_func_caaar(BS1_SVMState *ctx, elem args) { return(CAAAR(CAR(args))); }
elem bs1_func_cdaar(BS1_SVMState *ctx, elem args) { return(CDAAR(CAR(args))); }
elem bs1_func_cadar(BS1_SVMState *ctx, elem args) { return(CADAR(CAR(args))); }
elem bs1_func_cddar(BS1_SVMState *ctx, elem args) { return(CDDAR(CAR(args))); }
elem bs1_func_caadr(BS1_SVMState *ctx, elem args) { return(CAADR(CAR(args))); }
elem bs1_func_cdadr(BS1_SVMState *ctx, elem args) { return(CDADR(CAR(args))); }
elem bs1_func_caddr(BS1_SVMState *ctx, elem args) { return(CADDR(CAR(args))); }
elem bs1_func_cdddr(BS1_SVMState *ctx, elem args) { return(CDDDR(CAR(args))); }


elem bs1_func_heapused(BS1_SVMState *ctx, elem args)
	{ return(FIXNUM(BS1_MM_HeapUsed())); }
elem bs1_func_heapfree(BS1_SVMState *ctx, elem args)
	{ return(FIXNUM(BS1_MM_HeapFree())); }
elem bs1_func_heapsize(BS1_SVMState *ctx, elem args)
	{ return(FIXNUM(BS1_MM_HeapSize())); }

elem bs1_func_symsused(BS1_SVMState *ctx, elem args)
	{ return(FIXNUM(BS1_TY_SymsUsed())); }
elem bs1_func_symsfree(BS1_SVMState *ctx, elem args)
	{ return(FIXNUM(BS1_TY_SymsMax()-BS1_TY_SymsUsed())); }
elem bs1_func_symsmax(BS1_SVMState *ctx, elem args)
	{ return(FIXNUM(BS1_TY_SymsMax())); }

int BS1_Builtins_Init()
{
	BS1_SVM_AddBinding("quit", KEYSYM("quit"));

	BS1_SVM_AddBuiltin("print", "", &bs1_func_print, -1);
	BS1_SVM_AddBuiltin("println", "", &bs1_func_println, -1);
	BS1_SVM_AddBuiltin("load", "", &bs1_func_load, -2);
	BS1_SVM_AddBuiltin("eval", "", &bs1_func_eval, -2);

	BS1_SVM_AddBuiltin("car", "", &bs1_func_car, 1);
	BS1_SVM_AddBuiltin("cdr", "", &bs1_func_cdr, 1);
	BS1_SVM_AddBuiltin("caar", "", &bs1_func_caar, 1);
	BS1_SVM_AddBuiltin("cdar", "", &bs1_func_cdar, 1);
	BS1_SVM_AddBuiltin("cadr", "", &bs1_func_cadr, 1);
	BS1_SVM_AddBuiltin("cddr", "", &bs1_func_cddr, 1);
	BS1_SVM_AddBuiltin("caaar", "", &bs1_func_caaar, 1);
	BS1_SVM_AddBuiltin("cdaar", "", &bs1_func_cdaar, 1);
	BS1_SVM_AddBuiltin("cadar", "", &bs1_func_cadar, 1);
	BS1_SVM_AddBuiltin("cddar", "", &bs1_func_cddar, 1);
	BS1_SVM_AddBuiltin("caadr", "", &bs1_func_caadr, 1);
	BS1_SVM_AddBuiltin("cdadr", "", &bs1_func_cdadr, 1);
	BS1_SVM_AddBuiltin("caddr", "", &bs1_func_caddr, 1);
	BS1_SVM_AddBuiltin("cdddr", "", &bs1_func_cdddr, 1);

	BS1_SVM_AddBuiltin("heap_used", "", &bs1_func_heapused, 0);
	BS1_SVM_AddBuiltin("heap_free", "", &bs1_func_heapfree, 0);
	BS1_SVM_AddBuiltin("heap_size", "", &bs1_func_heapsize, 0);
	BS1_SVM_AddBuiltin("syms_used", "", &bs1_func_symsused, 0);
	BS1_SVM_AddBuiltin("syms_free", "", &bs1_func_symsfree, 0);
	BS1_SVM_AddBuiltin("syms_max", "", &bs1_func_symsmax, 0);

	BS1_BuiltinMath_Init();

	return(0);
}
