GC Basics:
This will be a conservative GC.
Pointers may be freely stored on the stack, in global variables, or in other garbage-collected objects. The pointer may point anywhere within the allocated object.

Caution needs to be excersized when mixing GC'ed data with non-GC'ed data (such as memory gained from malloc, mmap, ...). Likewise when "mutilating" pointers. In these cases, it is no longer required that the GC be able to correctly locate or identify these pointers (resulting in 'accidental' collection).


GC API:
void *gcalloc(size_t sz);
void *gctalloc(char *type, size_t sz);

void *gcatomic(size_t sz);
void *gctatomic(char *type, size_t sz);

void *gcweak(size_t sz);

void *gcexec(size_t sz);
void *gctexec(char *type, size_t sz);

void *gcrealloc(void *p, size_t sz);
void *gcfree(void *p);
char *gcgettype(void *p);
int gctypep(void *p, char *ty);

int gcsetmark(char *ty, void (*fcn)(void *p));
int gcsetfinal(char *ty, void (*fcn)(void *p));
int gcsetpreserve(char *ty, void (*fcn)(void *p));

Uncertain Features:
void *gctallocu(char *type, size_t sz);	//unaligned alloc
void *gcmalloc(size_t sz);	//alloc initially-locked object
void gclock(void *p);	//prevent collection
void gcunlock(void *p);	//allow collection


gcalloc():
Allocates an object on the garbage-collected heap.
The type of such a value will be viewed as being NULL.

gctalloc():
Allocates a typed object on the GC heap.
The type is a string whose structure is not specified by the GC. For custom types, effort should be used to ensure that the string does not clash with a builtin type or one provided by another library.

The creation of a new type may consist simply of allocating an object of the particular type.

gcatomic()/gctatomic():
Allocates an 'atomic' object on the garbage collected heap.
An atomic object will differ from a normal object primarily in that the contents of an atomic object will not be scanned for references.
As a result, it will be more suited for safely handling buffers and other types known not to contain memory references.

gcweak():
Allocates a 'weak' object on the garbage collected heap.
Weak objects will differ primarily in how they handle memory references. In a weak object, anything looking like a pointer will be assumed a pointer, but these pointers will not be used to mark objects. Rather, following garbage collection, any pointers in weak objects which refer to non-existent objects will be set to NULL.

gcexec()/gctexec():
Will behave more or less the same as gcalloc()/gctalloc(), but will allocate memory that may safely contain executable code. This may be used for autogenerated code fragments and closures and similar.


gcrealloc():
Reallocate an object to a larger or smaller size.
The type will be be retained from the parent object.

gcfree():
Forcibly free an object. This should only be done when it is known that this object will no longer be accessed.

gcgettype():
Return the type associated with an object.
If the pointer is not part of the GC's heap, or was gained from gcalloc, then the return value is NULL.

gctypep():
Returns a nonzero value if the type of p is the same as that given in ty. This determination will be based on string equality.

gcsetfinal():
Set the finalizer called for a specific type.
This function will be called while freeing objects of this type.


gcmalloc():
If included, would create objects by default resembling those from malloc (assuming manual memory management, ...).

However, unlike malloc(), the memory returned by gcmalloc() may be searched for pointers.



Space Management

These functions will deal with "inaccessible" regions of the address space. The purpose of these functions will be to allocate regions for use in implementing pointer-mapped value types (such as fixnums), presumably as part of a VM implementation.

Note that these functions will try to first map an arch-specific "inaccessible" region (such as the kernel space on Windows and Linux on x86, or part of the large unaddressable region on x86-64).

After this, it may try to allocate within the normal address space of the program. However, this space is finite, and not necessarily all that large. As a result, this space should be used sparingly.

The idea will be that values can be encoded as offsets relative to the base address of the space, where this offset is a type-specific bit pattern.


int gcllSpaceAllocSafeP(int bits);

Checks if it is safe to allocate a chunk of space with a size of 2**bits (that this will both succeed and will not use addressable). Note that if it is safe to create a space with a given size, it is also safe to create a smaller space.

Returns 1 if this can be done, 0 otherwise.


void *gcllSpaceNew(char *type, int bits);

Attempt to create a new space with a given type name and size.
If another space exists with the same type, this space will be returned instead (even if it is of a different size).

Returns the base address of the space, or NULL if this fails.


void *gcllSpaceLookup(char *type);

Lookup the base for the space given by the type name.

Returns the base address of the space, or NULL if this fails.


char *gcllSpaceType(void *ptr);
int gcllSpaceBits(void *ptr);
void *gcllSpaceBase(void *ptr);
size_t gcllSpaceOffset(void *ptr);

Returns info about a given pointer into the space:
'Type' gives the typename of the space;
'Bits' returns the size of the space as the number of bits.
'Base' returns the address of the first byte in the space.
'Offset' returns the distance between the base and the pointer.

void *gcllSpaceWrap(char *type, size_t offs);

Return the pointer at offs in the space identified by type.

