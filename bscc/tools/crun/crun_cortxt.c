/* Autogenerated source */
char *crun_coretext=
"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n"
"#include <stdarg.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\n"
"#ifndef BYTE_T\n#define BYTE_T\ntypedef unsigned char byte;\n#endif\n\n"
"#ifndef S64_T\n#define S64_T\ntypedef unsigned char s64;\n#endif\n\n"
"#ifndef CRUN_TIME_T\n#define CRUN_TIME_T\n"
"typedef long long crun_time_t;\n#endif\n\n#ifndef CRUN_DEPNODE_T\n"
"#define CRUN_DEPNODE_T\ntypedef struct crun_depnode_s crun_depnode;\n"
"struct crun_depnode_s {\ncrun_depnode *next;\nchar *name;\n"
"char **deps;\nchar **cmds;\n};\n#endif\n\n#ifndef CRUN_DEPVAR_T\n"
"#define CRUN_DEPVAR_T\ntypedef struct crun_depvar_s crun_depvar;\n"
"struct crun_depvar_s {\ncrun_depvar *next;\nchar *name;\nchar *value;\n"
"char *(*genvalue_f)(crun_depvar *self);\n};\n#endif\n\n"
"#ifndef CRUN_DEPCMD_T\n#define CRUN_DEPCMD_T\n"
"typedef struct crun_depcmd_s crun_depcmd;\nstruct crun_depcmd_s {\n"
"crun_depcmd *next;\nchar *name;\n"
"int (*handle_f)(crun_depcmd *self, char **args);\n};\n#endif\n\n"
"int crun_sputs(char **rt, char *str)\n{\n\tchar *s, *t;\n\n"
"\ts=str; t=*rt;\n\n\twhile(*s)\n\t{\n\t\tif(s[0]=='\\r')\n\t\t{\n"
"\t\t\tif(s[1]=='\\n')\n\t\t\t\t{ *t++=*s++; *t++=*s++; continue; }\n"
"\t\t\t*t++=*s++; continue;\n\t\t}\n\t\tif(s[0]=='\\n')\n"
"\t\t\t{ s++; *t++='\\r'; *t++='\\n'; continue; }\n\t\t*t++=*s++;\n\t}\n"
"\t*t=0;\n\n\t*rt=t;\n\treturn(0);\n}\n\n"
"int crun_printsf(char **rt, char *str, ...)\n{\n\tchar tb[4096];\n"
"\tva_list lst;\n\n\tva_start(lst, str);\n\tvsprintf(tb, str, lst);\n"
"\tva_end(lst);\n\tcrun_sputs(rt, tb);\n\treturn(0);\n}\n\n"
"int crun_system(char *str)\n{\n\tint i;\n\ti=system(str);\n"
"\treturn(i);\n}\n\nint crun_call(char *app, char **args)\n{\n"
"\tchar tbuf[4096];\n\tchar *t;\n\tint i;\n\n\tt=tbuf;\n"
"\tcrun_sputs(&t, app);\n\tfor(i=0; args[i]; i++)\n"
"\t\tcrun_printsf(&t, \" \\\"%s\\\"\", args[i]);\n\t*t++=0;\n\n"
"\ti=crun_system(tbuf);\n\treturn(i);\n}\n\n"
"int crun_callmake(char *dir, char *mkfile, char *targ)\n{\n"
"\tchar *args[64];\n\tint i, n;\n\n\tn=0;\n"
"\tif(dir) { args[n++]=\"-C\"; args[n++]=dir; }\n"
"\tif(mkfile) { args[n++]=\"-f\"; args[n++]=mkfile; }\n"
"\tif(targ) { args[n++]=targ; }\n\targs[n]=NULL;\n\n"
"\ti=crun_call(\"make\", args);\n\treturn(i);\n}\n\n"
"int crun_dechexchar(int i)\n{\n"
"\tif((i>='0') && (i<='9')) return(i-'0');\n"
"\tif((i>='A') && (i<='F')) return(i-'A'+10);\n"
"\tif((i>='a') && (i<='f')) return(i-'a'+10);\n\treturn(-1);\n}\n\n"
"int crun_dechexchar1(char *s)\n\t{ return(crun_dechexchar(*s)); }\n"
"int crun_dechexchar2(char *s)\n"
"\t{ return((crun_dechexchar(s[0])<<4)+crun_dechexchar(s[1])); }\n\n\n"
"char *crun_ralloc_buffer=NULL;\nint crun_ralloc_pos=0;\n\n"
"void *crun_ralloc(int sz)\n{\n\tchar *s;\n\n"
"\tif(!crun_ralloc_buffer)crun_ralloc_buffer=(char *)malloc(1<<20);\n"
"\tif((crun_ralloc_pos+sz)>=(1<<20))crun_ralloc_pos=0;\n\n"
"\ts=crun_ralloc_buffer+crun_ralloc_pos;\n\tcrun_ralloc_pos+=sz;\n"
"\treturn((void *)s);\n}\n\nchar *crun_rstrdup(char *s)\n{\n\tchar *t;\n"
"\n\tt=(char *)crun_ralloc(strlen(s)+1);\n\tstrcpy(t, s);\n"
"\treturn(t);\n}\n\nchar **crun_rsplit(char *s)\n{\n\tchar **a, *t;\n"
"\tint i, j;\n\n\ta=(char **)crun_ralloc(256*sizeof(char *));\n\ti=0;\n"
"\twhile(*s)\n\t{\n\t\twhile(*s && (*s<=' '))s++;\n\t\tif(!*s)break;\n"
"\t\tif(*s=='#')break;\n\t\tif(*s==';')break;\n"
"\t\tif((s[0]=='/') && (s[1]=='/'))\n\t\t\tbreak;\n\n"
"\t\tt=(char *)crun_ralloc(256);\n\t\ta[i++]=t;\n\n\t\tif(*s=='\"')\n"
"\t\t{\n\t\t\ts++;\n\t\t\twhile(*s && (*s!='\"'))\n\t\t\t{\n"
"\t\t\t\tif(*s=='\\\\')\n\t\t\t\t{\n\t\t\t\t\ts++; j=*s++;\n"
"\t\t\t\t\tswitch(j)\n\t\t\t\t\t{\n"
"\t\t\t\t\tcase 'r': *t++='\\r'; break;\n"
"\t\t\t\t\tcase 'n': *t++='\\n'; break;\n"
"\t\t\t\t\tcase 't': *t++='\\t'; break;\n"
"\t\t\t\t\tcase '\\\\': *t++='\\\\'; break;\n\t\t\t\t\tcase 'x':\n"
"\t\t\t\t\t\t*t++=crun_dechexchar2(s);\n\t\t\t\t\t\ts+=2;\n"
"\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: *t++=j; break;\n\t\t\t\t\t}\n"
"\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*t++=*s++;\n\t\t\t}\n"
"\t\t\tif(*s=='\"')s++;\n\t\t\t*t++=0; *t++='\\\"'; *t++=0;\n\t\t}else\n"
"\t\t{\n\t\t\twhile(*s && (*s>' '))*t++=*s++;\n"
"\t\t\t*t++=0; *t++=0; *t++=0;\n\t\t}\n\t}\n\ta[i]=NULL;\n\n"
"\treturn(a);\n}\n\nchar **crun_split(char *s)\n{\n\tchar tb[4096];\n"
"\tchar **a, *t;\n\tint i, j, m;\n\n"
"\ta=(char **)malloc(64*sizeof(char *)); m=64;\n\ti=0;\n\twhile(*s)\n"
"\t{\n\t\twhile(*s && (*s<=' '))s++;\n\t\tif(!*s)break;\n"
"\t\tif(*s=='#')break;\n\t\tif(*s==';')break;\n"
"\t\tif((s[0]=='/') && (s[1]=='/'))\n\t\t\tbreak;\n\n\t\tt=tb;\n"
"\t\tif(*s=='\"')\n\t\t{\n\t\t\ts++;\n\t\t\twhile(*s && (*s!='\"'))\n"
"\t\t\t{\n\t\t\t\tif(*s=='\\\\')\n\t\t\t\t{\n\t\t\t\t\ts++; j=*s++;\n"
"\t\t\t\t\tswitch(j)\n\t\t\t\t\t{\n"
"\t\t\t\t\tcase 'r': *t++='\\r'; break;\n"
"\t\t\t\t\tcase 'n': *t++='\\n'; break;\n"
"\t\t\t\t\tcase 't': *t++='\\t'; break;\n"
"\t\t\t\t\tcase '\\\\': *t++='\\\\'; break;\n\t\t\t\t\tcase 'x':\n"
"\t\t\t\t\t\t*t++=crun_dechexchar2(s);\n\t\t\t\t\t\ts+=2;\n"
"\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: *t++=j; break;\n\t\t\t\t\t}\n"
"\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*t++=*s++;\n\t\t\t}\n"
"\t\t\tif(*s=='\"')s++;\n\t\t\t*t++=0; *t++='\\\"'; *t++=0;\n\t\t}else\n"
"\t\t{\n\t\t\twhile(*s && (*s>' '))*t++=*s++;\n"
"\t\t\t*t++=0; *t++=0; *t++=0;\n\t\t}\n\n"
"\t\tif(i>=m) { m+=m>>1; a=(char **)realloc(a, m*sizeof(char *)); }\n\n"
"\t\tj=t-tb;\n\t\tt=(char *)malloc(j);\n\t\tmemcpy(t, tb, j);\n"
"\t\ta[i++]=t;\n\t}\n\ta[i]=NULL;\n\n\treturn(a);\n}\n\n"
"int crun_freestrs(char **a)\n{\n\tint i;\n"
"\tfor(i=0; a[i]; i++)free(a[i]);\n\tfree(a);\n\treturn(0);\n}\n\n"
"char **crun_dupstrs(char **a)\n{\n\tchar **b;\n\tint i;\n\n"
"\tif(!a)return(NULL);\n\n\tfor(i=0; a[i]; i++);\n"
"\tb=(char **)malloc((i+1)*sizeof(char *));\n\tfor(i=0; a[i]; i++)\n"
"\t\tb[i]=strdup(a[i]);\n\tb[i]=NULL;\n\treturn(b);\n}\n\n\n"
"int crun_bufferhash(void *buf, int sz)\n{\n\tunsigned char *cs, *ce;\n"
"\tint hi;\n\n\tcs=(unsigned char *)buf; ce=cs+sz;\n"
"\thi=0; while(cs<ce)hi=hi*251+(*cs++);\n\treturn(hi&0x3FFFFFFF);\n}\n\n"
"int crun_filehash(char *name)\n{\n\tFILE *fd;\n\tvoid *buf;\n"
"\tint i, sz;\n\n\tfd=fopen(name, \"rb\");\n\tif(!fd)return(-1);\n"
"\tfseek(fd, 0, 2);\n\tsz=ftell(fd);\n\tfseek(fd, 0, 0);\n\n"
"\tbuf=malloc(sz);\n\tfread(buf, 1, sz, fd);\n\tfclose(fd);\n\n"
"\ti=crun_bufferhash(buf, sz);\n\tfree(buf);\n\treturn(i);\n}\n\n"
"crun_time_t crun_futuretime()\n\t{ return(1LL<<62); }\n\n"
"#ifndef _WIN32\ncrun_time_t crun_filetime(char *name)\n"
"\t{ return(-1); }\n#endif\n\n#ifdef _WIN32\n"
"crun_time_t crun_filetime(char *name)\n{\n\tchar buf[1024];\n"
"\tWIN32_FIND_DATA FindFileData;\n\tHANDLE hFind;\n\tcrun_time_t lt;\n"
"\tchar *s, *t;\n\tint i;\n\n\tstrcpy(buf, name);\n\n\ts=buf; t=buf;\n"
"\twhile(*s)\n\t{\n\t\twhile((s[0]=='/') && (s[1]=='/'))s++;\n"
"\t\tif(*s=='/')*s='\\\\';\n\t\t*t++=*s++;\n\t}\n\n"
"\thFind=FindFirstFile(buf, &FindFileData);\n"
"\tif(hFind==INVALID_HANDLE_VALUE) \n\t\treturn(-1);\n"
"\tFindClose(hFind);\n\n"
"\tlt=(((crun_time_t)FindFileData.ftLastWriteTime.dwHighDateTime)<<32)+\n"
"\t\t((crun_time_t)FindFileData.ftLastWriteTime.dwLowDateTime);\n"
"\treturn(lt);\n}\n#endif\n\n/*\n"
"   Stuff for vars and dependency checking.\n */\n\n"
"crun_depvar *crun_depvar_root=NULL;\n"
"crun_depcmd *crun_depcmd_root=NULL;\n"
"crun_depnode *crun_depnode_root=NULL;\n\n"
"crun_depvar *crun_lookupdepvar(char *name)\n{\n\tcrun_depvar *cur;\n\n"
"\tcur=crun_depvar_root;\n\twhile(cur)\n\t{\n"
"\t\tif(!strcmp(cur->name, name))\n\t\t\treturn(cur);\n"
"\t\tcur=cur->next;\n\t}\n\treturn(cur);\n}\n\n"
"crun_depvar *crun_getdepvar(char *name)\n{\n\tcrun_depvar *tmp;\n\n"
"\ttmp=crun_lookupdepvar(name);\n\tif(tmp)return(tmp);\n\n"
"\ttmp=(crun_depvar *)malloc(sizeof(crun_depvar));\n"
"\tmemset(tmp, 0, sizeof(crun_depvar));\n\ttmp->name=strdup(name);\n"
"\treturn(tmp);\n}\n\n"
"crun_depvar *crun_setdepvar(char *name, char *value)\n{\n"
"\tcrun_depvar *tmp;\n\n\ttmp=crun_getdepvar(name);\n"
"\tif(tmp->value) { free(tmp->value); tmp->value=NULL; }\n"
"\tif(value)tmp->value=strdup(value);\n\treturn(tmp);\n}\n\n"
"char *crun_getvar(char *name)\n{\n\tcrun_depvar *tmp;\n"
"\ttmp=crun_lookupdepvar(name);\n\tif(!tmp)return(NULL);\n"
"\tif(tmp->genvalue_f)\n\t\treturn(tmp->genvalue_f(tmp));\n"
"\treturn(tmp->value);\n}\n\nvoid crun_setvar(char *name, char *value)\n"
"\t{ crun_setdepvar(name, value); }\n\n"
"char *crun_expandvars(char *str)\n{\n"
"\tchar buf[4096], tb[4096], tb1[256];\n\tchar *s, *t, *t1;\n\n"
"\t/* check if no patterns to expand */\n\ts=str;\n\twhile(*s)\n\t{\n"
"\t\tif((s[0]=='$') && (s[1]=='('))break;\n\t\ts++;\n\t}\n"
"\tif(!*s)return(str);\n\n\tstrcpy(buf, str);\n\twhile(1)\n\t{\n"
"\t\ts=buf;\n\t\twhile(*s)\n\t\t{\n"
"\t\t\tif((s[0]=='$') && (s[1]=='('))break;\n\t\t\ts++;\n\t\t}\n"
"\t\tif(!*s)break;\n\n\t\ts=buf; t=tb;\n\t\twhile(*s)\n\t\t{\n"
"\t\t\tif((s[0]=='$') && (s[1]=='('))\n\t\t\t{\n\t\t\t\ts+=2; t1=tb1;\n"
"\t\t\t\twhile(*s && (*s!=')'))\n\t\t\t\t\t*t1++=*s++;\n"
"\t\t\t\t*t1++=0; if(*s==')')s++;\n\n\t\t\t\tt1=crun_getvar(tb1);\n"
"\t\t\t\tif(t1) { strcpy(t, t1); t+=strlen(t); }\n\t\t\t\tcontinue;\n"
"\t\t\t}\n\t\t\t*t++=*s++;\n\t\t}\n\t\t*t++=0;\n\n\t\tstrcpy(buf, tb);\n"
"\t}\n\n\tt=crun_rstrdup(buf);\n\treturn(t);\n}\n\n/*\n"
"   Command handling\n */\n\n"
"crun_depcmd *crun_lookupdepcmd(char *name)\n{\n\tcrun_depcmd *cur;\n\n"
"\tcur=crun_depcmd_root;\n\twhile(cur)\n\t{\n"
"\t\tif(!strcmp(cur->name, name))\n\t\t\treturn(cur);\n"
"\t\tcur=cur->next;\n\t}\n\treturn(cur);\n}\n\n"
"crun_depcmd *crun_getdepcmd(char *name)\n{\n\tcrun_depcmd *tmp;\n\n"
"\ttmp=crun_lookupdepcmd(name);\n\tif(tmp)return(tmp);\n\n"
"\ttmp=(crun_depcmd *)malloc(sizeof(crun_depcmd));\n"
"\tmemset(tmp, 0, sizeof(crun_depcmd));\n\ttmp->name=strdup(name);\n"
"\treturn(tmp);\n}\n\ncrun_depcmd *crun_setdepcmd(char *name,\n"
"\tint (*fcn)(crun_depcmd *self, char **args))\n{\n\tcrun_depcmd *tmp;\n"
"\n\ttmp=crun_getdepcmd(name);\n\ttmp->handle_f=fcn;\n\treturn(tmp);\n"
"}\n\nint crun_runcmd(char *str)\n{\n\tcrun_depcmd *tmp;\n\n\tchar *s;\n"
"\tchar **a;\n\tint i;\n\n\ts=crun_expandvars(str);\n"
"\ta=crun_rsplit(s);\n\n\tif(!a[0])return(0);\n"
"\tif(!*(a[0]))return(0);\n\n\ttmp=crun_lookupdepcmd(a[0]);\n"
"\tif(tmp && tmp->handle_f)\n\t{\n\t\ti=tmp->handle_f(tmp, a);\n"
"\t\treturn(i);\n\t}\n\n\ti=crun_system(s);\n\treturn(i);\n}\n\n/*\n"
"   Dependency checking.\n */\n\nstatic crun_depnode *depstk[256];\n"
"static int depstkpos=0;\n\ncrun_depnode *crun_lookupdep(char *name)\n"
"{\n\tcrun_depnode *cur;\n\n\tcur=crun_depnode_root;\n\twhile(cur)\n"
"\t{\n\t\tif(!strcmp(cur->name, name))\n\t\t\treturn(cur);\n"
"\t\tcur=cur->next;\n\t}\n\treturn(cur);\n}\n\n"
"crun_depnode *crun_newdep(char *name, char **deps, char **cmds)\n{\n"
"\tcrun_depnode *tmp;\n\n\ttmp=crun_lookupdep(name);\n"
"\tif(tmp)return(tmp);\n\n"
"\ttmp=(crun_depnode *)malloc(sizeof(crun_depnode));\n"
"\tmemset(tmp, 0, sizeof(crun_depnode));\n\n\ttmp->name=strdup(name);\n"
"\ttmp->deps=crun_dupstrs(deps);\n\ttmp->cmds=crun_dupstrs(cmds);\n\n"
"\ttmp->next=crun_depnode_root;\n\tcrun_depnode_root=tmp;\n\n"
"\treturn(tmp);\n}\n\n/* -1=missing deps, >0=dep-time */\n"
"crun_time_t crun_deptime(char *name)\n{\n\tcrun_depnode *tmp;\n"
"\tcrun_time_t ct, tt;\n\tint i, j, mrk;\n\n"
"\ttmp=crun_lookupdep(name);\n\tif(!tmp)return(-1);\n\n"
"\t/* no deps or cmds == \"FORCE\" */\n\tif(!tmp->deps && !tmp->cmds)\n"
"\t\treturn(crun_futuretime());\n\n\tct=crun_filetime(tmp->name);\n\n"
"\tif(tmp->deps)\n\t{\n\t\t/* circular dependency check */\n"
"\t\tfor(i=0; i<depstkpos; i++)\n\t\t\tif(depstk[i]==tmp)\n"
"\t\t\t\treturn(0);\n\t\tmrk=depstkpos++;\n\t\tdepstk[mrk]=tmp;\n\n"
"\t\tfor(i=0; tmp->deps[i]; i++)\n\t\t{\n"
"\t\t\ttt=crun_deptime(tmp->deps[i]);\n"
"\t\t\tif(tt<0) { ct=tt; break; }\n\t\t\tif(tt>ct)ct=tt;\n\t\t}\n"
"\t\tdepstkpos=mrk;\n\t\treturn(ct);\n\t}\n\n\treturn(ct);\n}\n\n"
"/* -1=missing deps, 0=up-to-date, 1=needs rebuild */\n"
"int crun_checkdep(char *name)\n{\n\tcrun_depnode *tmp;\n"
"\tcrun_time_t ct, tt;\n\tint i, j, k, ret, mrk;\n\n"
"\ttmp=crun_lookupdep(name);\n\tif(!tmp)return(-1);\n\n"
"\t/* no deps or cmds == \"FORCE\" */\n"
"\tif((!tmp->deps) && (!tmp->cmds))\n\t\treturn(1);\n\n\tret=0;\n"
"\tif(tmp->deps)\n\t{\n\t\t/* circular dependency check */\n"
"\t\tfor(i=0; i<depstkpos; i++)\n\t\t\tif(depstk[i]==tmp)\n"
"\t\t\t\treturn(0);\n\t\tmrk=depstkpos++;\n\t\tdepstk[mrk]=tmp;\n\n"
"\t\tfor(i=0; tmp->deps[i]; i++)\n\t\t{\n"
"\t\t\tj=crun_checkdep(tmp->deps[i]);\n\t\t\tif(j<0) { ret=j; break; }\n"
"\t\t\tif(j>0)ret|=j;\n\t\t}\n\n"
"\t\tif(ret) { depstkpos=mrk; return(ret); }\n\n"
"\t\tct=crun_filetime(tmp->name);\n\n\t\tfor(i=0; tmp->deps[i]; i++)\n"
"\t\t{\n\t\t\ttt=crun_deptime(tmp->deps[i]);\n"
"\t\t\tif(tt<0) { ret=(int)tt; break; }\n\t\t\tif(tt>ct) ret|=1;\n"
"\t\t}\n\n\t\tif(ret) { depstkpos=mrk; return(ret); }\n"
"\t\tdepstkpos=mrk;\n\t}\n\n\treturn(0);\n}\n\n"
"int crun_rundeps(char *name)\n{\n\tcrun_depnode *tmp;\n"
"\tint i, j, ret, mrk;\n\n\ttmp=crun_lookupdep(name);\n"
"\tif(!tmp)return(-1);\n\n\tif(!tmp->deps && !tmp->cmds)\n"
"\t\treturn(0);\n\n\ti=crun_checkdep(name);\n"
"\tif(!i)return(0);\t/* nothing to do */\n"
"\tif(i<0)return(i);\t/* problem */\n\n\tret=0;\n\tif(tmp->deps)\n\t{\n"
"\t\t/* circular dependency check */\n\t\tfor(i=0; i<depstkpos; i++)\n"
"\t\t\tif(depstk[i]==tmp)\n\t\t\t\treturn(0);\n\t\tmrk=depstkpos++;\n"
"\t\tdepstk[mrk]=tmp;\n\n\t\tfor(i=0; tmp->deps[i]; i++)\n\t\t{\n"
"\t\t\tj=crun_rundeps(tmp->deps[i]);\n\t\t\tif(j<0) { ret=j; break; }\n"
"\t\t}\n\t\tdepstkpos=mrk;\n\t}\n\n\tif(ret<0)return(ret);\n\n"
"\tfor(i=0; tmp->cmds[i]; i++)\n\t{\n\t\tj=crun_runcmd(tmp->cmds[i]);\n"
"\t\tif(j) { ret=-1; break; }\n\t}\n\n\treturn(ret);\n}\n";

