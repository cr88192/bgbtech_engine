GC Basics:
This will be a conservative GC.
Pointers may be freely stored on the stack, in global variables, or in other garbage-collected objects. The pointer may point anywhere within the allocated object.

Caution needs to be excersized when mixing GC'ed data with non-GC'ed data (such as memory gained from malloc, mmap, ...). Likewise when "mutilating" pointers. In these cases, it is no longer required that the GC be able to correctly locate or identify these pointers (resulting in 'accidental' collection).


GC API:
void *gcalloc(size_t sz);
void *gctalloc(char *type, size_t sz);

void *gcatomic(size_t sz);
void *gctatomic(char *type, size_t sz);

void *gcweak(size_t sz);

void *gcexec(size_t sz);
void *gctexec(char *type, size_t sz);

void *gcrealloc(void *p, size_t sz);
void *gcfree(void *p);
char *gcgettype(void *p);
int gctypep(void *p, char *ty);

int gcsetmark(char *ty, void (*fcn)(void *p));
int gcsetfinal(char *ty, void (*fcn)(void *p));
int gcsetpreserve(char *ty, void (*fcn)(void *p));

Uncertain Features:
void *gctallocu(char *type, size_t sz);	//unaligned alloc
void *gcmalloc(size_t sz);	//alloc initially-locked object
void gclock(void *p);	//prevent collection
void gcunlock(void *p);	//allow collection


gcalloc():
Allocates an object on the garbage-collected heap.
The type of such a value will be viewed as being NULL.

gctalloc():
Allocates a typed object on the GC heap.
The type is a string whose structure is not specified by the GC. For custom types, effort should be used to ensure that the string does not clash with a builtin type or one provided by another library.

The creation of a new type may consist simply of allocating an object of the particular type.

gcatomic()/gctatomic():
Allocates an 'atomic' object on the garbage collected heap.
An atomic object will differ from a normal object primarily in that the contents of an atomic object will not be scanned for references.
As a result, it will be more suited for safely handling buffers and other types known not to contain memory references.

gcweak():
Allocates a 'weak' object on the garbage collected heap.
Weak objects will differ primarily in how they handle memory references. In a weak object, anything looking like a pointer will be assumed a pointer, but these pointers will not be used to mark objects. Rather, following garbage collection, any pointers in weak objects which refer to non-existent objects will be set to NULL.

gcexec()/gctexec():
Will behave more or less the same as gcalloc()/gctalloc(), but will allocate memory that may safely contain executable code. This may be used for autogenerated code fragments and closures and similar.


gcrealloc():
Reallocate an object to a larger or smaller size.
The type will be be retained from the parent object.

gcfree():
Forcibly free an object. This should only be done when it is known that this object will no longer be accessed.

gcgettype():
Return the type associated with an object.
If the pointer is not part of the GC's heap, or was gained from gcalloc, then the return value is NULL.

gctypep():
Returns a nonzero value if the type of p is the same as that given in ty. This determination will be based on string equality.

gcsetfinal():
Set the finalizer called for a specific type.
This function will be called while freeing objects of this type.


gcmalloc():
If included, would create objects by default resembling those from malloc (assuming manual memory management, ...).

However, unlike malloc(), the memory returned by gcmalloc() may be searched for pointers.


