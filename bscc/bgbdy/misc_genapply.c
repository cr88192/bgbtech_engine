/*
Type Numbers:
	0=Int(s32)
	1=Long(s64)
	2=Float
	3=Double
	4=Pointer
	
So a base 5 encoding.
The highest value will be 1, which will serve as a terminator.
Types will be encoded from left to right.
The lowest position in an id will be the return type.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *NameForMod(int id)
{
	char *s;
	switch(id)
	{
	case 0: s="s32"; break;
	case 1: s="s64"; break;
	case 2: s="f32"; break;
	case 3: s="f64"; break;
	case 4: s="void*"; break;
	default: s=NULL; break;
	}
	return(s);
}

char *StepForMod(int id)
{
	char *s;
	switch(id)
	{
	case 0: s="sizeof(nlint)"; break;
	case 1: s="sizeof(s64)"; break;
	case 2: s="sizeof(nlint)"; break;
	case 3: s="sizeof(f64)"; break;
	case 4: s="sizeof(nlint)"; break;
	default: s=NULL; break;
	}
	return(s);
}

void PrintArgsForID(FILE *fd, int id)
{
	char *ar[16];
	int i, n;
	
	n=0; i=id;
	while(i>=5)
	{
		ar[n++]=NameForMod(i%5);
		i/=5;
	}
	
	if(!n)return;
	
	for(i=n-1; i>0; i--)
	{
		fprintf(fd, "%s,", ar[i]);
	}
	fprintf(fd, "%s", ar[0]);
}

void PrintFuncTypeForID(FILE *fd, char *name, int id)
{
	char *s;
	
	if(!name)name="";
	
	s=NameForMod(id%5);
	fprintf(fd, "%s(*%s)(", s, name);
	PrintArgsForID(fd, id/5);
	fprintf(fd, ")");
}

void PrintFuncCallArgsForID(FILE *fd, char *name, int id)
{
	char *ar[16];
	int ao[16];
	char *s;
	int i, j, n;
	
	n=0; i=id;
	while(i>=5)
	{
		ar[n++]=NameForMod(i%5);
		i/=5;
	}
	
	if(!n)return;
	
	for(i=0; i<(n-1); i++)
	{
		fprintf(fd, "*(%s*)p%d,", ar[n-i-1], i);
	}
	fprintf(fd, "*(%s*)p%d", ar[0], n-1);
}

int main(int argc, char *argv[])
{
	char *ar[16];
	FILE *fd;
	int i, j, k, n;
	char *s;
	
	fd=fopen("base/dyll_func2_auto.c", "wt");
	if(!fd)
	{
		printf("%s: failed open output\n", argv[0]);
		return(-1);
	}
	
	fprintf(fd, "/* Autogenerated source */\n\n");
	fprintf(fd, "#include <bgbdy.h>\n\n");

	fprintf(fd, "#ifdef BGBDY_USEGENAPPLY\n");

	fprintf(fd, "BGBDY_API void DYLL_ApplyCallSig2"
		"(BGBGC_RawFunc *inf, void *buf)\n{\n");

	fprintf(fd, "\tvoid *p0,*p1,*p2,*p3,*p4,*p5;\n");
	fprintf(fd, "\tbyte *buf1;\n");

	fprintf(fd, "\tbuf1=(byte *)buf;\n");

	fprintf(fd, "\tswitch(inf->sig2id)\n");
	fprintf(fd, "\t{\n");
	for(i=5; i<(5*5*5*5*5*5); i++)
	{
		j=i/5; n=0;
		while(j>=5)
		{
			ar[n++]=StepForMod(j%5);
			j/=5;
		}
		if(j!=1)continue;

		fprintf(fd, "\tcase %d:\n", i);
		
		j=i/5; k=0;
		while(j>=5)
		{
			fprintf(fd, "\t\tp%d=buf1;", k);
			if(j>=25)
				fprintf(fd, " buf1+=%s;", ar[n-k-1]);
//				fprintf(fd, " buf1+=%s;", StepForMod(j%5));
			fprintf(fd, "\n");
			k++; j/=5;
		}
		
		s=NameForMod(i%5);
		fprintf(fd, "\t\t*(%s*)buf=", s);
		fprintf(fd, "((");
		PrintFuncTypeForID(fd, NULL, i);
		fprintf(fd, ")(inf->fcn))");

		fprintf(fd, "(");
		PrintFuncCallArgsForID(fd, NULL, i/5);
		fprintf(fd, ");\n");
		fprintf(fd, "\t\tbreak;\n");
	}

	fprintf(fd, "\tdefault: break;\n");

	fprintf(fd, "\t}\n");

	fprintf(fd, "}\n");
	fprintf(fd, "#endif\n");
	
	fclose(fd);
}
